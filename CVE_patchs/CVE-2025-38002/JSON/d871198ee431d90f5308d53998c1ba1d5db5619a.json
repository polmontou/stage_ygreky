"diff --git a/io_uring/fdinfo.c b/io_uring/fdinfo.c\nindex 9414ca6d101c..e0d6a59a89fa 100644\n--- a/io_uring/fdinfo.c\n+++ b/io_uring/fdinfo.c\n@@ -86,13 +86,8 @@ static inline void napi_show_fdinfo(struct io_ring_ctx *ctx,\n }\n #endif\n \n-/*\n- * Caller holds a reference to the file already, we don't need to do\n- * anything else to get an extra reference.\n- */\n-__cold void io_uring_show_fdinfo(struct seq_file *m, struct file *file)\n+static void __io_uring_show_fdinfo(struct io_ring_ctx *ctx, struct seq_file *m)\n {\n-\tstruct io_ring_ctx *ctx = file->private_data;\n \tstruct io_overflow_cqe *ocqe;\n \tstruct io_rings *r = ctx->rings;\n \tstruct rusage sq_usage;\n@@ -106,7 +101,6 @@ __cold void io_uring_show_fdinfo(struct seq_file *m, struct file *file)\n \tunsigned int sq_entries, cq_entries;\n \tint sq_pid = -1, sq_cpu = -1;\n \tu64 sq_total_time = 0, sq_work_time = 0;\n-\tbool has_lock;\n \tunsigned int i;\n \n \tif (ctx->flags & IORING_SETUP_CQE32)\n@@ -176,15 +170,7 @@ __cold void io_uring_show_fdinfo(struct seq_file *m, struct file *file)\n \t\tseq_printf(m, \"\\n\");\n \t}\n \n-\t/*\n-\t * Avoid ABBA deadlock between the seq lock and the io_uring mutex,\n-\t * since fdinfo case grabs it in the opposite direction of normal use\n-\t * cases. If we fail to get the lock, we just don't iterate any\n-\t * structures that could be going away outside the io_uring mutex.\n-\t */\n-\thas_lock = mutex_trylock(&ctx->uring_lock);\n-\n-\tif (has_lock && (ctx->flags & IORING_SETUP_SQPOLL)) {\n+\tif (ctx->flags & IORING_SETUP_SQPOLL) {\n \t\tstruct io_sq_data *sq = ctx->sq_data;\n \n \t\t/*\n@@ -206,7 +192,7 @@ __cold void io_uring_show_fdinfo(struct seq_file *m, struct file *file)\n \tseq_printf(m, \"SqTotalTime:\\t%llu\\n\", sq_total_time);\n \tseq_printf(m, \"SqWorkTime:\\t%llu\\n\", sq_work_time);\n \tseq_printf(m, \"UserFiles:\\t%u\\n\", ctx->file_table.data.nr);\n-\tfor (i = 0; has_lock && i < ctx->file_table.data.nr; i++) {\n+\tfor (i = 0; i < ctx->file_table.data.nr; i++) {\n \t\tstruct file *f = NULL;\n \n \t\tif (ctx->file_table.data.nodes[i])\n@@ -218,7 +204,7 @@ __cold void io_uring_show_fdinfo(struct seq_file *m, struct file *file)\n \t\t}\n \t}\n \tseq_printf(m, \"UserBufs:\\t%u\\n\", ctx->buf_table.nr);\n-\tfor (i = 0; has_lock && i < ctx->buf_table.nr; i++) {\n+\tfor (i = 0; i < ctx->buf_table.nr; i++) {\n \t\tstruct io_mapped_ubuf *buf = NULL;\n \n \t\tif (ctx->buf_table.nodes[i])\n@@ -228,7 +214,7 @@ __cold void io_uring_show_fdinfo(struct seq_file *m, struct file *file)\n \t\telse\n \t\t\tseq_printf(m, \"%5u: <none>\\n\", i);\n \t}\n-\tif (has_lock && !xa_empty(&ctx->personalities)) {\n+\tif (!xa_empty(&ctx->personalities)) {\n \t\tunsigned long index;\n \t\tconst struct cred *cred;\n \n@@ -238,7 +224,7 @@ __cold void io_uring_show_fdinfo(struct seq_file *m, struct file *file)\n \t}\n \n \tseq_puts(m, \"PollList:\\n\");\n-\tfor (i = 0; has_lock && i < (1U << ctx->cancel_table.hash_bits); i++) {\n+\tfor (i = 0; i < (1U << ctx->cancel_table.hash_bits); i++) {\n \t\tstruct io_hash_bucket *hb = &ctx->cancel_table.hbs[i];\n \t\tstruct io_kiocb *req;\n \n@@ -247,9 +233,6 @@ __cold void io_uring_show_fdinfo(struct seq_file *m, struct file *file)\n \t\t\t\t\ttask_work_pending(req->tctx->task));\n \t}\n \n-\tif (has_lock)\n-\t\tmutex_unlock(&ctx->uring_lock);\n-\n \tseq_puts(m, \"CqOverflowList:\\n\");\n \tspin_lock(&ctx->completion_lock);\n \tlist_for_each_entry(ocqe, &ctx->cq_overflow_list, list) {\n@@ -262,4 +245,23 @@ __cold void io_uring_show_fdinfo(struct seq_file *m, struct file *file)\n \tspin_unlock(&ctx->completion_lock);\n \tnapi_show_fdinfo(ctx, m);\n }\n+\n+/*\n+ * Caller holds a reference to the file already, we don't need to do\n+ * anything else to get an extra reference.\n+ */\n+__cold void io_uring_show_fdinfo(struct seq_file *m, struct file *file)\n+{\n+\tstruct io_ring_ctx *ctx = file->private_data;\n+\n+\t/*\n+\t * Avoid ABBA deadlock between the seq lock and the io_uring mutex,\n+\t * since fdinfo case grabs it in the opposite direction of normal use\n+\t * cases.\n+\t */\n+\tif (mutex_trylock(&ctx->uring_lock)) {\n+\t\t__io_uring_show_fdinfo(ctx, m);\n+\t\tmutex_unlock(&ctx->uring_lock);\n+\t}\n+}\n #endif"