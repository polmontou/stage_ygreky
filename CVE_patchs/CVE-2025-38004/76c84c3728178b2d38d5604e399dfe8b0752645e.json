"diff --git a/net/can/bcm.c b/net/can/bcm.c\nindex a1f5db0fd5d4..f0be2a0f8519 100644\n--- a/net/can/bcm.c\n+++ b/net/can/bcm.c\n@@ -58,6 +58,7 @@\n #include <linux/can/skb.h>\n #include <linux/can/bcm.h>\n #include <linux/slab.h>\n+#include <linux/spinlock.h>\n #include <net/sock.h>\n #include <net/net_namespace.h>\n \n@@ -120,6 +121,7 @@ struct bcm_op {\n \tstruct canfd_frame last_sframe;\n \tstruct sock *sk;\n \tstruct net_device *rx_reg_dev;\n+\tspinlock_t bcm_tx_lock; /* protect currframe/count in runtime updates */\n };\n \n struct bcm_sock {\n@@ -273,13 +275,18 @@ static void bcm_can_tx(struct bcm_op *op)\n {\n \tstruct sk_buff *skb;\n \tstruct net_device *dev;\n-\tstruct canfd_frame *cf = op->frames + op->cfsiz * op->currframe;\n+\tstruct canfd_frame *cf;\n \tint err;\n \n \t/* no target device? => exit */\n \tif (!op->ifindex)\n \t\treturn;\n \n+\t/* read currframe under lock protection */\n+\tspin_lock_bh(&op->bcm_tx_lock);\n+\tcf = op->frames + op->cfsiz * op->currframe;\n+\tspin_unlock_bh(&op->bcm_tx_lock);\n+\n \tdev = dev_get_by_index(sock_net(op->sk), op->ifindex);\n \tif (!dev) {\n \t\t/* RFC: should this bcm_op remove itself here? */\n@@ -300,6 +307,10 @@ static void bcm_can_tx(struct bcm_op *op)\n \tskb->dev = dev;\n \tcan_skb_set_owner(skb, op->sk);\n \terr = can_send(skb, 1);\n+\n+\t/* update currframe and count under lock protection */\n+\tspin_lock_bh(&op->bcm_tx_lock);\n+\n \tif (!err)\n \t\top->frames_abs++;\n \n@@ -308,6 +319,11 @@ static void bcm_can_tx(struct bcm_op *op)\n \t/* reached last frame? */\n \tif (op->currframe >= op->nframes)\n \t\top->currframe = 0;\n+\n+\tif (op->count > 0)\n+\t\top->count--;\n+\n+\tspin_unlock_bh(&op->bcm_tx_lock);\n out:\n \tdev_put(dev);\n }\n@@ -404,7 +420,7 @@ static enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)\n \tstruct bcm_msg_head msg_head;\n \n \tif (op->kt_ival1 && (op->count > 0)) {\n-\t\top->count--;\n+\t\tbcm_can_tx(op);\n \t\tif (!op->count && (op->flags & TX_COUNTEVT)) {\n \n \t\t\t/* create notification to user */\n@@ -419,7 +435,6 @@ static enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)\n \n \t\t\tbcm_send_to_user(op, &msg_head, NULL, 0);\n \t\t}\n-\t\tbcm_can_tx(op);\n \n \t} else if (op->kt_ival2) {\n \t\tbcm_can_tx(op);\n@@ -914,6 +929,27 @@ static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n \t\t}\n \t\top->flags = msg_head->flags;\n \n+\t\t/* only lock for unlikely count/nframes/currframe changes */\n+\t\tif (op->nframes != msg_head->nframes ||\n+\t\t    op->flags & TX_RESET_MULTI_IDX ||\n+\t\t    op->flags & SETTIMER) {\n+\n+\t\t\tspin_lock_bh(&op->bcm_tx_lock);\n+\n+\t\t\tif (op->nframes != msg_head->nframes ||\n+\t\t\t    op->flags & TX_RESET_MULTI_IDX) {\n+\t\t\t\t/* potentially update changed nframes */\n+\t\t\t\top->nframes = msg_head->nframes;\n+\t\t\t\t/* restart multiple frame transmission */\n+\t\t\t\top->currframe = 0;\n+\t\t\t}\n+\n+\t\t\tif (op->flags & SETTIMER)\n+\t\t\t\top->count = msg_head->count;\n+\n+\t\t\tspin_unlock_bh(&op->bcm_tx_lock);\n+\t\t}\n+\n \t} else {\n \t\t/* insert new BCM operation for the given can_id */\n \n@@ -921,9 +957,14 @@ static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n \t\tif (!op)\n \t\t\treturn -ENOMEM;\n \n+\t\tspin_lock_init(&op->bcm_tx_lock);\n \t\top->can_id = msg_head->can_id;\n \t\top->cfsiz = CFSIZ(msg_head->flags);\n \t\top->flags = msg_head->flags;\n+\t\top->nframes = msg_head->nframes;\n+\n+\t\tif (op->flags & SETTIMER)\n+\t\t\top->count = msg_head->count;\n \n \t\t/* create array for CAN frames and copy the data */\n \t\tif (msg_head->nframes > 1) {\n@@ -982,22 +1023,8 @@ static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n \n \t} /* if ((op = bcm_find_op(&bo->tx_ops, msg_head->can_id, ifindex))) */\n \n-\tif (op->nframes != msg_head->nframes) {\n-\t\top->nframes   = msg_head->nframes;\n-\t\t/* start multiple frame transmission with index 0 */\n-\t\top->currframe = 0;\n-\t}\n-\n-\t/* check flags */\n-\n-\tif (op->flags & TX_RESET_MULTI_IDX) {\n-\t\t/* start multiple frame transmission with index 0 */\n-\t\top->currframe = 0;\n-\t}\n-\n \tif (op->flags & SETTIMER) {\n \t\t/* set timer values */\n-\t\top->count = msg_head->count;\n \t\top->ival1 = msg_head->ival1;\n \t\top->ival2 = msg_head->ival2;\n \t\top->kt_ival1 = bcm_timeval_to_ktime(msg_head->ival1);\n@@ -1014,11 +1041,8 @@ static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n \t\top->flags |= TX_ANNOUNCE;\n \t}\n \n-\tif (op->flags & TX_ANNOUNCE) {\n+\tif (op->flags & TX_ANNOUNCE)\n \t\tbcm_can_tx(op);\n-\t\tif (op->count)\n-\t\t\top->count--;\n-\t}\n \n \tif (op->flags & STARTTIMER)\n \t\tbcm_tx_start_timer(op);"