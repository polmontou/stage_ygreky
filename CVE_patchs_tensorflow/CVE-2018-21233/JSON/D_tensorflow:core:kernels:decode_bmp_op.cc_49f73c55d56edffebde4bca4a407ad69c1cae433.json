"diff --git a/tensorflow/core/kernels/decode_bmp_op.cc b/tensorflow/core/kernels/decode_bmp_op.cc\nindex b7d120a6178..b4dcf0a74b3 100644\n--- a/tensorflow/core/kernels/decode_bmp_op.cc\n+++ b/tensorflow/core/kernels/decode_bmp_op.cc\n@@ -91,15 +91,32 @@ class DecodeBmpOp : public OpKernel {\n                 errors::InvalidArgument(\n                     \"Number of channels must be 1, 3 or 4, was \", channels_));\n \n+    OP_REQUIRES(context, width > 0 && header_size >= 0,\n+                errors::InvalidArgument(\"Width must be positive\"));\n+    OP_REQUIRES(context, header_size >= 0,\n+                errors::InvalidArgument(\"header size must be nonnegative\"));\n+\n+    // The real requirement is < 2^31 minus some headers and channel data,\n+    // so rounding down to something that's still ridiculously big.\n+    OP_REQUIRES(\n+        context,\n+        (static_cast<int64>(width) * std::abs(static_cast<int64>(height))) <\n+            static_cast<int64>(std::numeric_limits<int32_t>::max() / 8),\n+        errors::InvalidArgument(\n+            \"Total possible pixel bytes must be less than 2^30\"));\n+\n+    const int32 abs_height = abs(height);\n+\n     // there may be padding bytes when the width is not a multiple of 4 bytes\n     // 8 * channels == bits per pixel\n     const int row_size = (8 * channels_ * width + 31) / 32 * 4;\n \n-    const int last_pixel_offset =\n-        header_size + (abs(height) - 1) * row_size + (width - 1) * channels_;\n+    const int64 last_pixel_offset = static_cast<int64>(header_size) +\n+                                    (abs_height - 1) * row_size +\n+                                    (width - 1) * channels_;\n \n     // [expected file size] = [last pixel offset] + [last pixel size=channels]\n-    const int expected_file_size = last_pixel_offset + channels_;\n+    const int64 expected_file_size = last_pixel_offset + channels_;\n \n     OP_REQUIRES(\n         context, (expected_file_size <= input.size()),\n@@ -115,12 +132,12 @@ class DecodeBmpOp : public OpKernel {\n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(\n         context, context->allocate_output(\n-                     0, TensorShape({abs(height), width, channels_}), &output));\n+                     0, TensorShape({abs_height, width, channels_}), &output));\n \n     const uint8* bmp_pixels = &img_bytes[header_size];\n \n     Decode(bmp_pixels, row_size, output->flat<uint8>().data(), width,\n-           abs(height), channels_, top_down);\n+           abs_height, channels_, top_down);\n   }\n \n   uint8* Decode(const uint8* input, const int row_size, uint8* const output,"