"diff --git a/tensorflow/contrib/lite/tools/verifier.cc b/tensorflow/contrib/lite/tools/verifier.cc\nindex 59c74205f0a..8818a7dc85d 100644\n--- a/tensorflow/contrib/lite/tools/verifier.cc\n+++ b/tensorflow/contrib/lite/tools/verifier.cc\n@@ -148,11 +148,52 @@ bool VerifyNumericTensorBuffer(const Tensor& tensor, const Buffer& buffer,\n   // TODO(yichengfan): verify quantized tensors.\n }\n \n+using flatbuffers::Offset;\n+using flatbuffers::Vector;\n+\n+bool VerifyOperators(const Vector<Offset<Operator>>& operators,\n+                     ErrorReporter* error_reporter) {\n+  for (const auto& op : operators) {\n+    if (!op->inputs()) {\n+      ReportError(error_reporter, \"Missing 'inputs' for operator.\");\n+      return false;\n+    }\n+    if (!op->outputs()) {\n+      ReportError(error_reporter, \"Missing 'outputs' for operator.\");\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+bool VerifySubGraphs(const Model& model, ErrorReporter* error_reporter) {\n+  if (!model.subgraphs()) {\n+    ReportError(error_reporter, \"Missing 'subgraphs' section.\");\n+    return false;\n+  }\n+  for (const auto& subgraph : *model.subgraphs()) {\n+    if (!subgraph->operators()) {\n+      ReportError(error_reporter, \"Missing 'operators' section in subgraph.\");\n+      return false;\n+    }\n+\n+    if (!VerifyOperators(*subgraph->operators(), error_reporter)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n // Verifies tensors have valid properties and legit buffer if set.\n bool VerifyTensors(const Model& model, ErrorReporter* error_reporter) {\n   if (!model.subgraphs()) {\n     return true;\n   }\n+  if (!model.buffers()) {\n+    ReportError(error_reporter, \"Missing 'buffers' section.\");\n+    return false;\n+  }\n+\n   for (const auto& subgraph : *model.subgraphs()) {\n     if (!subgraph->tensors()) {\n       continue;\n@@ -167,19 +208,23 @@ bool VerifyTensors(const Model& model, ErrorReporter* error_reporter) {\n         return false;\n       }\n       auto* buffer = model.buffers()->Get(tensor->buffer());\n-      if (!buffer || !buffer->data()) {\n+      if (!buffer) {\n         ReportError(error_reporter, \"Tensor buffer %d not set\",\n                     tensor->buffer());\n         return false;\n       }\n \n-      if (tensor->type() == TensorType_STRING) {\n-        if (!VerifyStringTensorBuffer(*buffer, error_reporter)) {\n-          return false;\n-        }\n-      } else {\n-        if (!VerifyNumericTensorBuffer(*tensor, *buffer, error_reporter)) {\n-          return false;\n+      // Many transient tensors don't have data in the flatbuffer. Their\n+      // buffers will be allocated by the interpreter at run-time.\n+      if (buffer->data()) {\n+        if (tensor->type() == TensorType_STRING) {\n+          if (!VerifyStringTensorBuffer(*buffer, error_reporter)) {\n+            return false;\n+          }\n+        } else {\n+          if (!VerifyNumericTensorBuffer(*tensor, *buffer, error_reporter)) {\n+            return false;\n+          }\n         }\n       }\n     }\n@@ -193,6 +238,13 @@ bool VerifyOps(const Model& model, const OpResolver& resolver,\n     return true;\n   }\n   for (const auto& opcode : *model.operator_codes()) {\n+    if (opcode->builtin_code() < BuiltinOperator_MIN ||\n+        opcode->builtin_code() > BuiltinOperator_MAX) {\n+      ReportError(error_reporter, \"Operator id '%d' is out of range.\",\n+                  opcode->builtin_code());\n+      return false;\n+    }\n+\n     if (opcode->builtin_code() == BuiltinOperator_CUSTOM) {\n       if (!resolver.FindOp(opcode->custom_code()->c_str())) {\n         ReportError(error_reporter, \"Unsupported custom op: %s\",\n@@ -223,6 +275,9 @@ bool Verify(const void* buf, size_t len, const OpResolver& resolver,\n     ReportError(error_reporter, \"Invalid model version %d\", model->version());\n     return false;\n   }\n+  if (!VerifySubGraphs(*model, error_reporter)) {\n+    return false;\n+  }\n   if (!VerifyTensors(*model, error_reporter)) {\n     return false;\n   }"