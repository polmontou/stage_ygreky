"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/contrib/lite/toco/tflite/import.h\"\n\n#include \"flatbuffers/flexbuffers.h\"\n#include \"tensorflow/contrib/lite/model.h\"\n#include \"tensorflow/contrib/lite/schema/schema_generated.h\"\n#include \"tensorflow/contrib/lite/toco/tflite/operator.h\"\n#include \"tensorflow/contrib/lite/toco/tflite/types.h\"\n#include \"tensorflow/contrib/lite/toco/tooling_util.h\"\n#include \"tensorflow/contrib/lite/tools/verifier.h\"\n\nnamespace toco {\n\nnamespace tflite {\n\nnamespace details {\nvoid LoadTensorsTable(const ::tflite::Model& input_model,\n                      TensorsTable* tensors_table) {\n  // TODO(aselle): add support to toco for multiple subgraphs.\n  auto tensors = (*input_model.subgraphs())[0]->tensors();\n  if (!tensors) return;\n  for (const auto* tensor : *tensors) {\n    tensors_table->push_back(tensor->name()->c_str());\n  }\n}\n\nvoid LoadOperatorsTable(const ::tflite::Model& input_model,\n                        OperatorsTable* operators_table) {\n  auto opcodes = input_model.operator_codes();\n  if (!opcodes) return;\n  for (const auto* opcode : *opcodes) {\n    if (opcode->builtin_code() != ::tflite::BuiltinOperator_CUSTOM) {\n      operators_table->push_back(\n          EnumNameBuiltinOperator(opcode->builtin_code()));\n    } else {\n      operators_table->push_back(opcode->custom_code()->c_str());\n    }\n  }\n}\n}  // namespace details\n\nvoid ImportTensors(const ::tflite::Model& input_model, Model* model) {\n  auto tensors = (*input_model.subgraphs())[0]->tensors();\n  auto* buffers = input_model.buffers();\n  // auto tensors = input_model.tensors();\n  if (!tensors) return;\n  for (const auto* input_tensor : *tensors) {\n    Array& array = model->GetOrCreateArray(input_tensor->name()->c_str());\n    array.data_type = DataType::Deserialize(input_tensor->type());\n    int buffer_index = input_tensor->buffer();\n    auto* buffer = buffers->Get(buffer_index);\n    DataBuffer::Deserialize(*input_tensor, *buffer, &array);\n\n    auto shape = input_tensor->shape();\n    if (shape) {\n      // If the shape is 0-dimensional, make sure to record it as such,\n      // as oppose to leaving the array without a shape.\n      array.mutable_shape()->mutable_dims()->clear();\n      for (int i = 0; i < shape->Length(); ++i) {\n        auto d = shape->Get(i);\n        array.mutable_shape()->mutable_dims()->push_back(d);\n      }\n    }\n\n    auto quantization = input_tensor->quantization();\n    if (quantization) {\n      // Note that tf.mini only supports a single quantization parameters for\n      // the whole array.\n      if (quantization->min() && quantization->max()) {\n        CHECK_EQ(1, quantization->min()->Length());\n        CHECK_EQ(1, quantization->max()->Length());\n        MinMax& minmax = array.GetOrCreateMinMax();\n        minmax.min = quantization->min()->Get(0);\n        minmax.max = quantization->max()->Get(0);\n      }\n      if (quantization->scale() && quantization->zero_point()) {\n        CHECK_EQ(1, quantization->scale()->Length());\n        CHECK_EQ(1, quantization->zero_point()->Length());\n        QuantizationParams& q = array.GetOrCreateQuantizationParams();\n        q.scale = quantization->scale()->Get(0);\n        q.zero_point = quantization->zero_point()->Get(0);\n      }\n    }\n  }\n}\n\nvoid ImportOperators(\n    const ::tflite::Model& input_model,\n    const std::map<string, std::unique_ptr<BaseOperator>>& ops_by_name,\n    const details::TensorsTable& tensors_table,\n    const details::OperatorsTable& operators_table, Model* model) {\n  // TODO(aselle): add support for multiple subgraphs.\n  auto ops = (*input_model.subgraphs())[0]->operators();\n\n  if (!ops) return;\n  for (const auto* input_op : *ops) {\n    int index = input_op->opcode_index();\n    if (index < 0 || index > operators_table.size()) {\n      LOG(FATAL) << \"Index \" << index << \" must be between zero and \"\n                 << operators_table.size();\n    }\n    string opname = operators_table.at(index);\n    if (ops_by_name.count(opname) == 0) {\n      LOG(FATAL) << \"Op '\" << opname << \"' not supported\";\n    }\n\n    auto new_op = ops_by_name.at(opname)->Deserialize(\n        input_op->builtin_options(), input_op->custom_options());\n    model->operators.emplace_back(new_op.release());\n    auto* op = model->operators.back().get();\n\n    auto inputs = input_op->inputs();\n    for (int i = 0; i < inputs->Length(); i++) {\n      auto input_index = inputs->Get(i);\n      // input_index == -1 indicates optional tensor.\n      if (input_index != -1) {\n        const string& input_name = tensors_table.at(input_index);\n        op->inputs.push_back(input_name);\n      } else {\n        const string& tensor_name =\n            toco::AvailableArrayName(*model, \"OptionalTensor\");\n        model->CreateOptionalArray(tensor_name);\n        op->inputs.push_back(tensor_name);\n      }\n    }\n    auto outputs = input_op->outputs();\n    for (int i = 0; i < outputs->Length(); i++) {\n      auto output_index = outputs->Get(i);\n      const string& output_name = tensors_table.at(output_index);\n      op->outputs.push_back(output_name);\n    }\n  }\n}\n\nvoid ImportIOTensors(const ::tflite::Model& input_model,\n                     const details::TensorsTable& tensors_table, Model* model) {\n  auto inputs = (*input_model.subgraphs())[0]->inputs();\n  if (inputs) {\n    for (int input : *inputs) {\n      const string& input_name = tensors_table.at(input);\n      model->flags.add_input_arrays()->set_name(input_name);\n    }\n  }\n\n  auto outputs = (*input_model.subgraphs())[0]->outputs();\n  if (outputs) {\n    for (int output : *outputs) {\n      const string& output_name = tensors_table.at(output);\n      model->flags.add_output_arrays(output_name);\n    }\n  }\n}\n\nnamespace {\nbool Verify(const void* buf, size_t len) {\n  ::flatbuffers::Verifier verifier(static_cast<const uint8_t*>(buf), len);\n  return ::tflite::VerifyModelBuffer(verifier);\n}\n}  // namespace\n\nstd::unique_ptr<Model> Import(const ModelFlags& model_flags,\n                              const string& input_file_contents) {\n  ::tflite::AlwaysTrueResolver r;\n  if (!::tflite::Verify(input_file_contents.data(), input_file_contents.size(),\n                        r, ::tflite::DefaultErrorReporter())) {\n    LOG(FATAL) << \"Invalid flatbuffer.\";\n  }\n  const ::tflite::Model* input_model =\n      ::tflite::GetModel(input_file_contents.data());\n\n  // Full list of all known operators.\n  const auto ops_by_name = BuildOperatorByNameMap();\n\n  if (!input_model->subgraphs() || input_model->subgraphs()->size() != 1) {\n    LOG(FATAL) << \"Number of subgraphs in tflite should be exactly 1.\";\n  }\n  std::unique_ptr<Model> model;\n  model.reset(new Model);\n\n  details::TensorsTable tensors_table;\n  details::LoadTensorsTable(*input_model, &tensors_table);\n\n  details::OperatorsTable operators_table;\n  details::LoadOperatorsTable(*input_model, &operators_table);\n\n  ImportTensors(*input_model, model.get());\n  ImportOperators(*input_model, ops_by_name, tensors_table, operators_table,\n                  model.get());\n  ImportIOTensors(*input_model, tensors_table, model.get());\n\n  return model;\n}\n\n}  // namespace tflite\n\n}  // namespace toco"