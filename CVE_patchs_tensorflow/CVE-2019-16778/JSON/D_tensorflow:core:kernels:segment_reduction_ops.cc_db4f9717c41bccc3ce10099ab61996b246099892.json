"diff --git a/tensorflow/core/kernels/segment_reduction_ops.cc b/tensorflow/core/kernels/segment_reduction_ops.cc\nindex fabb7f6de1f..e26bc595f56 100644\n--- a/tensorflow/core/kernels/segment_reduction_ops.cc\n+++ b/tensorflow/core/kernels/segment_reduction_ops.cc\n@@ -376,18 +376,17 @@ namespace functor {\n template <typename T, typename Index, typename InitialValueF,\n           typename ReductionF>\n struct UnsortedSegmentFunctor<CPUDevice, T, Index, InitialValueF, ReductionF> {\n-  void operator()(OpKernelContext* ctx, const Index num_segments,\n-                  const TensorShape& segment_ids_shape,\n+  void operator()(OpKernelContext* ctx, const TensorShape& segment_ids_shape,\n                   typename TTypes<Index>::ConstFlat segment_ids,\n-                  const Index data_size, const T* data,\n+                  typename TTypes<T, 2>::ConstTensor data,\n                   typename TTypes<T, 2>::Tensor output) {\n     output.setConstant(InitialValueF()());\n-    if (data_size == 0) {\n+    if (data.size() == 0) {\n       return;\n     }\n     const int64 N = segment_ids.dimension(0);\n+    const int64 num_segments = output.dimension(0);\n     ReductionF reduction;\n-    auto data_flat = typename TTypes<T, 2>::ConstTensor(data, N, data_size / N);\n     for (int64 i = 0; i < N; ++i) {\n       Index j = internal::SubtleMustCopy(segment_ids(i));\n       if (j < 0) {\n@@ -397,7 +396,7 @@ struct UnsortedSegmentFunctor<CPUDevice, T, Index, InitialValueF, ReductionF> {\n                   errors::InvalidArgument(\n                       \"segment_ids\", SliceDebugString(segment_ids_shape, i),\n                       \" = \", j, \" is out of range [0, \", num_segments, \")\"));\n-      reduction(data_flat.template chip<0>(i), output.template chip<0>(j));\n+      reduction(data.template chip<0>(i), output.template chip<0>(j));\n     }\n   }\n };\n@@ -485,7 +484,7 @@ class UnsortedSegmentReductionOp : public OpKernel {\n       return;\n     }\n     const auto segment_flat = segment_ids.flat<Index>();\n-    const Index output_rows = internal::SubtleMustCopy(static_cast<Index>(\n+    const int64 output_rows = internal::SubtleMustCopy(static_cast<int64>(\n         num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                          : num_segments.scalar<int64>()()));\n     OP_REQUIRES(context, output_rows >= 0,\n@@ -499,9 +498,9 @@ class UnsortedSegmentReductionOp : public OpKernel {\n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n     auto output_flat = output->flat_outer_dims<T>();\n-    auto data_ptr = data.template flat<T>().data();\n-    reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat,\n-                       data.NumElements(), data_ptr, output_flat);\n+    auto data_flat = data.flat_inner_outer_dims<T, 2>(segment_ids.dims() - 1);\n+    reduction_functor_(context, segment_ids.shape(), segment_flat, data_flat,\n+                       output_flat);\n   }\n \n  protected:"