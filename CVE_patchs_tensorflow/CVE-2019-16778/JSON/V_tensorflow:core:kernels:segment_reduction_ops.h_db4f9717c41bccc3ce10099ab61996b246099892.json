"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_H_\n#define TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_H_\n\n// This file requires the following include because it uses GpuAtomicMax:\n// #include \"tensorflow/core/util/gpu_kernel_helper.h\"\n\n// Unfortunately we can't add the #include, since it breaks compilation for\n// non-GPU targets. This only breaks in clang, because it's more strict for\n// template code and GpuAtomicMax is used in template context.\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n\nnamespace tensorflow {\n\nclass OpKernelContext;\n\nnamespace functor {\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\ntypedef Eigen::GpuDevice GPUDevice;\n// Functor for SegmentSumGPUOp.\n// output_rows: the number of output segments (unique segment ids in\n//                'segment_ids').\n// segment_ids_shape: shape of 'segment_ids' tensor.\n// segment_ids: unsorted map from input to output segment ids at which to\n//                perform segment sum operation.\n// data_size: size of input data tensor.\n// data: input data tensor.\n// output: output reshaped to {output_rows, output.size/output_rows}\ntemplate <typename T, typename Index>\nstruct SegmentSumFunctor {\n  void operator()(OpKernelContext* ctx, const GPUDevice& d,\n                  const Index output_rows, const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output);\n};\n\n#endif\n\ntemplate <typename Device, typename T, typename Index, typename InitialValueF,\n          typename ReductionF>\nstruct UnsortedSegmentFunctor {\n  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output);\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n// reduction functors for the gpu\ntemplate <typename T>\nstruct SumOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicAdd(dest, value);\n  }\n};\n\ntemplate <typename T>\nstruct ProdOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicMul(dest, value);\n  }\n};\n\ntemplate <typename T>\nstruct MaxOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicMax(dest, value);\n  }\n};\n\ntemplate <typename T>\nstruct MinOpGpu {\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void operator()(T* dest,\n                                                        const T& value) {\n    GpuAtomicMin(dest, value);\n  }\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// initial value functors\ntemplate <typename T>\nstruct Zero {\n  EIGEN_STRONG_INLINE T operator()() const { return T(0); }\n};\n\ntemplate <typename T>\nstruct One {\n  EIGEN_STRONG_INLINE T operator()() const { return T(1); }\n};\n\ntemplate <typename T>\nstruct Lowest {\n  EIGEN_STRONG_INLINE T operator()() const {\n    return Eigen::NumTraits<T>::lowest();\n  }\n};\n\ntemplate <typename T>\nstruct Highest {\n  EIGEN_STRONG_INLINE T operator()() const {\n    return Eigen::NumTraits<T>::highest();\n  }\n};\n\n}  // namespace functor\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_CORE_KERNELS_SEGMENT_REDUCTION_OPS_H_"