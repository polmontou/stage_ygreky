"# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for sparse ops.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\n# Need array_grad to register gradient for Identity.\nfrom tensorflow.python.ops import array_grad  # pylint: disable=unused-import\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gradient_checker_v2 as gradient_checker\nfrom tensorflow.python.ops import math_ops\n# Need sparse_grad to register gradient for SparseToDense.\nfrom tensorflow.python.ops import sparse_grad  # pylint: disable=unused-import\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import googletest\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass SparseOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  def testSparseEye(self):\n    def test_one(n, m, as_tensors):\n      expected = np.eye(n, m)\n      if as_tensors:\n        m = constant_op.constant(m)\n        n = constant_op.constant(n)\n      s = sparse_ops.sparse_eye(n, m)\n      d = sparse_ops.sparse_to_dense(s.indices, s.dense_shape, s.values)\n      self.assertAllEqual(self.evaluate(d), expected)\n\n    for n in range(2, 10, 2):\n      for m in range(2, 10, 2):\n        # Test with n and m as both constants and tensors.\n        test_one(n, m, True)\n        test_one(n, m, False)\n\n  def testDenseFromConstantToSparse(self):\n    expected_constant = np.reshape(np.arange(24, dtype=np.int64), (3, 4, 2))\n    tensor = constant_op.constant(expected_constant)\n    sparse = sparse_ops.from_dense(tensor)\n    dense = sparse_ops.sparse_to_dense(sparse.indices, sparse.dense_shape,\n                                       sparse.values)\n    constant = self.evaluate(dense)\n    self.assertAllEqual(expected_constant, constant)\n\n  def testTransposePreservesShape(self):\n    with ops.Graph().as_default():\n      t = sparse_tensor.SparseTensor(indices=[[0, 0]],\n                                     values=[0.],\n                                     dense_shape=[3, 4])\n      self.assertTrue(t.shape.is_fully_defined)\n      transposed = sparse_ops.sparse_transpose(t)\n      self.assertAllEqual(transposed.shape, [4, 3])\n\n  def testSparseExpandDims(self):\n    for rank in range(1, 4):\n      # Create a dummy input. When rank=3, shape=[2, 4, 6].\n      shape = np.arange(1, rank + 1) * 2\n      before = np.arange(np.prod(shape)).reshape(shape)\n\n      # Make entries sparse.\n      before *= np.random.binomial(1, .2, before.shape)\n      dense_shape = before.shape\n      indices = np.array(np.where(before)).T\n      values = before[before != 0]\n\n      # Try every possible valid value of axis.\n      for axis in range(-rank - 1, rank):\n        expected_after = np.expand_dims(before, axis)\n\n        for axis_as_tensor in [False, True]:\n          dense_shape_t = constant_op.constant(dense_shape, dtype=dtypes.int64)\n          indices_t = constant_op.constant(indices)\n          values_t = constant_op.constant(values)\n          before_t = sparse_tensor.SparseTensor(\n              indices=indices_t, values=values_t, dense_shape=dense_shape_t)\n\n          if axis_as_tensor:\n            axis = constant_op.constant(axis)\n\n          s = sparse_ops.sparse_expand_dims(before_t, axis)\n          d = sparse_ops.sparse_to_dense(s.indices, s.dense_shape, s.values)\n          self.assertAllEqual(self.evaluate(d), expected_after)\n\n  @parameterized.parameters([\n      (math_ops.abs, [1.0, -1.0, 3.0, -4.0], [1.0, 1.0, 3.0, 4.0]),\n      (math_ops.negative, [1.0, -1.0, 3.0, -4.0], [-1.0, 1.0, -3.0, 4.0]),\n      (math_ops.sign, [3.0, -2.0, 0.0, -4.0], [1.0, -1.0, 0.0, -1.0]),\n      (math_ops.square, [1.0, -1.0, 3.0, -4.0], [1.0, 1.0, 9.0, 16.0]),\n  ])\n  def testUnarySparseDispatch(self, op, values, expected):\n    st = sparse_tensor.SparseTensor(\n        indices=[[0, 0], [0, 1], [2, 0], [2, 4]],\n        values=values,\n        dense_shape=[3, 6])\n    result = op(st)\n    result_value = self.evaluate(result)\n    self.assertAllEqual(result_value.indices, st.indices)\n    self.assertAllEqual(result_value.values, expected)\n    self.assertAllEqual(result_value.dense_shape, st.dense_shape)\n\n  def testSparseToDenseGradient(self):\n\n    def f(sparse_values, default_value):\n      st = sparse_tensor.SparseTensor(\n          indices=[[0, 3, 6], [1, 4, 7], [2, 5, 8]],\n          values=sparse_values,\n          dense_shape=[3, 6, 9])\n      return sparse_ops.sparse_tensor_to_dense(st, default_value)\n\n    grads = gradient_checker.compute_gradient(\n        f, [constant_op.constant([1.0, 2.0, 3.0]),\n            constant_op.constant(0.0)])\n    epsilon = 1e-4\n    self.assertLess(gradient_checker.max_error(*grads), epsilon)\n\n  def testSparseTensorToDenseString(self):\n    sp = sparse_tensor.SparseTensor(\n        indices=[[0, 0], [1, 2]], values=['a', 'b'], dense_shape=[2, 3])\n    dense = sparse_ops.sparse_tensor_to_dense(sp)\n    expected_dense = [[b'a', b'', b''], [b'', b'', b'b']]\n    result_dense = self.evaluate(dense)\n    self.assertAllEqual(expected_dense, result_dense)\n\n  def testDenseSparseTensorMatMul(self):\n\n    np.random.seed(42)\n    dense_numpy_array = np.random.rand(3, 3)\n    independent_dense_tf = constant_op.constant(\n        dense_numpy_array, dtype='float32')\n\n    sp = sparse_tensor.SparseTensor(\n        indices=[[0, 0], [1, 2]], values=[4., 8.], dense_shape=[3, 3])\n    dense_of_sparse = sparse_ops.sparse_to_dense(sp.indices, sp.shape,\n                                                 sp.values)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=False, adjoint_b=False)\n    expected = math_ops.matmul(independent_dense_tf, dense_of_sparse)\n    self.assertAllEqual(expected, result)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=False, adjoint_b=True)\n    expected = math_ops.matmul(independent_dense_tf,\n                               array_ops.transpose(dense_of_sparse))\n    self.assertAllEqual(expected, result)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=True, adjoint_b=False)\n    expected = math_ops.matmul(\n        array_ops.transpose(independent_dense_tf), dense_of_sparse)\n    self.assertAllEqual(expected, result)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=True, adjoint_b=True)\n    expected = math_ops.matmul(\n        array_ops.transpose(independent_dense_tf),\n        array_ops.transpose(dense_of_sparse))\n    self.assertAllEqual(expected, result)\n\n  def testMapValues(self):\n    # supplying no sparse tensor should result in ValueError\n    with self.assertRaises(ValueError):\n      sparse_ops.map_values(math_ops.abs, 0.0)\n\n    sp = sparse_ops.from_dense([[0.0, 1.0, 0.0], [-2.0, 1.0, 0.0]])\n\n    # helper function to check equality of sparse tensor\n    def assert_sparse_equal(expected, result):\n      self.assertAllEqual(expected.values, result.values, msg='Values differ')\n      self.assertAllEqual(\n          expected.indices, result.indices, msg='Indices differ')\n      self.assertAllEqual(\n          expected.dense_shape, result.dense_shape, msg='Shapes differ')\n\n    # check for a single sparse argument\n    expected = sparse_ops.from_dense([[0.0, 1.0, 0.0], [2.0, 1.0, 0.0]])\n    result = sparse_ops.map_values(math_ops.abs, sp)\n    assert_sparse_equal(expected, result)\n\n    # check correct passing of keyword argument, and handling of two sparse\n    # arguments at the same time\n    def mapping(arg1, arg2, kwarg):\n      self.assertEqual(kwarg, 'kwarg')\n      return arg1 + arg2\n\n    result = sparse_ops.map_values(mapping, sp, sp, kwarg='kwarg')\n    expected = sparse_ops.from_dense([[0.0, 2.0, 0.0], [-4.0, 2.0, 0.0]])\n    assert_sparse_equal(expected, result)\n\n    # check that index mismatches are correctly detected even if the `value`s\n    # have compatible shape\n    sp_incomp = sparse_ops.from_dense([[0.0, 1.0, 0.0], [-2.0, 0.0, 1.0]])\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      result = sparse_ops.map_values(mapping, sp, sp_incomp, kwarg='kwarg')\n      self.evaluate(result)\n\n    # check that shape mismatches are correctly detected\n    sp_incomp = sparse_tensor.SparseTensor(sp.indices, sp.values, (25, 25))\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      result = sparse_ops.map_values(mapping, sp, sp_incomp, kwarg='kwarg')\n      self.evaluate(result)\n\n  def testConstantStringToSparse(self):\n    # Test case for GitHub issue 40633.\n    tensor = constant_op.constant(list('ababa'))\n    sparse = sparse_ops.from_dense(tensor)\n    result = self.evaluate(sparse)\n    self.assertAllEqual([[0], [1], [2], [3], [4]], result.indices)\n    self.assertAllEqual([b'a', b'b', b'a', b'b', b'a'], result.values)\n    self.assertAllEqual([5], result.dense_shape)\n\n\nif __name__ == '__main__':\n  googletest.main()"