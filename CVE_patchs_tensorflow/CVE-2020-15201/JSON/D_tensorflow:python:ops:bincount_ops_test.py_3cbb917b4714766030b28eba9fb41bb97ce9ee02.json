"diff --git a/tensorflow/python/ops/bincount_ops_test.py b/tensorflow/python/ops/bincount_ops_test.py\nindex baf0018fb32..5bc9bc1ab77 100644\n--- a/tensorflow/python/ops/bincount_ops_test.py\n+++ b/tensorflow/python/ops/bincount_ops_test.py\n@@ -25,7 +25,9 @@ from tensorflow.python.eager import context\n from tensorflow.python.framework import errors\n from tensorflow.python.framework import ops\n from tensorflow.python.framework import sparse_tensor\n+from tensorflow.python.framework import test_util\n from tensorflow.python.ops import bincount_ops\n+from tensorflow.python.ops import gen_count_ops\n from tensorflow.python.ops import sparse_ops\n from tensorflow.python.ops.ragged import ragged_factory_ops\n from tensorflow.python.ops.ragged import ragged_tensor\n@@ -834,5 +836,121 @@ class TestSparseCountFailureModes(test.TestCase):\n       self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n \n \n+@test_util.run_all_in_graph_and_eager_modes\n+@test_util.disable_tfrt\n+class RawOpsTest(test.TestCase, parameterized.TestCase):\n+\n+  def testSparseCountSparseOutputBadIndicesShape(self):\n+    indices = [[[0], [0]], [[0], [1]], [[1], [0]], [[1], [2]]]\n+    values = [1, 1, 1, 10]\n+    weights = [1, 2, 4, 6]\n+    dense_shape = [2, 3]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Input indices must be a 2-dimensional tensor\"):\n+      self.evaluate(\n+          gen_count_ops.SparseCountSparseOutput(\n+              indices=indices,\n+              values=values,\n+              dense_shape=dense_shape,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testSparseCountSparseOutputBadWeightsShape(self):\n+    indices = [[0, 0], [0, 1], [1, 0], [1, 2]]\n+    values = [1, 1, 1, 10]\n+    weights = [1, 2, 4]\n+    dense_shape = [2, 3]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Weights and values must have the same shape\"):\n+      self.evaluate(\n+          gen_count_ops.SparseCountSparseOutput(\n+              indices=indices,\n+              values=values,\n+              dense_shape=dense_shape,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testSparseCountSparseOutputBadNumberOfValues(self):\n+    indices = [[0, 0], [0, 1], [1, 0]]\n+    values = [1, 1, 1, 10]\n+    weights = [1, 2, 4, 6]\n+    dense_shape = [2, 3]\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"Number of values must match first dimension of indices\"):\n+      self.evaluate(\n+          gen_count_ops.SparseCountSparseOutput(\n+              indices=indices,\n+              values=values,\n+              dense_shape=dense_shape,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testRaggedCountSparseOutput(self):\n+    splits = [0, 4, 7]\n+    values = [1, 1, 2, 1, 2, 10, 5]\n+    weights = [1, 2, 3, 4, 5, 6, 7]\n+    output_indices, output_values, output_shape = self.evaluate(\n+        gen_count_ops.RaggedCountSparseOutput(\n+            splits=splits, values=values, weights=weights, binary_output=False))\n+    self.assertAllEqual([[0, 1], [0, 2], [1, 2], [1, 5], [1, 10]],\n+                        output_indices)\n+    self.assertAllEqual([7, 3, 5, 7, 6], output_values)\n+    self.assertAllEqual([2, 11], output_shape)\n+\n+  def testRaggedCountSparseOutputBadWeightsShape(self):\n+    splits = [0, 4, 7]\n+    values = [1, 1, 2, 1, 2, 10, 5]\n+    weights = [1, 2, 3, 4, 5, 6]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Weights and values must have the same shape\"):\n+      self.evaluate(\n+          gen_count_ops.RaggedCountSparseOutput(\n+              splits=splits,\n+              values=values,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testRaggedCountSparseOutputEmptySplits(self):\n+    splits = []\n+    values = [1, 1, 2, 1, 2, 10, 5]\n+    weights = [1, 2, 3, 4, 5, 6, 7]\n+    with self.assertRaisesRegex(\n+        errors.InvalidArgumentError,\n+        \"Must provide at least 2 elements for the splits argument\"):\n+      self.evaluate(\n+          gen_count_ops.RaggedCountSparseOutput(\n+              splits=splits,\n+              values=values,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testRaggedCountSparseOutputBadSplitsStart(self):\n+    splits = [1, 7]\n+    values = [1, 1, 2, 1, 2, 10, 5]\n+    weights = [1, 2, 3, 4, 5, 6, 7]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Splits must start with 0\"):\n+      self.evaluate(\n+          gen_count_ops.RaggedCountSparseOutput(\n+              splits=splits,\n+              values=values,\n+              weights=weights,\n+              binary_output=False))\n+\n+  def testRaggedCountSparseOutputBadSplitsEnd(self):\n+    splits = [0, 5]\n+    values = [1, 1, 2, 1, 2, 10, 5]\n+    weights = [1, 2, 3, 4, 5, 6, 7]\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                \"Splits must end with the number of values\"):\n+      self.evaluate(\n+          gen_count_ops.RaggedCountSparseOutput(\n+              splits=splits,\n+              values=values,\n+              weights=weights,\n+              binary_output=False))\n+\n+\n if __name__ == \"__main__\":\n   test.main()"