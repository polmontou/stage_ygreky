"/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <algorithm>\n#include <string>\n#include <vector>\n\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/boosted_trees/boosted_trees.pb.h\"\n#include \"tensorflow/core/kernels/boosted_trees/resources.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/refcount.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/platform/protobuf.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\n\nstatic void ConvertVectorsToMatrices(\n    const OpInputList bucketized_features_list,\n    std::vector<tensorflow::TTypes<int32>::ConstMatrix>& bucketized_features) {\n  for (const Tensor& tensor : bucketized_features_list) {\n    if (tensor.dims() == 1) {\n      const auto v = tensor.vec<int32>();\n      bucketized_features.emplace_back(\n          TTypes<int32>::ConstMatrix(v.data(), v.size(), 1));\n    } else {\n      bucketized_features.emplace_back(tensor.matrix<int32>());\n    }\n  }\n}\n\n// The Op used during training time to get the predictions so far with the\n// current ensemble being built.\n// Expect some logits are cached from the previous step and passed through\n// to be reused.\nclass BoostedTreesTrainingPredictOp : public OpKernel {\n public:\n  explicit BoostedTreesTrainingPredictOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_bucketized_features\",\n                                             &num_bucketized_features_));\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"logits_dimension\", &logits_dimension_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> resource;\n    // Get the resource.\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &resource));\n\n    // Get the inputs.\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features\",\n                                                &bucketized_features_list));\n    std::vector<tensorflow::TTypes<int32>::ConstMatrix> bucketized_features;\n    bucketized_features.reserve(bucketized_features_list.size());\n    ConvertVectorsToMatrices(bucketized_features_list, bucketized_features);\n    const int batch_size = bucketized_features[0].dimension(0);\n\n    const Tensor* cached_tree_ids_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"cached_tree_ids\", &cached_tree_ids_t));\n    const auto cached_tree_ids = cached_tree_ids_t->vec<int32>();\n\n    const Tensor* cached_node_ids_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"cached_node_ids\", &cached_node_ids_t));\n    const auto cached_node_ids = cached_node_ids_t->vec<int32>();\n\n    // Allocate outputs.\n    Tensor* output_partial_logits_t = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"partial_logits\",\n                                            {batch_size, logits_dimension_},\n                                            &output_partial_logits_t));\n    auto output_partial_logits = output_partial_logits_t->matrix<float>();\n\n    Tensor* output_tree_ids_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"tree_ids\", {batch_size},\n                                                     &output_tree_ids_t));\n    auto output_tree_ids = output_tree_ids_t->vec<int32>();\n\n    Tensor* output_node_ids_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\"node_ids\", {batch_size},\n                                                     &output_node_ids_t));\n    auto output_node_ids = output_node_ids_t->vec<int32>();\n\n    // Indicate that the latest tree was used.\n    const int32 latest_tree = resource->num_trees() - 1;\n\n    if (latest_tree < 0) {\n      // Ensemble was empty. Output the very first node.\n      output_node_ids.setZero();\n      output_tree_ids = cached_tree_ids;\n      // All the predictions are zeros.\n      output_partial_logits.setZero();\n    } else {\n      output_tree_ids.setConstant(latest_tree);\n      auto do_work = [&resource, &bucketized_features, &cached_tree_ids,\n                      &cached_node_ids, &output_partial_logits,\n                      &output_node_ids, latest_tree,\n                      this](int32 start, int32 end) {\n        for (int32 i = start; i < end; ++i) {\n          int32 tree_id = cached_tree_ids(i);\n          int32 node_id = cached_node_ids(i);\n          std::vector<float> partial_tree_logits(logits_dimension_, 0.0);\n\n          if (node_id >= 0) {\n            // If the tree was pruned, returns the node id into which the\n            // current_node_id was pruned, as well the correction of the cached\n            // logit prediction.\n            resource->GetPostPruneCorrection(tree_id, node_id, &node_id,\n                                             &partial_tree_logits);\n            // Logic in the loop adds the cached node value again if it is a\n            // leaf. If it is not a leaf anymore we need to subtract the old\n            // node's value. The following logic handles both of these cases.\n            const auto& node_logits = resource->node_value(tree_id, node_id);\n            if (!node_logits.empty()) {\n              DCHECK_EQ(node_logits.size(), logits_dimension_);\n              for (int32 j = 0; j < logits_dimension_; ++j) {\n                partial_tree_logits[j] -= node_logits[j];\n              }\n            }\n          } else {\n            // No cache exists, start from the very first node.\n            node_id = 0;\n          }\n          std::vector<float> partial_all_logits(logits_dimension_, 0.0);\n          while (true) {\n            if (resource->is_leaf(tree_id, node_id)) {\n              const auto& leaf_logits = resource->node_value(tree_id, node_id);\n              DCHECK_EQ(leaf_logits.size(), logits_dimension_);\n              // Tree is done\n              const float tree_weight = resource->GetTreeWeight(tree_id);\n              for (int32 j = 0; j < logits_dimension_; ++j) {\n                partial_all_logits[j] +=\n                    tree_weight * (partial_tree_logits[j] + leaf_logits[j]);\n                partial_tree_logits[j] = 0;\n              }\n              // Stop if it was the latest tree.\n              if (tree_id == latest_tree) {\n                break;\n              }\n              // Move onto other trees.\n              ++tree_id;\n              node_id = 0;\n            } else {\n              node_id =\n                  resource->next_node(tree_id, node_id, i, bucketized_features);\n            }\n          }\n          output_node_ids(i) = node_id;\n          for (int32 j = 0; j < logits_dimension_; ++j) {\n            output_partial_logits(i, j) = partial_all_logits[j];\n          }\n        }\n      };\n      // 30 is the magic number. The actual value might be a function of (the\n      // number of layers) * (cpu cycles spent on each layer), but this value\n      // would work for many cases. May be tuned later.\n      const int64 cost = 30;\n      thread::ThreadPool* const worker_threads =\n          context->device()->tensorflow_cpu_worker_threads()->workers;\n      Shard(worker_threads->NumThreads(), worker_threads, batch_size,\n            /*cost_per_unit=*/cost, do_work);\n    }\n  }\n\n private:\n  int32 logits_dimension_;         // the size of the output prediction vector.\n  int32 num_bucketized_features_;  // Indicates the number of features.\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"BoostedTreesTrainingPredict\").Device(DEVICE_CPU),\n                        BoostedTreesTrainingPredictOp);\n\n// The Op to get the predictions at the evaluation/inference time.\nclass BoostedTreesPredictOp : public OpKernel {\n public:\n  explicit BoostedTreesPredictOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_bucketized_features\",\n                                             &num_bucketized_features_));\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"logits_dimension\", &logits_dimension_));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> resource;\n    // Get the resource.\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &resource));\n\n    // Get the inputs.\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features\",\n                                                &bucketized_features_list));\n    std::vector<tensorflow::TTypes<int32>::ConstMatrix> bucketized_features;\n    bucketized_features.reserve(bucketized_features_list.size());\n    ConvertVectorsToMatrices(bucketized_features_list, bucketized_features);\n    const int batch_size = bucketized_features[0].dimension(0);\n\n    // Allocate outputs.\n    Tensor* output_logits_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"logits\", {batch_size, logits_dimension_},\n                                &output_logits_t));\n    auto output_logits = output_logits_t->matrix<float>();\n\n    // Return zero logits if it's an empty ensemble.\n    if (resource->num_trees() <= 0) {\n      output_logits.setZero();\n      return;\n    }\n\n    const int32 last_tree = resource->num_trees() - 1;\n    auto do_work = [&resource, &bucketized_features, &output_logits, last_tree,\n                    this](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        std::vector<float> tree_logits(logits_dimension_, 0.0);\n        int32 tree_id = 0;\n        int32 node_id = 0;\n        while (true) {\n          if (resource->is_leaf(tree_id, node_id)) {\n            const float tree_weight = resource->GetTreeWeight(tree_id);\n            const auto& leaf_logits = resource->node_value(tree_id, node_id);\n            DCHECK_EQ(leaf_logits.size(), logits_dimension_);\n            for (int32 j = 0; j < logits_dimension_; ++j) {\n              tree_logits[j] += tree_weight * leaf_logits[j];\n            }\n            // Stop if it was the last tree.\n            if (tree_id == last_tree) {\n              break;\n            }\n            // Move onto other trees.\n            ++tree_id;\n            node_id = 0;\n          } else {\n            node_id =\n                resource->next_node(tree_id, node_id, i, bucketized_features);\n          }\n        }\n        for (int32 j = 0; j < logits_dimension_; ++j) {\n          output_logits(i, j) = tree_logits[j];\n        }\n      }\n    };\n    // 10 is the magic number. The actual number might depend on (the number of\n    // layers in the trees) and (cpu cycles spent on each layer), but this\n    // value would work for many cases. May be tuned later.\n    const int64 cost = (last_tree + 1) * 10;\n    thread::ThreadPool* const worker_threads =\n        context->device()->tensorflow_cpu_worker_threads()->workers;\n    Shard(worker_threads->NumThreads(), worker_threads, batch_size,\n          /*cost_per_unit=*/cost, do_work);\n  }\n\n private:\n  int32\n      logits_dimension_;  // Indicates the size of the output prediction vector.\n  int32 num_bucketized_features_;  // Indicates the number of features.\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"BoostedTreesPredict\").Device(DEVICE_CPU),\n                        BoostedTreesPredictOp);\n\n// The Op that returns debugging/model interpretability outputs for each\n// example. Currently it outputs the split feature ids and logits after each\n// split along the decision path for each example. This will be used to compute\n// directional feature contributions at predict time for an arbitrary activation\n// function.\n// TODO(crawles): return in proto 1) Node IDs for ensemble prediction path\n// 2) Leaf node IDs.\nclass BoostedTreesExampleDebugOutputsOp : public OpKernel {\n public:\n  explicit BoostedTreesExampleDebugOutputsOp(\n      OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_bucketized_features\",\n                                             &num_bucketized_features_));\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"logits_dimension\", &logits_dimension_));\n    OP_REQUIRES(context, logits_dimension_ == 1,\n                errors::InvalidArgument(\n                    \"Currently only one dimensional outputs are supported.\"));\n  }\n\n  void Compute(OpKernelContext* const context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> resource;\n    // Get the resource.\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &resource));\n\n    // Get the inputs.\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features\",\n                                                &bucketized_features_list));\n    std::vector<tensorflow::TTypes<int32>::ConstMatrix> bucketized_features;\n    bucketized_features.reserve(bucketized_features_list.size());\n    ConvertVectorsToMatrices(bucketized_features_list, bucketized_features);\n    const int batch_size = bucketized_features[0].dimension(0);\n\n    // We need to get the feature ids used for splitting and the logits after\n    // each split. We will use these to calculate the changes in the prediction\n    // (contributions) for an arbitrary activation function (done in Python) and\n    // attribute them to the associated feature ids. We will store these in\n    // a proto below.\n    Tensor* output_debug_info_t = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"examples_debug_outputs_serialized\",\n                                          {batch_size}, &output_debug_info_t));\n    // Will contain serialized protos, per example.\n    auto output_debug_info = output_debug_info_t->flat<tstring>();\n    const int32 last_tree = resource->num_trees() - 1;\n\n    // For each given example, traverse through all trees keeping track of the\n    // features used to split and the associated logits at each point along the\n    // path. Note: feature_ids has one less value than logits_path because the\n    // first value of each logit path will be the bias.\n    auto do_work = [&resource, &bucketized_features, &output_debug_info,\n                    last_tree](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        // Proto to store debug outputs, per example.\n        boosted_trees::DebugOutput example_debug_info;\n        // Initial bias prediction. E.g., prediction based off training mean.\n        const auto& tree_logits = resource->node_value(0, 0);\n        DCHECK_EQ(tree_logits.size(), 1);\n        float tree_logit = resource->GetTreeWeight(0) * tree_logits[0];\n        example_debug_info.add_logits_path(tree_logit);\n        int32 node_id = 0;\n        int32 tree_id = 0;\n        int32 feature_id;\n        float past_trees_logit = 0;  // Sum of leaf logits from prior trees.\n        // Go through each tree and populate proto.\n        while (tree_id <= last_tree) {\n          if (resource->is_leaf(tree_id, node_id)) {  // Move onto other trees.\n            // Accumulate tree_logits only if the leaf is non-root, but do so\n            // for bias tree.\n            if (tree_id == 0 || node_id > 0) {\n              past_trees_logit += tree_logit;\n            }\n            ++tree_id;\n            node_id = 0;\n          } else {  // Add to proto.\n            // Feature id used to split.\n            feature_id = resource->feature_id(tree_id, node_id);\n            example_debug_info.add_feature_ids(feature_id);\n            // Get logit after split.\n            node_id =\n                resource->next_node(tree_id, node_id, i, bucketized_features);\n            const auto& tree_logits = resource->node_value(tree_id, node_id);\n            DCHECK_EQ(tree_logits.size(), 1);\n            tree_logit = resource->GetTreeWeight(tree_id) * tree_logits[0];\n            // Output logit incorporates sum of leaf logits from prior trees.\n            example_debug_info.add_logits_path(tree_logit + past_trees_logit);\n          }\n        }\n        // Set output as serialized proto containing debug info.\n        string serialized = example_debug_info.SerializeAsString();\n        output_debug_info(i) = serialized;\n      }\n    };\n\n    // 10 is the magic number. The actual number might depend on (the number of\n    // layers in the trees) and (cpu cycles spent on each layer), but this\n    // value would work for many cases. May be tuned later.\n    const int64 cost = (last_tree + 1) * 10;\n    thread::ThreadPool* const worker_threads =\n        context->device()->tensorflow_cpu_worker_threads()->workers;\n    Shard(worker_threads->NumThreads(), worker_threads, batch_size,\n          /*cost_per_unit=*/cost, do_work);\n  }\n\n private:\n  int32 logits_dimension_;  // Indicates dimension of logits in the tree nodes.\n  int32 num_bucketized_features_;  // Indicates the number of features.\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesExampleDebugOutputs\").Device(DEVICE_CPU),\n    BoostedTreesExampleDebugOutputsOp);\n\n}  // namespace tensorflow"