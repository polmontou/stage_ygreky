"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/cc/saved_model/loader.h\"\n\n#include <unordered_set>\n\n#include \"tensorflow/cc/saved_model/constants.h\"\n#include \"tensorflow/cc/saved_model/loader_util.h\"\n#include \"tensorflow/cc/saved_model/reader.h\"\n#include \"tensorflow/core/framework/attr_value.pb.h\"\n#include \"tensorflow/core/framework/node_def.pb.h\"\n#include \"tensorflow/core/framework/tensor.pb.h\"\n#include \"tensorflow/core/lib/io/path.h\"\n#include \"tensorflow/core/lib/monitoring/counter.h\"\n#include \"tensorflow/core/lib/monitoring/sampler.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/protobuf/graph_debug_info.pb.h\"\n#include \"tensorflow/core/protobuf/meta_graph.pb.h\"\n#include \"tensorflow/core/protobuf/saver.pb.h\"\n#include \"tensorflow/core/public/session.h\"\n#include \"tensorflow/core/public/session_options.h\"\n#include \"tensorflow/core/util/tensor_bundle/naming.h\"\n\nnamespace tensorflow {\nnamespace {\n\nauto* load_attempt_count = monitoring::Counter<2>::New(\n    \"/tensorflow/cc/saved_model/load_attempt_count\",\n    \"The number of times a SavedModel was successfully loaded.\", \"model_path\",\n    \"status\");\nauto* load_latency = monitoring::Counter<1>::New(\n    \"/tensorflow/cc/saved_model/load_latency\",\n    \"Latency in microseconds for SavedModels that were successfully loaded.\",\n    \"model_path\");\nauto* load_latency_by_stage = monitoring::Sampler<2>::New(\n    {\n        \"/tensorflow/cc/saved_model/load_latency_by_stage\",  // metric name\n        \"Distribution of wall time spent (in microseconds) in each stage \"\n        \"(restore graph from disk, run init graph op, etc) when loading the \"\n        \"model\",\n        \"model_path\",\n        \"stage\",\n    },\n    // Scale of 10, power of 1.8 with bucket count 33 (~20 minutes).\n    monitoring::Buckets::Exponential(10, 1.8, 33));\n\nconstexpr char kLoadAttemptFail[] = \"fail\";\nconstexpr char kLoadAttemptSuccess[] = \"success\";\n\nuint64 GetLatencyMicroseconds(const uint64 start_microseconds) {\n  const uint64 end_microseconds = EnvTime::NowMicros();\n  // Avoid clock skew.\n  if (end_microseconds < start_microseconds) return 0;\n  return end_microseconds - start_microseconds;\n}\n\n// Ensure that constant tensors loaded from the saved model have valid shape.\n// Also ensure that constant nodes have a value assigned to them.\n// TODO(b/154763635): this is temporary and will be replaced with a better audit\nstatic Status ValidateSavedTensors(const GraphDef& graph_def) {\n  for (const auto& node : graph_def.node()) {\n    const auto node_iterator = node.attr().find(\"value\");\n    if (node_iterator != node.attr().end()) {\n      AttrValue node_value = node_iterator->second;\n      if (node_value.has_tensor()) {\n        const PartialTensorShape node_shape(node_value.tensor().tensor_shape());\n        if (node_shape.num_elements() < 0) {\n          return errors::FailedPrecondition(\n              \"Saved model contains node \\\"\", node.name(), \"\\\" (op \\\"\",\n              node.op(), \"\\\") which initializes from a tensor with \",\n              node_shape.num_elements(), \" elements\");\n        }\n      }\n    } else if (node.op() == \"Const\") {\n      return errors::FailedPrecondition(\n          \"Saved model contains node \\\"\", node.name(),\n          \"\\\" which is a constant tensor but no value has been provided\");\n    }\n  }\n  return Status::OK();\n}\n\nTensor CreateStringTensor(const string& value) {\n  Tensor tensor(DT_STRING, TensorShape({}));\n  tensor.scalar<tstring>()() = value;\n  return tensor;\n}\n\nvoid AddAssetsTensorsToInputs(const StringPiece export_dir,\n                              const std::vector<AssetFileDef>& asset_file_defs,\n                              std::vector<std::pair<string, Tensor>>* inputs) {\n  if (asset_file_defs.empty()) {\n    return;\n  }\n  for (auto& asset_file_def : asset_file_defs) {\n    Tensor assets_file_path_tensor = CreateStringTensor(io::JoinPath(\n        export_dir, kSavedModelAssetsDirectory, asset_file_def.filename()));\n    inputs->push_back(\n        {asset_file_def.tensor_info().name(), assets_file_path_tensor});\n  }\n}\n\n// Like Session::Run(), but uses the Make/Run/ReleaseCallable() API to avoid\n// leaving behind non-GC'ed state.\n//\n// Detailed motivation behind this approach, from ashankar@:\n//\n// Each call to Session::Run() that identifies a new subgraph (based on feeds\n// and fetches) creates some datastructures that live as long as the session\n// (the partitioned graph, associated executors etc.).\n//\n// A pathological case of this would be if say the initialization op\n// (main_op/legacy_init_op) involves the use of a large constant. Then we\n// allocate memory for that large constant that will just stick around till the\n// session dies. With this Callable mechanism, that memory will be released\n// right after ReleaseCallable returns.\n//\n// However, the resource manager state remains.\nStatus RunOnce(const RunOptions& run_options,\n               const std::vector<std::pair<string, Tensor>>& inputs,\n               const std::vector<string>& output_tensor_names,\n               const std::vector<string>& target_node_names,\n               std::vector<Tensor>* outputs, RunMetadata* run_metadata,\n               Session* session) {\n  CallableOptions callable_options;\n  std::vector<Tensor> feed_tensors;\n  *callable_options.mutable_run_options() = run_options;\n  for (const auto& input : inputs) {\n    const string& name = input.first;\n    const Tensor& tensor = input.second;\n    callable_options.add_feed(name);\n    feed_tensors.push_back(tensor);\n  }\n  for (const string& output_tensor_name : output_tensor_names) {\n    callable_options.add_fetch(output_tensor_name);\n  }\n  for (const string& target_node_name : target_node_names) {\n    callable_options.add_target(target_node_name);\n  }\n\n  Session::CallableHandle callable_handle;\n  TF_RETURN_IF_ERROR(session->MakeCallable(callable_options, &callable_handle));\n  const Status run_status = session->RunCallable(callable_handle, feed_tensors,\n                                                 outputs, run_metadata);\n  // Be sure to call ReleaseCallable() regardless of the outcome of\n  // RunCallable().\n  session->ReleaseCallable(callable_handle).IgnoreError();\n  return run_status;\n}\n\n// RunInitOp will return OK if the initialization op was run successfully.\n// An empty init_op_name indicates that there are no init ops to run.\nStatus RunInitOp(const RunOptions& run_options, const string& export_dir,\n                 const MetaGraphDef& meta_graph_def,\n                 const std::vector<AssetFileDef>& asset_file_defs,\n                 Session* session, const string& init_op_name) {\n  if (!init_op_name.empty()) {\n    LOG(INFO) << \"Running initialization op on SavedModel bundle at path: \"\n              << export_dir;\n    std::vector<std::pair<string, Tensor>> inputs;\n    AddAssetsTensorsToInputs(export_dir, asset_file_defs, &inputs);\n    RunMetadata run_metadata;\n    return RunOnce(run_options, inputs, {}, {init_op_name},\n                   nullptr /* outputs */, &run_metadata, session);\n  }\n  return Status::OK();\n}\n\nStatus RunRestore(const RunOptions& run_options, const string& export_dir,\n                  const StringPiece restore_op_name,\n                  const StringPiece variable_filename_const_op_name,\n                  const std::vector<AssetFileDef>& asset_file_defs,\n                  Session* session) {\n  LOG(INFO) << \"Restoring SavedModel bundle.\";\n  // Find path to variables to be restored in export directory.\n  const string variables_directory =\n      io::JoinPath(export_dir, kSavedModelVariablesDirectory);\n  // Check for saver checkpoints in v2 format. Models exported in the checkpoint\n  // v2 format will have a variables.index file. The corresponding\n  // variables are stored in the variables.data-?????-of-????? files.\n  const string variables_index_path = io::JoinPath(\n      variables_directory, MetaFilename(kSavedModelVariablesFilename));\n  if (!Env::Default()->FileExists(variables_index_path).ok()) {\n    LOG(INFO) << \"The specified SavedModel has no variables; no checkpoints \"\n                 \"were restored. File does not exist: \"\n              << variables_index_path;\n    return Status::OK();\n  }\n  const string variables_path =\n      io::JoinPath(variables_directory, kSavedModelVariablesFilename);\n\n  // Add variables to the graph.\n  Tensor variables_path_tensor(DT_STRING, TensorShape({}));\n  variables_path_tensor.scalar<tstring>()() = variables_path;\n\n  std::vector<std::pair<string, Tensor>> inputs = {\n      {string(variable_filename_const_op_name), variables_path_tensor}};\n\n  AddAssetsTensorsToInputs(export_dir, asset_file_defs, &inputs);\n\n  RunMetadata run_metadata;\n  return RunOnce(run_options, inputs, {}, {string(restore_op_name)},\n                 nullptr /* outputs */, &run_metadata, session);\n}\n\n}  // namespace\n\nSavedModelBundleInterface::~SavedModelBundleInterface() {}\n\nStatus LoadMetagraphIntoSession(const SessionOptions& session_options,\n                                const MetaGraphDef& meta_graph,\n                                std::unique_ptr<Session>* session) {\n  Session* session_p = nullptr;\n  TF_RETURN_IF_ERROR(NewSession(session_options, &session_p));\n  session->reset(session_p);\n  TF_RETURN_IF_ERROR(ValidateSavedTensors(meta_graph.graph_def()));\n  return (*session)->Create(meta_graph.graph_def());\n}\n\nStatus LoadSavedModelInternal(const SessionOptions& session_options,\n                              const RunOptions& run_options,\n                              const string& export_dir,\n                              const std::unordered_set<string>& tags,\n                              SavedModelBundle* const bundle) {\n  TF_RETURN_IF_ERROR(ReadMetaGraphDefFromSavedModel(export_dir, tags,\n                                                    &bundle->meta_graph_def));\n  TF_RETURN_IF_ERROR(\n      ReadSavedModelDebugInfoIfPresent(export_dir, &bundle->debug_info));\n  TF_RETURN_IF_ERROR(LoadMetagraphIntoSession(\n      session_options, bundle->meta_graph_def, &bundle->session));\n  TF_RETURN_IF_ERROR(RestoreSession(run_options, bundle->meta_graph_def,\n                                    export_dir, &bundle->session));\n  return Status::OK();\n}\n\nStatus LoadSavedModel(const SessionOptions& session_options,\n                      const RunOptions& run_options, const string& export_dir,\n                      const std::unordered_set<string>& tags,\n                      SavedModelBundle* const bundle) {\n  // TODO(robson): Add tests for the counters.\n  const uint64 start_microseconds = Env::Default()->NowMicros();\n  const Status status = LoadSavedModelInternal(session_options, run_options,\n                                               export_dir, tags, bundle);\n  auto log_and_count = [&](const string& status_str) {\n    LOG(INFO) << \"SavedModel load for tags { \" << absl::StrJoin(tags, \" \")\n              << \" }; Status: \" << status_str << \": \" << status << \". Took \"\n              << GetLatencyMicroseconds(start_microseconds) << \" microseconds.\";\n    load_attempt_count->GetCell(export_dir, status_str)->IncrementBy(1);\n  };\n  if (status.ok()) {\n    log_and_count(kLoadAttemptSuccess);\n  } else {\n    log_and_count(kLoadAttemptFail);\n  }\n  load_latency->GetCell(export_dir)\n      ->IncrementBy(GetLatencyMicroseconds(start_microseconds));\n  return status;\n}\n\nnamespace {\n// Session wrapper that prevents calls to Session::Create(), Session::Extend(),\n// and the deprecated partial-run methods.\n//\n// Limiting the available methods on a returned Session gives us the option\n// to replace the Session with a cut-down implementation, without breaking any\n// users.\nclass LiteSessionWrapper : public Session {\n public:\n  explicit LiteSessionWrapper(std::unique_ptr<Session> wrapped)\n      : wrapped_(std::move(wrapped)) {}\n\n  Status Create(const GraphDef& graph) override {\n    return errors::Unimplemented(\"Session::Create()\");\n  }\n  Status Create(GraphDef&& graph) override {\n    return errors::Unimplemented(\"Session::Create()\");\n  }\n\n  Status Extend(const GraphDef& graph) override {\n    return errors::Unimplemented(\"Session::Extend()\");\n  }\n  Status Extend(GraphDef&& graph) override {\n    return errors::Unimplemented(\"Session::Extend()\");\n  }\n\n  Status Run(const std::vector<std::pair<string, Tensor>>& inputs,\n             const std::vector<string>& output_tensor_names,\n             const std::vector<string>& target_node_names,\n             std::vector<Tensor>* outputs) override {\n    return wrapped_->Run(inputs, output_tensor_names, target_node_names,\n                         outputs);\n  }\n\n  Status Create(const RunOptions& run_options, const GraphDef& graph) override {\n    return errors::Unimplemented(\"Session::Create()\");\n  }\n  Status Extend(const RunOptions& run_options, const GraphDef& graph) override {\n    return errors::Unimplemented(\"Session::Extend()\");\n  }\n  Status Create(const RunOptions& run_options, GraphDef&& graph) override {\n    return errors::Unimplemented(\"Session::Create()\");\n  }\n  Status Extend(const RunOptions& run_options, GraphDef&& graph) override {\n    return errors::Unimplemented(\"Session::Extend()\");\n  }\n  Status Close(const RunOptions& run_options) override {\n    return wrapped_->Close(run_options);\n  }\n\n  Status Run(const RunOptions& run_options,\n             const std::vector<std::pair<string, Tensor>>& inputs,\n             const std::vector<string>& output_tensor_names,\n             const std::vector<string>& target_node_names,\n             std::vector<Tensor>* outputs, RunMetadata* run_metadata) override {\n    return wrapped_->Run(run_options, inputs, output_tensor_names,\n                         target_node_names, outputs, run_metadata);\n  }\n\n  Status PRunSetup(const std::vector<string>& input_names,\n                   const std::vector<string>& output_names,\n                   const std::vector<string>& target_nodes,\n                   string* handle) override {\n    return errors::Unimplemented(\"Session::PRunSetup()\");\n  }\n\n  Status PRun(const string& handle,\n              const std::vector<std::pair<string, Tensor>>& inputs,\n              const std::vector<string>& output_names,\n              std::vector<Tensor>* outputs) override {\n    return errors::Unimplemented(\"Session::PRun()\");\n  }\n\n  Status ListDevices(std::vector<DeviceAttributes>* response) override {\n    return wrapped_->ListDevices(response);\n  }\n\n  Status Close() override { return wrapped_->Close(); }\n\n  Status MakeCallable(const CallableOptions& callable_options,\n                      CallableHandle* out_handle) override {\n    return wrapped_->MakeCallable(callable_options, out_handle);\n  }\n\n  Status RunCallable(CallableHandle handle,\n                     const std::vector<Tensor>& feed_tensors,\n                     std::vector<Tensor>* fetch_tensors,\n                     RunMetadata* run_metadata) override {\n    return wrapped_->RunCallable(handle, feed_tensors, fetch_tensors,\n                                 run_metadata);\n  }\n\n  Status RunCallable(\n      CallableHandle handle, const std::vector<Tensor>& feed_tensors,\n      std::vector<Tensor>* fetch_tensors, RunMetadata* run_metadata,\n      const thread::ThreadPoolOptions& threadpool_options) override {\n    return wrapped_->RunCallable(handle, feed_tensors, fetch_tensors,\n                                 run_metadata, threadpool_options);\n  }\n\n  Status ReleaseCallable(CallableHandle handle) override {\n    return wrapped_->ReleaseCallable(handle);\n  }\n\n private:\n  const std::unique_ptr<Session> wrapped_;\n};\n}  // namespace\n\nStatus RestoreSession(const RunOptions& run_options,\n                      const MetaGraphDef& meta_graph, const string& export_dir,\n                      std::unique_ptr<Session>* session) {\n  const uint64 read_start_microseconds = Env::Default()->NowMicros();\n  std::vector<AssetFileDef> asset_file_defs;\n  TF_RETURN_IF_ERROR(internal::GetAssetFileDefs(meta_graph, &asset_file_defs));\n  TF_RETURN_IF_ERROR(RunRestore(run_options, export_dir,\n                                meta_graph.saver_def().restore_op_name(),\n                                meta_graph.saver_def().filename_tensor_name(),\n                                asset_file_defs, session->get()));\n  // Record walltime spent in restoring graph from disk, but postpone metric\n  // increments until graph init finishes.\n  const uint64 restore_graph_walltime =\n      GetLatencyMicroseconds(read_start_microseconds);\n\n  const uint64 graph_init_start_microseconds = Env::Default()->NowMicros();\n  string init_op_name;\n  TF_RETURN_IF_ERROR(\n      internal::GetInitOp(export_dir, meta_graph, &init_op_name));\n  TF_RETURN_IF_ERROR(RunInitOp(run_options, export_dir, meta_graph,\n                               asset_file_defs, session->get(), init_op_name));\n  load_latency_by_stage->GetCell(export_dir, \"restore_graph\")\n      ->Add(restore_graph_walltime);\n  // Record wall time spent in init op.\n  load_latency_by_stage->GetCell(export_dir, \"init_graph\")\n      ->Add(GetLatencyMicroseconds(graph_init_start_microseconds));\n  return Status::OK();\n}\n\nStatus LoadSavedModel(const SessionOptions& session_options,\n                      const RunOptions& run_options, const string& export_dir,\n                      const std::unordered_set<string>& tags,\n                      SavedModelBundleLite* const bundle) {\n  SavedModelBundle legacy_bundle;\n  SessionOptions rewritten_options(session_options);\n  // We disallow calls to Session::Extend() on the returned session, so we can\n  // reduce memory consumption by not storing the original GraphDef.\n  rewritten_options.config.mutable_experimental()\n      ->set_optimize_for_static_graph(true);\n  // Disallowing the `RunOptions.output_partition_graphs` option (typically used\n  // in debugging and tests) allows us to reduce memory consumption further by\n  // not storing the rewritten subgraph for each signature.\n  rewritten_options.config.mutable_experimental()\n      ->set_disable_output_partition_graphs(true);\n  // TODO(mrry): Consider specializing the session creation to reduce peak\n  // RAM consumption by using `Session::Create(GraphDef&&)`.\n  TF_RETURN_IF_ERROR(LoadSavedModel(rewritten_options, run_options, export_dir,\n                                    tags, &legacy_bundle));\n  *bundle = SavedModelBundleLite(\n      absl::make_unique<LiteSessionWrapper>(std::move(legacy_bundle.session)),\n      std::move(*legacy_bundle.meta_graph_def.mutable_signature_def()));\n  return Status::OK();\n}\n\nbool MaybeSavedModelDirectory(const string& export_dir) {\n  const string saved_model_pb_path =\n      io::JoinPath(export_dir, kSavedModelFilenamePb);\n  const string saved_model_pbtxt_path =\n      io::JoinPath(export_dir, kSavedModelFilenamePbTxt);\n  return Env::Default()->FileExists(saved_model_pb_path).ok() ||\n         Env::Default()->FileExists(saved_model_pbtxt_path).ok();\n}\n\n}  // namespace tensorflow"