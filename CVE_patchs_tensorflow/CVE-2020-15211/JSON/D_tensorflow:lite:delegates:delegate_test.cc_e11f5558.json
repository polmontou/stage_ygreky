"diff --git a/tensorflow/lite/delegates/delegate_test.cc b/tensorflow/lite/delegates/delegate_test.cc\nindex aac44b0ff51..c5a31374887 100644\n--- a/tensorflow/lite/delegates/delegate_test.cc\n+++ b/tensorflow/lite/delegates/delegate_test.cc\n@@ -42,9 +42,12 @@ TfLiteRegistration AddOpRegistration() {\n \n   reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n     // Set output size to input size\n-    const TfLiteTensor* input1 = GetInput(context, node, 0);\n-    const TfLiteTensor* input2 = GetInput(context, node, 1);\n-    TfLiteTensor* output = GetOutput(context, node, 0);\n+    const TfLiteTensor* input1;\n+    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input1));\n+    const TfLiteTensor* input2;\n+    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input2));\n+    TfLiteTensor* output;\n+    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n \n     TF_LITE_ENSURE_EQ(context, input1->dims->size, input2->dims->size);\n     for (int i = 0; i < input1->dims->size; ++i) {\n@@ -58,13 +61,16 @@ TfLiteRegistration AddOpRegistration() {\n \n   reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n     // Copy input data to output data.\n-    const TfLiteTensor* a0 = GetInput(context, node, 0);\n+    const TfLiteTensor* a0;\n+    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &a0));\n     TF_LITE_ENSURE(context, a0);\n     TF_LITE_ENSURE(context, a0->data.f);\n-    const TfLiteTensor* a1 = GetInput(context, node, 1);\n+    const TfLiteTensor* a1;\n+    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &a1));\n     TF_LITE_ENSURE(context, a1);\n     TF_LITE_ENSURE(context, a1->data.f);\n-    TfLiteTensor* out = GetOutput(context, node, 0);\n+    TfLiteTensor* out;\n+    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &out));\n     TF_LITE_ENSURE(context, out);\n     TF_LITE_ENSURE(context, out->data.f);\n     int num = a0->dims->data[0];\n@@ -267,7 +273,8 @@ class TestDelegate : public ::testing::Test {\n             a0 = GetInput(context, node, 0);\n             a1 = a0;\n           }\n-          TfLiteTensor* out = GetOutput(context, node, 0);\n+          TfLiteTensor* out;\n+          TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &out));\n           int num = 1;\n           for (int i = 0; i < a0->dims->size; ++i) {\n             num *= a0->dims->data[i];\n@@ -289,8 +296,10 @@ class TestDelegate : public ::testing::Test {\n         reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n           // Shapes should already by propagated by the runtime, just need to\n           // check.\n-          const TfLiteTensor* input1 = GetInput(context, node, 0);\n-          TfLiteTensor* output = GetOutput(context, node, 0);\n+          const TfLiteTensor* input1;\n+          TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input1));\n+          TfLiteTensor* output;\n+          TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n           const int input_dims_size = input1->dims->size;\n           TF_LITE_ENSURE(context, output->dims->size == input_dims_size);\n           for (int i = 0; i < input_dims_size; ++i) {\n@@ -315,7 +324,8 @@ class TestDelegate : public ::testing::Test {\n             input1 = GetInput(context, node, 0);\n             input2 = input1;\n           }\n-          TfLiteTensor* output = GetOutput(context, node, 0);\n+          TfLiteTensor* output;\n+          TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n \n           TF_LITE_ENSURE_STATUS(context->ResizeTensor(\n               context, output, TfLiteIntArrayCopy(input1->dims)));\n@@ -1169,11 +1179,14 @@ class TestDelegateWithDynamicTensors : public ::testing::Test {\n \n     reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n       // Output 0 is dynamic\n-      TfLiteTensor* output0 = GetOutput(context, node, 0);\n+      TfLiteTensor* output0;\n+      TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output0));\n       SetTensorToDynamic(output0);\n       // Output 1 has the same shape as input.\n-      const TfLiteTensor* input = GetInput(context, node, 0);\n-      TfLiteTensor* output1 = GetOutput(context, node, 1);\n+      const TfLiteTensor* input;\n+      TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n+      TfLiteTensor* output1;\n+      TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &output1));\n       TF_LITE_ENSURE_STATUS(context->ResizeTensor(\n           context, output1, TfLiteIntArrayCopy(input->dims)));\n       return kTfLiteOk;\n@@ -1193,11 +1206,14 @@ class TestDelegateWithDynamicTensors : public ::testing::Test {\n       // If tensors are resized, the runtime should propagate shapes\n       // automatically if correct flag is set. Ensure values are correct.\n       // Output 0 should be dynamic.\n-      TfLiteTensor* output0 = GetOutput(context, node, 0);\n+      TfLiteTensor* output0;\n+      TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output0));\n       TF_LITE_ENSURE(context, IsDynamicTensor(output0));\n       // Output 1 has the same shape as input.\n-      const TfLiteTensor* input = GetInput(context, node, 0);\n-      TfLiteTensor* output1 = GetOutput(context, node, 1);\n+      const TfLiteTensor* input;\n+      TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n+      TfLiteTensor* output1;\n+      TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &output1));\n       TF_LITE_ENSURE(context, input->dims->size == output1->dims->size);\n       TF_LITE_ENSURE(context, input->dims->data[0] == output1->dims->data[0]);\n       return kTfLiteOk;"