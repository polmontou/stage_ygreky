"diff --git a/tensorflow/lite/kernels/kernel_util.cc b/tensorflow/lite/kernels/kernel_util.cc\nindex cd243335c9c..a834d8ab913 100644\n--- a/tensorflow/lite/kernels/kernel_util.cc\n+++ b/tensorflow/lite/kernels/kernel_util.cc\n@@ -30,19 +30,70 @@ namespace tflite {\n \n namespace {\n \n-inline TfLiteTensor* GetMutableInput(const TfLiteContext* context,\n-                                     const TfLiteNode* node, int index) {\n-  if (index >= 0 && index < node->inputs->size) {\n-    const int tensor_index = node->inputs->data[index];\n+// Assumes tensor_index is a valid index (in bounds)\n+inline TfLiteTensor* GetTensorAtIndex(const TfLiteContext* context,\n+                                      int tensor_index) {\n+  if (context->tensors != nullptr) {\n+    return &context->tensors[tensor_index];\n+  } else {\n+    return context->GetTensor(context, tensor_index);\n+  }\n+}\n+\n+// Validate in a single place to reduce binary size\n+inline TfLiteStatus ValidateTensorIndexingSafe(const TfLiteContext* context,\n+                                               int index, int max_size,\n+                                               const int* tensor_indices,\n+                                               int* tensor_index) {\n+  if (index < 0 || index >= max_size) {\n+    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n+                       \"Invalid tensor index %d (not in [0, %d))\\n\", index,\n+                       max_size);\n+    return kTfLiteError;\n+  }\n+  if (tensor_indices[index] == kTfLiteOptionalTensor) {\n+    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n+                       \"Tensor at index %d was optional but was expected\\n\",\n+                       index);\n+    return kTfLiteError;\n+  }\n+\n+  *tensor_index = tensor_indices[index];\n+  return kTfLiteOk;\n+}\n+\n+// Same as above but returns -1 for invalid inputs instead of status + logging\n+// error.\n+inline int ValidateTensorIndexing(const TfLiteContext* context, int index,\n+                                  int max_size, const int* tensor_indices) {\n+  if (index >= 0 && index < max_size) {\n+    const int tensor_index = tensor_indices[index];\n     if (tensor_index != kTfLiteOptionalTensor) {\n-      if (context->tensors != nullptr) {\n-        return &context->tensors[tensor_index];\n-      } else {\n-        return context->GetTensor(context, tensor_index);\n-      }\n+      return tensor_index;\n     }\n   }\n-  return nullptr;\n+  return -1;\n+}\n+\n+inline TfLiteTensor* GetMutableInput(const TfLiteContext* context,\n+                                     const TfLiteNode* node, int index) {\n+  const int tensor_index = ValidateTensorIndexing(\n+      context, index, node->inputs->size, node->inputs->data);\n+  if (tensor_index < 0) {\n+    return nullptr;\n+  }\n+  return GetTensorAtIndex(context, tensor_index);\n+}\n+\n+inline TfLiteStatus GetMutableInputSafe(const TfLiteContext* context,\n+                                        const TfLiteNode* node, int index,\n+                                        const TfLiteTensor** tensor) {\n+  int tensor_index;\n+  TF_LITE_ENSURE_OK(\n+      context, ValidateTensorIndexingSafe(context, index, node->inputs->size,\n+                                          node->inputs->data, &tensor_index));\n+  *tensor = GetTensorAtIndex(context, tensor_index);\n+  return kTfLiteOk;\n }\n \n }  // anonymous namespace.\n@@ -52,6 +103,11 @@ const TfLiteTensor* GetInput(const TfLiteContext* context,\n   return GetMutableInput(context, node, index);\n }\n \n+TfLiteStatus GetInputSafe(const TfLiteContext* context, const TfLiteNode* node,\n+                          int index, const TfLiteTensor** tensor) {\n+  return GetMutableInputSafe(context, node, index, tensor);\n+}\n+\n TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                                int index) {\n   TfLiteTensor* tensor = GetMutableInput(context, node, index);\n@@ -60,17 +116,22 @@ TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n \n TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                         int index) {\n-  if (index >= 0 && index < node->outputs->size) {\n-    const int tensor_index = node->outputs->data[index];\n-    if (tensor_index != kTfLiteOptionalTensor) {\n-      if (context->tensors != nullptr) {\n-        return &context->tensors[tensor_index];\n-      } else {\n-        return context->GetTensor(context, tensor_index);\n-      }\n-    }\n+  const int tensor_index = ValidateTensorIndexing(\n+      context, index, node->outputs->size, node->outputs->data);\n+  if (tensor_index < 0) {\n+    return nullptr;\n   }\n-  return nullptr;\n+  return GetTensorAtIndex(context, tensor_index);\n+}\n+\n+TfLiteStatus GetOutputSafe(const TfLiteContext* context, const TfLiteNode* node,\n+                           int index, TfLiteTensor** tensor) {\n+  int tensor_index;\n+  TF_LITE_ENSURE_OK(\n+      context, ValidateTensorIndexingSafe(context, index, node->outputs->size,\n+                                          node->outputs->data, &tensor_index));\n+  *tensor = GetTensorAtIndex(context, tensor_index);\n+  return kTfLiteOk;\n }\n \n const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n@@ -78,6 +139,50 @@ const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n   return GetInput(context, node, index);\n }\n \n+#ifndef TF_LITE_STATIC_MEMORY\n+TfLiteTensor* GetTemporary(TfLiteContext* context, const TfLiteNode* node,\n+                           int index) {\n+  const int tensor_index = ValidateTensorIndexing(\n+      context, index, node->temporaries->size, node->temporaries->data);\n+  if (tensor_index < 0) {\n+    return nullptr;\n+  }\n+  return GetTensorAtIndex(context, tensor_index);\n+}\n+\n+TfLiteStatus GetTemporarySafe(const TfLiteContext* context,\n+                              const TfLiteNode* node, int index,\n+                              TfLiteTensor** tensor) {\n+  int tensor_index;\n+  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n+                                 context, index, node->temporaries->size,\n+                                 node->temporaries->data, &tensor_index));\n+  *tensor = GetTensorAtIndex(context, tensor_index);\n+  return kTfLiteOk;\n+}\n+\n+const TfLiteTensor* GetIntermediates(TfLiteContext* context,\n+                                     const TfLiteNode* node, int index) {\n+  const int tensor_index = ValidateTensorIndexing(\n+      context, index, node->intermediates->size, node->intermediates->data);\n+  if (tensor_index < 0) {\n+    return nullptr;\n+  }\n+  return GetTensorAtIndex(context, tensor_index);\n+}\n+\n+TfLiteStatus GetIntermediatesSafe(const TfLiteContext* context,\n+                                  const TfLiteNode* node, int index,\n+                                  TfLiteTensor** tensor) {\n+  int tensor_index;\n+  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n+                                 context, index, node->intermediates->size,\n+                                 node->intermediates->data, &tensor_index));\n+  *tensor = GetTensorAtIndex(context, tensor_index);\n+  return kTfLiteOk;\n+}\n+#endif  // TF_LITE_STATIC_MEMORY\n+\n // Per-axis\n TfLiteStatus PopulateConvolutionQuantizationParams(\n     TfLiteContext* context, const TfLiteTensor* input,"