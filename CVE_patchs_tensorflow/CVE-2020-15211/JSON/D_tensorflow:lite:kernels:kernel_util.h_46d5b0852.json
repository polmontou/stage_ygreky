"diff --git a/tensorflow/lite/kernels/kernel_util.h b/tensorflow/lite/kernels/kernel_util.h\nindex 0d6aa8fc790..5950effca0e 100644\n--- a/tensorflow/lite/kernels/kernel_util.h\n+++ b/tensorflow/lite/kernels/kernel_util.h\n@@ -29,18 +29,46 @@ namespace tflite {\n // benchmark_model for MobileNet + MobileBERT is unaffected. If such a change is\n // made, move the newly non-inlined function declarations to the top of this\n // header file.\n+\n+// Note: You must check if result is not null:\n+//\n+//   TfLiteTensor* my_tensor = GetInput(context, node, kMyTensorIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n const TfLiteTensor* GetInput(const TfLiteContext* context,\n                              const TfLiteNode* node, int index);\n \n // Note: You must check if result is not null:\n-// TfLiteTensor* my_tensor = GetVariableInput(context, node, kMyTensorIdx);\n-// TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+//   TfLiteTensor* my_tensor = GetVariableInput(context, node, kMyTensorIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                                int index);\n \n+// Note: You must check if result is not null:\n+//\n+//   TfLiteTensor* my_tensor = GetOutput(context, node, kMyTensorIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                         int index);\n \n+// Note: You must check if result is not null:\n+//\n+//   TfLiteTensor* my_tensor = GetOptionalInputTensor(context, node, kIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n+//\n+// Deprecated. GetInput has the same functionality.\n const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                            const TfLiteNode* node, int index);\n \n@@ -50,14 +78,46 @@ inline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n }\n \n #ifndef TF_LITE_STATIC_MEMORY\n+// Note: You must check if result is not null:\n+//\n+//   TfLiteTensor* my_tensor = GetTemporary(context, node, kMyTensorIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n inline TfLiteTensor* GetTemporary(TfLiteContext* context,\n                                   const TfLiteNode* node, int index) {\n-  return &context->tensors[node->temporaries->data[index]];\n+  if (index >= 0 && index < node->temporaries->size) {\n+    const int tensor_index = node->temporaries->data[index];\n+    if (tensor_index != kTfLiteOptionalTensor) {\n+      if (context->tensors != nullptr) {\n+        return &context->tensors[tensor_index];\n+      }\n+    }\n+  }\n+  return nullptr;\n }\n+\n+// Note: You must check if result is not null:\n+//\n+//   TfLiteTensor* my_tensor = GetIntermediates(context, node, kMyTensorIdx);\n+//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n+//\n+// This is because the index might point to the optional tensor constant\n+// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n inline const TfLiteTensor* GetIntermediates(TfLiteContext* context,\n                                             const TfLiteNode* node, int index) {\n-  return &context->tensors[node->intermediates->data[index]];\n+  if (index >= 0 && index < node->intermediates->size) {\n+    const int tensor_index = node->intermediates->data[index];\n+    if (tensor_index != kTfLiteOptionalTensor) {\n+      if (context->tensors != nullptr) {\n+        return &context->tensors[tensor_index];\n+      }\n+    }\n+  }\n+  return nullptr;\n }\n+\n inline int NumIntermediates(const TfLiteNode* node) {\n   return node->intermediates->size;\n }"