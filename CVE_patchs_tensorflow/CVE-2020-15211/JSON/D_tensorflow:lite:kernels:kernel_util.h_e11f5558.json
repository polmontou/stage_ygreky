"diff --git a/tensorflow/lite/kernels/kernel_util.h b/tensorflow/lite/kernels/kernel_util.h\nindex 5950effca0e..06f24b8e7d1 100644\n--- a/tensorflow/lite/kernels/kernel_util.h\n+++ b/tensorflow/lite/kernels/kernel_util.h\n@@ -40,6 +40,17 @@ namespace tflite {\n const TfLiteTensor* GetInput(const TfLiteContext* context,\n                              const TfLiteNode* node, int index);\n \n+// Same as `GetInput` but returns boolean and uses output argument for tensor.\n+//\n+//   TfLiteTensor* my_tensor;\n+//   TF_LITE_ENSURE_OK(context,\n+//                     GetInputSafe(context, node, kMyTensorIdx, &my_tensor));\n+//   // can use my_tensor directly from here onwards, it is not nullptr\n+//\n+// Should be used in cases where the binary size is too large.\n+TfLiteStatus GetInputSafe(const TfLiteContext* context, const TfLiteNode* node,\n+                          int index, const TfLiteTensor** tensor);\n+\n // Note: You must check if result is not null:\n //\n //   TfLiteTensor* my_tensor = GetVariableInput(context, node, kMyTensorIdx);\n@@ -60,6 +71,17 @@ TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                         int index);\n \n+// Same as `GetOutput` but returns boolean and uses output argument for tensor.\n+//\n+//   TfLiteTensor* my_tensor;\n+//   TF_LITE_ENSURE_OK(context,\n+//                     GetOutputSafe(context, node, kMyTensorIdx, &my_tensor));\n+//   // can use my_tensor directly from here onwards, it is not nullptr\n+//\n+// Should be used in cases where the binary size is too large.\n+TfLiteStatus GetOutputSafe(const TfLiteContext* context, const TfLiteNode* node,\n+                           int index, TfLiteTensor** tensor);\n+\n // Note: You must check if result is not null:\n //\n //   TfLiteTensor* my_tensor = GetOptionalInputTensor(context, node, kIdx);\n@@ -72,11 +94,6 @@ TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                            const TfLiteNode* node, int index);\n \n-inline int NumDimensions(const TfLiteTensor* t) { return t->dims->size; }\n-inline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n-  return t->dims->data[dim];\n-}\n-\n #ifndef TF_LITE_STATIC_MEMORY\n // Note: You must check if result is not null:\n //\n@@ -85,18 +102,22 @@ inline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n //\n // This is because the index might point to the optional tensor constant\n // (kTfLiteOptionalTensor) in which case there is no tensor to return.\n-inline TfLiteTensor* GetTemporary(TfLiteContext* context,\n-                                  const TfLiteNode* node, int index) {\n-  if (index >= 0 && index < node->temporaries->size) {\n-    const int tensor_index = node->temporaries->data[index];\n-    if (tensor_index != kTfLiteOptionalTensor) {\n-      if (context->tensors != nullptr) {\n-        return &context->tensors[tensor_index];\n-      }\n-    }\n-  }\n-  return nullptr;\n-}\n+TfLiteTensor* GetTemporary(TfLiteContext* context, const TfLiteNode* node,\n+                           int index);\n+\n+// Same as `GetTemporary` but returns boolean and uses output argument for\n+// tensor.\n+//\n+//   TfLiteTensor* my_tensor;\n+//   TF_LITE_ENSURE_OK(context,\n+//                     GetTemporarySafe(context, node, kMyTensorIdx,\n+//                     &my_tensor));\n+//   // can use my_tensor directly from here onwards, it is not nullptr\n+//\n+// Should be used in cases where the binary size is too large.\n+TfLiteStatus GetTemporarySafe(const TfLiteContext* context,\n+                              const TfLiteNode* node, int index,\n+                              TfLiteTensor** tensor);\n \n // Note: You must check if result is not null:\n //\n@@ -105,25 +126,37 @@ inline TfLiteTensor* GetTemporary(TfLiteContext* context,\n //\n // This is because the index might point to the optional tensor constant\n // (kTfLiteOptionalTensor) in which case there is no tensor to return.\n-inline const TfLiteTensor* GetIntermediates(TfLiteContext* context,\n-                                            const TfLiteNode* node, int index) {\n-  if (index >= 0 && index < node->intermediates->size) {\n-    const int tensor_index = node->intermediates->data[index];\n-    if (tensor_index != kTfLiteOptionalTensor) {\n-      if (context->tensors != nullptr) {\n-        return &context->tensors[tensor_index];\n-      }\n-    }\n-  }\n-  return nullptr;\n+const TfLiteTensor* GetIntermediates(TfLiteContext* context,\n+                                     const TfLiteNode* node, int index);\n+\n+// Same as `GetIntermediates` but returns boolean and uses output argument for\n+// tensor.\n+//\n+//   TfLiteTensor* my_tensor;\n+//   TF_LITE_ENSURE_OK(context,\n+//                     GetIntermediatesSafe(context, node, kMyTensorIdx,\n+//                     &my_tensor));\n+//   // can use my_tensor directly from here onwards, it is not nullptr\n+//\n+// Should be used in cases where the binary size is too large.\n+TfLiteStatus GetIntermediatesSafe(const TfLiteContext* context,\n+                                  const TfLiteNode* node, int index,\n+                                  TfLiteTensor** tensor);\n+#endif  // TF_LITE_STATIC_MEMORY\n+\n+inline int NumDimensions(const TfLiteTensor* t) { return t->dims->size; }\n+inline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n+  return t->dims->data[dim];\n }\n \n+inline int NumInputs(const TfLiteNode* node) { return node->inputs->size; }\n+inline int NumOutputs(const TfLiteNode* node) { return node->outputs->size; }\n+\n+#ifndef TF_LITE_STATIC_MEMORY\n inline int NumIntermediates(const TfLiteNode* node) {\n   return node->intermediates->size;\n }\n #endif  // TF_LITE_STATIC_MEMORY\n-inline int NumInputs(const TfLiteNode* node) { return node->inputs->size; }\n-inline int NumOutputs(const TfLiteNode* node) { return node->outputs->size; }\n \n inline int64_t NumElements(const TfLiteIntArray* dims) {\n   int64_t count = 1;"