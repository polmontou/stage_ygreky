"diff --git a/tensorflow/lite/kernels/rfft2d.cc b/tensorflow/lite/kernels/rfft2d.cc\nindex 4b0b4a6140a..c786aed73e7 100644\n--- a/tensorflow/lite/kernels/rfft2d.cc\n+++ b/tensorflow/lite/kernels/rfft2d.cc\n@@ -73,16 +73,20 @@ static TfLiteStatus InitTemporaryTensors(TfLiteContext* context,\n   data->fft_double_working_area_id = first_new_index + 1;\n \n   // Set up FFT integer working area buffer.\n-  TfLiteTensor* fft_integer_working_area =\n-      GetTemporary(context, node, kFftIntegerWorkingAreaTensor);\n+  TfLiteTensor* fft_integer_working_area;\n+  TF_LITE_ENSURE_OK(\n+      context, GetTemporarySafe(context, node, kFftIntegerWorkingAreaTensor,\n+                                &fft_integer_working_area));\n   fft_integer_working_area->type = kTfLiteInt32;\n   // If fft_length is not a constant tensor, fft_integer_working_area will be\n   // set to dynamic later in Prepare.\n   fft_integer_working_area->allocation_type = kTfLiteArenaRw;\n \n   // Set up FFT double working area buffer.\n-  TfLiteTensor* fft_double_working_area =\n-      GetTemporary(context, node, kFftDoubleWorkingAreaTensor);\n+  TfLiteTensor* fft_double_working_area;\n+  TF_LITE_ENSURE_OK(context,\n+                    GetTemporarySafe(context, node, kFftDoubleWorkingAreaTensor,\n+                                     &fft_double_working_area));\n   // fft_double_working_area is a double tensor. Ideally, double should be\n   // added into tflite data types. However, since fft_double_working_area is a\n   // temporary tensor, and there are no ops having double input/output tensors\n@@ -100,10 +104,13 @@ static TfLiteStatus InitTemporaryTensors(TfLiteContext* context,\n \n TfLiteStatus ResizeOutputandTemporaryTensors(TfLiteContext* context,\n                                              TfLiteNode* node) {\n-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n+  const TfLiteTensor* input;\n+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n   const int num_dims = NumDimensions(input);\n   TF_LITE_ENSURE(context, num_dims >= 2);\n-  const TfLiteTensor* fft_length = GetInput(context, node, kFftLengthTensor);\n+  const TfLiteTensor* fft_length;\n+  TF_LITE_ENSURE_OK(context,\n+                    GetInputSafe(context, node, kFftLengthTensor, &fft_length));\n   const int32_t* fft_length_data = GetTensorData<int32_t>(fft_length);\n   // The lib, fft2d, can only handle fft_lengths of power of 2.\n   TF_LITE_ENSURE(context, IsPowerOfTwo(fft_length_data[0]));\n@@ -116,15 +123,19 @@ TfLiteStatus ResizeOutputandTemporaryTensors(TfLiteContext* context,\n   int half_fft_working_length = fft_working_length / 2;\n \n   // Resize output tensor.\n-  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n+  TfLiteTensor* output;\n+  TF_LITE_ENSURE_OK(context,\n+                    GetOutputSafe(context, node, kOutputTensor, &output));\n   TfLiteIntArray* output_shape = TfLiteIntArrayCopy(input->dims);\n   output_shape->data[num_dims - 2] = fft_length_data[0];\n   output_shape->data[num_dims - 1] = fft_length_data[1] / 2 + 1;\n   TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n \n   // Resize temporary tensors, fft_integer_working_area.\n-  TfLiteTensor* fft_integer_working_area =\n-      GetTemporary(context, node, kFftIntegerWorkingAreaTensor);\n+  TfLiteTensor* fft_integer_working_area;\n+  TF_LITE_ENSURE_OK(\n+      context, GetTemporarySafe(context, node, kFftIntegerWorkingAreaTensor,\n+                                &fft_integer_working_area));\n   TfLiteIntArray* fft_integer_working_area_shape = TfLiteIntArrayCreate(1);\n   fft_integer_working_area_shape->data[0] =\n       2 + static_cast<int>(sqrt(fft_working_length));\n@@ -132,8 +143,10 @@ TfLiteStatus ResizeOutputandTemporaryTensors(TfLiteContext* context,\n                                               fft_integer_working_area_shape));\n \n   // Resize temporary tensors, fft_double_working_area.\n-  TfLiteTensor* fft_double_working_area =\n-      GetTemporary(context, node, kFftDoubleWorkingAreaTensor);\n+  TfLiteTensor* fft_double_working_area;\n+  TF_LITE_ENSURE_OK(context,\n+                    GetTemporarySafe(context, node, kFftDoubleWorkingAreaTensor,\n+                                     &fft_double_working_area));\n   TfLiteIntArray* fft_double_working_area_shape = TfLiteIntArrayCreate(1);\n   fft_double_working_area_shape->data[0] =\n       half_fft_working_length + fft_width / 4;\n@@ -157,7 +170,8 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n   TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n \n   // Check type and shape of the input tensor\n-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n+  const TfLiteTensor* input;\n+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n   TF_LITE_ENSURE(context, NumDimensions(input) >= 2);\n   if (input->type != kTfLiteFloat32) {\n     context->ReportError(context,\n@@ -167,7 +181,9 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n   }\n \n   // Check type and shape of the fft_length tensor\n-  const TfLiteTensor* fft_length = GetInput(context, node, kFftLengthTensor);\n+  const TfLiteTensor* fft_length;\n+  TF_LITE_ENSURE_OK(context,\n+                    GetInputSafe(context, node, kFftLengthTensor, &fft_length));\n   const RuntimeShape fft_length_shape = GetTensorShape(fft_length);\n \n   TF_LITE_ENSURE_EQ(context, NumDimensions(fft_length), 1);\n@@ -183,17 +199,23 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n   TF_LITE_ENSURE_STATUS(InitTemporaryTensors(context, node));\n \n   // Set output type\n-  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n+  TfLiteTensor* output;\n+  TF_LITE_ENSURE_OK(context,\n+                    GetOutputSafe(context, node, kOutputTensor, &output));\n   output->type = kTfLiteComplex64;\n \n   // Exit early if fft_length is a non-const tensor. Set output tensor and\n   // temporary tensors to dynamic, so that their tensor sizes can be determined\n   // in Eval.\n   if (!IsConstantTensor(fft_length)) {\n-    TfLiteTensor* fft_integer_working_area =\n-        GetTemporary(context, node, kFftIntegerWorkingAreaTensor);\n-    TfLiteTensor* fft_double_working_area =\n-        GetTemporary(context, node, kFftDoubleWorkingAreaTensor);\n+    TfLiteTensor* fft_integer_working_area;\n+    TF_LITE_ENSURE_OK(\n+        context, GetTemporarySafe(context, node, kFftIntegerWorkingAreaTensor,\n+                                  &fft_integer_working_area));\n+    TfLiteTensor* fft_double_working_area;\n+    TF_LITE_ENSURE_OK(\n+        context, GetTemporarySafe(context, node, kFftDoubleWorkingAreaTensor,\n+                                  &fft_double_working_area));\n     SetTensorToDynamic(fft_integer_working_area);\n     SetTensorToDynamic(fft_double_working_area);\n     SetTensorToDynamic(output);\n@@ -325,11 +347,16 @@ void PrepareOutputBuffer(complex<float>* output_data, int fft_height,\n }\n \n TfLiteStatus Rfft2dHelper(TfLiteContext* context, TfLiteNode* node) {\n-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n+  const TfLiteTensor* input;\n+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n   const float* input_data = GetTensorData<float>(input);\n-  const TfLiteTensor* fft_length = GetInput(context, node, kFftLengthTensor);\n+  const TfLiteTensor* fft_length;\n+  TF_LITE_ENSURE_OK(context,\n+                    GetInputSafe(context, node, kFftLengthTensor, &fft_length));\n   const int32_t* fft_length_data = GetTensorData<int32_t>(fft_length);\n-  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n+  TfLiteTensor* output;\n+  TF_LITE_ENSURE_OK(context,\n+                    GetOutputSafe(context, node, kOutputTensor, &output));\n   complex<float>* output_data = GetTensorData<complex<float>>(output);\n \n   int fft_height, fft_width;\n@@ -358,14 +385,18 @@ TfLiteStatus Rfft2dHelper(TfLiteContext* context, TfLiteNode* node) {\n   }\n \n   // Get buffer for integer working area.\n-  TfLiteTensor* fft_integer_working_area =\n-      GetTemporary(context, node, kFftIntegerWorkingAreaTensor);\n+  TfLiteTensor* fft_integer_working_area;\n+  TF_LITE_ENSURE_OK(\n+      context, GetTemporarySafe(context, node, kFftIntegerWorkingAreaTensor,\n+                                &fft_integer_working_area));\n   int* fft_integer_working_area_data =\n       GetTensorData<int>(fft_integer_working_area);\n \n   // Get buffer for double working area.\n-  TfLiteTensor* fft_double_working_area =\n-      GetTemporary(context, node, kFftDoubleWorkingAreaTensor);\n+  TfLiteTensor* fft_double_working_area;\n+  TF_LITE_ENSURE_OK(context,\n+                    GetTemporarySafe(context, node, kFftDoubleWorkingAreaTensor,\n+                                     &fft_double_working_area));\n   // Get double value out of the memory of fft_double_working_area_data.\n   double* fft_double_working_area_data = reinterpret_cast<double*>(\n       GetTensorData<int64_t>(fft_double_working_area));\n@@ -393,10 +424,15 @@ TfLiteStatus Rfft2dHelper(TfLiteContext* context, TfLiteNode* node) {\n }\n \n TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n-  const TfLiteTensor* fft_length = GetInput(context, node, kFftLengthTensor);\n+  const TfLiteTensor* input;\n+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n+  const TfLiteTensor* fft_length;\n+  TF_LITE_ENSURE_OK(context,\n+                    GetInputSafe(context, node, kFftLengthTensor, &fft_length));\n   const int32_t* fft_length_data = GetTensorData<int32_t>(fft_length);\n-  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n+  TfLiteTensor* output;\n+  TF_LITE_ENSURE_OK(context,\n+                    GetOutputSafe(context, node, kOutputTensor, &output));\n \n   if (output->type != kTfLiteComplex64) {\n     context->ReportError(context,"