"diff --git a/tensorflow/lite/kernels/topk_v2.cc b/tensorflow/lite/kernels/topk_v2.cc\nindex 3fb241356e1..5531e75ac13 100644\n--- a/tensorflow/lite/kernels/topk_v2.cc\n+++ b/tensorflow/lite/kernels/topk_v2.cc\n@@ -35,14 +35,16 @@ constexpr int kOutputIndexes = 1;\n \n namespace {\n TfLiteStatus ResizeOutput(TfLiteContext* context, TfLiteNode* node) {\n-  const TfLiteTensor* top_k = GetInput(context, node, kInputTopK);\n+  const TfLiteTensor* top_k;\n+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTopK, &top_k));\n   // INT32 number of top results is supported.\n   TF_LITE_ENSURE_TYPES_EQ(context, top_k->type, kTfLiteInt32);\n   // Check that the tensor contains only one value.\n   TF_LITE_ENSURE_EQ(context, NumElements(top_k), 1);\n   const int32 k = *GetTensorData<int32_t>(top_k);\n \n-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n+  const TfLiteTensor* input;\n+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n   const int num_dimensions = NumDimensions(input);\n   // Check that input has one or more dimensions.\n   TF_LITE_ENSURE_MSG(context, input->dims->size >= 1,\n@@ -59,8 +61,12 @@ TfLiteStatus ResizeOutput(TfLiteContext* context, TfLiteNode* node) {\n   }\n   output_indexes_shape->data[num_dimensions - 1] = k;\n   output_values_shape->data[num_dimensions - 1] = k;\n-  TfLiteTensor* output_indexes = GetOutput(context, node, kOutputIndexes);\n-  TfLiteTensor* output_values = GetOutput(context, node, kOutputValues);\n+  TfLiteTensor* output_indexes;\n+  TF_LITE_ENSURE_OK(\n+      context, GetOutputSafe(context, node, kOutputIndexes, &output_indexes));\n+  TfLiteTensor* output_values;\n+  TF_LITE_ENSURE_OK(\n+      context, GetOutputSafe(context, node, kOutputValues, &output_values));\n   // Force output types.\n   output_indexes->type = kTfLiteInt32;\n   output_values->type = input->type;\n@@ -195,19 +201,27 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n   TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n   TF_LITE_ENSURE_EQ(context, NumOutputs(node), 2);\n \n-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n-  TfLiteTensor* output_values = GetOutput(context, node, kOutputValues);\n+  const TfLiteTensor* input;\n+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n+  TfLiteTensor* output_values;\n+  TF_LITE_ENSURE_OK(\n+      context, GetOutputSafe(context, node, kOutputValues, &output_values));\n   TF_LITE_ENSURE_TYPES_EQ(context, input->type, output_values->type);\n \n-  const TfLiteTensor* top_k = GetInput(context, node, kInputTopK);\n+  const TfLiteTensor* top_k;\n+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTopK, &top_k));\n   TF_LITE_ENSURE_TYPES_EQ(context, top_k->type, kTfLiteInt32);\n \n   // Set output dynamic if the input is not const.\n   if (IsConstantTensor(top_k)) {\n     TF_LITE_ENSURE_OK(context, ResizeOutput(context, node));\n   } else {\n-    TfLiteTensor* output_indexes = GetOutput(context, node, kOutputIndexes);\n-    TfLiteTensor* output_values = GetOutput(context, node, kOutputValues);\n+    TfLiteTensor* output_indexes;\n+    TF_LITE_ENSURE_OK(\n+        context, GetOutputSafe(context, node, kOutputIndexes, &output_indexes));\n+    TfLiteTensor* output_values;\n+    TF_LITE_ENSURE_OK(\n+        context, GetOutputSafe(context, node, kOutputValues, &output_values));\n     SetTensorToDynamic(output_indexes);\n     SetTensorToDynamic(output_values);\n   }\n@@ -215,16 +229,22 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n }\n \n TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n-  TfLiteTensor* output_values = GetOutput(context, node, kOutputValues);\n-  TfLiteTensor* output_indexes = GetOutput(context, node, kOutputIndexes);\n+  TfLiteTensor* output_values;\n+  TF_LITE_ENSURE_OK(\n+      context, GetOutputSafe(context, node, kOutputValues, &output_values));\n+  TfLiteTensor* output_indexes;\n+  TF_LITE_ENSURE_OK(\n+      context, GetOutputSafe(context, node, kOutputIndexes, &output_indexes));\n   if (IsDynamicTensor(output_values)) {\n     TF_LITE_ENSURE_OK(context, ResizeOutput(context, node));\n   }\n-  const TfLiteTensor* top_k = GetInput(context, node, kInputTopK);\n+  const TfLiteTensor* top_k;\n+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTopK, &top_k));\n   const int32 k = top_k->data.i32[0];\n   // The tensor can have more than 2 dimensions or even be a vector, the code\n   // anyway calls the internal dimension as row;\n-  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n+  const TfLiteTensor* input;\n+  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n   const int32 row_size = input->dims->data[input->dims->size - 1];\n   int32 num_rows = 1;\n   for (int i = 0; i < input->dims->size - 1; ++i) {"