"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include <cstddef>\n#include <cstdint>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/kernel_utils.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace rnn {\n\nnamespace {\n\nstruct OpData {\n  int scratch_tensor_index;\n  bool compute_row_sums = false;\n};\n\n}  // namespace\n\nconstexpr int kInputTensor = 0;\nconstexpr int kWeightsTensor = 1;\nconstexpr int kRecurrentWeightsTensor = 2;\nconstexpr int kBiasTensor = 3;\nconstexpr int kHiddenStateTensor = 4;\n\n// Output tensor.\nconstexpr int kOutputTensor = 0;\n\nvoid* Init(TfLiteContext* context, const char* buffer, size_t length) {\n  auto* op_data = new OpData();\n  context->AddTensors(context, /*tensors_to_add=*/6,\n                      &op_data->scratch_tensor_index);\n  return op_data;\n}\n\nvoid Free(TfLiteContext* context, void* buffer) {\n  delete reinterpret_cast<OpData*>(buffer);\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* input_weights;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node, kWeightsTensor, &input_weights));\n  const TfLiteTensor* recurrent_weights;\n  TF_LITE_ENSURE_OK(\n      context,\n      GetInputSafe(context, node, kRecurrentWeightsTensor, &recurrent_weights));\n  const TfLiteTensor* bias;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBiasTensor, &bias));\n  const TfLiteTensor* hidden_state;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node, kHiddenStateTensor, &hidden_state));\n\n  // Check all the parameters of tensor match within themselves and match the\n  // input configuration.\n  const int batch_size = input->dims->data[0];\n  const int num_units = input_weights->dims->data[0];\n  TF_LITE_ENSURE_EQ(context, input->dims->data[1],\n                    input_weights->dims->data[1]);\n  TF_LITE_ENSURE_EQ(context, input_weights->dims->data[0], bias->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, recurrent_weights->dims->data[0],\n                    bias->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, recurrent_weights->dims->data[1],\n                    bias->dims->data[0]);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  TF_LITE_ENSURE_TYPES_EQ(context, input_weights->type,\n                          recurrent_weights->type);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hidden_state), 2);\n  TF_LITE_ENSURE_EQ(context, hidden_state->dims->data[0], batch_size);\n  TF_LITE_ENSURE_EQ(context, hidden_state->dims->data[1], num_units);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  // Resize output.\n  TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(2);\n  output_size_array->data[0] = batch_size;\n  output_size_array->data[1] = num_units;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_size_array));\n\n  const bool is_hybrid = IsHybridOp(input, input_weights);\n\n  // Allocate temporary tensors to store quantized values of input and\n  // hidden_state tensors.\n  if (is_hybrid) {\n    auto* op_data = reinterpret_cast<OpData*>(node->user_data);\n    op_data->compute_row_sums = true;\n    TfLiteIntArrayFree(node->temporaries);\n    node->temporaries = TfLiteIntArrayCreate(6);\n    node->temporaries->data[0] = op_data->scratch_tensor_index;\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/0,\n                                                &input_quantized));\n    input_quantized->type = input_weights->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n    node->temporaries->data[1] = op_data->scratch_tensor_index + 1;\n    TfLiteTensor* hidden_state_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,\n                                                &hidden_state_quantized));\n    hidden_state_quantized->type = input_weights->type;\n    hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(hidden_state_quantized->dims,\n                             hidden_state->dims)) {\n      TfLiteIntArray* hidden_state_quantized_size =\n          TfLiteIntArrayCopy(hidden_state->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, hidden_state_quantized,\n                                              hidden_state_quantized_size));\n    }\n    node->temporaries->data[2] = op_data->scratch_tensor_index + 2;\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,\n                                                &scaling_factors));\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n    node->temporaries->data[3] = op_data->scratch_tensor_index + 3;\n    TfLiteTensor* accum_scratch;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/3, &accum_scratch));\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {num_units, batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2);\n      accum_scratch_size->data[0] = accum_scratch_dims[0];\n      accum_scratch_size->data[1] = accum_scratch_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch,\n                                                       accum_scratch_size));\n    }\n    node->temporaries->data[4] = op_data->scratch_tensor_index + 4;\n    TfLiteTensor* zero_points;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/4, &zero_points));\n    zero_points->type = kTfLiteInt32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n    node->temporaries->data[5] = op_data->scratch_tensor_index + 5;\n    TfLiteTensor* row_sums;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, /*index=*/5, &row_sums));\n    row_sums->type = kTfLiteInt32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_dims[2] = {2, num_units};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 2, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(2);\n      row_sums_size->data[0] = row_sums_dims[0];\n      row_sums_size->data[1] = row_sums_dims[1];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n  return kTfLiteOk;\n}\n\nTfLiteStatus EvalFloat(const TfLiteTensor* input,\n                       const TfLiteTensor* input_weights,\n                       const TfLiteTensor* recurrent_weights,\n                       const TfLiteTensor* bias, const TfLiteRNNParams* params,\n                       TfLiteTensor* hidden_state, TfLiteTensor* output) {\n  const int batch_size = input->dims->data[0];\n  const int num_units = input_weights->dims->data[0];\n  const int input_size = input->dims->data[1];\n  const int output_batch_leading_dim =\n      output->dims->data[output->dims->size - 1];\n\n  // Initialize the pointer to hidden state.\n  float* hidden_state_ptr_batch = GetTensorData<float>(hidden_state);\n  // Initialize the pointer to input and output.\n  const float* input_ptr_batch = GetTensorData<float>(input);\n  float* output_ptr_batch = GetTensorData<float>(output);\n  // Initialize input_weights, recurrent_weights and bias.\n  const float* input_weights_ptr = GetTensorData<float>(input_weights);\n  const float* recurrent_weights_ptr = GetTensorData<float>(recurrent_weights);\n  const float* bias_ptr = GetTensorData<float>(bias);\n\n  kernel_utils::RnnBatchStep(\n      input_ptr_batch, input_weights_ptr, recurrent_weights_ptr, bias_ptr,\n      input_size, num_units, batch_size, output_batch_leading_dim,\n      params->activation, hidden_state_ptr_batch, output_ptr_batch);\n  return kTfLiteOk;\n}\n\nTfLiteStatus EvalHybrid(const TfLiteTensor* input,\n                        const TfLiteTensor* input_weights,\n                        const TfLiteTensor* recurrent_weights,\n                        const TfLiteTensor* bias, const TfLiteRNNParams* params,\n                        TfLiteTensor* input_scratch,\n                        TfLiteTensor* hidden_state_scratch,\n                        TfLiteTensor* scaling_factors,\n                        TfLiteTensor* hidden_state, TfLiteTensor* output,\n                        TfLiteTensor* zero_points, TfLiteTensor* accum_scratch,\n                        TfLiteTensor* row_sums, bool* compute_row_sums) {\n  const int batch_size = input->dims->data[0];\n  const int num_units = input_weights->dims->data[0];\n  const int input_size = input->dims->data[1];\n  const int output_batch_leading_dim =\n      output->dims->data[output->dims->size - 1];\n\n  // Initialize the pointer to hidden state.\n  float* hidden_state_ptr_batch = GetTensorData<float>(hidden_state);\n  // Initialize the pointer to input and output.\n  const float* input_ptr_batch = GetTensorData<float>(input);\n  float* output_ptr_batch = GetTensorData<float>(output);\n  // Initialize input_weights, recurrent_weights and bias.\n  const int8_t* input_weights_ptr = GetTensorData<int8_t>(input_weights);\n  const int8_t* recurrent_weights_ptr =\n      GetTensorData<int8_t>(recurrent_weights);\n  const float* bias_ptr = GetTensorData<float>(bias);\n  // Get the scale of the quantized weights.\n  float input_weights_scale = input_weights->params.scale;\n  float recurrent_weights_scale = recurrent_weights->params.scale;\n  // Initialize temporary storage for quantized values.\n  int8_t* quantized_input_ptr = GetTensorData<int8_t>(input_scratch);\n  int8_t* quantized_hidden_state_ptr =\n      GetTensorData<int8_t>(hidden_state_scratch);\n  float* scaling_factors_ptr = GetTensorData<float>(scaling_factors);\n  int32_t* accum_scratch_ptr = GetTensorData<int32_t>(accum_scratch);\n  int32_t* zero_points_ptr = nullptr;\n  int32_t* row_sums_ptr = nullptr;\n  if (params->asymmetric_quantize_inputs) {\n    zero_points_ptr = GetTensorData<int32_t>(zero_points);\n    row_sums_ptr = GetTensorData<int32_t>(row_sums);\n  }\n  kernel_utils::RnnBatchStep(\n      input_ptr_batch, input_weights_ptr, input_weights_scale,\n      recurrent_weights_ptr, recurrent_weights_scale, bias_ptr, input_size,\n      num_units, batch_size, output_batch_leading_dim, params->activation,\n      quantized_input_ptr, quantized_hidden_state_ptr, scaling_factors_ptr,\n      hidden_state_ptr_batch, output_ptr_batch,\n      params->asymmetric_quantize_inputs, zero_points_ptr, accum_scratch_ptr,\n      row_sums_ptr, compute_row_sums);\n  return kTfLiteOk;\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteRNNParams*>(node->builtin_data);\n  auto* op_data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* input_weights;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node, kWeightsTensor, &input_weights));\n  const TfLiteTensor* recurrent_weights;\n  TF_LITE_ENSURE_OK(\n      context,\n      GetInputSafe(context, node, kRecurrentWeightsTensor, &recurrent_weights));\n  const TfLiteTensor* bias;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBiasTensor, &bias));\n  TfLiteTensor* hidden_state =\n      GetVariableInput(context, node, kHiddenStateTensor);\n  TF_LITE_ENSURE(context, hidden_state != nullptr);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  // We already checked that weight types are consistent, so branch on one.\n  switch (input_weights->type) {\n    case kTfLiteFloat32:\n      return EvalFloat(input, input_weights, recurrent_weights, bias, params,\n                       hidden_state, output);\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      // TODO(mirkov): implement eval with quantized inputs as well.\n      TfLiteTensor* input_quantized;\n      TF_LITE_ENSURE_OK(context,\n                        GetTemporarySafe(context, node, 0, &input_quantized));\n      TfLiteTensor* hidden_state_quantized;\n      TF_LITE_ENSURE_OK(\n          context, GetTemporarySafe(context, node, 1, &hidden_state_quantized));\n      TfLiteTensor* scaling_factors;\n      TF_LITE_ENSURE_OK(context,\n                        GetTemporarySafe(context, node, 2, &scaling_factors));\n      TfLiteTensor* accum_scratch;\n      TF_LITE_ENSURE_OK(context,\n                        GetTemporarySafe(context, node, 3, &accum_scratch));\n      TfLiteTensor* zero_points;\n      TF_LITE_ENSURE_OK(context,\n                        GetTemporarySafe(context, node, 4, &zero_points));\n      TfLiteTensor* row_sums;\n      TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, 5, &row_sums));\n      return EvalHybrid(input, input_weights, recurrent_weights, bias, params,\n                        input_quantized, hidden_state_quantized,\n                        scaling_factors, hidden_state, output, zero_points,\n                        accum_scratch, row_sums, &op_data->compute_row_sums);\n    }\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input_weights->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n\n}  // namespace rnn\n\nTfLiteRegistration* Register_RNN() {\n  static TfLiteRegistration r = {rnn::Init, rnn::Free, rnn::Prepare, rnn::Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite"