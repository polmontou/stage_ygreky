"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/lite/kernels/internal/optimized/integer_ops/conv.h\"\n\n#include <stddef.h>\n\n#include <cstdint>\n#include <vector>\n\n// Only use multi-threaded Eigen if ruy is disabled.\n#if !defined(TFLITE_WITH_RUY)\n#define TFLITE_WITH_MULTITHREADED_EIGEN\n#endif\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/cpu_backend_context.h\"\n#if defined(TFLITE_WITH_MULTITHREADED_EIGEN)\n#include \"tensorflow/lite/kernels/eigen_support.h\"\n#endif\n#include \"tensorflow/lite/kernels/internal/compatibility.h\"\n#include \"tensorflow/lite/kernels/internal/types.h\"\n// b/131835803 forces us to include multithreaded_conv.h before optimized_ops.h\n#if defined(TFLITE_WITH_MULTITHREADED_EIGEN)\n#include \"tensorflow/lite/kernels/internal/optimized/multithreaded_conv.h\"\n#endif\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/kernels/internal/quantization_util.h\"\n#include \"tensorflow/lite/kernels/internal/reference/conv.h\"\n#include \"tensorflow/lite/kernels/internal/reference/integer_ops/conv.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_utils.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n#include \"tensorflow/lite/kernels/padding.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace conv {\n\n// This file has 4 implementation of Conv.\nenum KernelType {\n  kReference,\n  kGenericOptimized,  // Neon-free\n  // kMultithreadOptimized is a mixture of an Eigen-based kernel when threads\n  // are available and kGenericOptimized when we must use only one thread.\n  kMultithreadOptimized,\n  // The kernel uses use CBLAS interface for matrix multiplication.\n  // It's fast when an optimized CBLAS implementation is available (e.g. Apple\n  // Accelerate Framework), and it's slow when falling back to naive\n  // implementation.\n  kCblasOptimized,\n};\n\nconst int kTensorNotAllocated = -1;\n\nstruct OpData {\n  // IDs are the arbitrary identifiers used by TF Lite to identify and access\n  // memory buffers.\n  int im2col_id = kTensorNotAllocated;\n  int hwcn_weights_id = kTensorNotAllocated;\n  int input_quantized_id = kTensorNotAllocated;\n  int scaling_factors_id = kTensorNotAllocated;\n  int input_offset_id = kTensorNotAllocated;\n  int accum_scratch_id = kTensorNotAllocated;\n  // Row sums are used to cache filter sums for hybrid zero-point calculations.\n  int row_sums_id = kTensorNotAllocated;\n\n  TfLitePaddingValues padding;\n  // The scaling factor from input to output (aka the 'real multiplier') can\n  // be represented as a fixed point multiplier plus a left shift.\n  int32_t output_multiplier;\n  int output_shift;\n\n  // Per channel output multiplier and shift.\n  std::vector<int32_t> per_channel_output_multiplier;\n  std::vector<int> per_channel_output_shift;\n\n  // The range of the fused activation layer. For example for kNone and\n  // uint8_t these would be 0 and 255.\n  int32_t output_activation_min;\n  int32_t output_activation_max;\n  // Indexes are the offset to the memory buffer in the array used to keep track\n  // of the allocated temporaries.\n  int32_t im2col_index;\n  int32_t hwcn_weights_index;\n  int32_t input_quantized_index;\n  int32_t scaling_factors_index;\n  int32_t accum_scratch_index;\n  int32_t input_offset_index;\n  int32_t row_sums_index;\n\n  bool need_hwcn_weights = false;\n  bool have_weights_been_transposed = false;\n  bool need_im2col = false;\n\n  bool supports_multithreaded_kernel = false;\n  bool is_hybrid_per_channel = false;\n  bool compute_hybrid_row_sums = true;\n};\n\ninline PaddingType RuntimePaddingType(TfLitePadding padding) {\n  switch (padding) {\n    case TfLitePadding::kTfLitePaddingSame:\n      return PaddingType::kSame;\n    case TfLitePadding::kTfLitePaddingValid:\n      return PaddingType::kValid;\n    case TfLitePadding::kTfLitePaddingUnknown:\n    default:\n      return PaddingType::kNone;\n  }\n}\n\nvoid* Init(TfLiteContext* context, const char* buffer, size_t length) {\n  // This is a builtin op, so we don't use the contents in 'buffer', if any.\n  // Instead, we allocate a new object to use as scratch space for im2col, and\n  // to carry information from Prepare() to Eval().\n  auto* data = new OpData;\n#if defined(TFLITE_WITH_MULTITHREADED_EIGEN)\n  eigen_support::IncrementUsageCounter(context);\n#endif\n  return data;\n}\n\nvoid Free(TfLiteContext* context, void* buffer) {\n#if defined(TFLITE_WITH_MULTITHREADED_EIGEN)\n  eigen_support::DecrementUsageCounter(context);\n#endif\n  delete reinterpret_cast<OpData*>(buffer);\n}\n\n// Naive implementation of transpose for floats. Could be optimized to be more\n// cache friendly, but for now it's a one-time cost on first run, and we would\n// prefer to remove the need to do this at all eventually.\nvoid TransposeFloatTensor(const TfLiteTensor* input, TfLiteTensor* output) {\n  const int rows = output->dims->data[1];\n  const int cols = output->dims->data[0];\n  const float* input_data = GetTensorData<float>(input);\n  float* output_data = GetTensorData<float>(output);\n  for (int i = 0; i < rows; ++i) {\n    for (int j = 0; j < cols; ++j) {\n      const float in_value = input_data[i * cols + j];\n      output_data[j * rows + i] = in_value;\n    }\n  }\n}\n\n// Check if im2col needs to be allocated, as some version of optimized Conv dont\n// use it. If any change is supporting im2col in any of the Conv versions, then\n// it should be updated here as well\nbool IsIm2ColRequired(const TfLiteTensor* input, TfLiteConvParams* params,\n                      const TfLiteTensor* filter, OpData* data, bool is_hybrid,\n                      KernelType kernel_type) {\n  // If HWCN weights are required, Im2Col not required\n  if (data->need_hwcn_weights) return false;\n\n  // segregate based on dilated conv & non-dialated conv\n  const bool need_dilated_im2col =\n      params->dilation_width_factor != 1 || params->dilation_height_factor != 1;\n  const bool need_non_dilated_im2col =\n      params->stride_width != 1 || params->stride_height != 1 ||\n      filter->dims->data[2] != 1 || filter->dims->data[1] != 1;\n\n  const bool need_im2col = need_dilated_im2col || need_non_dilated_im2col;\n\n  // Return early as basic requirement is not met\n  if (!need_im2col) return false;\n\n  // Special case for Hybrid, as it supports only non-dilated im2col currently\n  const bool is_hybrid_non_dilated = is_hybrid && need_non_dilated_im2col;\n  const bool is_quantized =\n      input->type == kTfLiteUInt8 || input->type == kTfLiteInt8;\n\n  switch (kernel_type) {\n    case kReference:\n      if (is_hybrid) {\n        return true;\n      } else {\n        return false;\n      }\n    case kGenericOptimized:\n    case kCblasOptimized:\n      if (is_hybrid && !need_non_dilated_im2col) {\n        return false;\n      } else {\n        return true;\n      }\n    case kMultithreadOptimized:\n      if (is_hybrid_non_dilated || is_quantized ||\n          !data->supports_multithreaded_kernel) {\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\n// Allocate temporary tensors (`im2col`, `hwcn_weights` if necessary).\n// Note: `context->AddTensors` might invalidate pointers to existing tensors.\n// Therefore the logic to add tensors are isolated into this function.\nstatic TfLiteStatus AllocateTemporaryTensorsIfRequired(TfLiteContext* context,\n                                                       TfLiteNode* node,\n                                                       bool is_hybrid,\n                                                       bool is_per_channel,\n                                                       KernelType kernel_type) {\n  auto* params = reinterpret_cast<TfLiteConvParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE(context, node->inputs->size >= 2);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  const TfLiteTensor* filter;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &filter));\n\n  // If we're using the optimized multithreaded EigenTensor implementation of\n  // convolution, it expects the filter weights to be transposed compared to\n  // the normal TF Lite buffer format. Typical TF Lite weights are\n  // [filter_count, filter_height, filter_width, input_depth], but for the float\n  // implementation we need them as [filter_height, filter_width, input_depth,\n  // filter_count]. We get to that format by transposing, and create a temporary\n  // buffer to store the results.\n  // This path is only used for float processing, so only create the buffer if\n  // we're running with that data type.\n  data->need_hwcn_weights =\n      input->type == kTfLiteFloat32 && data->supports_multithreaded_kernel;\n\n  // We don't always need to allocate im2col. It is only used in some versions\n  // of the optimized Conv. This test just mimics something that happens inside\n  // optimized_ops.h, in order to avoid a DCHECK(!im2col_data).\n  data->need_im2col =\n      IsIm2ColRequired(input, params, filter, data, is_hybrid, kernel_type);\n\n  int temporaries_count = 0;\n  if (data->need_im2col) {\n    data->im2col_index = temporaries_count;\n    if (data->im2col_id == kTensorNotAllocated) {\n      context->AddTensors(context, 1, &data->im2col_id);\n    }\n    ++temporaries_count;\n  }\n  if (data->need_hwcn_weights) {\n    data->hwcn_weights_index = temporaries_count;\n    if (data->hwcn_weights_id == kTensorNotAllocated) {\n      context->AddTensors(context, 1, &data->hwcn_weights_id);\n    }\n    ++temporaries_count;\n  }\n\n  if (is_hybrid) {\n    // Allocate tensor to store the on-the-fly quantized inputs.\n    data->input_quantized_index = temporaries_count;\n    if (data->input_quantized_id == kTensorNotAllocated) {\n      TF_LITE_ENSURE_OK(\n          context, context->AddTensors(context, 1, &data->input_quantized_id));\n    }\n    ++temporaries_count;\n\n    // Allocate tensor to store the quantization params computed during\n    // on-the-fly input quantization.\n    data->scaling_factors_index = temporaries_count;\n    if (data->scaling_factors_id == kTensorNotAllocated) {\n      TF_LITE_ENSURE_OK(\n          context, context->AddTensors(context, 1, &data->scaling_factors_id));\n    }\n    ++temporaries_count;\n\n    // Allocate tensor to store the accumulators for the matrix multiply.\n    data->accum_scratch_index = temporaries_count;\n    if (data->accum_scratch_id == kTensorNotAllocated) {\n      TF_LITE_ENSURE_OK(\n          context, context->AddTensors(context, 1, &data->accum_scratch_id));\n    }\n    ++temporaries_count;\n    if (is_per_channel) {\n      data->input_offset_index = temporaries_count;\n      if (data->input_offset_id == kTensorNotAllocated) {\n        TF_LITE_ENSURE_OK(\n            context, context->AddTensors(context, 1, &data->input_offset_id));\n      }\n      ++temporaries_count;\n\n      data->row_sums_index = temporaries_count;\n      if (data->row_sums_id == kTensorNotAllocated) {\n        TF_LITE_ENSURE_OK(context,\n                          context->AddTensors(context, 1, &data->row_sums_id));\n      }\n      ++temporaries_count;\n    }\n  }\n\n  TfLiteIntArrayFree(node->temporaries);\n  node->temporaries = TfLiteIntArrayCreate(temporaries_count);\n\n  return kTfLiteOk;\n}\n\nTfLiteStatus Prepare(KernelType kernel_type, TfLiteContext* context,\n                     TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteConvParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  bool has_bias = node->inputs->size == 3;\n  // Check number of inputs/outputs\n  TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  const TfLiteTensor* filter;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &filter));\n\n  // Check dimensionality of input, filter\n  TF_LITE_ENSURE_EQ(context, input->dims->size, 4);\n  TF_LITE_ENSURE_EQ(context, filter->dims->size, 4);\n  // Check input channels matching filter\n  TF_LITE_ENSURE_EQ(context, input->dims->data[3], filter->dims->data[3]);\n\n  // Check types. (We assume that UINT8 refers to quantized tensors)\n  TfLiteType input_type = input->type;\n  TF_LITE_ENSURE(context,\n                 input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||\n                     input_type == kTfLiteInt8 || input_type == kTfLiteInt16);\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type);\n\n  const TfLiteTensor* bias = nullptr;\n\n  // TODO(ahentz): At this point the optimized versions require 'bias'. We can\n  // either change that or document that convolution requires it.\n  TF_LITE_ENSURE(context, has_bias);\n\n  if (has_bias) {\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &bias));\n    if (input_type == kTfLiteUInt8 || input_type == kTfLiteInt8) {\n      TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32);\n      TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);\n    } else if (input_type == kTfLiteInt16) {\n      TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt64);\n      TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);\n      TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);\n      TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n    } else {\n      TF_LITE_ENSURE_TYPES_EQ(context, bias->type, input_type);\n    }\n    TF_LITE_ENSURE_EQ(context, NumElements(bias), SizeOfDimension(filter, 0));\n  }\n\n  const bool is_hybrid =\n      (input->type == kTfLiteFloat32 &&\n       (filter->type == kTfLiteUInt8 || filter->type == kTfLiteInt8));\n\n  if (is_hybrid && filter->type == kTfLiteInt8 &&\n      filter->quantization.type == kTfLiteAffineQuantization &&\n      filter->quantization.params &&\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params)\n          ->scale &&\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params)\n              ->scale->size > 1) {\n    const auto* affine_quantization =\n        reinterpret_cast<TfLiteAffineQuantization*>(\n            filter->quantization.params);\n    const float scale = affine_quantization->scale->data[0];\n    for (int i = 1; i < affine_quantization->scale->size; i++) {\n      if (affine_quantization->scale->data[i] != scale) {\n        data->is_hybrid_per_channel = true;\n        break;\n      }\n    }\n  }\n\n  // The multi-threaded kernel supports neither dilation nor hybrid kernels, and\n  // is incompatible with mutable input filters that might change between evals.\n  data->supports_multithreaded_kernel =\n      (kernel_type == kMultithreadOptimized) &&\n      (context->recommended_num_threads != 1) && !is_hybrid &&\n      (params->dilation_width_factor == 1) &&\n      (params->dilation_height_factor == 1) &&\n      (filter->allocation_type != kTfLiteArenaRw) &&\n      !IsDynamicTensor(filter);\n\n  TF_LITE_ENSURE_STATUS(AllocateTemporaryTensorsIfRequired(\n      context, node, is_hybrid, data->is_hybrid_per_channel, kernel_type));\n\n  int channels_in = filter->dims->data[3];\n  int channels_out = filter->dims->data[0];\n  int width = input->dims->data[2];\n  int height = input->dims->data[1];\n  int filter_width = filter->dims->data[2];\n  int filter_height = filter->dims->data[1];\n  int batches = input->dims->data[0];\n\n  // Matching GetWindowedOutputSize in TensorFlow.\n  auto padding = params->padding;\n  int out_width, out_height;\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width,\n      params->dilation_height_factor, params->dilation_width_factor, height,\n      width, filter_height, filter_width, padding, &out_height, &out_width);\n\n  TF_LITE_ENSURE(context, has_bias);\n\n  // Note that full fixed-point inference requires that all tensors have their\n  // parameters set. This is usually done during quantized training or\n  // calibration.\n  if (input_type != kTfLiteFloat32) {\n    TF_LITE_ENSURE_EQ(context, filter->quantization.type,\n                      kTfLiteAffineQuantization);\n    const auto* affine_quantization =\n        reinterpret_cast<TfLiteAffineQuantization*>(\n            filter->quantization.params);\n    TF_LITE_ENSURE(context, affine_quantization);\n    TF_LITE_ENSURE(context, affine_quantization->scale);\n    TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 ||\n                             affine_quantization->scale->size == channels_out));\n\n    data->per_channel_output_multiplier.resize(channels_out);\n    data->per_channel_output_shift.resize(channels_out);\n    TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(\n        context, input, filter, bias, output, params->activation,\n        &data->output_multiplier, &data->output_shift,\n        &data->output_activation_min, &data->output_activation_max,\n        data->per_channel_output_multiplier.data(),\n        data->per_channel_output_shift.data(), channels_out));\n  }\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = batches;\n  output_size->data[1] = out_height;\n  output_size->data[2] = out_width;\n  output_size->data[3] = channels_out;\n  auto output_status = context->ResizeTensor(context, output, output_size);\n\n  if (output_status != kTfLiteOk) return output_status;\n\n  if (data->need_im2col) {\n    node->temporaries->data[data->im2col_index] = data->im2col_id;\n\n    TfLiteIntArray* im2col_size = TfLiteIntArrayCreate(4);\n\n    int input_depth = input->dims->data[3];\n    im2col_size->data[0] = output_size->data[0];\n    im2col_size->data[1] = output_size->data[1];\n    im2col_size->data[2] = output_size->data[2];\n    im2col_size->data[3] = input_depth * filter_height * filter_width;\n\n    TfLiteTensor* im2col =\n        &context->tensors[node->temporaries->data[data->im2col_index]];\n    im2col->type = input->type;\n    if (is_hybrid) {\n      im2col->type = filter->type;\n    }\n    im2col->allocation_type = kTfLiteArenaRw;\n    auto im2col_status = context->ResizeTensor(context, im2col, im2col_size);\n    if (im2col_status != kTfLiteOk) return im2col_status;\n  }\n\n  if (data->need_hwcn_weights) {\n    node->temporaries->data[data->hwcn_weights_index] = data->hwcn_weights_id;\n    TfLiteIntArray* hwcn_weights_size = TfLiteIntArrayCreate(2);\n\n    // Because we're treating the filter weights as a matrix when we do the\n    // transpose, we allocate the buffer with a two-dimensional shape, where one\n    // dimension is the number of elements in each filter, and the second is the\n    // total number of filters.\n    int input_depth = input->dims->data[3];\n    hwcn_weights_size->data[0] = (filter_height * filter_width * input_depth);\n    hwcn_weights_size->data[1] = channels_out;\n\n    TfLiteTensor* hwcn_weights =\n        &context->tensors[node->temporaries->data[data->hwcn_weights_index]];\n    hwcn_weights->type = input_type;\n    hwcn_weights->allocation_type = kTfLiteArenaRwPersistent;\n\n    auto hwcn_weights_status =\n        context->ResizeTensor(context, hwcn_weights, hwcn_weights_size);\n    if (hwcn_weights_status != kTfLiteOk) return hwcn_weights_status;\n\n    // TODO(petewarden): If Resize() is called when the size hasn't actually\n    // changed, this will do extra redundant work.\n    data->have_weights_been_transposed = false;\n  }\n\n  if (is_hybrid) {\n    node->temporaries->data[data->input_quantized_index] =\n        data->input_quantized_id;\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, data->input_quantized_index,\n                                  &input_quantized));\n    input_quantized->type = kTfLiteInt8;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    node->temporaries->data[data->scaling_factors_index] =\n        data->scaling_factors_id;\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, data->scaling_factors_index,\n                                  &scaling_factors));\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    // Only one scale factor per batch is typically necessary. See optimized\n    // implementation for why we need to allocate for the height of the inputs\n    // flattened to 2D.\n    const int height = NumElements(input) / channels_in;\n    int scaling_dims[1] = {height};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = height;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n\n    node->temporaries->data[data->accum_scratch_index] = data->accum_scratch_id;\n    TfLiteTensor* accum_scratch;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, data->accum_scratch_index,\n                                       &accum_scratch));\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    const int scratch_width = batches * out_height * out_width;\n    int accum_scratch_dims[2] = {channels_out, scratch_width};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2);\n      accum_scratch_size->data[0] = channels_out;\n      accum_scratch_size->data[1] = scratch_width;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch,\n                                                       accum_scratch_size));\n    }\n\n    if (data->is_hybrid_per_channel) {\n      const auto* affine_quantization =\n          reinterpret_cast<TfLiteAffineQuantization*>(\n              filter->quantization.params);\n      TF_LITE_ENSURE_EQ(\n          context, affine_quantization->scale->size,\n          filter->dims->data[affine_quantization->quantized_dimension]);\n      node->temporaries->data[data->input_offset_index] = data->input_offset_id;\n      TfLiteTensor* input_offsets;\n      TF_LITE_ENSURE_OK(\n          context, GetTemporarySafe(context, node, data->input_offset_index,\n                                    &input_offsets));\n      input_offsets->type = kTfLiteInt32;\n      input_offsets->allocation_type = kTfLiteArenaRw;\n      // See above comment for the need to allocate for height of inputs.\n      const int height = NumElements(input) / channels_in;\n      const int input_offset_dims[1] = {height};\n      if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1,\n                                     input_offset_dims)) {\n        TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);\n        input_offsets_size->data[0] = input_offset_dims[0];\n        TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,\n                                                         input_offsets_size));\n      }\n      node->temporaries->data[data->row_sums_index] = data->row_sums_id;\n      TfLiteTensor* row_sums;\n      TF_LITE_ENSURE_OK(\n          context,\n          GetTemporarySafe(context, node, data->row_sums_index, &row_sums));\n      row_sums->type = kTfLiteInt32;\n      row_sums->allocation_type = kTfLiteArenaRwPersistent;\n      // See above comment for the need to allocate for height of inputs.\n      const int row_sums_dims[1] = {channels_out};\n      if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {\n        TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);\n        row_sums_size->data[0] = row_sums_dims[0];\n        TF_LITE_ENSURE_OK(\n            context, context->ResizeTensor(context, row_sums, row_sums_size));\n      }\n    }\n  }\n  return kTfLiteOk;\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  return Prepare(kernel_type, context, node);\n}\n\ntemplate <KernelType kernel_type>\nvoid EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                   TfLiteConvParams* params, OpData* data,\n                   const TfLiteTensor* input, const TfLiteTensor* filter,\n                   const TfLiteTensor* bias, TfLiteTensor* im2col,\n                   TfLiteTensor* output) {\n  auto input_offset = -input->params.zero_point;\n  auto filter_offset = -filter->params.zero_point;\n  auto output_offset = output->params.zero_point;\n\n  KernelType effective_kernel_type;\n  if ((kernel_type == kMultithreadOptimized ||\n       kernel_type == kCblasOptimized) &&\n      (params->dilation_width_factor != 1 ||\n       params->dilation_height_factor != 1)) {\n    // kMultithreadOptimized and kCblasOptimized do not support dilation.\n    // Therefore, fallback to optimized.\n    effective_kernel_type = kGenericOptimized;\n  } else {\n    effective_kernel_type = kernel_type;\n  }\n\n  ConvParams op_params;\n  op_params.padding_type = PaddingType::kSame;\n  op_params.padding_values.width = data->padding.width;\n  op_params.padding_values.height = data->padding.height;\n  op_params.stride_width = params->stride_width;\n  op_params.stride_height = params->stride_height;\n  op_params.dilation_width_factor = params->dilation_width_factor;\n  op_params.dilation_height_factor = params->dilation_height_factor;\n  op_params.input_offset = input_offset;\n  op_params.weights_offset = filter_offset;\n  op_params.output_offset = output_offset;\n  op_params.output_multiplier = data->output_multiplier;\n  op_params.output_shift = -data->output_shift;\n  op_params.quantized_activation_min = data->output_activation_min;\n  op_params.quantized_activation_max = data->output_activation_max;\n  switch (effective_kernel_type) {\n    case kReference: {\n      reference_ops::Conv(\n          op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n          GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n          GetTensorShape(bias), GetTensorData<int32_t>(bias),\n          GetTensorShape(output), GetTensorData<uint8_t>(output),\n          GetTensorShape(im2col), GetTensorData<uint8_t>(im2col),\n          /* cpu_backend_context = */ nullptr);\n      break;\n    }\n    case kGenericOptimized:\n    case kMultithreadOptimized:\n    case kCblasOptimized: {\n      // There is only one optimized implementation for Quantized Conv.\n      optimized_ops::Conv(\n          op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n          GetTensorShape(filter), GetTensorData<uint8_t>(filter),\n          GetTensorShape(bias), GetTensorData<int32_t>(bias),\n          GetTensorShape(output), GetTensorData<uint8_t>(output),\n          GetTensorShape(im2col), GetTensorData<uint8_t>(im2col),\n          CpuBackendContext::GetFromContext(context));\n      break;\n    }\n  }\n}\n\ntemplate <KernelType kernel_type>\nvoid EvalQuantizedPerChannel(TfLiteContext* context, TfLiteNode* node,\n                             TfLiteConvParams* params, OpData* data,\n                             const TfLiteTensor* input,\n                             const TfLiteTensor* filter,\n                             const TfLiteTensor* bias, TfLiteTensor* output,\n                             TfLiteTensor* im2col) {\n  ConvParams op_params;\n  op_params.input_offset = -input->params.zero_point;\n  op_params.output_offset = output->params.zero_point;\n  op_params.stride_height = params->stride_height;\n  op_params.stride_width = params->stride_width;\n  op_params.dilation_height_factor = params->dilation_height_factor;\n  op_params.dilation_width_factor = params->dilation_width_factor;\n  op_params.padding_values.height = data->padding.height;\n  op_params.padding_values.width = data->padding.width;\n  op_params.quantized_activation_min = data->output_activation_min;\n  op_params.quantized_activation_max = data->output_activation_max;\n\n  switch (kernel_type) {\n    case kReference: {\n      reference_integer_ops::ConvPerChannel(\n          op_params, data->per_channel_output_multiplier.data(),\n          data->per_channel_output_shift.data(), GetTensorShape(input),\n          GetTensorData<int8>(input), GetTensorShape(filter),\n          GetTensorData<int8>(filter), GetTensorShape(bias),\n          GetTensorData<int32>(bias), GetTensorShape(output),\n          GetTensorData<int8>(output));\n      break;\n    }\n    case kGenericOptimized:\n    case kMultithreadOptimized:\n    case kCblasOptimized: {\n      optimized_integer_ops::ConvPerChannel(\n          op_params, data->per_channel_output_multiplier.data(),\n          data->per_channel_output_shift.data(), GetTensorShape(input),\n          GetTensorData<int8>(input), GetTensorShape(filter),\n          GetTensorData<int8>(filter), GetTensorShape(bias),\n          GetTensorData<int32>(bias), GetTensorShape(output),\n          GetTensorData<int8>(output), GetTensorShape(im2col),\n          GetTensorData<int8>(im2col),\n          CpuBackendContext::GetFromContext(context));\n      break;\n    }\n  }\n}\n\ntemplate <KernelType kernel_type>\nvoid EvalQuantizedPerChannel16x8(TfLiteContext* context, TfLiteNode* node,\n                                 TfLiteConvParams* params, OpData* data,\n                                 const TfLiteTensor* input,\n                                 const TfLiteTensor* filter,\n                                 const TfLiteTensor* bias, TfLiteTensor* output,\n                                 TfLiteTensor* im2col) {\n  ConvParams op_params;\n  op_params.input_offset = -input->params.zero_point;\n  op_params.output_offset = output->params.zero_point;\n  op_params.stride_height = params->stride_height;\n  op_params.stride_width = params->stride_width;\n  op_params.dilation_height_factor = params->dilation_height_factor;\n  op_params.dilation_width_factor = params->dilation_width_factor;\n  op_params.padding_values.height = data->padding.height;\n  op_params.padding_values.width = data->padding.width;\n  op_params.quantized_activation_min = data->output_activation_min;\n  op_params.quantized_activation_max = data->output_activation_max;\n\n  switch (kernel_type) {\n    case kGenericOptimized:\n    case kMultithreadOptimized:\n    case kCblasOptimized:\n    case kReference: {\n      reference_integer_ops::ConvPerChannel(\n          op_params, data->per_channel_output_multiplier.data(),\n          data->per_channel_output_shift.data(), GetTensorShape(input),\n          GetTensorData<int16>(input), GetTensorShape(filter),\n          GetTensorData<int8>(filter), GetTensorShape(bias),\n          GetTensorData<std::int64_t>(bias), GetTensorShape(output),\n          GetTensorData<int16>(output));\n      break;\n    }\n  }\n}\n\ntemplate <KernelType kernel_type>\nvoid EvalFloat(TfLiteContext* context, TfLiteNode* node,\n               TfLiteConvParams* params, OpData* data,\n               const TfLiteTensor* input, const TfLiteTensor* filter,\n               const TfLiteTensor* bias, TfLiteTensor* im2col,\n               TfLiteTensor* hwcn_weights, TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n  KernelType effective_kernel_type = kernel_type;\n  // Fall back to the optimized path if multi-threaded conv is unsupported.\n  if ((kernel_type == kMultithreadOptimized) &&\n      !data->supports_multithreaded_kernel) {\n    effective_kernel_type = kGenericOptimized;\n  }\n  ConvParams op_params;\n  op_params.padding_type = RuntimePaddingType(params->padding);\n  op_params.padding_values.width = data->padding.width;\n  op_params.padding_values.height = data->padding.height;\n  op_params.stride_width = params->stride_width;\n  op_params.stride_height = params->stride_height;\n  op_params.dilation_width_factor = params->dilation_width_factor;\n  op_params.dilation_height_factor = params->dilation_height_factor;\n  op_params.float_activation_min = output_activation_min;\n  op_params.float_activation_max = output_activation_max;\n  switch (effective_kernel_type) {\n    case kReference: {\n      reference_ops::Conv(op_params, GetTensorShape(input),\n                          GetTensorData<float>(input), GetTensorShape(filter),\n                          GetTensorData<float>(filter), GetTensorShape(bias),\n                          GetTensorData<float>(bias), GetTensorShape(output),\n                          GetTensorData<float>(output), GetTensorShape(im2col),\n                          GetTensorData<float>(im2col));\n      break;\n    }\n    case kCblasOptimized:\n    case kGenericOptimized: {\n      optimized_ops::Conv(op_params, GetTensorShape(input),\n                          GetTensorData<float>(input), GetTensorShape(filter),\n                          GetTensorData<float>(filter), GetTensorShape(bias),\n                          GetTensorData<float>(bias), GetTensorShape(output),\n                          GetTensorData<float>(output), GetTensorShape(im2col),\n                          GetTensorData<float>(im2col),\n                          CpuBackendContext::GetFromContext(context));\n      break;\n    }\n    case kMultithreadOptimized: {\n#if defined(TFLITE_WITH_MULTITHREADED_EIGEN)\n      const float* filter_data;\n      if (data->need_hwcn_weights) {\n        filter_data = GetTensorData<float>(hwcn_weights);\n      } else {\n        filter_data = GetTensorData<float>(filter);\n      }\n      multithreaded_ops::Conv(\n          *eigen_support::GetThreadPoolDevice(context), op_params,\n          GetTensorShape(input), GetTensorData<float>(input),\n          GetTensorShape(filter), filter_data, GetTensorShape(bias),\n          GetTensorData<float>(bias), GetTensorShape(output),\n          GetTensorData<float>(output), GetTensorShape(im2col),\n          GetTensorData<float>(im2col));\n      break;\n#else  // !defined(TFLITE_WITH_MULTITHREADED_EIGEN)\n      // See Register_CONV_2D: we should never be here when TFLITE_WITH_RUY\n      // was enabled. We #if out this code in order to get the corresponding\n      // binary size benefits.\n      TFLITE_DCHECK(false);\n#endif  // defined(TFLITE_WITH_MULTITHREADED_EIGEN)\n    }\n  }\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node,\n                                  TfLiteConvParams* params, OpData* data,\n                                  const TfLiteTensor* input,\n                                  const TfLiteTensor* filter,\n                                  const TfLiteTensor* bias,\n                                  TfLiteTensor* im2col, TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n\n  const int input_size = NumElements(input) / SizeOfDimension(input, 0);\n  const int batch_size = SizeOfDimension(input, 0);\n  TfLiteTensor* quantized_input_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_quantized_index,\n                                     &quantized_input_tensor));\n  int8_t* quantized_input_ptr_batch =\n      GetTensorData<int8_t>(quantized_input_tensor);\n  TfLiteTensor* scaling_factors_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->scaling_factors_index,\n                                     &scaling_factors_tensor));\n  float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor);\n  TfLiteTensor* input_offset_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_offset_index,\n                                     &input_offset_tensor));\n  int32_t* input_offset_ptr = GetTensorData<int32_t>(input_offset_tensor);\n\n  for (int b = 0; b < batch_size; ++b) {\n    const int offset = b * input_size;\n    tensor_utils::AsymmetricQuantizeFloats(\n        GetTensorData<float>(input) + offset, input_size,\n        quantized_input_ptr_batch + offset, &scaling_factors_ptr[b],\n        &input_offset_ptr[b]);\n  }\n\n  int8_t* im2col_ptr = nullptr;\n  int8_t* filter_ptr = nullptr;\n  if (im2col != nullptr) {\n    im2col_ptr = im2col->data.int8;\n  }\n  filter_ptr = filter->data.int8;\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n  ConvParams op_params;\n  op_params.padding_type = PaddingType::kSame;\n  op_params.padding_values.width = data->padding.width;\n  op_params.padding_values.height = data->padding.height;\n  op_params.stride_width = params->stride_width;\n  op_params.stride_height = params->stride_height;\n  op_params.dilation_width_factor = 1;\n  op_params.dilation_height_factor = 1;\n  op_params.float_activation_min = output_activation_min;\n  op_params.float_activation_max = output_activation_max;\n  switch (kernel_type) {\n    case kReference:\n      reference_ops::HybridConvPerChannel(\n          op_params, scaling_factors_ptr, GetTensorShape(input),\n          quantized_input_ptr_batch, GetTensorShape(filter), filter_ptr,\n          GetTensorShape(bias), GetTensorData<float>(bias),\n          GetTensorShape(output), GetTensorData<float>(output),\n          GetTensorShape(im2col), im2col_ptr, affine_quantization->scale->data,\n          input_offset_ptr);\n      break;\n    case kGenericOptimized:\n    case kMultithreadOptimized:\n    case kCblasOptimized: {\n      TfLiteTensor* row_sums;\n      TF_LITE_ENSURE_OK(\n          context,\n          GetTemporarySafe(context, node, data->row_sums_index, &row_sums));\n      TfLiteTensor* scratch;\n      TF_LITE_ENSURE_OK(\n          context,\n          GetTemporarySafe(context, node, data->accum_scratch_index, &scratch));\n      optimized_ops::HybridConvPerChannel(\n          op_params, scaling_factors_ptr, GetTensorShape(input),\n          quantized_input_ptr_batch, GetTensorShape(filter), filter_ptr,\n          GetTensorShape(bias), GetTensorData<float>(bias),\n          GetTensorShape(output), GetTensorData<float>(output),\n          GetTensorShape(im2col), im2col_ptr, affine_quantization->scale->data,\n          input_offset_ptr, GetTensorShape(scratch),\n          GetTensorData<int32>(scratch), GetTensorData<int32_t>(row_sums),\n          &data->compute_hybrid_row_sums,\n          CpuBackendContext::GetFromContext(context));\n      data->compute_hybrid_row_sums = false;\n      break;\n    }\n  }\n\n  return kTfLiteOk;\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus EvalHybrid(TfLiteContext* context, TfLiteNode* node,\n                        TfLiteConvParams* params, OpData* data,\n                        const TfLiteTensor* input, const TfLiteTensor* filter,\n                        const TfLiteTensor* bias, TfLiteTensor* im2col,\n                        TfLiteTensor* accum_scratch, TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n\n  const int input_size = NumElements(input) / SizeOfDimension(input, 0);\n  const int batch_size = SizeOfDimension(input, 0);\n\n  const float* input_ptr = GetTensorData<float>(input);\n  TfLiteTensor* quantized_input_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_quantized_index,\n                                     &quantized_input_tensor));\n  int8_t* quantized_input_ptr_batch =\n      GetTensorData<int8_t>(quantized_input_tensor);\n  TfLiteTensor* scaling_factors_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->scaling_factors_index,\n                                     &scaling_factors_tensor));\n  float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor);\n\n  // Per-batch input quantization for higher accuracy.\n  {\n    ruy::profiler::ScopeLabel label(\"ConvHybridQuantizeInputs\");\n    for (int b = 0; b < batch_size; ++b) {\n      float unused_min, unused_max;\n      const int offset = b * input_size;\n      tensor_utils::SymmetricQuantizeFloats(\n          input_ptr + offset, input_size, quantized_input_ptr_batch + offset,\n          &unused_min, &unused_max, &scaling_factors_ptr[b]);\n      scaling_factors_ptr[b] *= filter->params.scale;\n    }\n  }\n\n  switch (kernel_type) {\n    case kReference:\n    case kGenericOptimized:\n    case kMultithreadOptimized:\n    case kCblasOptimized: {\n      // There is only one implementation for hybrid kernel.\n      ConvParams op_params;\n      op_params.padding_type = PaddingType::kSame;\n      op_params.padding_values.width = data->padding.width;\n      op_params.padding_values.height = data->padding.height;\n      op_params.stride_width = params->stride_width;\n      op_params.stride_height = params->stride_height;\n      op_params.dilation_width_factor = 1;\n      op_params.dilation_height_factor = 1;\n      op_params.float_activation_min = output_activation_min;\n      op_params.float_activation_max = output_activation_max;\n      optimized_ops::HybridConv(\n          op_params, scaling_factors_ptr, GetTensorShape(input),\n          quantized_input_ptr_batch, GetTensorShape(filter),\n          GetTensorData<int8_t>(filter), GetTensorShape(bias),\n          GetTensorData<float>(bias), GetTensorShape(accum_scratch),\n          GetTensorData<int32_t>(accum_scratch), GetTensorShape(output),\n          GetTensorData<float>(output), GetTensorShape(im2col),\n          GetTensorData<int8_t>(im2col),\n          CpuBackendContext::GetFromContext(context));\n      break;\n    }\n  }\n\n  return kTfLiteOk;\n}\n\ntemplate <KernelType kernel_type, TfLiteType input_type>\nTfLiteStatus EvalImpl(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteConvParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  const TfLiteTensor* filter;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &filter));\n  bool has_bias = node->inputs->size == 3;\n  const TfLiteTensor* bias = has_bias ? GetInput(context, node, 2) : nullptr;\n  TfLiteTensor* im2col =\n      data->need_im2col\n          ? &context->tensors[node->temporaries->data[data->im2col_index]]\n          : nullptr;\n  TfLiteTensor* hwcn_weights =\n      data->need_hwcn_weights\n          ? &context->tensors[node->temporaries->data[data->hwcn_weights_index]]\n          : nullptr;\n\n  if (data->need_hwcn_weights && !data->have_weights_been_transposed) {\n    TransposeFloatTensor(filter, hwcn_weights);\n    data->have_weights_been_transposed = true;\n  }\n\n  TFLITE_DCHECK_EQ(input_type, input->type);\n  switch (input_type) {  // Already know in/outtypes are same.\n    case kTfLiteFloat32:\n      if (filter->type == kTfLiteUInt8 || filter->type == kTfLiteInt8) {\n        if (data->is_hybrid_per_channel) {\n          TF_LITE_ENSURE_OK(context, EvalHybridPerChannel<kernel_type>(\n                                         context, node, params, data, input,\n                                         filter, bias, im2col, output));\n        } else {\n          TfLiteTensor* accum_scratch =\n              &context->tensors[node->temporaries\n                                    ->data[data->accum_scratch_index]];\n          TF_LITE_ENSURE_OK(context,\n                            EvalHybrid<kernel_type>(context, node, params, data,\n                                                    input, filter, bias, im2col,\n                                                    accum_scratch, output));\n        }\n      } else {\n        EvalFloat<kernel_type>(context, node, params, data, input, filter, bias,\n                               im2col, hwcn_weights, output);\n      }\n      break;\n    case kTfLiteUInt8:\n      EvalQuantized<kernel_type>(context, node, params, data, input, filter,\n                                 bias, im2col, output);\n      break;\n    case kTfLiteInt8:\n      EvalQuantizedPerChannel<kernel_type>(context, node, params, data, input,\n                                           filter, bias, output, im2col);\n      break;\n    case kTfLiteInt16:\n      EvalQuantizedPerChannel16x8<kernel_type>(\n          context, node, params, data, input, filter, bias, output, im2col);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s currently not supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n\n  switch (input->type) {\n    case kTfLiteFloat32:\n      return EvalImpl<kernel_type, kTfLiteFloat32>(context, node);\n    case kTfLiteUInt8:\n      return EvalImpl<kernel_type, kTfLiteUInt8>(context, node);\n    case kTfLiteInt8:\n      return EvalImpl<kernel_type, kTfLiteInt8>(context, node);\n    case kTfLiteInt16:\n      return EvalImpl<kernel_type, kTfLiteInt16>(context, node);\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n}\n\n}  // namespace conv\n\nTfLiteRegistration* Register_CONVOLUTION_REF() {\n  static TfLiteRegistration r = {conv::Init, conv::Free,\n                                 conv::Prepare<conv::kReference>,\n                                 conv::Eval<conv::kReference>};\n  return &r;\n}\n\nTfLiteRegistration* Register_CONVOLUTION_GENERIC_OPT() {\n  static TfLiteRegistration r = {conv::Init, conv::Free,\n                                 conv::Prepare<conv::kGenericOptimized>,\n                                 conv::Eval<conv::kGenericOptimized>};\n  return &r;\n}\n\nTfLiteRegistration* Register_CONVOLUTION_GENERIC_OPT_UINT8() {\n  static TfLiteRegistration r = {\n      conv::Init, conv::Free, conv::Prepare<conv::kGenericOptimized>,\n      conv::EvalImpl<conv::kGenericOptimized, kTfLiteUInt8>};\n  return &r;\n}\n\nTfLiteRegistration* Register_CONVOLUTION_MULTITHREADED_OPT() {\n  static TfLiteRegistration r = {conv::Init, conv::Free,\n                                 conv::Prepare<conv::kMultithreadOptimized>,\n                                 conv::Eval<conv::kMultithreadOptimized>};\n  return &r;\n}\n\nTfLiteRegistration* Register_CONVOLUTION_CBLAS_OPT() {\n  static TfLiteRegistration r = {conv::Init, conv::Free,\n                                 conv::Prepare<conv::kCblasOptimized>,\n                                 conv::Eval<conv::kCblasOptimized>};\n  return &r;\n}\n\nTfLiteRegistration* Register_CONV_2D() {\n#if defined TFLITE_USE_APPLE_ACCELERATE_FOR_CONV\n  return Register_CONVOLUTION_CBLAS_OPT();\n#elif defined TFLITE_WITH_MULTITHREADED_EIGEN\n  return Register_CONVOLUTION_MULTITHREADED_OPT();\n#else\n  return Register_CONVOLUTION_GENERIC_OPT();\n#endif\n}\n\n// Warning: Clients using this variant are responsible for ensuring that their\n// models only need the UINT8 type. TFLite's op registration mechanism doesn't\n// yet allow for more nuanced registration mechanisms.\nTfLiteRegistration* Register_CONV_2D_UINT8() {\n#if defined TFLITE_WITH_RUY\n  // TFLITE_WITH_RUY optimizes the generic kernel type.\n  return Register_CONVOLUTION_GENERIC_OPT_UINT8();\n#else\n  return Register_CONV_2D();\n#endif\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite"