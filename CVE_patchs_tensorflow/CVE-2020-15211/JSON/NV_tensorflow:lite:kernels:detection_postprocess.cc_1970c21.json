"/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#include <algorithm>\n#include <initializer_list>\n#include <numeric>\n#include <vector>\n\n#include \"flatbuffers/flexbuffers.h\"  // from @flatbuffers\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/compatibility.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/kernels/internal/reference/reference_ops.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace custom {\nnamespace detection_postprocess {\n\n// Input tensors\nconstexpr int kInputTensorBoxEncodings = 0;\nconstexpr int kInputTensorClassPredictions = 1;\nconstexpr int kInputTensorAnchors = 2;\n\n// Output tensors\nconstexpr int kOutputTensorDetectionBoxes = 0;\nconstexpr int kOutputTensorDetectionClasses = 1;\nconstexpr int kOutputTensorDetectionScores = 2;\nconstexpr int kOutputTensorNumDetections = 3;\n\nconstexpr int kNumCoordBox = 4;\nconstexpr int kBatchSize = 1;\n\nconstexpr int kNumDetectionsPerClass = 100;\n\n// Object Detection model produces axis-aligned boxes in two formats:\n// BoxCorner represents the lower left corner (xmin, ymin) and\n// the upper right corner (xmax, ymax).\n// CenterSize represents the center (xcenter, ycenter), height and width.\n// BoxCornerEncoding and CenterSizeEncoding are related as follows:\n// ycenter = y / y_scale * anchor.h + anchor.y;\n// xcenter = x / x_scale * anchor.w + anchor.x;\n// half_h = 0.5*exp(h/ h_scale)) * anchor.h;\n// half_w = 0.5*exp(w / w_scale)) * anchor.w;\n// ymin = ycenter - half_h\n// ymax = ycenter + half_h\n// xmin = xcenter - half_w\n// xmax = xcenter + half_w\nstruct BoxCornerEncoding {\n  float ymin;\n  float xmin;\n  float ymax;\n  float xmax;\n};\n\nstruct CenterSizeEncoding {\n  float y;\n  float x;\n  float h;\n  float w;\n};\n// We make sure that the memory allocations are contiguous with static assert.\nstatic_assert(sizeof(BoxCornerEncoding) == sizeof(float) * kNumCoordBox,\n              \"Size of BoxCornerEncoding is 4 float values\");\nstatic_assert(sizeof(CenterSizeEncoding) == sizeof(float) * kNumCoordBox,\n              \"Size of CenterSizeEncoding is 4 float values\");\n\nstruct OpData {\n  int max_detections;\n  int max_classes_per_detection;  // Fast Non-Max-Suppression\n  int detections_per_class;       // Regular Non-Max-Suppression\n  float non_max_suppression_score_threshold;\n  float intersection_over_union_threshold;\n  int num_classes;\n  bool use_regular_non_max_suppression;\n  CenterSizeEncoding scale_values;\n  // Indices of Temporary tensors\n  int decoded_boxes_index;\n  int scores_index;\n  int active_candidate_index;\n};\n\nvoid* Init(TfLiteContext* context, const char* buffer, size_t length) {\n  auto* op_data = new OpData;\n  const uint8_t* buffer_t = reinterpret_cast<const uint8_t*>(buffer);\n  const flexbuffers::Map& m = flexbuffers::GetRoot(buffer_t, length).AsMap();\n  op_data->max_detections = m[\"max_detections\"].AsInt32();\n  op_data->max_classes_per_detection = m[\"max_classes_per_detection\"].AsInt32();\n  if (m[\"detections_per_class\"].IsNull())\n    op_data->detections_per_class = kNumDetectionsPerClass;\n  else\n    op_data->detections_per_class = m[\"detections_per_class\"].AsInt32();\n  if (m[\"use_regular_nms\"].IsNull())\n    op_data->use_regular_non_max_suppression = false;\n  else\n    op_data->use_regular_non_max_suppression = m[\"use_regular_nms\"].AsBool();\n\n  op_data->non_max_suppression_score_threshold =\n      m[\"nms_score_threshold\"].AsFloat();\n  op_data->intersection_over_union_threshold = m[\"nms_iou_threshold\"].AsFloat();\n  op_data->num_classes = m[\"num_classes\"].AsInt32();\n  op_data->scale_values.y = m[\"y_scale\"].AsFloat();\n  op_data->scale_values.x = m[\"x_scale\"].AsFloat();\n  op_data->scale_values.h = m[\"h_scale\"].AsFloat();\n  op_data->scale_values.w = m[\"w_scale\"].AsFloat();\n  context->AddTensors(context, 1, &op_data->decoded_boxes_index);\n  context->AddTensors(context, 1, &op_data->scores_index);\n  context->AddTensors(context, 1, &op_data->active_candidate_index);\n  return op_data;\n}\n\nvoid Free(TfLiteContext* context, void* buffer) {\n  delete static_cast<OpData*>(buffer);\n}\n\nTfLiteStatus SetTensorSizes(TfLiteContext* context, TfLiteTensor* tensor,\n                            std::initializer_list<int> values) {\n  TfLiteIntArray* size = TfLiteIntArrayCreate(values.size());\n  int index = 0;\n  for (const auto& v : values) {\n    size->data[index] = v;\n    ++index;\n  }\n  return context->ResizeTensor(context, tensor, size);\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* op_data = static_cast<OpData*>(node->user_data);\n  // Inputs: box_encodings, scores, anchors\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  const TfLiteTensor* input_box_encodings;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorBoxEncodings,\n                                 &input_box_encodings));\n  const TfLiteTensor* input_class_predictions;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorClassPredictions,\n                                 &input_class_predictions));\n  const TfLiteTensor* input_anchors;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensorAnchors,\n                                          &input_anchors));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_box_encodings), 3);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_class_predictions), 3);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_anchors), 2);\n  // number of detected boxes\n  const int num_detected_boxes =\n      op_data->max_detections * op_data->max_classes_per_detection;\n\n  // Outputs: detection_boxes, detection_scores, detection_classes,\n  // num_detections\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 4);\n  // Output Tensor detection_boxes: size is set to (1, num_detected_boxes, 4)\n  TfLiteTensor* detection_boxes;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionBoxes,\n                                  &detection_boxes));\n  detection_boxes->type = kTfLiteFloat32;\n  SetTensorSizes(context, detection_boxes,\n                 {kBatchSize, num_detected_boxes, kNumCoordBox});\n\n  // Output Tensor detection_classes: size is set to (1, num_detected_boxes)\n  TfLiteTensor* detection_classes;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionClasses,\n                                  &detection_classes));\n  detection_classes->type = kTfLiteFloat32;\n  SetTensorSizes(context, detection_classes, {kBatchSize, num_detected_boxes});\n\n  // Output Tensor detection_scores: size is set to (1, num_detected_boxes)\n  TfLiteTensor* detection_scores;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionScores,\n                                  &detection_scores));\n  detection_scores->type = kTfLiteFloat32;\n  SetTensorSizes(context, detection_scores, {kBatchSize, num_detected_boxes});\n\n  // Output Tensor num_detections: size is set to 1\n  TfLiteTensor* num_detections;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorNumDetections,\n                                  &num_detections));\n  num_detections->type = kTfLiteFloat32;\n  // TODO (chowdhery): Make it a scalar when available\n  SetTensorSizes(context, num_detections, {1});\n\n  // Temporary tensors\n  TfLiteIntArrayFree(node->temporaries);\n  node->temporaries = TfLiteIntArrayCreate(3);\n  node->temporaries->data[0] = op_data->decoded_boxes_index;\n  node->temporaries->data[1] = op_data->scores_index;\n  node->temporaries->data[2] = op_data->active_candidate_index;\n\n  // decoded_boxes\n  TfLiteTensor* decoded_boxes = &context->tensors[op_data->decoded_boxes_index];\n  decoded_boxes->type = kTfLiteFloat32;\n  decoded_boxes->allocation_type = kTfLiteArenaRw;\n  SetTensorSizes(context, decoded_boxes,\n                 {input_box_encodings->dims->data[1], kNumCoordBox});\n\n  // scores\n  TfLiteTensor* scores = &context->tensors[op_data->scores_index];\n  scores->type = kTfLiteFloat32;\n  scores->allocation_type = kTfLiteArenaRw;\n  SetTensorSizes(context, scores,\n                 {input_class_predictions->dims->data[1],\n                  input_class_predictions->dims->data[2]});\n\n  // active_candidate\n  TfLiteTensor* active_candidate =\n      &context->tensors[op_data->active_candidate_index];\n  active_candidate->type = kTfLiteUInt8;\n  active_candidate->allocation_type = kTfLiteArenaRw;\n  SetTensorSizes(context, active_candidate,\n                 {input_box_encodings->dims->data[1]});\n\n  return kTfLiteOk;\n}\n\nclass Dequantizer {\n public:\n  Dequantizer(int zero_point, float scale)\n      : zero_point_(zero_point), scale_(scale) {}\n  float operator()(uint8 x) {\n    return (static_cast<float>(x) - zero_point_) * scale_;\n  }\n\n private:\n  int zero_point_;\n  float scale_;\n};\n\nvoid DequantizeBoxEncodings(const TfLiteTensor* input_box_encodings, int idx,\n                            float quant_zero_point, float quant_scale,\n                            int length_box_encoding,\n                            CenterSizeEncoding* box_centersize) {\n  const uint8* boxes =\n      GetTensorData<uint8>(input_box_encodings) + length_box_encoding * idx;\n  Dequantizer dequantize(quant_zero_point, quant_scale);\n  // See definition of the KeyPointBoxCoder at\n  // https://github.com/tensorflow/models/blob/master/research/object_detection/box_coders/keypoint_box_coder.py\n  // The first four elements are the box coordinates, which is the same as the\n  // FastRnnBoxCoder at\n  // https://github.com/tensorflow/models/blob/master/research/object_detection/box_coders/faster_rcnn_box_coder.py\n  box_centersize->y = dequantize(boxes[0]);\n  box_centersize->x = dequantize(boxes[1]);\n  box_centersize->h = dequantize(boxes[2]);\n  box_centersize->w = dequantize(boxes[3]);\n}\n\ntemplate <class T>\nT ReInterpretTensor(const TfLiteTensor* tensor) {\n  // TODO (chowdhery): check float\n  const float* tensor_base = GetTensorData<float>(tensor);\n  return reinterpret_cast<T>(tensor_base);\n}\n\ntemplate <class T>\nT ReInterpretTensor(TfLiteTensor* tensor) {\n  // TODO (chowdhery): check float\n  float* tensor_base = GetTensorData<float>(tensor);\n  return reinterpret_cast<T>(tensor_base);\n}\n\nTfLiteStatus DecodeCenterSizeBoxes(TfLiteContext* context, TfLiteNode* node,\n                                   OpData* op_data) {\n  // Parse input tensor boxencodings\n  const TfLiteTensor* input_box_encodings;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorBoxEncodings,\n                                 &input_box_encodings));\n  TF_LITE_ENSURE_EQ(context, input_box_encodings->dims->data[0], kBatchSize);\n  const int num_boxes = input_box_encodings->dims->data[1];\n  TF_LITE_ENSURE(context, input_box_encodings->dims->data[2] >= kNumCoordBox);\n  const TfLiteTensor* input_anchors;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensorAnchors,\n                                          &input_anchors));\n\n  // Decode the boxes to get (ymin, xmin, ymax, xmax) based on the anchors\n  CenterSizeEncoding box_centersize;\n  CenterSizeEncoding scale_values = op_data->scale_values;\n  CenterSizeEncoding anchor;\n  for (int idx = 0; idx < num_boxes; ++idx) {\n    switch (input_box_encodings->type) {\n        // Quantized\n      case kTfLiteUInt8:\n        DequantizeBoxEncodings(\n            input_box_encodings, idx,\n            static_cast<float>(input_box_encodings->params.zero_point),\n            static_cast<float>(input_box_encodings->params.scale),\n            input_box_encodings->dims->data[2], &box_centersize);\n        DequantizeBoxEncodings(\n            input_anchors, idx,\n            static_cast<float>(input_anchors->params.zero_point),\n            static_cast<float>(input_anchors->params.scale), kNumCoordBox,\n            &anchor);\n        break;\n        // Float\n      case kTfLiteFloat32: {\n        // Please see DequantizeBoxEncodings function for the support detail.\n        const int box_encoding_idx = idx * input_box_encodings->dims->data[2];\n        const float* boxes =\n            &(GetTensorData<float>(input_box_encodings)[box_encoding_idx]);\n        box_centersize = *reinterpret_cast<const CenterSizeEncoding*>(boxes);\n        anchor =\n            ReInterpretTensor<const CenterSizeEncoding*>(input_anchors)[idx];\n        break;\n      }\n      default:\n        // Unsupported type.\n        return kTfLiteError;\n    }\n\n    float ycenter = box_centersize.y / scale_values.y * anchor.h + anchor.y;\n    float xcenter = box_centersize.x / scale_values.x * anchor.w + anchor.x;\n    float half_h =\n        0.5f * static_cast<float>(std::exp(box_centersize.h / scale_values.h)) *\n        anchor.h;\n    float half_w =\n        0.5f * static_cast<float>(std::exp(box_centersize.w / scale_values.w)) *\n        anchor.w;\n    TfLiteTensor* decoded_boxes =\n        &context->tensors[op_data->decoded_boxes_index];\n    auto& box = ReInterpretTensor<BoxCornerEncoding*>(decoded_boxes)[idx];\n    box.ymin = ycenter - half_h;\n    box.xmin = xcenter - half_w;\n    box.ymax = ycenter + half_h;\n    box.xmax = xcenter + half_w;\n  }\n  return kTfLiteOk;\n}\n\nvoid DecreasingPartialArgSort(const float* values, int num_values,\n                              int num_to_sort, int* indices) {\n  std::iota(indices, indices + num_values, 0);\n  std::partial_sort(\n      indices, indices + num_to_sort, indices + num_values,\n      [&values](const int i, const int j) { return values[i] > values[j]; });\n}\n\nvoid SelectDetectionsAboveScoreThreshold(const std::vector<float>& values,\n                                         const float threshold,\n                                         std::vector<float>* keep_values,\n                                         std::vector<int>* keep_indices) {\n  for (int i = 0; i < values.size(); i++) {\n    if (values[i] >= threshold) {\n      keep_values->emplace_back(values[i]);\n      keep_indices->emplace_back(i);\n    }\n  }\n}\n\nbool ValidateBoxes(const TfLiteTensor* decoded_boxes, const int num_boxes) {\n  for (int i = 0; i < num_boxes; ++i) {\n    // ymax>=ymin, xmax>=xmin\n    auto& box = ReInterpretTensor<const BoxCornerEncoding*>(decoded_boxes)[i];\n    if (box.ymin >= box.ymax || box.xmin >= box.xmax) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfloat ComputeIntersectionOverUnion(const TfLiteTensor* decoded_boxes,\n                                   const int i, const int j) {\n  auto& box_i = ReInterpretTensor<const BoxCornerEncoding*>(decoded_boxes)[i];\n  auto& box_j = ReInterpretTensor<const BoxCornerEncoding*>(decoded_boxes)[j];\n  const float area_i = (box_i.ymax - box_i.ymin) * (box_i.xmax - box_i.xmin);\n  const float area_j = (box_j.ymax - box_j.ymin) * (box_j.xmax - box_j.xmin);\n  if (area_i <= 0 || area_j <= 0) return 0.0;\n  const float intersection_ymin = std::max<float>(box_i.ymin, box_j.ymin);\n  const float intersection_xmin = std::max<float>(box_i.xmin, box_j.xmin);\n  const float intersection_ymax = std::min<float>(box_i.ymax, box_j.ymax);\n  const float intersection_xmax = std::min<float>(box_i.xmax, box_j.xmax);\n  const float intersection_area =\n      std::max<float>(intersection_ymax - intersection_ymin, 0.0) *\n      std::max<float>(intersection_xmax - intersection_xmin, 0.0);\n  return intersection_area / (area_i + area_j - intersection_area);\n}\n\n// NonMaxSuppressionSingleClass() prunes out the box locations with high overlap\n// before selecting the highest scoring boxes (max_detections in number)\n// It assumes all boxes are good in beginning and sorts based on the scores.\n// If lower-scoring box has too much overlap with a higher-scoring box,\n// we get rid of the lower-scoring box.\n// Complexity is O(N^2) pairwise comparison between boxes\nTfLiteStatus NonMaxSuppressionSingleClassHelper(\n    TfLiteContext* context, TfLiteNode* node, OpData* op_data,\n    const std::vector<float>& scores, std::vector<int>* selected,\n    int max_detections) {\n  const TfLiteTensor* input_box_encodings;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorBoxEncodings,\n                                 &input_box_encodings));\n  const TfLiteTensor* decoded_boxes =\n      &context->tensors[op_data->decoded_boxes_index];\n  const int num_boxes = input_box_encodings->dims->data[1];\n  const float non_max_suppression_score_threshold =\n      op_data->non_max_suppression_score_threshold;\n  const float intersection_over_union_threshold =\n      op_data->intersection_over_union_threshold;\n  // Maximum detections should be positive.\n  TF_LITE_ENSURE(context, (max_detections >= 0));\n  // intersection_over_union_threshold should be positive\n  // and should be less than 1.\n  TF_LITE_ENSURE(context, (intersection_over_union_threshold > 0.0f) &&\n                              (intersection_over_union_threshold <= 1.0f));\n  // Validate boxes\n  TF_LITE_ENSURE(context, ValidateBoxes(decoded_boxes, num_boxes));\n\n  // threshold scores\n  std::vector<int> keep_indices;\n  // TODO (chowdhery): Remove the dynamic allocation and replace it\n  // with temporaries, esp for std::vector<float>\n  std::vector<float> keep_scores;\n  SelectDetectionsAboveScoreThreshold(\n      scores, non_max_suppression_score_threshold, &keep_scores, &keep_indices);\n\n  int num_scores_kept = keep_scores.size();\n  std::vector<int> sorted_indices;\n  sorted_indices.resize(num_scores_kept);\n  DecreasingPartialArgSort(keep_scores.data(), num_scores_kept, num_scores_kept,\n                           sorted_indices.data());\n  const int num_boxes_kept = num_scores_kept;\n  const int output_size = std::min(num_boxes_kept, max_detections);\n  selected->clear();\n  TfLiteTensor* active_candidate =\n      &context->tensors[op_data->active_candidate_index];\n  TF_LITE_ENSURE(context, (active_candidate->dims->data[0]) == num_boxes);\n  int num_active_candidate = num_boxes_kept;\n  uint8_t* active_box_candidate = (active_candidate->data.uint8);\n  for (int row = 0; row < num_boxes_kept; row++) {\n    active_box_candidate[row] = 1;\n  }\n\n  for (int i = 0; i < num_boxes_kept; ++i) {\n    if (num_active_candidate == 0 || selected->size() >= output_size) break;\n    if (active_box_candidate[i] == 1) {\n      selected->push_back(keep_indices[sorted_indices[i]]);\n      active_box_candidate[i] = 0;\n      num_active_candidate--;\n    } else {\n      continue;\n    }\n    for (int j = i + 1; j < num_boxes_kept; ++j) {\n      if (active_box_candidate[j] == 1) {\n        float intersection_over_union = ComputeIntersectionOverUnion(\n            decoded_boxes, keep_indices[sorted_indices[i]],\n            keep_indices[sorted_indices[j]]);\n\n        if (intersection_over_union > intersection_over_union_threshold) {\n          active_box_candidate[j] = 0;\n          num_active_candidate--;\n        }\n      }\n    }\n  }\n  return kTfLiteOk;\n}\n\n// This function implements a regular version of Non Maximal Suppression (NMS)\n// for multiple classes where\n// 1) we do NMS separately for each class across all anchors and\n// 2) keep only the highest anchor scores across all classes\n// 3) The worst runtime of the regular NMS is O(K*N^2)\n// where N is the number of anchors and K the number of\n// classes.\nTfLiteStatus NonMaxSuppressionMultiClassRegularHelper(TfLiteContext* context,\n                                                      TfLiteNode* node,\n                                                      OpData* op_data,\n                                                      const float* scores) {\n  const TfLiteTensor* input_box_encodings;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorBoxEncodings,\n                                 &input_box_encodings));\n  const TfLiteTensor* input_class_predictions;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorClassPredictions,\n                                 &input_class_predictions));\n  const TfLiteTensor* decoded_boxes =\n      &context->tensors[op_data->decoded_boxes_index];\n\n  TfLiteTensor* detection_boxes;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionBoxes,\n                                  &detection_boxes));\n  TfLiteTensor* detection_classes;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionClasses,\n                                  &detection_classes));\n  TfLiteTensor* detection_scores;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionScores,\n                                  &detection_scores));\n  TfLiteTensor* num_detections;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorNumDetections,\n                                  &num_detections));\n\n  const int num_boxes = input_box_encodings->dims->data[1];\n  const int num_classes = op_data->num_classes;\n  const int num_detections_per_class = op_data->detections_per_class;\n  const int max_detections = op_data->max_detections;\n  const int num_classes_with_background =\n      input_class_predictions->dims->data[2];\n  // The row index offset is 1 if background class is included and 0 otherwise.\n  int label_offset = num_classes_with_background - num_classes;\n  TF_LITE_ENSURE(context, num_detections_per_class > 0);\n\n  // For each class, perform non-max suppression.\n  std::vector<float> class_scores(num_boxes);\n\n  std::vector<int> box_indices_after_regular_non_max_suppression(\n      num_boxes + max_detections);\n  std::vector<float> scores_after_regular_non_max_suppression(num_boxes +\n                                                              max_detections);\n\n  int size_of_sorted_indices = 0;\n  std::vector<int> sorted_indices;\n  sorted_indices.resize(num_boxes + max_detections);\n  std::vector<float> sorted_values;\n  sorted_values.resize(max_detections);\n\n  for (int col = 0; col < num_classes; col++) {\n    for (int row = 0; row < num_boxes; row++) {\n      // Get scores of boxes corresponding to all anchors for single class\n      class_scores[row] =\n          *(scores + row * num_classes_with_background + col + label_offset);\n    }\n    // Perform non-maximal suppression on single class\n    std::vector<int> selected;\n    TF_LITE_ENSURE_STATUS(NonMaxSuppressionSingleClassHelper(\n        context, node, op_data, class_scores, &selected,\n        num_detections_per_class));\n    // Add selected indices from non-max suppression of boxes in this class\n    int output_index = size_of_sorted_indices;\n    for (const auto& selected_index : selected) {\n      box_indices_after_regular_non_max_suppression[output_index] =\n          (selected_index * num_classes_with_background + col + label_offset);\n      scores_after_regular_non_max_suppression[output_index] =\n          class_scores[selected_index];\n      output_index++;\n    }\n    // Sort the max scores among the selected indices\n    // Get the indices for top scores\n    int num_indices_to_sort = std::min(output_index, max_detections);\n    DecreasingPartialArgSort(scores_after_regular_non_max_suppression.data(),\n                             output_index, num_indices_to_sort,\n                             sorted_indices.data());\n\n    // Copy values to temporary vectors\n    for (int row = 0; row < num_indices_to_sort; row++) {\n      int temp = sorted_indices[row];\n      sorted_indices[row] = box_indices_after_regular_non_max_suppression[temp];\n      sorted_values[row] = scores_after_regular_non_max_suppression[temp];\n    }\n    // Copy scores and indices from temporary vectors\n    for (int row = 0; row < num_indices_to_sort; row++) {\n      box_indices_after_regular_non_max_suppression[row] = sorted_indices[row];\n      scores_after_regular_non_max_suppression[row] = sorted_values[row];\n    }\n    size_of_sorted_indices = num_indices_to_sort;\n  }\n\n  // Allocate output tensors\n  for (int output_box_index = 0; output_box_index < max_detections;\n       output_box_index++) {\n    if (output_box_index < size_of_sorted_indices) {\n      const int anchor_index = floor(\n          box_indices_after_regular_non_max_suppression[output_box_index] /\n          num_classes_with_background);\n      const int class_index =\n          box_indices_after_regular_non_max_suppression[output_box_index] -\n          anchor_index * num_classes_with_background - label_offset;\n      const float selected_score =\n          scores_after_regular_non_max_suppression[output_box_index];\n      // detection_boxes\n      ReInterpretTensor<BoxCornerEncoding*>(detection_boxes)[output_box_index] =\n          ReInterpretTensor<const BoxCornerEncoding*>(\n              decoded_boxes)[anchor_index];\n      // detection_classes\n      GetTensorData<float>(detection_classes)[output_box_index] = class_index;\n      // detection_scores\n      GetTensorData<float>(detection_scores)[output_box_index] = selected_score;\n    } else {\n      ReInterpretTensor<BoxCornerEncoding*>(\n          detection_boxes)[output_box_index] = {0.0f, 0.0f, 0.0f, 0.0f};\n      // detection_classes\n      GetTensorData<float>(detection_classes)[output_box_index] = 0.0f;\n      // detection_scores\n      GetTensorData<float>(detection_scores)[output_box_index] = 0.0f;\n    }\n  }\n  GetTensorData<float>(num_detections)[0] = size_of_sorted_indices;\n  box_indices_after_regular_non_max_suppression.clear();\n  scores_after_regular_non_max_suppression.clear();\n  return kTfLiteOk;\n}\n\n// This function implements a fast version of Non Maximal Suppression for\n// multiple classes where\n// 1) we keep the top-k scores for each anchor and\n// 2) during NMS, each anchor only uses the highest class score for sorting.\n// 3) Compared to standard NMS, the worst runtime of this version is O(N^2)\n// instead of O(KN^2) where N is the number of anchors and K the number of\n// classes.\nTfLiteStatus NonMaxSuppressionMultiClassFastHelper(TfLiteContext* context,\n                                                   TfLiteNode* node,\n                                                   OpData* op_data,\n                                                   const float* scores) {\n  const TfLiteTensor* input_box_encodings;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorBoxEncodings,\n                                 &input_box_encodings));\n  const TfLiteTensor* input_class_predictions;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorClassPredictions,\n                                 &input_class_predictions));\n  const TfLiteTensor* decoded_boxes =\n      &context->tensors[op_data->decoded_boxes_index];\n\n  TfLiteTensor* detection_boxes;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionBoxes,\n                                  &detection_boxes));\n  TfLiteTensor* detection_classes;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionClasses,\n                                  &detection_classes));\n  TfLiteTensor* detection_scores;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorDetectionScores,\n                                  &detection_scores));\n  TfLiteTensor* num_detections;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensorNumDetections,\n                                  &num_detections));\n\n  const int num_boxes = input_box_encodings->dims->data[1];\n  const int num_classes = op_data->num_classes;\n  const int max_categories_per_anchor = op_data->max_classes_per_detection;\n  const int num_classes_with_background =\n      input_class_predictions->dims->data[2];\n  // The row index offset is 1 if background class is included and 0 otherwise.\n  int label_offset = num_classes_with_background - num_classes;\n  TF_LITE_ENSURE(context, (max_categories_per_anchor > 0));\n  const int num_categories_per_anchor =\n      std::min(max_categories_per_anchor, num_classes);\n  std::vector<float> max_scores;\n  max_scores.resize(num_boxes);\n  std::vector<int> sorted_class_indices;\n  sorted_class_indices.resize(num_boxes * num_classes);\n  for (int row = 0; row < num_boxes; row++) {\n    const float* box_scores =\n        scores + row * num_classes_with_background + label_offset;\n    int* class_indices = sorted_class_indices.data() + row * num_classes;\n    DecreasingPartialArgSort(box_scores, num_classes, num_categories_per_anchor,\n                             class_indices);\n    max_scores[row] = box_scores[class_indices[0]];\n  }\n  // Perform non-maximal suppression on max scores\n  std::vector<int> selected;\n  TF_LITE_ENSURE_STATUS(NonMaxSuppressionSingleClassHelper(\n      context, node, op_data, max_scores, &selected, op_data->max_detections));\n  // Allocate output tensors\n  int output_box_index = 0;\n  for (const auto& selected_index : selected) {\n    const float* box_scores =\n        scores + selected_index * num_classes_with_background + label_offset;\n    const int* class_indices =\n        sorted_class_indices.data() + selected_index * num_classes;\n\n    for (int col = 0; col < num_categories_per_anchor; ++col) {\n      int box_offset = num_categories_per_anchor * output_box_index + col;\n      // detection_boxes\n      ReInterpretTensor<BoxCornerEncoding*>(detection_boxes)[box_offset] =\n          ReInterpretTensor<const BoxCornerEncoding*>(\n              decoded_boxes)[selected_index];\n      // detection_classes\n      GetTensorData<float>(detection_classes)[box_offset] = class_indices[col];\n      // detection_scores\n      GetTensorData<float>(detection_scores)[box_offset] =\n          box_scores[class_indices[col]];\n      output_box_index++;\n    }\n  }\n  GetTensorData<float>(num_detections)[0] = output_box_index;\n  return kTfLiteOk;\n}\n\nvoid DequantizeClassPredictions(const TfLiteTensor* input_class_predictions,\n                                const int num_boxes,\n                                const int num_classes_with_background,\n                                TfLiteTensor* scores) {\n  float quant_zero_point =\n      static_cast<float>(input_class_predictions->params.zero_point);\n  float quant_scale = static_cast<float>(input_class_predictions->params.scale);\n  Dequantizer dequantize(quant_zero_point, quant_scale);\n  const uint8* scores_quant = GetTensorData<uint8>(input_class_predictions);\n  for (int idx = 0; idx < num_boxes * num_classes_with_background; ++idx) {\n    GetTensorData<float>(scores)[idx] = dequantize(scores_quant[idx]);\n  }\n}\n\nTfLiteStatus NonMaxSuppressionMultiClass(TfLiteContext* context,\n                                         TfLiteNode* node, OpData* op_data) {\n  // Get the input tensors\n  const TfLiteTensor* input_box_encodings;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorBoxEncodings,\n                                 &input_box_encodings));\n  const TfLiteTensor* input_class_predictions;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensorClassPredictions,\n                                 &input_class_predictions));\n  const int num_boxes = input_box_encodings->dims->data[1];\n  const int num_classes = op_data->num_classes;\n  TF_LITE_ENSURE_EQ(context, input_class_predictions->dims->data[0],\n                    kBatchSize);\n  TF_LITE_ENSURE_EQ(context, input_class_predictions->dims->data[1], num_boxes);\n  const int num_classes_with_background =\n      input_class_predictions->dims->data[2];\n\n  TF_LITE_ENSURE(context, (num_classes_with_background - num_classes <= 1));\n  TF_LITE_ENSURE(context, (num_classes_with_background >= num_classes));\n\n  const TfLiteTensor* scores;\n  switch (input_class_predictions->type) {\n    case kTfLiteUInt8: {\n      TfLiteTensor* temporary_scores = &context->tensors[op_data->scores_index];\n      DequantizeClassPredictions(input_class_predictions, num_boxes,\n                                 num_classes_with_background, temporary_scores);\n      scores = temporary_scores;\n    } break;\n    case kTfLiteFloat32:\n      scores = input_class_predictions;\n      break;\n    default:\n      // Unsupported type.\n      return kTfLiteError;\n  }\n  if (op_data->use_regular_non_max_suppression)\n    TF_LITE_ENSURE_STATUS(NonMaxSuppressionMultiClassRegularHelper(\n        context, node, op_data, GetTensorData<float>(scores)));\n  else\n    TF_LITE_ENSURE_STATUS(NonMaxSuppressionMultiClassFastHelper(\n        context, node, op_data, GetTensorData<float>(scores)));\n\n  return kTfLiteOk;\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  // TODO(chowdhery): Generalize for any batch size\n  TF_LITE_ENSURE(context, (kBatchSize == 1));\n  auto* op_data = static_cast<OpData*>(node->user_data);\n  // These two functions correspond to two blocks in the Object Detection model.\n  // In future, we would like to break the custom op in two blocks, which is\n  // currently not feasible because we would like to input quantized inputs\n  // and do all calculations in float. Mixed quantized/float calculations are\n  // currently not supported in TFLite.\n\n  // This fills in temporary decoded_boxes\n  // by transforming input_box_encodings and input_anchors from\n  // CenterSizeEncodings to BoxCornerEncoding\n  TF_LITE_ENSURE_STATUS(DecodeCenterSizeBoxes(context, node, op_data));\n  // This fills in the output tensors\n  // by choosing effective set of decoded boxes\n  // based on Non Maximal Suppression, i.e. selecting\n  // highest scoring non-overlapping boxes.\n  TF_LITE_ENSURE_STATUS(NonMaxSuppressionMultiClass(context, node, op_data));\n\n  return kTfLiteOk;\n}\n}  // namespace detection_postprocess\n\nTfLiteRegistration* Register_DETECTION_POSTPROCESS() {\n  static TfLiteRegistration r = {\n      detection_postprocess::Init, detection_postprocess::Free,\n      detection_postprocess::Prepare, detection_postprocess::Eval};\n  return &r;\n}\n\n}  // namespace custom\n}  // namespace ops\n}  // namespace tflite"