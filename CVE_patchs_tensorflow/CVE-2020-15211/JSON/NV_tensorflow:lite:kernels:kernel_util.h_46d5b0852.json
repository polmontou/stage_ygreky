"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#ifndef TENSORFLOW_LITE_KERNELS_KERNEL_UTIL_H_\n#define TENSORFLOW_LITE_KERNELS_KERNEL_UTIL_H_\n\n#include <stdint.h>\n\n#include <limits>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n\nnamespace tflite {\n\n// A fair number of functions in this header have historically been inline.\n// It is ok to change functions to not be inline if the latency with\n// benchmark_model for MobileNet + MobileBERT is unaffected. If such a change is\n// made, move the newly non-inlined function declarations to the top of this\n// header file.\n\n// Note: You must check if result is not null:\n//\n//   TfLiteTensor* my_tensor = GetInput(context, node, kMyTensorIdx);\n//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n//\n// This is because the index might point to the optional tensor constant\n// (kTfLiteOptionalTensor) in which case there is no tensor to return.\nconst TfLiteTensor* GetInput(const TfLiteContext* context,\n                             const TfLiteNode* node, int index);\n\n// Note: You must check if result is not null:\n//\n//   TfLiteTensor* my_tensor = GetVariableInput(context, node, kMyTensorIdx);\n//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n//\n// This is because the index might point to the optional tensor constant\n// (kTfLiteOptionalTensor) in which case there is no tensor to return.\nTfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                               int index);\n\n// Note: You must check if result is not null:\n//\n//   TfLiteTensor* my_tensor = GetOutput(context, node, kMyTensorIdx);\n//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n//\n// This is because the index might point to the optional tensor constant\n// (kTfLiteOptionalTensor) in which case there is no tensor to return.\nTfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index);\n\n// Note: You must check if result is not null:\n//\n//   TfLiteTensor* my_tensor = GetOptionalInputTensor(context, node, kIdx);\n//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n//\n// This is because the index might point to the optional tensor constant\n// (kTfLiteOptionalTensor) in which case there is no tensor to return.\n//\n// Deprecated. GetInput has the same functionality.\nconst TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index);\n\ninline int NumDimensions(const TfLiteTensor* t) { return t->dims->size; }\ninline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n  return t->dims->data[dim];\n}\n\n#ifndef TF_LITE_STATIC_MEMORY\n// Note: You must check if result is not null:\n//\n//   TfLiteTensor* my_tensor = GetTemporary(context, node, kMyTensorIdx);\n//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n//\n// This is because the index might point to the optional tensor constant\n// (kTfLiteOptionalTensor) in which case there is no tensor to return.\ninline TfLiteTensor* GetTemporary(TfLiteContext* context,\n                                  const TfLiteNode* node, int index) {\n  if (index >= 0 && index < node->temporaries->size) {\n    const int tensor_index = node->temporaries->data[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      if (context->tensors != nullptr) {\n        return &context->tensors[tensor_index];\n      }\n    }\n  }\n  return nullptr;\n}\n\n// Note: You must check if result is not null:\n//\n//   TfLiteTensor* my_tensor = GetIntermediates(context, node, kMyTensorIdx);\n//   TF_LITE_ENSURE(context, my_tensor != nullptr);\n//\n// This is because the index might point to the optional tensor constant\n// (kTfLiteOptionalTensor) in which case there is no tensor to return.\ninline const TfLiteTensor* GetIntermediates(TfLiteContext* context,\n                                            const TfLiteNode* node, int index) {\n  if (index >= 0 && index < node->intermediates->size) {\n    const int tensor_index = node->intermediates->data[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      if (context->tensors != nullptr) {\n        return &context->tensors[tensor_index];\n      }\n    }\n  }\n  return nullptr;\n}\n\ninline int NumIntermediates(const TfLiteNode* node) {\n  return node->intermediates->size;\n}\n#endif  // TF_LITE_STATIC_MEMORY\ninline int NumInputs(const TfLiteNode* node) { return node->inputs->size; }\ninline int NumOutputs(const TfLiteNode* node) { return node->outputs->size; }\n\ninline int64_t NumElements(const TfLiteIntArray* dims) {\n  int64_t count = 1;\n  for (int i = 0; i < dims->size; ++i) {\n    count *= dims->data[i];\n  }\n  return count;\n}\n\ninline int64_t NumElements(const TfLiteTensor* t) {\n  return NumElements(t->dims);\n}\n\n// Determines whether tensor is constant.\n// TODO(b/138199592): Introduce new query which checks for constant OR\n// persistent-read-only, which would be useful for most tensor kernels that\n// are potentially dynamic based on the input tensor value availability at the\n// time of prepare.\ninline bool IsConstantTensor(const TfLiteTensor* tensor) {\n  return tensor->allocation_type == kTfLiteMmapRo;\n}\n\n// Determines whether tensor is dynamic. Note that a tensor can be non-const and\n// not dynamic. This function specifically checks for a dynamic tensor.\ninline bool IsDynamicTensor(const TfLiteTensor* tensor) {\n  return tensor->allocation_type == kTfLiteDynamic;\n}\n\n// Sets tensor to dynamic.\ninline void SetTensorToDynamic(TfLiteTensor* tensor) {\n  if (tensor->allocation_type != kTfLiteDynamic) {\n    tensor->allocation_type = kTfLiteDynamic;\n    tensor->data.raw = nullptr;\n  }\n}\n\n// Sets tensor to persistent and read-only.\ninline void SetTensorToPersistentRo(TfLiteTensor* tensor) {\n  if (tensor->allocation_type != kTfLitePersistentRo) {\n    tensor->allocation_type = kTfLitePersistentRo;\n    tensor->data.raw = nullptr;\n  }\n}\n\n// Determines whether it is a hybrid op - one that has float inputs and\n// quantized weights.\ninline bool IsHybridOp(const TfLiteTensor* input, const TfLiteTensor* weight) {\n  return ((weight->type == kTfLiteUInt8 || weight->type == kTfLiteInt8) &&\n          input->type == kTfLiteFloat32);\n}\n\n// Check dimensionality match and populate OpData for Conv and DepthwiseConv.\nTfLiteStatus PopulateConvolutionQuantizationParams(\n    TfLiteContext* context, const TfLiteTensor* input,\n    const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* output,\n    const TfLiteFusedActivation& activation, int32_t* multiplier, int* shift,\n    int32_t* output_activation_min, int32_t* output_activation_max,\n    int32_t* per_channel_multiplier, int* per_channel_shift);\n\nTfLiteStatus PopulateConvolutionQuantizationParams(\n    TfLiteContext* context, const TfLiteTensor* input,\n    const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* output,\n    const TfLiteFusedActivation& activation, int32_t* multiplier, int* shift,\n    int32_t* output_activation_min, int32_t* output_activation_max,\n    int32_t* per_channel_multiplier, int* per_channel_shift, int num_channels);\n\n// Calculates the multiplication factor for a quantized convolution (or\n// quantized depthwise convolution) involving the given tensors. Returns an\n// error if the scales of the tensors are not compatible.\nTfLiteStatus GetQuantizedConvolutionMultipler(TfLiteContext* context,\n                                              const TfLiteTensor* input,\n                                              const TfLiteTensor* filter,\n                                              const TfLiteTensor* bias,\n                                              TfLiteTensor* output,\n                                              double* multiplier);\n\nTfLiteStatus GetQuantizedConvolutionMultipler(TfLiteContext* context,\n                                              const TfLiteTensor* input,\n                                              const TfLiteTensor* filter,\n                                              TfLiteTensor* output,\n                                              double* multiplier);\n\n// Calculates the useful quantized range of an activation layer given its\n// activation tensor.\nTfLiteStatus CalculateActivationRangeQuantized(TfLiteContext* context,\n                                               TfLiteFusedActivation activation,\n                                               TfLiteTensor* output,\n                                               int32_t* act_min,\n                                               int32_t* act_max);\n\n// Calculates the useful range of an activation layer given its activation\n// tensor.a\ntemplate <typename T>\nvoid CalculateActivationRange(TfLiteFusedActivation activation,\n                              T* activation_min, T* activation_max) {\n  if (activation == kTfLiteActRelu) {\n    *activation_min = 0;\n    *activation_max = std::numeric_limits<T>::max();\n  } else if (activation == kTfLiteActRelu6) {\n    *activation_min = 0;\n    *activation_max = 6;\n  } else if (activation == kTfLiteActReluN1To1) {\n    *activation_min = -1;\n    *activation_max = 1;\n  } else {\n    *activation_min = std::numeric_limits<T>::lowest();\n    *activation_max = std::numeric_limits<T>::max();\n  }\n}\n\n// Return true if the given tensors have the same shape.\nbool HaveSameShapes(const TfLiteTensor* input1, const TfLiteTensor* input2);\n\n// Calculates the output_shape that is necessary for element-wise operations\n// with broadcasting involving the two input tensors.\nTfLiteStatus CalculateShapeForBroadcast(TfLiteContext* context,\n                                        const TfLiteTensor* input1,\n                                        const TfLiteTensor* input2,\n                                        TfLiteIntArray** output_shape);\n\n// Calculates the output_shape that is necessary for element-wise operations\n// with broadcasting involving the three input tensors.\nTfLiteStatus CalculateShapeForBroadcast(TfLiteContext* context,\n                                        const TfLiteTensor* input1,\n                                        const TfLiteTensor* input2,\n                                        const TfLiteTensor* input3,\n                                        TfLiteIntArray** output_shape);\n}  // namespace tflite\n\n#endif  // TENSORFLOW_LITE_KERNELS_KERNEL_UTIL_H_"