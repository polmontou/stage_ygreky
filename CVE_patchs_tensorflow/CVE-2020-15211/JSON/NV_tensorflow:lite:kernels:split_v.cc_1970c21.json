"/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include <stdint.h>\n\n#include <vector>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/kernels/internal/reference/reference_ops.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/types.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace split_v {\n\nstruct OpContext {\n  OpContext(TfLiteContext* context, TfLiteNode* node) {\n    params = reinterpret_cast<TfLiteSplitVParams*>(node->builtin_data);\n    input = GetInput(context, node, 0);\n    size_splits = GetInput(context, node, 1);\n    axis = GetInput(context, node, 2);\n  }\n  TfLiteSplitVParams* params;\n  const TfLiteTensor* input;\n  const TfLiteTensor* size_splits;\n  const TfLiteTensor* axis;\n};\n\nTfLiteStatus UseDynamicOutputTensors(TfLiteContext* context, TfLiteNode* node) {\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteTensor* tensor;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &tensor));\n    SetTensorToDynamic(tensor);\n  }\n  return kTfLiteOk;\n}\n\ntemplate <typename T>\nvoid GetSizeSplitsVector(const TfLiteTensor* size_splits,\n                         std::vector<int64_t>* size_splits_vector) {\n  const auto num_elements = NumElements(size_splits);\n  for (int i = 0; i < num_elements; ++i) {\n    size_splits_vector->push_back(GetTensorData<T>(size_splits)[i]);\n  }\n}\n\nTfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* input,\n                                 const TfLiteTensor* size_splits,\n                                 const TfLiteTensor* axis) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  std::vector<int64_t> size_splits_vector;\n  if (size_splits->type == kTfLiteInt32) {\n    GetSizeSplitsVector<int32_t>(size_splits, &size_splits_vector);\n  } else if (size_splits->type == kTfLiteInt64) {\n    GetSizeSplitsVector<int64_t>(size_splits, &size_splits_vector);\n  } else {\n    context->ReportError(context, \"size_splits only support type int32|int64.\");\n    return kTfLiteError;\n  }\n\n  int minus_one_index = -1;\n  int64_t size_splits_sum = 0;\n\n  for (int i = 0; i < size_splits_vector.size(); ++i) {\n    if (size_splits_vector.at(i) == -1) {\n      if (minus_one_index == -1) {\n        minus_one_index = i;\n      } else {\n        context->ReportError(context,\n                             \"The size_splits contains more than one -1.\");\n      }\n    } else {\n      size_splits_sum += size_splits_vector.at(i);\n    }\n  }\n\n  const int input_size = SizeOfDimension(input, axis_value);\n\n  if (minus_one_index != -1) {\n    if (size_splits_sum > input_size) {\n      context->ReportError(\n          context,\n          \"The sum of size_splits must be less than the dimension of value.\");\n    } else {\n      size_splits_vector[minus_one_index] = input_size - size_splits_sum;\n    }\n  } else if (size_splits_sum != input_size) {\n    context->ReportError(\n        context,\n        \"The size_splits must sum to the dimension of value along axis.\");\n  }\n\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = size_splits_vector.at(i);\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n\n  return kTfLiteOk;\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n\n  OpContext op_context(context, node);\n\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), op_context.params->num_splits);\n\n  auto input_type = op_context.input->type;\n  TF_LITE_ENSURE(context,\n                 input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||\n                     input_type == kTfLiteInt16 || input_type == kTfLiteInt32 ||\n                     input_type == kTfLiteInt64 || input_type == kTfLiteInt8);\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteTensor* tensor;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &tensor));\n    tensor->type = input_type;\n  }\n\n  auto size_splits = op_context.size_splits;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(size_splits), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), NumElements(size_splits));\n\n  // If we know the contents of the 'size_splits' tensor and the 'axis' tensor,\n  // resize all outputs. Otherwise, wait until Eval().\n  if (IsConstantTensor(op_context.size_splits) &&\n      IsConstantTensor(op_context.axis)) {\n    return ResizeOutputTensors(context, node, op_context.input,\n                               op_context.size_splits, op_context.axis);\n  } else {\n    return UseDynamicOutputTensors(context, node);\n  }\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n  // When the 'size_splits' and the 'axis' tensor is non-const we can't resize\n  // output tensors in Prepare(), and we have to do it now.\n  if (!IsConstantTensor(op_context.axis) ||\n      !IsConstantTensor(op_context.size_splits)) {\n    TF_LITE_ENSURE_OK(\n        context, ResizeOutputTensors(context, node, op_context.input,\n                                     op_context.size_splits, op_context.axis));\n  }\n\n  int axis_value = GetTensorData<int>(op_context.axis)[0];\n\n  // Use split function to build the outputs since they share the same logic.\n#define TF_LITE_SPLIT_V(scalar)                                     \\\n  VectorOfTensors<scalar> all_outputs(*context, *node->outputs);    \\\n  tflite::SplitParams op_params;                                    \\\n  op_params.num_split = NumOutputs(node);                           \\\n  op_params.axis = axis_value;                                      \\\n  reference_ops::Split(op_params, GetTensorShape(op_context.input), \\\n                       GetTensorData<scalar>(op_context.input),     \\\n                       all_outputs.shapes(), all_outputs.data());\n  switch (op_context.input->type) {\n    case kTfLiteFloat32: {\n      TF_LITE_SPLIT_V(float);\n      break;\n    }\n    case kTfLiteUInt8: {\n      TF_LITE_SPLIT_V(uint8_t);\n      break;\n    }\n    case kTfLiteInt16: {\n      TF_LITE_SPLIT_V(int16_t);\n      break;\n    }\n    case kTfLiteInt32: {\n      TF_LITE_SPLIT_V(int32_t);\n      break;\n    }\n    case kTfLiteInt64: {\n      TF_LITE_SPLIT_V(int64_t);\n      break;\n    }\n    case kTfLiteInt8: {\n      TF_LITE_SPLIT_V(int8_t);\n      break;\n    }\n    default:\n      context->ReportError(context, \"Type %s currently not supported.\",\n                           TfLiteTypeGetName(op_context.input->type));\n      return kTfLiteError;\n  }\n#undef TF_LITE_SPLIT_V\n\n  return kTfLiteOk;\n}\n\n}  // namespace split_v\n\nTfLiteRegistration* Register_SPLIT_V() {\n  static TfLiteRegistration r = {nullptr, nullptr, split_v::Prepare,\n                                 split_v::Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite"