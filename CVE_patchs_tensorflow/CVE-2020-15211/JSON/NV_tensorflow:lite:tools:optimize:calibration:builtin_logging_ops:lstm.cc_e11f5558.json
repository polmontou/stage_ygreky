"/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/lite/tools/optimize/calibration/builtin_logging_ops/lstm.h\"\n\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/core/api/error_reporter.h\"\n#include \"tensorflow/lite/interpreter.h\"\n#include \"tensorflow/lite/kernels/internal/kernel_utils.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_utils.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n#include \"tensorflow/lite/kernels/lstm_shared.h\"\n#include \"tensorflow/lite/kernels/op_macros.h\"\n#include \"tensorflow/lite/tools/optimize/calibration/calibration_logger.h\"\n\nnamespace tflite {\nnamespace optimize {\nnamespace calibration {\nnamespace builtin {\n\nnamespace {\n\ninline void CalculateLstmGateFloat(\n    const float* input, const float* input_to_gate_weights,\n    const float* aux_input, const float* aux_input_to_gate_weights,\n    const float* output_state, const float* recurrent_to_gate_weights,\n    const float* cell_state, const float* cell_to_gate_weights,\n    const float* layer_norm_coefficients, const float* gate_bias,\n    const int n_batch, const int n_input, const int n_aux_input,\n    const int n_output, const int n_cell,\n    const TfLiteFusedActivation activation, float* gate,\n    const bool is_input_all_zeros, const bool is_aux_input_all_zeros,\n    Logger* logger, int intermediate_tensor_index,\n    ErrorReporter* error_reporter) {\n  const bool use_peephole = (cell_to_gate_weights != nullptr);\n  const bool use_layer_norm = (layer_norm_coefficients != nullptr);\n\n  // Initialize scratch buffers with bias for regular lstm or initialize with\n  // zero for layer norm lstm.\n  if (use_layer_norm) {\n    std::fill_n(gate, n_cell * n_batch, 0.0f);\n  } else {\n    tensor_utils::VectorBatchVectorAssign(gate_bias, n_cell, n_batch, gate);\n  }\n  // For each batch and cell: compute input_weight * input.\n  // Skip if input is all zeros.\n  if (!is_input_all_zeros) {\n    tensor_utils::MatrixBatchVectorMultiplyAccumulate(\n        input_to_gate_weights, n_cell, n_input, input, n_batch, gate);\n  }\n  // For each batch and cell: compute aux_input_weight * aux_input.\n  // Skip if auxiliary input is not available or all zeros.\n  if (!is_aux_input_all_zeros) {\n    tensor_utils::MatrixBatchVectorMultiplyAccumulate(aux_input_to_gate_weights,\n                                                      n_cell, n_aux_input,\n                                                      aux_input, n_batch, gate);\n  }\n  // For each batch and cell: compute recurrent_weight * output_state.\n  tensor_utils::MatrixBatchVectorMultiplyAccumulate(\n      recurrent_to_gate_weights, n_cell, n_output, output_state, n_batch, gate);\n  // For each batch and cell: compute cell_weight .* cell_state (peephole LSTM)\n  if (use_peephole) {\n    tensor_utils::VectorBatchVectorCwiseProductAccumulate(\n        cell_to_gate_weights, n_cell, cell_state, n_batch, gate);\n  }\n  // Do layer normalization (if layer norm LSTM)\n  if (use_layer_norm) {\n    logger->LogTensorValue(intermediate_tensor_index, gate, n_cell * n_batch,\n                           error_reporter);\n\n    tensor_utils::MeanStddevNormalization(gate, gate, n_cell, n_batch);\n    tensor_utils::VectorBatchVectorCwiseProduct(layer_norm_coefficients, n_cell,\n                                                gate, n_batch, gate);\n    tensor_utils::VectorBatchVectorAdd(gate_bias, n_cell, n_batch, gate);\n  }\n  // Apply activation\n  tensor_utils::ApplyActivationToVector(gate, n_batch * n_cell, activation,\n                                        gate);\n}\n\n// TODO(b/159066113): This is the exact same function as UpdateLstmCellFloat in\n// kernels/lstm_eval.cc, make that public and remove this.\nvoid UpdateLstmCellFloat(int n_batch, int n_cell, float* cell_state,\n                         const float* input_gate, float* forget_gate,\n                         const float* cell_gate, bool use_cifg, float clip) {\n  tensor_utils::VectorVectorCwiseProduct(forget_gate, cell_state,\n                                         n_batch * n_cell, cell_state);\n\n  if (use_cifg) {\n    // With CIFG, input_gate = 1-forget_gate. Use the forget_gate array as\n    // scratch, as input_gate array is not allocated in this case. (Be careful\n    // not to write to the scratch before reading the forget gate data.)\n    float* scratch = forget_gate;\n    tensor_utils::Sub1Vector(forget_gate, n_batch * n_cell, scratch);\n    tensor_utils::VectorVectorCwiseProductAccumulate(\n        cell_gate, scratch, n_batch * n_cell, cell_state);\n  } else {\n    tensor_utils::VectorVectorCwiseProductAccumulate(\n        cell_gate, input_gate, n_batch * n_cell, cell_state);\n  }\n  if (clip > 0.0f) {\n    tensor_utils::CwiseClipping(cell_state, n_batch * n_cell, clip);\n  }\n}\n\nvoid CalculateLstmOutputCalibration(\n    int n_batch, int n_cell, int n_output, const float* cell_state,\n    const float* output_gate, TfLiteFusedActivation activation,\n    const float* projection_weights, const float* projection_bias,\n    const float proj_clip, float* output_state, float* scratch, Logger* logger,\n    const std::vector<int>& intermediate_tensor_indexes,\n    ErrorReporter* error_reporter) {\n  tensor_utils::ApplyActivationToVector(cell_state, n_batch * n_cell,\n                                        activation, scratch);\n  tensor_utils::VectorVectorCwiseProduct(output_gate, scratch, n_batch * n_cell,\n                                         scratch);\n\n  logger->LogTensorValue(intermediate_tensor_indexes[4], scratch,\n                         n_cell * n_batch, error_reporter);\n\n  const bool use_projection = (projection_weights != nullptr);\n  const bool use_projection_bias = (projection_bias != nullptr);\n\n  if (use_projection) {\n    if (use_projection_bias) {\n      tensor_utils::VectorBatchVectorAssign(projection_bias, n_output, n_batch,\n                                            output_state);\n    } else {\n      std::fill_n(output_state, n_batch * n_output, 0.0f);\n    }\n    tensor_utils::MatrixBatchVectorMultiplyAccumulate(\n        projection_weights, n_output, n_cell, scratch, n_batch, output_state);\n    if (proj_clip > 0.0f) {\n      tensor_utils::CwiseClipping(output_state, n_batch * n_output, proj_clip);\n    }\n  } else {\n    std::copy_n(scratch, n_batch * n_output, output_state);\n  }\n}\n\ninline void LstmStepCalibration(\n    const float* input_ptr, const float* input_to_input_weights_ptr,\n    const float* input_to_forget_weights_ptr,\n    const float* input_to_cell_weights_ptr,\n    const float* input_to_output_weights_ptr, const float* aux_input_ptr,\n    const float* aux_input_to_input_weights_ptr,\n    const float* aux_input_to_forget_weights_ptr,\n    const float* aux_input_to_cell_weights_ptr,\n    const float* aux_input_to_output_weights_ptr,\n    const float* recurrent_to_input_weights_ptr,\n    const float* recurrent_to_forget_weights_ptr,\n    const float* recurrent_to_cell_weights_ptr,\n    const float* recurrent_to_output_weights_ptr,\n    const float* cell_to_input_weights_ptr,\n    const float* cell_to_forget_weights_ptr,\n    const float* cell_to_output_weights_ptr,\n    const float* input_layer_norm_coefficients_ptr,\n    const float* forget_layer_norm_coefficients_ptr,\n    const float* cell_layer_norm_coefficients_ptr,\n    const float* output_layer_norm_coefficients_ptr,\n    const float* input_gate_bias_ptr, const float* forget_gate_bias_ptr,\n    const float* cell_gate_bias_ptr, const float* output_gate_bias_ptr,\n    const float* projection_weights_ptr, const float* projection_bias_ptr,\n    const TfLiteLSTMParams* params, int n_batch, int n_cell, int n_input,\n    int n_aux_input, int n_output, int output_batch_leading_dim,\n    float* output_state_ptr, float* cell_state_ptr, float* scratch0,\n    float* scratch1, float* scratch2, float* scratch3, float* output_ptr,\n    Logger* logger, const std::vector<int>& intermediate_tensor_indexes,\n    ErrorReporter* error_reporter) {\n  ruy::profiler::ScopeLabel label(\"LstmStepCalibration\");\n  // Since we have already checked that weights are all there or none, we can\n  // check the existence of only one to the get the condition.\n  const bool use_cifg = (input_to_input_weights_ptr == nullptr);\n\n  // Make named scratch buffers.\n  float* input_gate_scratch = scratch0;\n  float* forget_gate_scratch = scratch1;\n  float* cell_gate_scratch = scratch2;\n  float* output_gate_scratch = scratch3;\n\n  // Check if inputs are all zeros so we can skip some computations.\n  const bool is_input_all_zeros =\n      tensor_utils::IsZeroVector(input_ptr, n_batch * n_input);\n  const bool is_aux_input_all_zeros =\n      (aux_input_ptr == nullptr ||\n       tensor_utils::IsZeroVector(aux_input_ptr, n_batch * n_aux_input));\n  if (!use_cifg) {\n    // Calculate the input gate. (If not CIFG.)\n    CalculateLstmGateFloat(\n        input_ptr, input_to_input_weights_ptr, aux_input_ptr,\n        aux_input_to_input_weights_ptr, output_state_ptr,\n        recurrent_to_input_weights_ptr, cell_state_ptr,\n        cell_to_input_weights_ptr, input_layer_norm_coefficients_ptr,\n        input_gate_bias_ptr, n_batch, n_input, n_aux_input, n_output, n_cell,\n        /*activation=*/kTfLiteActSigmoid, input_gate_scratch,\n        is_input_all_zeros, is_aux_input_all_zeros, logger,\n        intermediate_tensor_indexes[0], error_reporter);\n  }\n  // Calculate the forget gate.\n  CalculateLstmGateFloat(\n      input_ptr, input_to_forget_weights_ptr, aux_input_ptr,\n      aux_input_to_forget_weights_ptr, output_state_ptr,\n      recurrent_to_forget_weights_ptr, cell_state_ptr,\n      cell_to_forget_weights_ptr, forget_layer_norm_coefficients_ptr,\n      forget_gate_bias_ptr, n_batch, n_input, n_aux_input, n_output, n_cell,\n      /*activation=*/kTfLiteActSigmoid, forget_gate_scratch, is_input_all_zeros,\n      is_aux_input_all_zeros, logger, intermediate_tensor_indexes[1],\n      error_reporter);\n  // Calculate the cell update gate.\n  CalculateLstmGateFloat(input_ptr, input_to_cell_weights_ptr, aux_input_ptr,\n                         aux_input_to_cell_weights_ptr, output_state_ptr,\n                         recurrent_to_cell_weights_ptr, /*cell_state=*/nullptr,\n                         /*cell_to_gate_weights=*/nullptr,\n                         cell_layer_norm_coefficients_ptr, cell_gate_bias_ptr,\n                         n_batch, n_input, n_aux_input, n_output, n_cell,\n                         params->activation, cell_gate_scratch,\n                         is_input_all_zeros, is_aux_input_all_zeros, logger,\n                         intermediate_tensor_indexes[2], error_reporter);\n  // Update the cell state.\n  UpdateLstmCellFloat(n_batch, n_cell, cell_state_ptr, input_gate_scratch,\n                      forget_gate_scratch, cell_gate_scratch, use_cifg,\n                      params->cell_clip);\n  // Calculate output gate.\n  CalculateLstmGateFloat(\n      input_ptr, input_to_output_weights_ptr, aux_input_ptr,\n      aux_input_to_output_weights_ptr, output_state_ptr,\n      recurrent_to_output_weights_ptr, cell_state_ptr,\n      cell_to_output_weights_ptr, output_layer_norm_coefficients_ptr,\n      output_gate_bias_ptr, n_batch, n_input, n_aux_input, n_output, n_cell,\n      /*activation=*/kTfLiteActSigmoid, output_gate_scratch, is_input_all_zeros,\n      is_aux_input_all_zeros, logger, intermediate_tensor_indexes[3],\n      error_reporter);\n  // Update the output state.\n  CalculateLstmOutputCalibration(\n      n_batch, n_cell, n_output, cell_state_ptr, output_gate_scratch,\n      params->activation, projection_weights_ptr, projection_bias_ptr,\n      params->proj_clip, output_state_ptr, scratch2, logger,\n      intermediate_tensor_indexes, error_reporter);\n  // Copy output state to the output. Note that the output's rows may not be\n  // contiguous (output_batch_leading_dim != n_output).\n  for (int b = 0; b < n_batch; b++) {\n    std::copy_n(output_state_ptr + b * n_output, n_output,\n                output_ptr + b * output_batch_leading_dim);\n  }\n}\n\nTfLiteStatus EvalCalibration(\n    const TfLiteTensor* input, const TfLiteTensor* input_to_input_weights,\n    const TfLiteTensor* input_to_forget_weights,\n    const TfLiteTensor* input_to_cell_weights,\n    const TfLiteTensor* input_to_output_weights,\n    const TfLiteTensor* recurrent_to_input_weights,\n    const TfLiteTensor* recurrent_to_forget_weights,\n    const TfLiteTensor* recurrent_to_cell_weights,\n    const TfLiteTensor* recurrent_to_output_weights,\n    const TfLiteTensor* cell_to_input_weights,\n    const TfLiteTensor* cell_to_forget_weights,\n    const TfLiteTensor* cell_to_output_weights,\n    const TfLiteTensor* input_layer_norm_coefficients,\n    const TfLiteTensor* forget_layer_norm_coefficients,\n    const TfLiteTensor* cell_layer_norm_coefficients,\n    const TfLiteTensor* output_layer_norm_coefficients,\n    const TfLiteTensor* aux_input,\n    const TfLiteTensor* aux_input_to_input_weights,\n    const TfLiteTensor* aux_input_to_forget_weights,\n    const TfLiteTensor* aux_input_to_cell_weights,\n    const TfLiteTensor* aux_input_to_output_weights,\n    const TfLiteTensor* input_gate_bias, const TfLiteTensor* forget_gate_bias,\n    const TfLiteTensor* cell_gate_bias, const TfLiteTensor* output_gate_bias,\n    const TfLiteTensor* projection_weights, const TfLiteTensor* projection_bias,\n    const TfLiteLSTMParams* params, bool forward_sequence, bool time_major,\n    int output_offset, TfLiteTensor* scratch_buffer, TfLiteTensor* output_state,\n    TfLiteTensor* cell_state, TfLiteTensor* output, Logger* logger,\n    const std::vector<int>& intermediate_tensor_indexes,\n    ErrorReporter* error_reporter) {\n  TF_LITE_ASSERT(input->dims->size >= 2 && input->dims->size <= 3);\n  int max_time, n_batch;\n  if (input->dims->size == 3) {\n    max_time = (time_major) ? input->dims->data[0] : input->dims->data[1];\n    n_batch = (time_major) ? input->dims->data[1] : input->dims->data[0];\n  } else {\n    max_time = 1;\n    n_batch = input->dims->data[0];\n  }\n  const int n_input = input->dims->data[input->dims->size - 1];\n  const int aux_input_size =\n      (aux_input) ? aux_input->dims->data[aux_input->dims->size - 1] : 0;\n\n  // n_cell and n_output will be the same size when there is no projection.\n  const int n_cell = input_to_output_weights->dims->data[0];\n  const int n_output = recurrent_to_output_weights->dims->data[1];\n\n  // Since we have already checked that weights are all there or none, we can\n  // check the existence of only one to the get the condition.\n  const bool use_cifg = (input_to_input_weights == nullptr);\n\n  // Index the scratch buffers pointers to the global scratch buffer.\n  float* scratch_buffer_ptr = GetTensorData<float>(scratch_buffer);\n  float* input_gate_scratch = nullptr;\n  float* cell_gate_scratch = nullptr;\n  float* forget_gate_scratch = nullptr;\n  float* output_gate_scratch = nullptr;\n  if (use_cifg) {\n    cell_gate_scratch = scratch_buffer_ptr;\n    forget_gate_scratch = scratch_buffer_ptr + n_cell * n_batch;\n    output_gate_scratch = scratch_buffer_ptr + 2 * n_cell * n_batch;\n  } else {\n    input_gate_scratch = scratch_buffer_ptr;\n    cell_gate_scratch = scratch_buffer_ptr + n_cell * n_batch;\n    forget_gate_scratch = scratch_buffer_ptr + 2 * n_cell * n_batch;\n    output_gate_scratch = scratch_buffer_ptr + 3 * n_cell * n_batch;\n  }\n\n  const int output_batch_leading_dim =\n      output->dims->data[output->dims->size - 1];\n  if (time_major) {\n    // Loop through the sequence.\n    const int input_step = n_batch * n_input;\n    const int output_step = n_batch * output_batch_leading_dim;\n    for (int t = 0; t < max_time; t++) {\n      // If this is the forward_sequence, step forward, otherwise step\n      // backwards.\n      const int t_rel = forward_sequence ? t : max_time - t - 1;\n      const float* input_ptr = GetTensorData<float>(input) + t_rel * input_step;\n      const float* aux_input_ptr = nullptr;\n      if (aux_input) {\n        aux_input_ptr = GetTensorData<float>(aux_input) + t_rel * input_step;\n      }\n      float* output_ptr_time =\n          GetTensorData<float>(output) + t_rel * output_step + output_offset;\n\n      LstmStepCalibration(\n          input_ptr, GetTensorData<float>(input_to_input_weights),\n          GetTensorData<float>(input_to_forget_weights),\n          GetTensorData<float>(input_to_cell_weights),\n          GetTensorData<float>(input_to_output_weights), aux_input_ptr,\n          GetTensorData<float>(aux_input_to_input_weights),\n          GetTensorData<float>(aux_input_to_forget_weights),\n          GetTensorData<float>(aux_input_to_cell_weights),\n          GetTensorData<float>(aux_input_to_output_weights),\n          GetTensorData<float>(recurrent_to_input_weights),\n          GetTensorData<float>(recurrent_to_forget_weights),\n          GetTensorData<float>(recurrent_to_cell_weights),\n          GetTensorData<float>(recurrent_to_output_weights),\n          GetTensorData<float>(cell_to_input_weights),\n          GetTensorData<float>(cell_to_forget_weights),\n          GetTensorData<float>(cell_to_output_weights),\n          GetTensorData<float>(input_layer_norm_coefficients),\n          GetTensorData<float>(forget_layer_norm_coefficients),\n          GetTensorData<float>(cell_layer_norm_coefficients),\n          GetTensorData<float>(output_layer_norm_coefficients),\n          GetTensorData<float>(input_gate_bias),\n          GetTensorData<float>(forget_gate_bias),\n          GetTensorData<float>(cell_gate_bias),\n          GetTensorData<float>(output_gate_bias),\n          GetTensorData<float>(projection_weights),\n          GetTensorData<float>(projection_bias), params, n_batch, n_cell,\n          n_input, aux_input_size, n_output, output_batch_leading_dim,\n          GetTensorData<float>(output_state), GetTensorData<float>(cell_state),\n          input_gate_scratch, forget_gate_scratch, cell_gate_scratch,\n          output_gate_scratch, output_ptr_time, logger,\n          intermediate_tensor_indexes, error_reporter);\n    }\n  } else {\n    for (int b = 0; b < n_batch; b++) {\n      const int input_step = n_input;\n      const int output_step = output_batch_leading_dim;\n      for (int t = 0; t < max_time; t++) {\n        // If this is the forward_sequence, step forward, otherwise step\n        // backwards.\n        const int t_rel = forward_sequence ? t : max_time - t - 1;\n        const int time_offset = b * max_time + t_rel;\n        const float* input_ptr =\n            GetTensorData<float>(input) + time_offset * input_step;\n        const float* aux_input_ptr = nullptr;\n        if (aux_input) {\n          aux_input_ptr =\n              GetTensorData<float>(aux_input) + time_offset * input_step;\n        }\n        float* output_ptr = GetTensorData<float>(output) +\n                            time_offset * output_step + output_offset;\n\n        // Offset the {output,cell}_state pointers to the right batch.\n        float* output_state_ptr =\n            GetTensorData<float>(output_state) + b * output_batch_leading_dim;\n        float* cell_state_ptr = GetTensorData<float>(cell_state) + b * n_cell;\n        // Offset the scratch pointers to the right batch.\n        float* input_gate_scratch_ptr =\n            input_gate_scratch ? input_gate_scratch + b * n_cell : nullptr;\n        float* forget_gate_scratch_ptr = forget_gate_scratch + b * n_cell;\n        float* cell_gate_scratch_ptr = cell_gate_scratch + b * n_cell;\n        float* output_gate_scratch_ptr = output_gate_scratch + b * n_cell;\n\n        LstmStepCalibration(\n            input_ptr, GetTensorData<float>(input_to_input_weights),\n            GetTensorData<float>(input_to_forget_weights),\n            GetTensorData<float>(input_to_cell_weights),\n            GetTensorData<float>(input_to_output_weights), aux_input_ptr,\n            GetTensorData<float>(aux_input_to_input_weights),\n            GetTensorData<float>(aux_input_to_forget_weights),\n            GetTensorData<float>(aux_input_to_cell_weights),\n            GetTensorData<float>(aux_input_to_output_weights),\n            GetTensorData<float>(recurrent_to_input_weights),\n            GetTensorData<float>(recurrent_to_forget_weights),\n            GetTensorData<float>(recurrent_to_cell_weights),\n            GetTensorData<float>(recurrent_to_output_weights),\n            GetTensorData<float>(cell_to_input_weights),\n            GetTensorData<float>(cell_to_forget_weights),\n            GetTensorData<float>(cell_to_output_weights),\n            GetTensorData<float>(input_layer_norm_coefficients),\n            GetTensorData<float>(forget_layer_norm_coefficients),\n            GetTensorData<float>(cell_layer_norm_coefficients),\n            GetTensorData<float>(output_layer_norm_coefficients),\n            GetTensorData<float>(input_gate_bias),\n            GetTensorData<float>(forget_gate_bias),\n            GetTensorData<float>(cell_gate_bias),\n            GetTensorData<float>(output_gate_bias),\n            GetTensorData<float>(projection_weights),\n            GetTensorData<float>(projection_bias), params, /*n_batch=*/1,\n            n_cell, n_input, aux_input_size, n_output, output_batch_leading_dim,\n            output_state_ptr, cell_state_ptr, input_gate_scratch_ptr,\n            forget_gate_scratch_ptr, cell_gate_scratch_ptr,\n            output_gate_scratch_ptr, output_ptr, logger,\n            intermediate_tensor_indexes, error_reporter);\n      }\n    }\n  }\n  return kTfLiteOk;\n}\n\nstruct OpData {\n  // Which kernel type to use. Full kernel (24 inputs) or basic kernel (5\n  // inputs).\n  // Please note the 20-input full kernel is deprecated and only kept\n  // here for backward compatibility.\n  TfLiteLSTMKernelType kernel_type;\n\n  // If the lstm is layer norm.\n  bool use_layer_norm;\n\n  // These fields are only used by full kernel.\n  int scratch_tensor_index;\n};\n\n// Resize the output, state tensors based on the sizes of the input tensors.\n// Allocate a temporary scratch tensor. Also check that the sizes of the input\n// tensors match each other.\nTfLiteStatus lstm_eval(TfLiteContext* context, TfLiteNode* node, Logger* logger,\n                       ErrorReporter* error_reporter) {\n  const auto* params = static_cast<TfLiteLSTMParams*>(node->builtin_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node,\n                            ops::builtin::lstm::full::kInputTensor, &input));\n\n  const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor(\n      context, node, ops::builtin::lstm::full::kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights;\n  TF_LITE_ENSURE_OK(\n      context,\n      GetInputSafe(context, node,\n                   ops::builtin::lstm::full::kInputToForgetWeightsTensor,\n                   &input_to_forget_weights));\n  const TfLiteTensor* input_to_cell_weights;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node,\n                            ops::builtin::lstm::full::kInputToCellWeightsTensor,\n                            &input_to_cell_weights));\n  const TfLiteTensor* input_to_output_weights;\n  TF_LITE_ENSURE_OK(\n      context,\n      GetInputSafe(context, node,\n                   ops::builtin::lstm::full::kInputToOutputWeightsTensor,\n                   &input_to_output_weights));\n\n  const TfLiteTensor* recurrent_to_input_weights = GetOptionalInputTensor(\n      context, node, ops::builtin::lstm::full::kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights;\n  TF_LITE_ENSURE_OK(\n      context,\n      GetInputSafe(context, node,\n                   ops::builtin::lstm::full::kRecurrentToForgetWeightsTensor,\n                   &recurrent_to_forget_weights));\n  const TfLiteTensor* recurrent_to_cell_weights;\n  TF_LITE_ENSURE_OK(\n      context,\n      GetInputSafe(context, node,\n                   ops::builtin::lstm::full::kRecurrentToCellWeightsTensor,\n                   &recurrent_to_cell_weights));\n  const TfLiteTensor* recurrent_to_output_weights;\n  TF_LITE_ENSURE_OK(\n      context,\n      GetInputSafe(context, node,\n                   ops::builtin::lstm::full::kRecurrentToOutputWeightsTensor,\n                   &recurrent_to_output_weights));\n\n  const TfLiteTensor* cell_to_input_weights = GetOptionalInputTensor(\n      context, node, ops::builtin::lstm::full::kCellToInputWeightsTensor);\n  const TfLiteTensor* cell_to_forget_weights = GetOptionalInputTensor(\n      context, node, ops::builtin::lstm::full::kCellToForgetWeightsTensor);\n  const TfLiteTensor* cell_to_output_weights = GetOptionalInputTensor(\n      context, node, ops::builtin::lstm::full::kCellToOutputWeightsTensor);\n\n  const TfLiteTensor* input_layer_norm_coefficients = GetOptionalInputTensor(\n      context, node,\n      ops::builtin::lstm::full::kInputLayerNormCoefficientsTensor);\n  const TfLiteTensor* forget_layer_norm_coefficients = GetOptionalInputTensor(\n      context, node,\n      ops::builtin::lstm::full::kForgetLayerNormCoefficientsTensor);\n  const TfLiteTensor* cell_layer_norm_coefficients = GetOptionalInputTensor(\n      context, node,\n      ops::builtin::lstm::full::kCellLayerNormCoefficientsTensor);\n  const TfLiteTensor* output_layer_norm_coefficients = GetOptionalInputTensor(\n      context, node,\n      ops::builtin::lstm::full::kOutputLayerNormCoefficientsTensor);\n\n  const TfLiteTensor* input_gate_bias = GetOptionalInputTensor(\n      context, node, ops::builtin::lstm::full::kInputGateBiasTensor);\n  const TfLiteTensor* forget_gate_bias;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node,\n                            ops::builtin::lstm::full::kForgetGateBiasTensor,\n                            &forget_gate_bias));\n  const TfLiteTensor* cell_gate_bias;\n  TF_LITE_ENSURE_OK(\n      context,\n      GetInputSafe(context, node, ops::builtin::lstm::full::kCellGateBiasTensor,\n                   &cell_gate_bias));\n  const TfLiteTensor* output_gate_bias;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node,\n                            ops::builtin::lstm::full::kOutputGateBiasTensor,\n                            &output_gate_bias));\n\n  const TfLiteTensor* projection_weights = GetOptionalInputTensor(\n      context, node, ops::builtin::lstm::full::kProjectionWeightsTensor);\n  const TfLiteTensor* projection_bias = GetOptionalInputTensor(\n      context, node, ops::builtin::lstm::full::kProjectionBiasTensor);\n\n  // Index the scratch buffers pointers to the global scratch buffer.\n  TfLiteTensor* scratch_buffer;\n  TF_LITE_ENSURE_OK(\n      context, GetTemporarySafe(context, node, /*index=*/0, &scratch_buffer));\n\n  TfLiteTensor* output_state = GetVariableInput(\n      context, node, ops::builtin::lstm::full::kOutputStateTensor);\n  TF_LITE_ENSURE(context, output_state != nullptr);\n  TfLiteTensor* cell_state = GetVariableInput(\n      context, node, ops::builtin::lstm::full::kCellStateTensor);\n  TF_LITE_ENSURE(context, cell_state != nullptr);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(\n      context, GetOutputSafe(context, node,\n                             ops::builtin::lstm::full::kOutputTensor, &output));\n\n  std::vector<int> intermediate_tensor_indexes(node->intermediates->size);\n  for (int i = 0; i < node->intermediates->size; ++i) {\n    intermediate_tensor_indexes[i] = node->intermediates->data[i];\n  }\n\n  switch (input_to_output_weights->type) {\n    case kTfLiteFloat32: {\n      return EvalCalibration(\n          input, input_to_input_weights, input_to_forget_weights,\n          input_to_cell_weights, input_to_output_weights,\n          recurrent_to_input_weights, recurrent_to_forget_weights,\n          recurrent_to_cell_weights, recurrent_to_output_weights,\n          cell_to_input_weights, cell_to_forget_weights, cell_to_output_weights,\n          input_layer_norm_coefficients, forget_layer_norm_coefficients,\n          cell_layer_norm_coefficients, output_layer_norm_coefficients,\n          /*aux_input=*/nullptr,\n          /*aux_input_to_input_weights=*/nullptr,\n          /*aux_input_to_forget_weights=*/nullptr,\n          /*aux_input_to_cell_weights=*/nullptr,\n          /*aux_input_to_output_weights=*/nullptr, input_gate_bias,\n          forget_gate_bias, cell_gate_bias, output_gate_bias,\n          projection_weights, projection_bias, params,\n          /*forward_sequence=*/true,\n          /*time_major=*/true,\n          /*output_offset=*/0, scratch_buffer, output_state, cell_state, output,\n          logger, intermediate_tensor_indexes, error_reporter);\n    }\n    case kTfLiteUInt8:\n    case kTfLiteInt8:\n    default:\n      printf(\"Error. Only float model can be calibrated\\n\");\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n}  // namespace\n\nTfLiteStatus lstm_logging_kernel(TfLiteContext* context, TfLiteNode* node,\n                                 Logger* logger,\n                                 ErrorReporter* error_reporter) {\n  return lstm_eval(context, node, logger, error_reporter);\n}\n\n}  // namespace builtin\n}  // namespace calibration\n}  // namespace optimize\n}  // namespace tflite"