"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/lite/interpreter.h\"\n\n#include <stdint.h>\n\n#include <memory>\n\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n#include \"third_party/eigen3/Eigen/Core\"\n#include \"tensorflow/lite/builtin_op_data.h\"\n#include \"tensorflow/lite/core/api/error_reporter.h\"\n#include \"tensorflow/lite/external_cpu_backend_context.h\"\n#include \"tensorflow/lite/kernels/builtin_op_kernels.h\"\n#include \"tensorflow/lite/kernels/cpu_backend_context.h\"\n#include \"tensorflow/lite/kernels/internal/compatibility.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n#include \"tensorflow/lite/kernels/register.h\"\n#include \"tensorflow/lite/schema/schema_generated.h\"\n#include \"tensorflow/lite/string_util.h\"\n#include \"tensorflow/lite/testing/util.h\"\n#include \"tensorflow/lite/version.h\"\n\nnamespace tflite {\n\n// InterpreterTest is a friend of Interpreter, so it can access context_.\nclass InterpreterTest : public ::testing::Test {\n public:\n  template <typename Delegate>\n  static TfLiteStatus ModifyGraphWithDelegate(\n      Interpreter* interpreter, std::unique_ptr<Delegate> delegate) {\n    return interpreter->ModifyGraphWithDelegate(std::move(delegate));\n  }\n\n protected:\n  TfLiteContext* GetInterpreterContext() { return interpreter_.context_; }\n\n  Interpreter interpreter_;\n};\n\nnamespace ops {\nnamespace builtin {\nTfLiteRegistration* Register_PADV2();\nTfLiteRegistration* Register_NEG();\n}  // namespace builtin\n}  // namespace ops\nnamespace {\n\nusing ::testing::IsEmpty;\n\n// Make an interpreter that has no tensors and no nodes\nTEST(BasicInterpreter, ZeroInterpreter) {\n  testing::internal::CaptureStderr();\n\n  Interpreter interpreter;\n\n#ifndef NDEBUG\n  const char* kExpectedLog = \"INFO: Initialized TensorFlow Lite runtime\";\n#else\n  const char* kExpectedLog = \"\";\n#endif\n  EXPECT_THAT(testing::internal::GetCapturedStderr(),\n              testing::HasSubstr(kExpectedLog));\n\n  interpreter.SetInputs({});\n  interpreter.SetOutputs({});\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n\n  // Creating a new interpreter should not redundantly log runtime init.\n  testing::internal::CaptureStderr();\n  Interpreter interpreter2;\n  EXPECT_THAT(testing::internal::GetCapturedStderr(), IsEmpty());\n}\n\n// Test various error conditions.\nTEST(BasicInterpreter, InvokeInvalidModel) {\n  Interpreter interpreter;\n  ASSERT_NE(interpreter.Invoke(), kTfLiteOk);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n}\n\nTEST(BasicInterpreter, TestAllocateTensorsResetVariableTensorsFloatAndHyrbid) {\n  Interpreter interpreter;\n  int tensor_index;\n  ASSERT_EQ(interpreter.AddTensors(1, &tensor_index), kTfLiteOk);\n  constexpr int kTensorSize = 16;\n  TfLiteQuantizationParams quant;\n  interpreter.SetTensorParametersReadWrite(tensor_index, kTfLiteFloat32, \"\",\n                                           {kTensorSize}, quant,\n                                           /*is_variable=*/true);\n  interpreter.SetVariables({tensor_index});\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  TfLiteTensor* tensor = interpreter.tensor(tensor_index);\n  // Ensure that variable tensors are reset to zero.\n  for (int i = 0; i < kTensorSize; ++i) {\n    ASSERT_EQ(tensor->data.f[i], 0.0f);\n  }\n}\n\nTEST(BasicInterpreter, TestAllocateTensorsResetVariableTensorsInt8) {\n  Interpreter interpreter;\n  int tensor_index;\n  ASSERT_EQ(interpreter.AddTensors(1, &tensor_index), kTfLiteOk);\n  constexpr int kTensorSize = 16;\n  TfLiteQuantizationParams quant;\n  quant.scale = 0.15;\n  quant.zero_point = -3;\n  interpreter.SetTensorParametersReadWrite(tensor_index, kTfLiteInt8, \"\",\n                                           {kTensorSize}, quant,\n                                           /*is_variable=*/true);\n  interpreter.SetVariables({tensor_index});\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  TfLiteTensor* tensor = interpreter.tensor(tensor_index);\n  // Ensure that variable tensors are reset to zero point.\n  for (int i = 0; i < kTensorSize; ++i) {\n    ASSERT_EQ(tensor->data.int8[i], -3);\n  }\n}\n\n// Test size accessor functions.\nTEST(BasicInterpreter, TestSizeFunctions) {\n  Interpreter interpreter;\n  int base_index;\n  ASSERT_EQ(interpreter.nodes_size(), 0);\n  ASSERT_EQ(interpreter.tensors_size(), 0);\n  ASSERT_EQ(interpreter.AddTensors(2, &base_index), kTfLiteOk);\n  ASSERT_EQ(interpreter.tensors_size(), 2);\n  ASSERT_EQ(base_index, 0);\n  ASSERT_EQ(interpreter.AddTensors(3, &base_index), kTfLiteOk);\n  ASSERT_EQ(interpreter.tensors_size(), 5);\n  ASSERT_EQ(interpreter.AddTensors(1), kTfLiteOk);\n  ASSERT_EQ(interpreter.tensors_size(), 6);\n  ASSERT_EQ(base_index, 2);\n}\n\n// Test if invalid indices make a model inconsistent (and conversely if\n// valid indices keep a model consistent).\nTEST(BasicInterpreter, InconsistentModel) {\n  // Invalid inputs\n  {\n    Interpreter interpreter;\n    ASSERT_NE(interpreter.SetInputs({5}), kTfLiteOk);\n    ASSERT_NE(interpreter.AllocateTensors(), kTfLiteOk);\n    ASSERT_NE(interpreter.Invoke(), kTfLiteOk);\n    ASSERT_EQ(interpreter.inputs(), std::vector<int>());\n  }\n  // Invalid outputs\n  {\n    Interpreter interpreter;\n    ASSERT_NE(interpreter.SetOutputs({5}), kTfLiteOk);\n    ASSERT_NE(interpreter.AllocateTensors(), kTfLiteOk);\n    ASSERT_NE(interpreter.Invoke(), kTfLiteOk);\n    ASSERT_EQ(interpreter.outputs(), std::vector<int>());\n  }\n  // Invalid node inputs\n  {\n    Interpreter interpreter;\n    TfLiteRegistration registration = {nullptr, nullptr, nullptr, nullptr};\n    ASSERT_NE(interpreter.AddNodeWithParameters({3}, {0}, nullptr, 0, nullptr,\n                                                &registration),\n              kTfLiteOk);\n    ASSERT_NE(interpreter.AllocateTensors(), kTfLiteOk);\n    ASSERT_NE(interpreter.Invoke(), kTfLiteOk);\n  }\n  // Valid inputs and outputs and a node with valid inputs and outputs\n  {\n    Interpreter interpreter;\n    ASSERT_EQ(interpreter.AddTensors(2), kTfLiteOk);\n    TfLiteRegistration registration = {nullptr, nullptr, nullptr, nullptr};\n    ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n    ASSERT_EQ(interpreter.SetOutputs({0}), kTfLiteOk);\n    ASSERT_EQ(interpreter.AddNodeWithParameters({0}, {1}, nullptr, 0, nullptr,\n                                                &registration),\n              kTfLiteOk);\n  }\n}\n\n// Make an interpreter that has one tensor but no ops\nTEST(BasicInterpreter, CheckAllocate) {\n  struct {\n    TfLiteType type;\n    size_t size;\n  } cases[] = {\n      {kTfLiteFloat32, sizeof(float)}, {kTfLiteInt32, sizeof(int32_t)},\n      {kTfLiteUInt8, sizeof(uint8_t)}, {kTfLiteInt64, sizeof(int64_t)},\n      {kTfLiteInt16, sizeof(int16_t)}, {kTfLiteFloat16, sizeof(TfLiteFloat16)},\n  };\n\n  for (auto test : cases) {\n    Interpreter interpreter;\n    ASSERT_EQ(interpreter.AddTensors(2), kTfLiteOk);\n    interpreter.SetInputs({0, 1});\n    interpreter.SetOutputs({});\n    TfLiteQuantizationParams quant;\n\n    interpreter.SetTensorParametersReadWrite(0, test.type, \"\", {3}, quant);\n    interpreter.SetTensorParametersReadWrite(1, test.type, \"\", {4}, quant);\n    ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n    ASSERT_EQ(interpreter.tensor(0)->bytes, 3 * test.size);\n    ASSERT_NE(interpreter.tensor(0)->data.raw, nullptr);\n    ASSERT_EQ(interpreter.tensor(1)->bytes, 4 * test.size);\n    ASSERT_NE(interpreter.tensor(1)->data.raw, nullptr);\n  }\n}\n\nTEST(BasicInterpreter, CheckQuantization) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(2), kTfLiteOk);\n  interpreter.SetInputs({0, 1});\n  interpreter.SetOutputs({});\n  TfLiteType tensor_type = kTfLiteInt8;\n  const uint8_t int8s[] = {3, 4};\n  float scale = 0.5f;\n  int32_t zero_point = 12;\n\n  TfLiteQuantization rw_quantization;\n  rw_quantization.type = kTfLiteAffineQuantization;\n  auto* rw_affine_quantization = static_cast<TfLiteAffineQuantization*>(\n      malloc(sizeof(TfLiteAffineQuantization)));\n  rw_affine_quantization->scale = TfLiteFloatArrayCreate(1);\n  rw_affine_quantization->zero_point = TfLiteIntArrayCreate(1);\n  rw_affine_quantization->scale->data[0] = scale;\n  rw_affine_quantization->zero_point->data[0] = zero_point;\n  rw_quantization.params = rw_affine_quantization;\n\n  TfLiteQuantization ro_quantization;\n  ro_quantization.type = kTfLiteAffineQuantization;\n  auto* ro_affine_quantization = static_cast<TfLiteAffineQuantization*>(\n      malloc(sizeof(TfLiteAffineQuantization)));\n  ro_affine_quantization->scale = TfLiteFloatArrayCreate(1);\n  ro_affine_quantization->zero_point = TfLiteIntArrayCreate(1);\n  ro_affine_quantization->scale->data[0] = scale;\n  ro_affine_quantization->zero_point->data[0] = zero_point;\n  ro_quantization.params = ro_affine_quantization;\n\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(0, tensor_type, \"\", {3},\n                                                     rw_quantization),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.SetTensorParametersReadOnly(\n                1, tensor_type, \"\", {2}, ro_quantization,\n                reinterpret_cast<const char*>(int8s), 2),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  // Check that the legacy scale and zero_point are set correctly.\n  ASSERT_EQ(interpreter.tensor(0)->params.scale, scale);\n  ASSERT_EQ(interpreter.tensor(0)->params.zero_point, zero_point);\n  ASSERT_EQ(interpreter.tensor(0)->quantization.type, rw_quantization.type);\n  ASSERT_EQ(interpreter.tensor(1)->params.scale, scale);\n  ASSERT_EQ(interpreter.tensor(1)->params.zero_point, zero_point);\n  ASSERT_EQ(interpreter.tensor(1)->quantization.type, ro_quantization.type);\n}\n\nTEST(BasicInterpreter, CheckResize) {\n  const float floats[] = {-3., -4.};\n  const int32_t int32s[] = {-3, -4};\n  const uint8_t uint8s[] = {3, 4};\n  const int64_t int64s[] = {6, -7};\n  const int16_t int16s[] = {8, -9};\n  const Eigen::half float16s[] = {Eigen::half_impl::float_to_half_rtne(-3.f),\n                                  Eigen::half_impl::float_to_half_rtne(-4.f)};\n\n  struct {\n    TfLiteType type;\n    size_t size;\n    const char* array;\n  } cases[] = {\n      {kTfLiteFloat32, sizeof(float), reinterpret_cast<const char*>(floats)},\n      {kTfLiteInt32, sizeof(int32_t), reinterpret_cast<const char*>(int32s)},\n      {kTfLiteUInt8, sizeof(uint8_t), reinterpret_cast<const char*>(uint8s)},\n      {kTfLiteInt64, sizeof(int64_t), reinterpret_cast<const char*>(int64s)},\n      {kTfLiteInt16, sizeof(int16_t), reinterpret_cast<const char*>(int16s)},\n      {kTfLiteFloat16, sizeof(TfLiteFloat16),\n       reinterpret_cast<const char*>(float16s)},\n  };\n\n  for (auto test : cases) {\n    Interpreter interpreter;\n\n    ASSERT_EQ(interpreter.AddTensors(2), kTfLiteOk);\n    interpreter.SetInputs({0, 1});\n    interpreter.SetOutputs({});\n    TfLiteQuantizationParams quant;\n\n    ASSERT_EQ(\n        interpreter.SetTensorParametersReadWrite(0, test.type, \"\", {3}, quant),\n        kTfLiteOk);\n    ASSERT_EQ(interpreter.SetTensorParametersReadOnly(\n                  1, test.type, \"\", {2}, quant, test.array, 2 * test.size),\n              kTfLiteOk);\n    ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n    ASSERT_EQ(interpreter.ResizeInputTensor(0, {1, 2}), kTfLiteOk);\n    // Resizing a mmapped tensor is not allowed and should produce error.\n    ASSERT_NE(interpreter.ResizeInputTensor(1, {3}), kTfLiteOk);\n    // Set the tensor to be mmapped but with a buffer size that is insufficient\n    // to match the dimensionality.\n    ASSERT_NE(interpreter.SetTensorParametersReadOnly(\n                  1, test.type, \"\", {2}, quant, test.array, 1 * test.size),\n              kTfLiteOk);\n    // Allocating should work since we should have our last correct array\n    // values in place.\n    ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  }\n}\n\nTEST(BasicInterpreter, CheckAlignment) {\n  struct {\n    TfLiteType type;\n  } cases[] = {{kTfLiteFloat32}, {kTfLiteInt32}, {kTfLiteUInt8},\n               {kTfLiteInt64},   {kTfLiteInt16}, {kTfLiteFloat16}};\n\n  for (auto test : cases) {\n    Interpreter interpreter;\n\n    ASSERT_EQ(interpreter.AddTensors(4), kTfLiteOk);\n\n    for (int i = 0; i < 4; i++) {\n      TfLiteQuantizationParams quant;\n      interpreter.SetTensorParametersReadWrite(i, test.type, \"\", {2 * i + 1},\n                                               quant);\n    }\n    interpreter.AllocateTensors();\n    for (int i = 0; i < 4; i++) {\n      const TfLiteTensor& tensor = *interpreter.tensor(i);\n      ASSERT_EQ(reinterpret_cast<intptr_t>(tensor.data.raw) % 4, 0);\n    }\n  }\n}\n\nTEST(BasicInterpreter, CheckArenaAllocation) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(10), kTfLiteOk);\n\n  TfLiteQuantizationParams quant;\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n\n  std::vector<int> sizes{2048, 4096, 1023, 2047, 1021,\n                         2047, 1023, 2046, 0,    2048};\n  for (size_t i = 0; i < sizes.size(); ++i) {\n    interpreter.SetTensorParametersReadWrite(static_cast<int>(i), kTfLiteUInt8,\n                                             \"\", {sizes[i]}, quant);\n  }\n  interpreter.SetInputs({0, 1});\n  interpreter.SetOutputs({9, 4});\n  interpreter.AddNodeWithParameters({0, 1}, {2, 3}, nullptr, 0, nullptr, &reg);\n  interpreter.AddNodeWithParameters({2, 1}, {4, 5}, nullptr, 0, nullptr, &reg);\n  interpreter.AddNodeWithParameters({4, 3}, {6, 7}, nullptr, 0, nullptr, &reg);\n  interpreter.AddNodeWithParameters({6, 5}, {8}, nullptr, 0, nullptr, &reg);\n  interpreter.AddNodeWithParameters({8, 7}, {9}, nullptr, 0, nullptr, &reg);\n\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  ASSERT_LT(interpreter.tensor(0)->data.raw, interpreter.tensor(1)->data.raw);\n  ASSERT_LT(interpreter.tensor(1)->data.raw, interpreter.tensor(3)->data.raw);\n  ASSERT_EQ(interpreter.tensor(3)->data.raw, interpreter.tensor(9)->data.raw);\n  ASSERT_LT(interpreter.tensor(3)->data.raw, interpreter.tensor(5)->data.raw);\n  ASSERT_LT(interpreter.tensor(5)->data.raw, interpreter.tensor(2)->data.raw);\n  ASSERT_EQ(interpreter.tensor(2)->data.raw, interpreter.tensor(7)->data.raw);\n  ASSERT_LT(interpreter.tensor(2)->data.raw, interpreter.tensor(4)->data.raw);\n  // #4 is the one with the largest pointer.\n  ASSERT_EQ(interpreter.tensor(8)->data.raw, nullptr);\n}\n\nTEST(BasicInterpreter, BufferAccess) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(1), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(\n                0, kTfLiteFloat32, \"\", {3}, TfLiteQuantizationParams()),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  // Verify we get a valid pointer.\n  ASSERT_NE(interpreter.typed_tensor<float>(0), nullptr);\n  // Verify incorrect pointer is not returned.\n  ASSERT_EQ(interpreter.typed_tensor<int>(0), nullptr);\n  // Verify that raw c interface ptr matches safe interface.\n  ASSERT_EQ(interpreter.typed_tensor<float>(0), interpreter.tensor(0)->data.f);\n}\n\nTEST(BasicInterpreter, NoOpInterpreter) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(1), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({0}), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(\n                0, kTfLiteFloat32, \"\", {3}, TfLiteQuantizationParams()),\n            kTfLiteOk);\n\n  ASSERT_EQ(interpreter.ResizeInputTensor(interpreter.inputs()[0], {1, 2, 3}),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n}\n\nTEST(BasicInterpreter, RedundantAllocateTensors) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(1), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(\n                0, kTfLiteFloat32, \"\", {3}, TfLiteQuantizationParams()),\n            kTfLiteOk);\n\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  const auto data_raw = interpreter.tensor(0)->data.raw;\n  ASSERT_NE(data_raw, nullptr);\n\n  // A redundant allocation request should have no impact.\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.tensor(0)->data.raw, data_raw);\n}\n\nTEST(BasicInterpreter, RedundantAllocateTensorsWithDynamicInputs) {\n  Interpreter interpreter;\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  ASSERT_EQ(interpreter.AddTensors(2), kTfLiteOk);\n  interpreter.SetInputs({0});\n  interpreter.SetOutputs({1});\n  interpreter.AddNodeWithParameters({0}, {1}, nullptr, 0, nullptr, &reg);\n\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(\n                0, kTfLiteFloat32, \"\", {3}, TfLiteQuantizationParams()),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(\n                1, kTfLiteFloat32, \"\", {3}, TfLiteQuantizationParams()),\n            kTfLiteOk);\n\n  // Configure the input tensor as dynamic.\n  interpreter.tensor(0)->data.raw = nullptr;\n  interpreter.tensor(0)->allocation_type = kTfLiteDynamic;\n\n  ASSERT_EQ(interpreter.ResizeInputTensor(interpreter.inputs()[0], {1, 2, 3}),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_NE(interpreter.tensor(1)->data.raw, nullptr);\n\n  // Reset the output tensor's buffer.\n  interpreter.tensor(1)->data.raw = nullptr;\n\n  // A redundant allocation request should be honored, as the input tensor\n  // was marked dynamic.\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_NE(interpreter.tensor(1)->data.raw, nullptr);\n}\n\nTEST(BasicInterpreter, ResizingTensors) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(1), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({0}), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(\n                0, kTfLiteFloat32, \"\", {3}, TfLiteQuantizationParams()),\n            kTfLiteOk);\n\n  int t = interpreter.inputs()[0];\n  TfLiteTensor* tensor = interpreter.tensor(t);\n\n  ASSERT_EQ(interpreter.ResizeInputTensor(t, {1, 2, 3}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 6 * sizeof(float));\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  tensor->data.f[5] = 0.123f;\n\n  // Changing from kTfLiteArenaRw to kTfLiteDynamic is quite complicate: we need\n  // to unset data.raw, otherwise Realloc will try to free that memory.\n  tensor->data.raw = nullptr;\n  tensor->allocation_type = kTfLiteDynamic;\n\n  ASSERT_EQ(interpreter.ResizeInputTensor(t, {1, 2, 4}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 8 * sizeof(float));\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.ResizeInputTensor(t, {}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 1 * sizeof(float));\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.ResizeInputTensor(t, {0}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 0);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.ResizeInputTensor(t, {1, 2, 0}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 0);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  // TODO(ahentz): We shouldn't have to force reallocation, but\n  // ResizeInputTensor doesn't realloc dynamic tensors. Also note that\n  // TfLiteTensorRealloc(tensor->bytes, tensor) is a no-op.\n  TfLiteTensorRealloc(9 * sizeof(float), tensor);\n  tensor->data.f[7] = 0.123f;\n\n  ASSERT_EQ(interpreter.ResizeInputTensor(t, {2, 2, 4}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 16 * sizeof(float));\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  // TODO(ahentz): We shouldn't have to force reallocation, but\n  // ResizeInputTensor doesn't realloc dynamic tensors. Also note that\n  // TfLiteTensorRealloc(tensor->bytes, tensor) is a no-op.\n  TfLiteTensorRealloc(17 * sizeof(float), tensor);\n  tensor->data.f[15] = 0.123f;\n}\n\nTEST(BasicInterpreter, NoopResizingTensors) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(1), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({0}), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(\n                0, kTfLiteFloat32, \"\", {3}, TfLiteQuantizationParams()),\n            kTfLiteOk);\n\n  int t = interpreter.inputs()[0];\n  TfLiteTensor* tensor = interpreter.tensor(t);\n\n  ASSERT_EQ(interpreter.ResizeInputTensor(t, {1, 2, 3}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 6 * sizeof(float));\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  tensor->data.f[5] = 0.123f;\n\n  // Resizing to the same size should not trigger re-allocation.\n  ASSERT_EQ(interpreter.ResizeInputTensor(t, {1, 2, 3}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 6 * sizeof(float));\n  ASSERT_NE(tensor->data.raw, nullptr);\n  ASSERT_EQ(tensor->data.f[5], 0.123f);\n\n  // Explicitly allocating should be a no-op, as no resize was performed.\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 6 * sizeof(float));\n  ASSERT_NE(tensor->data.raw, nullptr);\n  ASSERT_EQ(tensor->data.f[5], 0.123f);\n}\n\nTEST(BasicInterpreter, ResizingTensorsStrictInvalid) {\n  // Tests ResizeInputTensorStrict where `dims_signature` is not specified.\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(1), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({0}), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(\n                0, kTfLiteFloat32, \"\", {1, 1, 3}, TfLiteQuantizationParams()),\n            kTfLiteOk);\n\n  int t = interpreter.inputs()[0];\n  TfLiteTensor* tensor = interpreter.tensor(t);\n\n  ASSERT_EQ(interpreter.ResizeInputTensorStrict(t, {1, 1, 3}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 3 * sizeof(float));\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  // Invalid becuase `dims_signature` is not specified.\n  ASSERT_EQ(interpreter.ResizeInputTensorStrict(t, {1, 2, 3}), kTfLiteError);\n  EXPECT_EQ(tensor->bytes, 3 * sizeof(float));\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  // Assert that ResizeInputTensor works for this value.\n  ASSERT_EQ(interpreter.ResizeInputTensor(t, {1, 2, 3}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 6 * sizeof(float));\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n}\n\nTEST(BasicInterpreter, ResizingTensorsStrict) {\n  // Tests ResizeInputTensorStrict where `dims_signature` is specified.\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(1), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({0}), kTfLiteOk);\n\n  std::vector<int> dims_signature = {-1, -1, 3};\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(\n                0, kTfLiteFloat32, \"\", {1, 1, 3}, TfLiteQuantizationParams(),\n                false, &dims_signature),\n            kTfLiteOk);\n\n  int t = interpreter.inputs()[0];\n  TfLiteTensor* tensor = interpreter.tensor(t);\n\n  ASSERT_EQ(interpreter.ResizeInputTensorStrict(t, {1, 2, 3}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 6 * sizeof(float));\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.ResizeInputTensorStrict(t, {1, 2, 4}), kTfLiteError);\n  EXPECT_EQ(tensor->bytes, 6 * sizeof(float));\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  // Assert that ResizeInputTensor works for this value.\n  ASSERT_EQ(interpreter.ResizeInputTensor(t, {1, 2, 4}), kTfLiteOk);\n  EXPECT_EQ(tensor->bytes, 8 * sizeof(float));\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n}\n\n// Simple op that does input = output.\nTfLiteRegistration GetPassthroughOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.init = [](TfLiteContext* context, const char*, size_t) -> void* {\n    auto* first_new_tensor = new int;\n    context->AddTensors(context, 2, first_new_tensor);\n    return first_new_tensor;\n  };\n  reg.free = [](TfLiteContext* context, void* buffer) {\n    delete static_cast<int*>(buffer);\n  };\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    auto* first_new_tensor = static_cast<int*>(node->user_data);\n\n    const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n    TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n\n    TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, tensor1, newSize));\n\n    TfLiteIntArrayFree(node->temporaries);\n    node->temporaries = TfLiteIntArrayCreate(2);\n    for (int i = 0; i < 2; ++i) {\n      node->temporaries->data[i] = *(first_new_tensor) + i;\n    }\n\n    auto setup_temporary = [&](int id) {\n      TfLiteTensor* tmp = &context->tensors[id];\n      tmp->type = kTfLiteFloat32;\n      tmp->allocation_type = kTfLiteArenaRw;\n      return context->ResizeTensor(context, tmp,\n                                   TfLiteIntArrayCopy(tensor0->dims));\n    };\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[0]));\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[1]));\n\n    return kTfLiteOk;\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n\n    auto populate = [&](int id) {\n      TfLiteTensor* t = &context->tensors[id];\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        t->data.f[i] = a0->data.f[i];\n      }\n    };\n\n    populate(node->outputs->data[0]);\n    populate(node->temporaries->data[0]);\n    populate(node->temporaries->data[1]);\n    return kTfLiteOk;\n  };\n\n  return reg;\n}\n\nTEST(BasicInterpreter, OneOpInterpreter) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(2), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({1}), kTfLiteOk);\n\n  TfLiteQuantizationParams quantized;\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(0, kTfLiteFloat32, \"in1\",\n                                                     {3}, quantized),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(1, kTfLiteFloat32, \"out0\",\n                                                     {3}, quantized),\n            kTfLiteOk);\n\n  ASSERT_EQ(interpreter.GetInputName(0), \"in1\");\n  ASSERT_EQ(interpreter.GetOutputName(0), \"out0\");\n\n  TfLiteRegistration reg = GetPassthroughOpRegistration();\n\n  ASSERT_EQ(\n      interpreter.AddNodeWithParameters({0}, {1}, nullptr, 0, nullptr, &reg),\n      kTfLiteOk);\n  ASSERT_EQ(interpreter.ResizeInputTensor(0, {3}), kTfLiteOk);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n}\n\nTEST(BasicInterpreter, ReleaseNonPersistentMemory) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(2), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({1}), kTfLiteOk);\n\n  TfLiteQuantizationParams quantized;\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(0, kTfLiteFloat32, \"in1\",\n                                                     {3}, quantized),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(1, kTfLiteFloat32, \"out0\",\n                                                     {3}, quantized),\n            kTfLiteOk);\n\n  TfLiteRegistration reg = GetPassthroughOpRegistration();\n\n  ASSERT_EQ(\n      interpreter.AddNodeWithParameters({0}, {1}, nullptr, 0, nullptr, &reg),\n      kTfLiteOk);\n  ASSERT_EQ(interpreter.ResizeInputTensor(0, {3}), kTfLiteOk);\n\n  // AllocateTensors() hasn't been called yet, so this should be a no-op.\n  ASSERT_EQ(interpreter.ReleaseNonPersistentMemory(), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.ReleaseNonPersistentMemory(), kTfLiteOk);\n  // Invoke() now fails because non-persistent arenas have been released.\n  ASSERT_NE(interpreter.Invoke(), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n\n  // ResizeInputTensors just after ReleaseNonPersistentMemory should also need\n  // AllocateTensors, without causing any unexpected crashes.\n  ASSERT_EQ(interpreter.ReleaseNonPersistentMemory(), kTfLiteOk);\n  ASSERT_EQ(interpreter.ResizeInputTensor(0, {4}), kTfLiteOk);\n  ASSERT_NE(interpreter.Invoke(), kTfLiteOk);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n}\n\n// Forcefully divides tensor allocation in three steps: one before invocation\n// and two more at invocation time. This happens because we use string tensors\n// and their sizes can't be determined until invocation time.\nTEST(BasicInterpreter, ThreeStepAllocate) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(5), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({4}), kTfLiteOk);\n\n  TfLiteQuantizationParams quantized;\n\n  // String tensor with one string of length 3\n  union {\n    char raw_bytes[15];\n    struct {\n      int32_t num_strs;\n      int32_t offsets[2];\n      char str_data[3];\n    } tensor_data;\n  } data;\n  data.tensor_data = {1, {12, 15}, {'A', 'B', 'C'}};\n\n  // Read only string tensor.\n  ASSERT_EQ(interpreter.SetTensorParametersReadOnly(0, kTfLiteString, \"\", {1},\n                                                    quantized, data.raw_bytes,\n                                                    sizeof(data.raw_bytes)),\n            kTfLiteOk);\n  // Read-write string tensor.\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(1, kTfLiteString, \"\", {1},\n                                                     quantized),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(2, kTfLiteInt32, \"\", {1},\n                                                     quantized),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(3, kTfLiteString, \"\", {1},\n                                                     quantized),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(4, kTfLiteInt32, \"\", {1},\n                                                     quantized),\n            kTfLiteOk);\n\n  // String-in String-out node.\n  TfLiteRegistration reg_copy = {nullptr, nullptr, nullptr, nullptr};\n  reg_copy.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* input = GetInput(context, node, 0);\n    TfLiteTensor* output = GetOutput(context, node, 0);\n    DynamicBuffer buf;\n    StringRef str_ref = GetString(input, 0);\n    buf.AddString(str_ref);\n    buf.WriteToTensorAsVector(output);\n    return kTfLiteOk;\n  };\n\n  // String-in Int-out node.\n  TfLiteRegistration reg_len = {nullptr, nullptr, nullptr, nullptr};\n  reg_len.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    TfLiteTensor* output = GetOutput(context, node, 0);\n    TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n    outputSize->data[0] = 1;\n    return context->ResizeTensor(context, output, outputSize);\n  };\n  reg_len.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    TfLiteTensor* a1 = GetOutput(context, node, 0);\n    a1->data.i32[0] = a0->bytes;\n    return kTfLiteOk;\n  };\n\n  ASSERT_EQ(interpreter.AddNodeWithParameters({0}, {1}, nullptr, 0, nullptr,\n                                              &reg_copy),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AddNodeWithParameters({1}, {2}, nullptr, 0, nullptr,\n                                              &reg_len),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AddNodeWithParameters({0}, {3}, nullptr, 0, nullptr,\n                                              &reg_copy),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AddNodeWithParameters({3}, {4}, nullptr, 0, nullptr,\n                                              &reg_len),\n            kTfLiteOk);\n\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n\n  ASSERT_EQ(interpreter.tensor(0)->bytes, 15);\n  ASSERT_NE(interpreter.tensor(0)->data.raw, nullptr);\n  ASSERT_EQ(interpreter.tensor(1)->bytes, 15);\n  ASSERT_NE(interpreter.tensor(1)->data.raw, nullptr);\n  ASSERT_EQ(interpreter.tensor(3)->bytes, 15);\n  ASSERT_NE(interpreter.tensor(4)->data.raw, nullptr);\n  ASSERT_EQ(interpreter.tensor(2)->bytes, 4);\n  ASSERT_EQ(interpreter.tensor(2)->data.i32[0], 15);\n  ASSERT_EQ(interpreter.tensor(4)->bytes, 4);\n  ASSERT_EQ(interpreter.tensor(4)->data.i32[0], 15);\n}\n\nTEST(BasicInterpreter, AllocateTwice) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(2), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({1}), kTfLiteOk);\n\n  TfLiteQuantizationParams quantized;\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(0, kTfLiteFloat32, \"\", {3},\n                                                     quantized),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.SetTensorParametersReadWrite(1, kTfLiteFloat32, \"\", {3},\n                                                     quantized),\n            kTfLiteOk);\n\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n    TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n    TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n    return context->ResizeTensor(context, tensor1, newSize);\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    TfLiteTensor* a1 = GetOutput(context, node, 0);\n    int num = a0->dims->data[0];\n    for (int i = 0; i < num; i++) {\n      a1->data.f[i] = a0->data.f[i];\n    }\n    return kTfLiteOk;\n  };\n  ASSERT_EQ(\n      interpreter.AddNodeWithParameters({0}, {1}, nullptr, 0, nullptr, &reg),\n      kTfLiteOk);\n  ASSERT_EQ(interpreter.ResizeInputTensor(0, {3}), kTfLiteOk);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n  char* old_tensor0_ptr = interpreter.tensor(0)->data.raw;\n  char* old_tensor1_ptr = interpreter.tensor(1)->data.raw;\n\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n  ASSERT_EQ(old_tensor0_ptr, interpreter.tensor(0)->data.raw);\n  ASSERT_EQ(old_tensor1_ptr, interpreter.tensor(1)->data.raw);\n}\n\nTEST(BasicInterpreter, TestNullErrorReporter) {\n  TestErrorReporter reporter;\n  Interpreter interpreter;\n}\n\nTEST(BasicInterpreter, TestCustomErrorReporter) {\n  TestErrorReporter reporter;\n  Interpreter interpreter(&reporter);\n  ASSERT_NE(interpreter.Invoke(), kTfLiteOk);\n  ASSERT_EQ(reporter.error_messages(),\n            \"Invoke called on model that is not ready.\");\n  ASSERT_EQ(reporter.num_calls(), 1);\n}\n\nTEST(BasicInterpreter, TestOverflow) {\n  TestErrorReporter reporter;\n  Interpreter interpreter(&reporter);\n  TfLiteQuantizationParams quantized;\n\n  ASSERT_EQ(interpreter.AddTensors(1), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({0}), kTfLiteOk);\n  // Overflow testing is pointer word size dependent.\n  if (sizeof(size_t) == 8) {\n    // #bits for bytecount = 30 + 30 + 2 = 62 < 64\n    ASSERT_EQ(interpreter.SetTensorParametersReadWrite(\n                  0, kTfLiteFloat32, \"in1\", {1 << 30, 1 << 30}, quantized),\n              kTfLiteOk);\n    // #bits for element count = 30 + 30 + 2 = 62 < 64 (no overflow)\n    // #bits for byte count = 30 + 30 + 2 + 2 = 64 == 64 (overflow)\n    ASSERT_NE(\n        interpreter.SetTensorParametersReadWrite(\n            0, kTfLiteFloat32, \"in1\", {1 << 30, 1 << 30, 1 << 2}, quantized),\n        kTfLiteOk);\n    EXPECT_THAT(\n        reporter.error_messages(),\n        testing::EndsWith(\"BytesRequired number of bytes overflowed.\\n\"));\n    // #bits for element count = 30 + 30 + 2 + 4 = 66 > 64 (overflow).\n    // #bits for byte count = 30 + 30 + 2 + 4 + 2 = 68 > 64 (overflow).\n    reporter.Reset();\n    ASSERT_NE(interpreter.SetTensorParametersReadWrite(\n                  0, kTfLiteFloat32, \"in1\", {1 << 30, 1 << 30, 1 << 2, 1 << 4},\n                  quantized),\n              kTfLiteOk);\n    EXPECT_THAT(\n        reporter.error_messages(),\n        testing::EndsWith(\"BytesRequired number of elements overflowed.\\n\"));\n\n  } else if (sizeof(size_t) == 4) {\n    // #bits for bytecount = 14 + 14 + 2 = 30 < 32\n    ASSERT_EQ(interpreter.SetTensorParametersReadWrite(\n                  0, kTfLiteFloat32, \"in1\", {1 << 14, 1 << 14}, quantized),\n              kTfLiteOk);\n    // #bits for element count = 14 + 14 + 3 = 31 < 32 (no overflow).\n    // #bits for byte count = 14 + 14 + 3 + 2 = 33 > 32 (overflow).\n    ASSERT_NE(\n        interpreter.SetTensorParametersReadWrite(\n            0, kTfLiteFloat32, \"in1\", {1 << 14, 1 << 14, 1 << 3}, quantized),\n        kTfLiteOk);\n    EXPECT_THAT(\n        reporter.error_messages(),\n        testing::EndsWith(\"BytesRequired number of bytes overflowed.\\n\"));\n    // #bits for element count = 14 + 14 + 4 = 32 == 32 (overflow).\n    // byte count also overflows, but we don't get to that check.\n    reporter.Reset();\n    ASSERT_NE(\n        interpreter.SetTensorParametersReadWrite(\n            0, kTfLiteFloat32, \"in1\", {1 << 14, 1 << 14, 1 << 4}, quantized),\n        kTfLiteOk);\n    EXPECT_THAT(\n        reporter.error_messages(),\n        testing::EndsWith(\"BytesRequired number of elements overflowed.\\n\"));\n  } else {\n    // This test failing means that we are using a non 32/64 bit architecture.\n    ASSERT_TRUE(false);\n  }\n}\n\nTEST(BasicInterpreter, TestUseNNAPI) {\n  TestErrorReporter reporter;\n  Interpreter interpreter(&reporter);\n  interpreter.UseNNAPI(true);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n  interpreter.UseNNAPI(false);\n  ASSERT_EQ(reporter.error_messages(),\n            \"Attempting to disable NNAPI delegate after it's applied.\");\n}\n\nTEST(BasicInterpreter, TestUnsupportedDelegateFunctions) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(2), kTfLiteOk);\n  TfLiteRegistration registration = {nullptr, nullptr, nullptr, nullptr};\n  // These functions are only supported inside Delegate's Prepare function.\n  // The test verifies that these functions returns `kTfLiteError`, but not\n  // `kTfLiteOk` or just crashes.\n  registration.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    {\n      TfLiteIntArray* execution_plan;\n      EXPECT_EQ(context->GetExecutionPlan(context, &execution_plan),\n                kTfLiteError);\n    }\n    {\n      TfLiteNode* node;\n      TfLiteRegistration* registration;\n      EXPECT_EQ(\n          context->GetNodeAndRegistration(context, 0, &node, &registration),\n          kTfLiteError);\n    }\n    {\n      TfLiteRegistration delegate_registration = {nullptr, nullptr, nullptr,\n                                                  nullptr};\n      TfLiteIntArray nodes_to_replace;\n      nodes_to_replace.size = 0;\n      EXPECT_EQ(context->ReplaceNodeSubsetsWithDelegateKernels(\n                    context, delegate_registration, &nodes_to_replace, nullptr),\n                kTfLiteError);\n    }\n    return kTfLiteError;\n  };\n  ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.SetOutputs({0}), kTfLiteOk);\n  ASSERT_EQ(interpreter.AddNodeWithParameters({0}, {1}, nullptr, 0, nullptr,\n                                              &registration),\n            kTfLiteOk);\n  EXPECT_EQ(interpreter.AllocateTensors(), kTfLiteError);\n}\n\nTEST(BasicInterpreter, DynamicTensorsResizeDescendants) {\n  // Assemble a graph with a node that has dynamically sized output (via the\n  // pad op), followed by a node with a standard element-wise op (negate).\n  Interpreter interpreter;\n  interpreter.AddTensors(4);\n  interpreter.SetInputs({0, 1});\n  interpreter.SetOutputs({3});\n  TfLiteQuantizationParams quant;\n  interpreter.SetTensorParametersReadWrite(0, kTfLiteFloat32, \"\", {2, 2, 1, 1},\n                                           quant);\n  interpreter.SetTensorParametersReadWrite(1, kTfLiteInt32, \"\", {4, 2}, quant);\n  interpreter.SetTensorParametersReadWrite(2, kTfLiteFloat32, \"\", {}, quant);\n  interpreter.SetTensorParametersReadWrite(3, kTfLiteFloat32, \"\", {}, quant);\n\n  TfLiteRegistration* pad_op = tflite::ops::builtin::Register_PADV2();\n  TfLiteRegistration* neg_op = tflite::ops::builtin::Register_NEG();\n  interpreter.AddNodeWithParameters({0, 1}, {2}, nullptr, 0, nullptr, pad_op);\n  interpreter.AddNodeWithParameters({2}, {3}, nullptr, 0, nullptr, neg_op);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n\n  // Configure [[2,2],[4,4]] padding and execute the graph.\n  interpreter.typed_tensor<int>(1)[0] = 2;\n  interpreter.typed_tensor<int>(1)[1] = 2;\n  interpreter.typed_tensor<int>(1)[2] = 2;\n  interpreter.typed_tensor<int>(1)[3] = 2;\n  interpreter.typed_tensor<int>(1)[4] = 0;\n  interpreter.typed_tensor<int>(1)[5] = 0;\n  interpreter.typed_tensor<int>(1)[6] = 0;\n  interpreter.typed_tensor<int>(1)[7] = 0;\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n\n  // Both the output and intermediate tensor sizes should reflect the output\n  // from the dynamic pad operation.\n  ASSERT_EQ(interpreter.tensor(2)->bytes, sizeof(float) * 6 * 6);\n  ASSERT_EQ(interpreter.tensor(3)->bytes, sizeof(float) * 6 * 6);\n\n  // Now configure [[4,4],[6,6]] padding and execute the graph.\n  interpreter.typed_tensor<int>(1)[0] = 4;\n  interpreter.typed_tensor<int>(1)[1] = 4;\n  interpreter.typed_tensor<int>(1)[2] = 6;\n  interpreter.typed_tensor<int>(1)[3] = 6;\n  interpreter.typed_tensor<int>(1)[4] = 0;\n  interpreter.typed_tensor<int>(1)[5] = 0;\n  interpreter.typed_tensor<int>(1)[6] = 0;\n  interpreter.typed_tensor<int>(1)[7] = 0;\n  ASSERT_EQ(interpreter.Invoke(), kTfLiteOk);\n\n  // Again, the output and intermediate tensor sizes should reflect the *new*\n  // resize from the latest pad operation.\n  ASSERT_EQ(interpreter.tensor(2)->bytes, sizeof(float) * 10 * 14);\n  ASSERT_EQ(interpreter.tensor(3)->bytes, sizeof(float) * 10 * 14);\n}\n\nTEST(InterpreterTensorsCapacityTest, TestWithinHeadroom) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(Interpreter::kTensorsReservedCapacity),\n            kTfLiteOk);\n  TfLiteRegistration registration = {nullptr, nullptr, nullptr, nullptr};\n  registration.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    TfLiteTensor* first_tensor = context->tensors;\n\n    int new_tensor_index;\n    context->AddTensors(context, Interpreter::kTensorsCapacityHeadroom,\n                        &new_tensor_index);\n    EXPECT_EQ(first_tensor, context->tensors);\n    return kTfLiteOk;\n  };\n  ASSERT_EQ(interpreter.AddNodeWithParameters({0}, {1}, nullptr, 0, nullptr,\n                                              &registration),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n}\n\nTEST(InterpreterTensorsCapacityTest, TestExceedHeadroom) {\n  Interpreter interpreter;\n  ASSERT_EQ(interpreter.AddTensors(Interpreter::kTensorsReservedCapacity),\n            kTfLiteOk);\n  TfLiteRegistration registration = {nullptr, nullptr, nullptr, nullptr};\n  registration.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    TfLiteTensor* first_tensor = context->tensors;\n\n    int new_tensor_index;\n    // Add enough tensors to trigger buffer re-allocation.\n    context->AddTensors(\n        context,\n        (context->tensors_size + Interpreter::kTensorsCapacityHeadroom + 1) * 2,\n        &new_tensor_index);\n    EXPECT_NE(first_tensor, context->tensors);\n    return kTfLiteOk;\n  };\n  ASSERT_EQ(interpreter.AddNodeWithParameters({0}, {1}, nullptr, 0, nullptr,\n                                              &registration),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter.AllocateTensors(), kTfLiteOk);\n}\n\nstruct TestExternalContext : public TfLiteExternalContext {\n  static constexpr TfLiteExternalContextType kType = kTfLiteGemmLowpContext;\n\n  static TestExternalContext* Get(TfLiteContext* context) {\n    return reinterpret_cast<TestExternalContext*>(\n        context->GetExternalContext(context, kType));\n  }\n\n  static void Set(TfLiteContext* context, TestExternalContext* value) {\n    context->SetExternalContext(context, kType, value);\n  }\n\n  int num_refreshes = 0;\n};\n\nTEST_F(InterpreterTest, GetSetResetExternalContexts) {\n  auto* context = GetInterpreterContext();\n\n  TestExternalContext external_context;\n  external_context.Refresh = [](TfLiteContext* context) {\n    auto* ptr = TestExternalContext::Get(context);\n    if (ptr != nullptr) {\n      ++ptr->num_refreshes;\n    }\n    return kTfLiteOk;\n  };\n\n  EXPECT_EQ(TestExternalContext::Get(context), nullptr);\n  ASSERT_EQ(interpreter_.SetNumThreads(4), kTfLiteOk);\n\n  TestExternalContext::Set(context, &external_context);\n  EXPECT_EQ(TestExternalContext::Get(context), &external_context);\n  ASSERT_EQ(interpreter_.SetNumThreads(4), kTfLiteOk);\n  ASSERT_EQ(interpreter_.SetNumThreads(5), kTfLiteOk);\n  EXPECT_EQ(external_context.num_refreshes, 2);\n\n  // Reset refresh count to 0\n  external_context.num_refreshes = 0;\n  // Below should not call external context refresh\n  ASSERT_EQ(interpreter_.SetNumThreads(-2), kTfLiteError);\n  EXPECT_EQ(external_context.num_refreshes, 0);\n\n  ASSERT_EQ(interpreter_.SetNumThreads(-1), kTfLiteOk);\n  EXPECT_EQ(external_context.num_refreshes, 1);\n\n  TestExternalContext::Set(context, nullptr);\n  EXPECT_EQ(TestExternalContext::Get(context), nullptr);\n  ASSERT_EQ(interpreter_.SetNumThreads(4), kTfLiteOk);\n}\n\nstruct TestCpuBackendContext : public TfLiteInternalBackendContext {\n  // Count the number of calls to ClearCaches for the backend context.\n  void ClearCaches() override { ++num_calls; }\n  void SetMaxNumThreads(int num_threads) override {}\n  int num_calls = 0;\n};\n\nTEST_F(InterpreterTest, ExternalBackendContextClearsCachesOnDelete) {\n  ExternalCpuBackendContext external_cpu_context;\n  TestCpuBackendContext* cpu_backend_context = new TestCpuBackendContext();\n  external_cpu_context.set_internal_backend_context(\n      std::unique_ptr<TfLiteInternalBackendContext>(cpu_backend_context));\n\n  {\n    // Create an interpreter with an external Cpu backend context and ensure\n    // it goes out of scope.\n    Interpreter interpreter;\n    interpreter.SetExternalContext(kTfLiteCpuBackendContext,\n                                   &external_cpu_context);\n    EXPECT_EQ(cpu_backend_context->num_calls, 0);\n  }\n  EXPECT_EQ(cpu_backend_context->num_calls, 1);\n}\n\n// Test fixture that allows playing with execution plans. It creates a two\n// node graph that can be executed in either [0,1] order or [1,0] order.\n// The CopyOp records when it is invoked in the class member run_order_\n// so we can test whether the execution plan was honored.\nclass TestExecutionPlan : public ::testing::Test {\n  // Encapsulates the node ids and provides them to a C primitive data type\n  // Allocatable with placement new, but never destructed, so make sure this\n  // doesn't own any heap allocated data. This is then is used as op local\n  // data to allow access to the test fixture data.\n  class CallReporting {\n   public:\n    CallReporting(int node_id, std::vector<int>* run_order)\n        : node_id_(node_id), run_order_(run_order) {}\n\n    void Record() { run_order_->push_back(node_id_); }\n\n   private:\n    // The node id for this particular node\n    int node_id_;\n    // A pointer to the global run-order\n    std::vector<int>* run_order_;\n  };\n\n  // Build a kernel registration for an op that copies its one input\n  // to an output\n  TfLiteRegistration CopyOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      // Set output size to input size\n      const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n      TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n      TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n      return context->ResizeTensor(context, tensor1, newSize);\n    };\n\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      CallReporting* call_reporting =\n          static_cast<CallReporting*>(node->builtin_data);\n      // Copy input data to output data.\n      const TfLiteTensor* a0 = GetInput(context, node, 0);\n      TfLiteTensor* a1 = GetOutput(context, node, 0);\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        a1->data.f[i] = a0->data.f[i];\n      }\n      call_reporting->Record();\n      return kTfLiteOk;\n    };\n    return reg;\n  }\n\n  // Adds a copy node going from tensor `input` to output tensor `output`.\n  // Note, input is used as the node_id. Inject run_order as op accessible\n  // data. Note: this is a little strange of a way to do this, but it is\n  // using op functionality to avoid static global variables.\n  void MakeCopyNode(int input, int output) {\n    // Ownership of call_reporting is taken by interpreter (malloc is used due\n    // to nodes being a C99 interface so free() is used).\n    TfLiteRegistration copy_op = CopyOpRegistration();\n    CallReporting* call_reporting_1 =\n        static_cast<CallReporting*>(malloc(sizeof(CallReporting)));\n    new (call_reporting_1) CallReporting(input, &run_order_);\n    ASSERT_EQ(interpreter_.AddNodeWithParameters(\n                  {0}, {2}, nullptr, 0, static_cast<void*>(call_reporting_1),\n                  &copy_op),\n              kTfLiteOk);\n    ASSERT_EQ(interpreter_.ResizeInputTensor(input, {3}), kTfLiteOk);\n  }\n\n  void SetUp() final {\n    // Add two inputs and two outputs that don't depend on each other\n    ASSERT_EQ(interpreter_.AddTensors(4), kTfLiteOk);\n    interpreter_.SetInputs({0, 1});\n    interpreter_.SetOutputs({2, 3});\n    TfLiteQuantizationParams quantized;\n    for (int tensor_index = 0; tensor_index < 4; tensor_index++) {\n      ASSERT_EQ(interpreter_.SetTensorParametersReadWrite(\n                    tensor_index, kTfLiteFloat32, \"\", {3}, quantized),\n                kTfLiteOk);\n    }\n\n    // Define two copy functions that also use the user_data to report that\n    // they were called.\n    // i.e. tensor[2] = copy(tensor[0]); tensor[3] = copy(tensor[1]);\n    // thus we can reorder the two nodes arbitrary and still satisfy dependency\n    // order.\n    MakeCopyNode(0, 2);\n    MakeCopyNode(1, 3);\n\n    ASSERT_EQ(interpreter_.AllocateTensors(), kTfLiteOk);\n  }\n\n protected:\n  Interpreter interpreter_;\n\n  // list of node_ids that were run\n  std::vector<int> run_order_;\n};\n\nTEST_F(TestExecutionPlan, DefaultExecutionPlan) {\n  // Check default order\n  ASSERT_EQ(interpreter_.Invoke(), kTfLiteOk);\n  ASSERT_EQ(run_order_, std::vector<int>({0, 1}));\n}\n\nTEST_F(TestExecutionPlan, ReversedExecutionPlan) {\n  // Check reversed order\n  interpreter_.SetExecutionPlan({1, 0});\n  ASSERT_EQ(interpreter_.Invoke(), kTfLiteOk);\n  ASSERT_EQ(run_order_, std::vector<int>({1, 0}));\n}\n\nTEST_F(TestExecutionPlan, SubsetExecutionPlan) {\n  // Check running only node index 1\n  interpreter_.SetExecutionPlan({1});\n  ASSERT_EQ(interpreter_.Invoke(), kTfLiteOk);\n  ASSERT_EQ(run_order_, std::vector<int>({1}));\n}\n\nTEST_F(TestExecutionPlan, NullExecutionPlan) {\n  // Check nothing executed.\n  interpreter_.SetExecutionPlan({});\n  ASSERT_EQ(interpreter_.Invoke(), kTfLiteOk);\n  ASSERT_EQ(run_order_, std::vector<int>());\n}\n\nTEST(TestDelegateOwnership, ProperlyDisposed) {\n  struct TfLiteInterpreterOwnedDelegate : public TfLiteDelegate {\n    TfLiteInterpreterOwnedDelegate(bool* destroyed, bool* prepared)\n        : destroyed(destroyed), prepared(prepared) {\n      flags = kTfLiteDelegateFlagsNone;\n      Prepare = [](TfLiteContext*, TfLiteDelegate* delegate) -> TfLiteStatus {\n        *static_cast<TfLiteInterpreterOwnedDelegate*>(delegate)->prepared =\n            true;\n        return kTfLiteOk;\n      };\n    }\n    ~TfLiteInterpreterOwnedDelegate() { *destroyed = true; }\n\n    bool* destroyed;\n    bool* prepared;\n  };\n\n  // Construct a delegate with flags for indicating preparation/destruction.\n  bool destroyed = false;\n  bool prepared = false;\n  std::unique_ptr<TfLiteInterpreterOwnedDelegate> delegate(\n      new TfLiteInterpreterOwnedDelegate(&destroyed, &prepared));\n  {\n    // Create an interpreter and assemble a simple graph.\n    Interpreter interpreter;\n    TfLiteRegistration registration = {nullptr, nullptr, nullptr, nullptr};\n    ASSERT_EQ(interpreter.AddTensors(2), kTfLiteOk);\n    ASSERT_EQ(interpreter.SetInputs({0}), kTfLiteOk);\n    ASSERT_EQ(interpreter.SetOutputs({1}), kTfLiteOk);\n    ASSERT_EQ(interpreter.AddNodeWithParameters({0}, {1}, nullptr, 0, nullptr,\n                                                &registration),\n              kTfLiteOk);\n\n    // Pass delegate ownership to that interpreter.\n    ASSERT_EQ(InterpreterTest::ModifyGraphWithDelegate(&interpreter,\n                                                       std::move(delegate)),\n              kTfLiteOk);\n\n    // The delegate should be prepared as normal, and should be preserved.\n    EXPECT_TRUE(prepared);\n    EXPECT_FALSE(destroyed);\n\n    // Interpreter interaction should not impact the delegate's validity.\n    interpreter.AllocateTensors();\n    interpreter.Invoke();\n    EXPECT_FALSE(destroyed);\n  }\n\n  // Only after the interpreter is destroyed should the delegate be destroyed.\n  EXPECT_TRUE(destroyed);\n}\n\n// CancellationData contains the data required to cancel a call to Invoke().\nstruct CancellationData {\n  bool is_cancelled = false;\n};\n\n// Indicates whether Invoke() has been cancelled based on the value of the\n// CancellationData object passed in.\nbool CheckCancellation(void* data) {\n  CancellationData* cancellation_data =\n      static_cast<struct CancellationData*>(data);\n  return cancellation_data->is_cancelled;\n}\n\nstatic struct CancellationData cancellation_data_;\n\n// Test fixture to test cancellation within the Interpreter.\nclass CancellationTest : public ::testing::Test {\n public:\n  TfLiteStatus Invoke() { return interpreter_.Invoke(); }\n  void Cancel() { cancellation_data_.is_cancelled = true; }\n\n  // Adds an CancelOp with input tensor `input` and output tensor `output`.\n  void MakeCancelNode(int input, int output) {\n    TfLiteRegistration op = CancelOpRegistration();\n    ASSERT_EQ(interpreter_.AddNodeWithParameters({input}, {output}, nullptr, 0,\n                                                 nullptr, &op),\n              kTfLiteOk);\n    ASSERT_EQ(interpreter_.ResizeInputTensor(input, {3}), kTfLiteOk);\n  }\n\n  // Adds an OkOp with input tensor `input` and output tensor `output`.\n  void MakeOkNode(int input, int output) {\n    TfLiteRegistration op = OkOpRegistration();\n    ASSERT_EQ(interpreter_.AddNodeWithParameters({input}, {output}, nullptr, 0,\n                                                 nullptr, &op),\n              kTfLiteOk);\n    ASSERT_EQ(interpreter_.ResizeInputTensor(input, {3}), kTfLiteOk);\n  }\n\n  Interpreter interpreter_;\n\n private:\n  // Build the kernel registration for an op that cancels the operation.\n  TfLiteRegistration CancelOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n\n    // Set output size to the input size in CancelOp::Prepare(). Code exists to\n    // have a framework in Prepare. The input and output tensors are not used.\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      cancellation_data_.is_cancelled = true;\n      return kTfLiteOk;\n    };\n    return reg;\n  }\n\n  // Build the kernel registration for an op that returns kTfLiteOk.\n  TfLiteRegistration OkOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n\n    // Set output size to the input size in OkOp::Prepare(). Code exists to have\n    // a framework in Prepare. The input and output tensors are not used.\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      return kTfLiteOk;\n    };\n    return reg;\n  }\n\n  void SetUp() final {\n    cancellation_data_.is_cancelled = false;\n\n    // Set up the interpreter. Create the input and output tensors.\n    int num_tensors = 3;\n    ASSERT_EQ(interpreter_.AddTensors(num_tensors), kTfLiteOk);\n    interpreter_.SetInputs({0});\n    interpreter_.SetOutputs({2});\n    TfLiteQuantizationParams quantized;\n    for (int tensor_index = 0; tensor_index < num_tensors; tensor_index++) {\n      ASSERT_EQ(interpreter_.SetTensorParametersReadWrite(\n                    tensor_index, kTfLiteFloat32, \"\", {3}, quantized),\n                kTfLiteOk);\n    }\n    interpreter_.SetCancellationFunction(&cancellation_data_,\n                                         &CheckCancellation);\n  }\n};\n\nTEST_F(CancellationTest, CancelBeforeInvoke) {\n  // Cancel prior to calling Invoke.\n  CancellationTest::MakeOkNode(1, 2);\n  ASSERT_EQ(interpreter_.AllocateTensors(), kTfLiteOk);\n\n  CancellationTest::Cancel();\n  TfLiteStatus invoke_error_code = CancellationTest::Invoke();\n  ASSERT_EQ(invoke_error_code, kTfLiteError);\n}\n\nTEST_F(CancellationTest, CancelDuringInvoke) {\n  // Tests a model which sets the cancel in order to test cancellation works\n  // between ops.\n  //\n  // The first op will set the cancellation bit to true. The second op returns\n  // `kTfLiteOk` if executed.\n  CancellationTest::MakeCancelNode(0, 1);\n  CancellationTest::MakeOkNode(1, 2);\n  ASSERT_EQ(interpreter_.AllocateTensors(), kTfLiteOk);\n\n  TfLiteStatus invoke_error_code = CancellationTest::Invoke();\n  ASSERT_EQ(invoke_error_code, kTfLiteError);\n}\n\n// Tests functionality related to custom memory allocations in TFLite.\nclass TestCustomAllocation : public ::testing::Test {\n protected:\n  void SetUp() override {\n    // Simple model with two custom ops that add 2 float tensors each.\n    interpreter_.reset(new Interpreter);\n    interpreter_->AddTensors(7);\n    interpreter_->SetInputs({0, 1});\n    interpreter_->SetOutputs({3, 4, 6});\n    TfLiteQuantizationParams quant;\n    interpreter_->SetTensorParametersReadWrite(0, kTfLiteFloat32, \"\", {3},\n                                               quant);\n    interpreter_->SetTensorParametersReadWrite(1, kTfLiteFloat32, \"\", {3},\n                                               quant);\n    interpreter_->SetTensorParametersReadWrite(2, kTfLiteFloat32, \"\", {3},\n                                               quant);\n    interpreter_->SetTensorParametersReadWrite(3, kTfLiteFloat32, \"\", {3},\n                                               quant);\n    interpreter_->SetTensorParametersReadWrite(4, kTfLiteFloat32, \"\", {3},\n                                               quant);\n    interpreter_->SetTensorParametersReadWrite(5, kTfLiteFloat32, \"\", {3},\n                                               quant, /*is_variable=*/true);\n    interpreter_->SetTensorParametersReadWrite(6, kTfLiteFloat32, \"\", {3},\n                                               quant);\n    auto* add_reg = ops::builtin::Register_ADD();\n    TfLiteAddParams* builtin_data0 =\n        reinterpret_cast<TfLiteAddParams*>(malloc(sizeof(TfLiteAddParams)));\n    TfLiteAddParams* builtin_data1 =\n        reinterpret_cast<TfLiteAddParams*>(malloc(sizeof(TfLiteAddParams)));\n    TfLiteAddParams* builtin_data2 =\n        reinterpret_cast<TfLiteAddParams*>(malloc(sizeof(TfLiteAddParams)));\n    TfLiteAddParams* builtin_data3 =\n        reinterpret_cast<TfLiteAddParams*>(malloc(sizeof(TfLiteAddParams)));\n    builtin_data0->activation = kTfLiteActNone;\n    builtin_data1->activation = kTfLiteActNone;\n    builtin_data2->activation = kTfLiteActNone;\n    builtin_data3->activation = kTfLiteActNone;\n    interpreter_->AddNodeWithParameters({0, 0}, {2}, nullptr, 0, builtin_data0,\n                                        add_reg);\n    interpreter_->AddNodeWithParameters({1, 1}, {3}, nullptr, 0, builtin_data1,\n                                        add_reg);\n    interpreter_->AddNodeWithParameters({2, 1}, {4}, nullptr, 0, builtin_data2,\n                                        add_reg);\n    interpreter_->AddNodeWithParameters({0, 5}, {6}, nullptr, 0, builtin_data3,\n                                        add_reg);\n    interpreter_->SetVariables({5});\n  }\n\n  void AssignCustomAllocForTensor(int tensor_idx, int required_alignment) {\n    const TfLiteTensor* tensor = interpreter_->tensor(tensor_idx);\n    auto tensor_alloc = NewCustomAlloc(tensor->bytes, required_alignment);\n    ASSERT_EQ(\n        interpreter_->SetCustomAllocationForTensor(tensor_idx, tensor_alloc),\n        kTfLiteOk);\n  }\n\n  void VerifyInvoke() {\n    std::vector<float> input = {1.0f, 2.0f, 3.0f};\n    std::vector<float> variable = {0.0f, 1.0f, 2.0f};\n    std::vector<float> expected_output = {2.0f, 4.0f, 6.0f};\n\n    // typed_tensor<...> should work irrespective of custom alloc, since it\n    // accesses output_tensor.data.\n    memcpy(interpreter_->typed_tensor<float>(interpreter_->variables()[0]),\n           variable.data(), 3 * sizeof(float));\n    memcpy(interpreter_->typed_tensor<float>(0), input.data(),\n           3 * sizeof(float));\n    memcpy(interpreter_->typed_tensor<float>(1), input.data(),\n           3 * sizeof(float));\n    ASSERT_EQ(interpreter_->Invoke(), kTfLiteOk);\n    TfLiteTensor* output_tensor =\n        interpreter_->tensor(interpreter_->outputs()[0]);\n    for (int i = 0; i < 3; ++i) {\n      EXPECT_EQ(output_tensor->data.f[i], expected_output[i]) << i;\n    }\n  }\n\n  // Actual initialized allocation is more than num_bytes, to account for\n  // required_allocation.\n  TfLiteCustomAllocation NewCustomAlloc(size_t num_bytes,\n                                        int required_alignment) {\n    // Extra memory to ensure alignment.\n    char* new_alloc = new char[num_bytes + required_alignment];\n    char* new_underlying_buffer_aligned_ptr = reinterpret_cast<char*>(\n        AlignTo(required_alignment, reinterpret_cast<intptr_t>(new_alloc)));\n    custom_alloc_buffers_.emplace_back(new_alloc);\n\n    return TfLiteCustomAllocation(\n        {new_underlying_buffer_aligned_ptr, num_bytes});\n  }\n\n  intptr_t AlignTo(size_t alignment, intptr_t offset) {\n    return offset % alignment == 0 ? offset\n                                   : offset + (alignment - offset % alignment);\n  }\n\n  void TearDown() override {\n    interpreter_.reset();\n    custom_alloc_buffers_.clear();\n  }\n\n protected:\n  TfLiteAddParams add_params_;\n  std::unique_ptr<Interpreter> interpreter_;\n  std::vector<std::unique_ptr<char[]>> custom_alloc_buffers_;\n};\n\nTEST_F(TestCustomAllocation, InvalidAlignment) {\n  const TfLiteTensor* input_tensor =\n      interpreter_->tensor(interpreter_->inputs()[0]);\n  intptr_t dummy_ptr = kDefaultTensorAlignment - 1;\n  TfLiteCustomAllocation input_alloc{reinterpret_cast<void*>(dummy_ptr),\n                                     input_tensor->bytes};\n  ASSERT_EQ(interpreter_->SetCustomAllocationForTensor(\n                interpreter_->inputs()[0], input_alloc),\n            kTfLiteError);\n\n  // Allocate tensors & Invoke should still work.\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n  VerifyInvoke();\n}\n\nTEST_F(TestCustomAllocation, InsufficientBytes) {\n  auto input_alloc = NewCustomAlloc(4, kDefaultTensorAlignment);\n  ASSERT_EQ(interpreter_->SetCustomAllocationForTensor(\n                interpreter_->inputs()[0], input_alloc),\n            kTfLiteError);\n\n  // Allocate tensors & Invoke should still work.\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n  VerifyInvoke();\n}\n\nTEST_F(TestCustomAllocation, CustomInputAlloc) {\n  // Set custom allocation for one input tensor.\n  AssignCustomAllocForTensor(interpreter_->inputs()[0],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n  VerifyInvoke();\n}\n\nTEST_F(TestCustomAllocation, CustomInputAlloc_MultipleAssigns) {\n  // Set custom allocation for one input tensor.\n  AssignCustomAllocForTensor(interpreter_->inputs()[0],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n\n  AssignCustomAllocForTensor(interpreter_->inputs()[0],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n  VerifyInvoke();\n\n  AssignCustomAllocForTensor(interpreter_->inputs()[0],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n  VerifyInvoke();\n}\n\nTEST_F(TestCustomAllocation, CustomInputAlloc_AllocateTensorsBefore) {\n  // Allocate tensors.\n  // Allocating now will cause TFLite to reserve some extra memory, but nothing\n  // should break.\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n\n  AssignCustomAllocForTensor(interpreter_->inputs()[0],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n\n  VerifyInvoke();\n}\n\nTEST_F(TestCustomAllocation, CustomInputAndOutputAllocs) {\n  // Set custom allocations for all IO tensors.\n  AssignCustomAllocForTensor(interpreter_->inputs()[0],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n  AssignCustomAllocForTensor(interpreter_->inputs()[1],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n  AssignCustomAllocForTensor(interpreter_->outputs()[0],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n  AssignCustomAllocForTensor(interpreter_->outputs()[1],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n  VerifyInvoke();\n}\n\n// Ensure that custom allocs work for tensors on persistent arena as well.\nTEST_F(TestCustomAllocation, CustomAlloc_VariableTensor) {\n  // Set custom allocation for one input tensor.\n  AssignCustomAllocForTensor(interpreter_->variables()[0],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n  VerifyInvoke();\n\n  AssignCustomAllocForTensor(interpreter_->variables()[0],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n\n  std::vector<float> input = {2.0f, 3.0f, 4.0f};\n  std::vector<float> variable = {1.0f, 2.0f, 3.0f};\n  std::vector<float> expected_output = {3.0f, 5.0f, 7.0f};\n  memcpy(interpreter_->typed_tensor<float>(interpreter_->variables()[0]),\n         variable.data(), 3 * sizeof(float));\n  memcpy(interpreter_->typed_tensor<float>(0), input.data(), 3 * sizeof(float));\n  memcpy(interpreter_->typed_tensor<float>(1), input.data(), 3 * sizeof(float));\n  ASSERT_EQ(interpreter_->Invoke(), kTfLiteOk);\n\n  // expected_output = input + variable\n  TfLiteTensor* output_tensor =\n      interpreter_->tensor(interpreter_->outputs()[2]);\n  for (int i = 0; i < 3; ++i) {\n    EXPECT_EQ(output_tensor->data.f[i], expected_output[i]) << i;\n  }\n}\n\nTEST_F(TestCustomAllocation, ResizeTensorsWithoutEnoughMemory) {\n  // Set custom allocations for all input tensors.\n  AssignCustomAllocForTensor(interpreter_->inputs()[0],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n  AssignCustomAllocForTensor(interpreter_->inputs()[1],\n                             /*required_alignment=*/kDefaultTensorAlignment);\n\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n\n  // Now resize tensors to double the size.\n  ASSERT_EQ(interpreter_->ResizeInputTensor(interpreter_->inputs()[0], {2, 3}),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter_->ResizeInputTensor(interpreter_->inputs()[1], {2, 3}),\n            kTfLiteOk);\n\n  // Since the custom memory previously allocated isn't enough,\n  // AllocateTensors() will fail.\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteError);\n  // Interpreter should no longer be in invokable state, so expect failure.\n  ASSERT_EQ(interpreter_->Invoke(), kTfLiteError);\n}\n\nTEST_F(TestCustomAllocation, ResizeTensorsWithEnoughMemory) {\n  // Set custom allocations for all input tensors, with double the required\n  // memory.\n  const TfLiteTensor* input0_tensor =\n      interpreter_->tensor(interpreter_->inputs()[0]);\n  auto input0_alloc =\n      NewCustomAlloc(2 * input0_tensor->bytes, kDefaultTensorAlignment);\n  ASSERT_EQ(interpreter_->SetCustomAllocationForTensor(\n                interpreter_->inputs()[0], input0_alloc),\n            kTfLiteOk);\n  const TfLiteTensor* input1_tensor =\n      interpreter_->tensor(interpreter_->inputs()[1]);\n  auto input1_alloc =\n      NewCustomAlloc(2 * input1_tensor->bytes, kDefaultTensorAlignment);\n  ASSERT_EQ(interpreter_->SetCustomAllocationForTensor(\n                interpreter_->inputs()[1], input1_alloc),\n            kTfLiteOk);\n\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n\n  // Now resize tensors to double the size.\n  ASSERT_EQ(interpreter_->ResizeInputTensor(interpreter_->inputs()[0], {6, 1}),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter_->ResizeInputTensor(interpreter_->inputs()[1], {6, 1}),\n            kTfLiteOk);\n\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n\n  std::vector<float> input = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f};\n  std::vector<float> expected_output = {2.0f, 4.0f, 6.0f, 8.0f, 10.0f, 12.0f};\n  TfLiteTensor* tensor = interpreter_->tensor(interpreter_->outputs()[0]);\n  memcpy(interpreter_->typed_tensor<float>(0), input.data(), 6 * sizeof(float));\n  memcpy(interpreter_->typed_tensor<float>(1), input.data(), 6 * sizeof(float));\n  ASSERT_EQ(interpreter_->Invoke(), kTfLiteOk);\n  for (int i = 0; i < 6; ++i) {\n    EXPECT_EQ(tensor->data.f[i], expected_output[i]) << i;\n  }\n\n  ASSERT_EQ(interpreter_->ResizeInputTensor(interpreter_->inputs()[0], {3, 1}),\n            kTfLiteOk);\n  ASSERT_EQ(interpreter_->ResizeInputTensor(interpreter_->inputs()[1], {3, 1}),\n            kTfLiteOk);\n\n  ASSERT_EQ(interpreter_->AllocateTensors(), kTfLiteOk);\n  VerifyInvoke();\n}\n\n}  // namespace\n}  // namespace tflite\n\nint main(int argc, char** argv) {\n  ::tflite::LogToStderr();\n  ::testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}"