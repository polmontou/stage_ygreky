"/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#include <vector>\n\n#include \"flatbuffers/flexbuffers.h\"  // from @flatbuffers\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/kernels/internal/reference/reference_ops.h\"\n#include \"tensorflow/lite/kernels/internal/spectrogram.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace custom {\nnamespace audio_spectrogram {\n\nconstexpr int kInputTensor = 0;\nconstexpr int kOutputTensor = 0;\n\nenum KernelType {\n  kReference,\n};\n\ntypedef struct {\n  int window_size;\n  int stride;\n  bool magnitude_squared;\n  int output_height;\n  internal::Spectrogram* spectrogram;\n} TfLiteAudioSpectrogramParams;\n\nvoid* Init(TfLiteContext* context, const char* buffer, size_t length) {\n  auto* data = new TfLiteAudioSpectrogramParams;\n\n  const uint8_t* buffer_t = reinterpret_cast<const uint8_t*>(buffer);\n\n  const flexbuffers::Map& m = flexbuffers::GetRoot(buffer_t, length).AsMap();\n  data->window_size = m[\"window_size\"].AsInt64();\n  data->stride = m[\"stride\"].AsInt64();\n  data->magnitude_squared = m[\"magnitude_squared\"].AsBool();\n\n  data->spectrogram = new internal::Spectrogram;\n\n  return data;\n}\n\nvoid Free(TfLiteContext* context, void* buffer) {\n  auto* params = reinterpret_cast<TfLiteAudioSpectrogramParams*>(buffer);\n  delete params->spectrogram;\n  delete params;\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteAudioSpectrogramParams*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 2);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, kTfLiteFloat32);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  TF_LITE_ENSURE(context, params->spectrogram->Initialize(params->window_size,\n                                                          params->stride));\n  const int64_t sample_count = input->dims->data[0];\n  const int64_t length_minus_window = (sample_count - params->window_size);\n  if (length_minus_window < 0) {\n    params->output_height = 0;\n  } else {\n    params->output_height = 1 + (length_minus_window / params->stride);\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(3);\n  output_size->data[0] = input->dims->data[1];\n  output_size->data[1] = params->output_height;\n  output_size->data[2] = params->spectrogram->output_frequency_channels();\n\n  return context->ResizeTensor(context, output, output_size);\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteAudioSpectrogramParams*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE(context, params->spectrogram->Initialize(params->window_size,\n                                                          params->stride));\n\n  const float* input_data = GetTensorData<float>(input);\n\n  const int64_t sample_count = input->dims->data[0];\n  const int64_t channel_count = input->dims->data[1];\n\n  const int64_t output_width = params->spectrogram->output_frequency_channels();\n\n  float* output_flat = GetTensorData<float>(output);\n\n  std::vector<float> input_for_channel(sample_count);\n  for (int64_t channel = 0; channel < channel_count; ++channel) {\n    float* output_slice =\n        output_flat + (channel * params->output_height * output_width);\n    for (int i = 0; i < sample_count; ++i) {\n      input_for_channel[i] = input_data[i * channel_count + channel];\n    }\n    std::vector<std::vector<float>> spectrogram_output;\n    TF_LITE_ENSURE(context,\n                   params->spectrogram->ComputeSquaredMagnitudeSpectrogram(\n                       input_for_channel, &spectrogram_output));\n    TF_LITE_ENSURE_EQ(context, spectrogram_output.size(),\n                      params->output_height);\n    TF_LITE_ENSURE(context, spectrogram_output.empty() ||\n                                (spectrogram_output[0].size() == output_width));\n    for (int row_index = 0; row_index < params->output_height; ++row_index) {\n      const std::vector<float>& spectrogram_row = spectrogram_output[row_index];\n      TF_LITE_ENSURE_EQ(context, spectrogram_row.size(), output_width);\n      float* output_row = output_slice + (row_index * output_width);\n      if (params->magnitude_squared) {\n        for (int i = 0; i < output_width; ++i) {\n          output_row[i] = spectrogram_row[i];\n        }\n      } else {\n        for (int i = 0; i < output_width; ++i) {\n          output_row[i] = sqrtf(spectrogram_row[i]);\n        }\n      }\n    }\n  }\n  return kTfLiteOk;\n}\n\n}  // namespace audio_spectrogram\n\nTfLiteRegistration* Register_AUDIO_SPECTROGRAM() {\n  static TfLiteRegistration r = {\n      audio_spectrogram::Init, audio_spectrogram::Free,\n      audio_spectrogram::Prepare,\n      audio_spectrogram::Eval<audio_spectrogram::kReference>};\n  return &r;\n}\n\n}  // namespace custom\n}  // namespace ops\n}  // namespace tflite"