"/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/lite/kernels/internal/reference/batch_matmul.h\"\n\n#include <stddef.h>\n\n#include <algorithm>\n#include <cstdint>\n#include <limits>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/cpu_backend_context.h\"\n#include \"tensorflow/lite/kernels/internal/compatibility.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/batch_matmul.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/kernels/internal/reference/reference_ops.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_utils.h\"\n#include \"tensorflow/lite/kernels/internal/types.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace batch_matmul {\n\nstatic const int kInputLHSTensor = 0;\nstatic const int kInputRHSTensor = 1;\nstatic const int kOutputTensor = 0;\n\nstatic const int kNumTempTensorsForAdjoints = 2;\nstatic const int kNumTempTensorsForHybrid = 5;\n\n// This file has two implementations of Transpose.\nenum KernelType {\n  kReference,\n  kGenericOptimized,\n};\n\nstruct OpData {\n  // The scaling factor from input to output (aka the 'real multiplier') can\n  // be represented as a fixed point multiplier plus a left shift.\n  int32_t output_multiplier;\n  int output_shift;\n  // The range of the fused activation layer. For example for kNone and\n  // uint8_t these would be 0 and 255.\n  int32_t output_activation_min;\n  int32_t output_activation_max;\n  // The index of the temporary tensors where we store transposed LHS/RHS.\n  int scratch_tensor_index;\n  bool rhs_transposed;\n  bool compute_row_sums = false;\n};\n\nstruct OpContext {\n  OpContext(TfLiteContext* context, TfLiteNode* node) {\n    params = reinterpret_cast<TfLiteBatchMatMulParams*>(node->builtin_data);\n    lhs = GetInput(context, node, kInputLHSTensor);\n    rhs = GetInput(context, node, kInputRHSTensor);\n    output = GetOutput(context, node, 0);\n  }\n  TfLiteBatchMatMulParams* params;\n  const TfLiteTensor* lhs;\n  const TfLiteTensor* rhs;\n  TfLiteTensor* output;\n};\n\nvoid* Init(TfLiteContext* context, const char* buffer, size_t length) {\n  auto* op_data = new OpData();\n  // If the RHS is constant, we only transpose once.\n  op_data->rhs_transposed = false;\n  // Creates the temp tensors to store the transposed LHS and/or RHS, and\n  // extra buffers for the quantized case.\n  context->AddTensors(context,\n                      kNumTempTensorsForAdjoints + kNumTempTensorsForHybrid,\n                      &op_data->scratch_tensor_index);\n  return op_data;\n}\n\nvoid Free(TfLiteContext* context, void* buffer) {\n  delete static_cast<OpData*>(buffer);\n}\n\nTfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const RuntimeShape& extended_lhs_shape,\n                                const RuntimeShape& extended_rhs_shape,\n                                bool adj_x, bool adj_y, int output_rank,\n                                TfLiteTensor* output) {\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);\n  // Fill in any broadcast dimensions.\n  for (int i = 0; i < output_rank - 2; ++i) {\n    const int lhs_dim = extended_lhs_shape.Dims(i);\n    const int rhs_dim = extended_rhs_shape.Dims(i);\n    int broadcast_dim = lhs_dim;\n    if ((lhs_dim != rhs_dim) && (lhs_dim == 1)) {\n      broadcast_dim = rhs_dim;\n    }\n    output_shape->data[i] = broadcast_dim;\n  }\n  // Fill in the matmul dimensions.\n  int lhs_rows_index = adj_x ? output_rank - 1 : output_rank - 2;\n  int rhs_cols_index = adj_y ? output_rank - 2 : output_rank - 1;\n\n  output_shape->data[output_rank - 2] = extended_lhs_shape.Dims(lhs_rows_index);\n  output_shape->data[output_rank - 1] = extended_rhs_shape.Dims(rhs_cols_index);\n  TfLiteStatus stat = context->ResizeTensor(context, output, output_shape);\n  return stat;\n}\n\n// Initializes temp tensors to store transposed operands.\nTfLiteStatus InitializeTemporaries(TfLiteContext* context, TfLiteNode* node,\n                                   OpContext* op_context) {\n  // Create temporary tensors to hold transposed LHS/RHS.\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* lhs = op_context->lhs;\n  const TfLiteTensor* rhs = op_context->rhs;\n  TfLiteIntArrayFree(node->temporaries);\n  // For \"hybrid\" quantization, we impose the constraint that the LHS\n  // is float (typically an activation from a prior layer) and the RHS\n  // is quantized int8.\n  bool is_hybrid =\n      (op_context->lhs->type == kTfLiteFloat32 && rhs->type == kTfLiteInt8);\n  if (is_hybrid) {\n    node->temporaries = TfLiteIntArrayCreate(kNumTempTensorsForAdjoints +\n                                             kNumTempTensorsForHybrid);\n  } else {\n    node->temporaries = TfLiteIntArrayCreate(kNumTempTensorsForAdjoints);\n  }\n\n  const int lhs_rank = NumDimensions(lhs);\n  const int rhs_rank = NumDimensions(rhs);\n  const int batch_size = op_context->params->adj_x\n                             ? lhs->dims->data[lhs_rank - 2]\n                             : lhs->dims->data[lhs_rank - 1];\n  const int num_units = op_context->params->adj_x\n                            ? lhs->dims->data[lhs_rank - 1]\n                            : lhs->dims->data[lhs_rank - 2];\n\n  // Temp tensor for Transposed LHS;\n  {\n    node->temporaries->data[0] = op_data->scratch_tensor_index;\n    TfLiteTensor* scratch_buffer = GetTemporary(context, node, /*index=*/0);\n    TfLiteIntArray* scratch_buffer_size = TfLiteIntArrayCreate(lhs_rank);\n    for (int i = 0; i < lhs_rank - 2; ++i) {\n      scratch_buffer_size->data[i] = lhs->dims->data[i];\n    }\n    // Swap last two dimensions.\n    scratch_buffer_size->data[lhs_rank - 2] = lhs->dims->data[lhs_rank - 1];\n    scratch_buffer_size->data[lhs_rank - 1] = lhs->dims->data[lhs_rank - 2];\n\n    scratch_buffer->type = op_context->lhs->type;\n    scratch_buffer->allocation_type = kTfLiteArenaRw;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_buffer,\n                                                     scratch_buffer_size));\n  }\n\n  // We need a temp buffer for the RHS if we need to transpose the RHS. We\n  // transpose by default, so that the two inputs (LHS and RHS) are in a proper\n  // layout for our fast matrix multiplication routines. If the transpose flag\n  // is set by the caller, the data is already in the desired layout.\n  {\n    node->temporaries->data[1] = op_data->scratch_tensor_index + 1;\n    TfLiteTensor* scratch_buffer = GetTemporary(context, node, /*index=*/1);\n    const TfLiteTensor* rhs = op_context->rhs;\n    int rhs_rank = NumDimensions(rhs);\n    TfLiteIntArray* scratch_buffer_size = TfLiteIntArrayCreate(rhs_rank);\n    for (int i = 0; i < rhs_rank - 2; ++i) {\n      scratch_buffer_size->data[i] = rhs->dims->data[i];\n    }\n    // Swap last two dimensions.\n    scratch_buffer_size->data[rhs_rank - 2] = rhs->dims->data[rhs_rank - 1];\n    scratch_buffer_size->data[rhs_rank - 1] = rhs->dims->data[rhs_rank - 2];\n\n    if (IsConstantTensor(op_context->rhs)) {\n      scratch_buffer->allocation_type = kTfLiteArenaRwPersistent;\n    } else {\n      scratch_buffer->allocation_type = kTfLiteArenaRw;\n    }\n    scratch_buffer->type = op_context->rhs->type;\n    scratch_buffer->allocation_type = kTfLiteArenaRw;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_buffer,\n                                                     scratch_buffer_size));\n  }\n\n  // If we have to perform on-the-fly quantization (with quantized weights and\n  // float inputs) first we need to quantize the inputs. Allocate temporary\n  // buffer to store the intermediate quantized values, the batch scaling\n  // factors, the accumulator buffer (optimized version), the input offsets,\n  // and the sums of the rows for each weights matrix.\n  // RHS = weights, LHS = inputs\n  if (is_hybrid) {\n    // Calculate the total number of LHS batches.\n    int num_batches = 1;\n    for (int i = 0; i < lhs_rank - 2; ++i) {\n      num_batches *= lhs->dims->data[i];\n    }\n    int num_weights_matrices = 1;\n    for (int i = 0; i < rhs_rank - 2; ++i) {\n      num_weights_matrices *= rhs->dims->data[i];\n    }\n    op_data->compute_row_sums = true;\n    node->temporaries->data[2] = op_data->scratch_tensor_index + 2;\n    TfLiteTensor* input_quantized = GetTemporary(context, node, /*index=*/2);\n    input_quantized->type = op_context->rhs->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n\n    TfLiteIntArray* input_quantized_size =\n        TfLiteIntArrayCopy(op_context->lhs->dims);\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                     input_quantized_size));\n\n    node->temporaries->data[3] = op_data->scratch_tensor_index + 3;\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, /*index=*/3);\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    // Total size of scaling factors is batch size * number of total batches\n    int scaling_dims[1] = {num_batches * batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n\n    node->temporaries->data[4] = op_data->scratch_tensor_index + 4;\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, /*index=*/4);\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {num_units, batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_size = TfLiteIntArrayCreate(2);\n      accum_size->data[0] = num_units;\n      accum_size->data[1] = batch_size;\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, accum_scratch, accum_size));\n    }\n\n    node->temporaries->data[5] = op_data->scratch_tensor_index + 5;\n    TfLiteTensor* input_offsets = GetTemporary(context, node, /*index=*/5);\n    input_offsets->type = kTfLiteInt32;\n    input_offsets->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) {\n      TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);\n      input_offsets_size->data[0] = num_batches * batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,\n                                                       input_offsets_size));\n    }\n    node->temporaries->data[6] = op_data->scratch_tensor_index + 6;\n    TfLiteTensor* row_sums = GetTemporary(context, node, /*index=*/6);\n    row_sums->type = kTfLiteInt32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_dims[1] = {num_weights_matrices * num_units};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);\n      row_sums_size->data[0] = row_sums_dims[0];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n\n  return kTfLiteOk;\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  OpContext op_context(context, node);\n  TF_LITE_ENSURE_OK(context, InitializeTemporaries(context, node, &op_context));\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  bool adj_x = op_context.params->adj_x;\n  bool adj_y = op_context.params->adj_y;\n\n  const TfLiteTensor* lhs_data = GetInput(context, node, kInputLHSTensor);\n  const TfLiteTensor* rhs_data = GetInput(context, node, kInputRHSTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // Note that quantized inference requires that all tensors have their\n  // parameters set. This is usually done during quantized training.\n  if (lhs_data->type == kTfLiteInt8) {\n    double real_multiplier = 0.0;\n    TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(\n        context, lhs_data, rhs_data, output, &real_multiplier));\n    int exponent;\n    QuantizeMultiplier(real_multiplier, &op_data->output_multiplier, &exponent);\n    op_data->output_shift = exponent;\n    // BatchMatMul has no fused activation functions. Therefore, set\n    // output activation min and max to min and max of int8_t type,\n    // respecitvely.\n    op_data->output_activation_min = std::numeric_limits<int8_t>::min();\n    op_data->output_activation_max = std::numeric_limits<int8_t>::max();\n  }\n\n  TF_LITE_ENSURE(context, lhs_data->type == kTfLiteFloat32 ||\n                              lhs_data->type == kTfLiteInt8);\n  TF_LITE_ENSURE(context, rhs_data->type == kTfLiteFloat32 ||\n                              rhs_data->type == kTfLiteInt8);\n  // Support dimensions between 2 and 4, inclusive.\n  TF_LITE_ENSURE(context, NumDimensions(lhs_data) >= 2);\n  TF_LITE_ENSURE(context, NumDimensions(lhs_data) <= 4);\n  TF_LITE_ENSURE(context, NumDimensions(rhs_data) >= 2);\n  TF_LITE_ENSURE(context, NumDimensions(rhs_data) <= 4);\n\n  const int lhs_rank = NumDimensions(lhs_data);\n  const int rhs_rank = NumDimensions(rhs_data);\n  const int output_rank = std::max(lhs_rank, rhs_rank);\n  const RuntimeShape extended_lhs_shape =\n      RuntimeShape::ExtendedShape(output_rank, GetTensorShape(lhs_data));\n  const RuntimeShape extended_rhs_shape =\n      RuntimeShape::ExtendedShape(output_rank, GetTensorShape(rhs_data));\n\n  // Ensure any batch dimensions obey broacasting rules.\n  for (int i = 0; i < output_rank - 2; ++i) {\n    const int lhs_dim = extended_lhs_shape.Dims(i);\n    const int rhs_dim = extended_rhs_shape.Dims(i);\n    if (lhs_dim != rhs_dim) {\n      if (lhs_dim != 1) {\n        TF_LITE_ENSURE_EQ(context, rhs_dim, 1);\n      }\n    }\n  }\n  // Ensure other dimensions work for matrix multiplication.\n  int accum_dim_lhs = adj_x ? extended_lhs_shape.Dims(output_rank - 2)\n                            : extended_lhs_shape.Dims(output_rank - 1);\n  int accum_dim_rhs = adj_y ? extended_rhs_shape.Dims(output_rank - 1)\n                            : extended_rhs_shape.Dims(output_rank - 2);\n\n  TF_LITE_ENSURE_EQ(context, accum_dim_lhs, accum_dim_rhs);\n  TfLiteStatus status =\n      ResizeOutputTensor(context, extended_lhs_shape, extended_rhs_shape, adj_x,\n                         adj_y, output_rank, output);\n  return status;\n}\n\ntemplate <typename scalar>\nvoid TransposeRowsColumnsImpl(const TfLiteTensor* tensor_in,\n                              const scalar* input, TfLiteTensor* tensor_out,\n                              scalar* output) {\n  RuntimeShape transposed_shape(GetTensorShape(tensor_in));\n  RuntimeShape shape(GetTensorShape(tensor_in));\n  TransposeParams params;\n  int rank = NumDimensions(tensor_in);\n  params.perm_count = rank;\n  for (int i = 0; i < rank - 2; ++i) {\n    params.perm[i] = i;\n  }\n  // Transpose the last two dimensions.\n  params.perm[rank - 2] = rank - 1;\n  params.perm[rank - 1] = rank - 2;\n  transposed_shape.SetDim(rank - 1, shape.Dims(rank - 2));\n  transposed_shape.SetDim(rank - 2, shape.Dims(rank - 1));\n  optimized_ops::Transpose(params, shape, input, transposed_shape, output);\n}\n\nTfLiteStatus TransposeRowsColumns(TfLiteContext* context,\n                                  const TfLiteTensor* tensor_in,\n                                  TfLiteTensor* tensor_out) {\n  if (tensor_in->type == kTfLiteFloat32) {\n    TransposeRowsColumnsImpl<float>(tensor_in, GetTensorData<float>(tensor_in),\n                                    tensor_out,\n                                    GetTensorData<float>(tensor_out));\n    return kTfLiteOk;\n  } else if (tensor_in->type == kTfLiteInt8) {\n    TransposeRowsColumnsImpl<int8_t>(\n        tensor_in, GetTensorData<int8_t>(tensor_in), tensor_out,\n        GetTensorData<int8_t>(tensor_out));\n    return kTfLiteOk;\n  } else {\n    TF_LITE_KERNEL_LOG(context,\n                       \"Can only transpose tensors with float and int8 type.\");\n    return kTfLiteError;\n  }\n}\n\nRuntimeShape SwapRowColumnDims(const RuntimeShape& shape) {\n  RuntimeShape swapped_shape(shape);\n  const int32_t dims = shape.DimensionsCount();\n  swapped_shape.SetDim(dims - 2, shape.Dims(dims - 1));\n  swapped_shape.SetDim(dims - 1, shape.Dims(dims - 2));\n  return swapped_shape;\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus EvalHybrid(TfLiteContext* context, TfLiteNode* node, OpData* data,\n                        const RuntimeShape& input_shape,\n                        const TfLiteTensor* input,\n                        const RuntimeShape& filter_shape,\n                        const TfLiteTensor* filter,\n                        TfLiteTensor* input_quantized,\n                        TfLiteTensor* scaling_factors,\n                        TfLiteTensor* accum_scratch, TfLiteTensor* row_sums,\n                        TfLiteTensor* input_offsets, TfLiteTensor* output) {\n  const int32_t num_input_dims = input_shape.DimensionsCount();\n\n  // Input row/cols have been swapped at this point, so dims are\n  // {input_size, num_batches}\n  const int input_size = input_shape.Dims(num_input_dims - 2);\n  const int batch_size = input_shape.Dims(num_input_dims - 1);\n\n  int num_batches_to_quantize = batch_size;\n  for (int i = 0; i < input_shape.DimensionsCount() - 2; ++i) {\n    num_batches_to_quantize *= input_shape.Dims(i);\n  }\n  // Quantize input from float to uint8 + quantization params (scaling factor).\n  float* scaling_factors_ptr = GetTensorData<float>(scaling_factors);\n  int32_t* input_offset_ptr = nullptr;\n  int32_t* row_sums_ptr = nullptr;\n  // Only asymmetric quantization is supported.\n  input_offset_ptr = GetTensorData<int32_t>(input_offsets);\n  row_sums_ptr = GetTensorData<int32_t>(row_sums);\n  int8_t* quant_data = GetTensorData<int8_t>(input_quantized);\n  const int8_t* filter_data = GetTensorData<int8_t>(filter);\n  const float* input_ptr = GetTensorData<float>(input);\n  // Quantize each batch independently.\n  for (int b = 0; b < num_batches_to_quantize; ++b) {\n    const int offset = b * input_size;\n    tensor_utils::AsymmetricQuantizeFloats(\n        input_ptr + offset, input_size, quant_data + offset,\n        &scaling_factors_ptr[b], &input_offset_ptr[b]);\n    // Incorporate scaling of the filter.\n    scaling_factors_ptr[b] *= filter->params.scale;\n  }\n\n  RuntimeShape output_shape = GetTensorShape(output);\n  int output_size = 1;\n  for (int i = 0; i < output_shape.DimensionsCount(); ++i) {\n    output_size *= output_shape.Dims(i);\n  }\n  std::fill_n(GetTensorData<float>(output), output_size, 0.0f);\n  if (kernel_type == kGenericOptimized) {\n    optimized_ops::BatchMatMul(\n        filter_shape, filter_data, input_shape, quant_data, scaling_factors_ptr,\n        input_offset_ptr, row_sums_ptr, GetTensorShape(output),\n        GetTensorData<int32_t>(accum_scratch), GetTensorData<float>(output),\n        &(data->compute_row_sums), CpuBackendContext::GetFromContext(context));\n  } else {\n    reference_ops::BatchMatMul(\n        filter_shape, filter_data, input_shape, quant_data, scaling_factors_ptr,\n        input_offset_ptr, row_sums_ptr, GetTensorShape(output),\n        GetTensorData<float>(output), &(data->compute_row_sums));\n  }\n\n  return kTfLiteOk;\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus EvalInt8(TfLiteContext* context, const OpData* data,\n                      const RuntimeShape& lhs_shape, const TfLiteTensor* lhs,\n                      const RuntimeShape& rhs_shape, const TfLiteTensor* rhs,\n                      const RuntimeShape& output_shape, TfLiteTensor* output) {\n  // Reuse params struct from FullyConnected Op.\n  FullyConnectedParams op_params;\n  int32_t input_offset = -lhs->params.zero_point;\n  int32_t filter_offset = -rhs->params.zero_point;\n  int32_t output_offset = output->params.zero_point;\n  op_params.input_offset = input_offset;\n  op_params.weights_offset = filter_offset;\n  op_params.output_offset = output_offset;\n  op_params.output_multiplier = data->output_multiplier;\n  op_params.output_shift = data->output_shift;\n  op_params.quantized_activation_min = data->output_activation_min;\n  op_params.quantized_activation_max = data->output_activation_max;\n  op_params.lhs_cacheable = IsConstantTensor(lhs);\n  op_params.rhs_cacheable = IsConstantTensor(rhs);\n\n  if (kernel_type == kReference) {\n    reference_ops::BatchMatMul(op_params, rhs_shape, GetTensorData<int8_t>(rhs),\n                               lhs_shape, GetTensorData<int8_t>(lhs),\n                               GetTensorShape(output),\n                               GetTensorData<int8_t>(output));\n  } else {\n    optimized_ops::BatchMatMul(op_params, rhs_shape, GetTensorData<int8_t>(rhs),\n                               lhs_shape, GetTensorData<int8_t>(lhs),\n                               GetTensorShape(output),\n                               GetTensorData<int8_t>(output),\n                               CpuBackendContext::GetFromContext(context));\n  }\n  return kTfLiteOk;\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           OpData* data, const RuntimeShape& lhs_shape,\n                           const TfLiteTensor* lhs,\n                           const RuntimeShape& rhs_shape,\n                           const TfLiteTensor* rhs, TfLiteTensor* output) {\n  if (lhs->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized = GetTemporary(context, node, /*index=*/2);\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, /*index=*/3);\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, /*index=*/4);\n    TfLiteTensor* input_offsets = GetTemporary(context, node, /*index=*/5);\n    TfLiteTensor* row_sums = GetTemporary(context, node, /*index=*/6);\n    return EvalHybrid<kernel_type>(\n        context, node, data, lhs_shape, lhs, rhs_shape, rhs, input_quantized,\n        scaling_factors, accum_scratch, row_sums, input_offsets, output);\n  } else if (lhs->type == kTfLiteInt8) {\n    return EvalInt8<kernel_type>(context, data, lhs_shape, lhs, rhs_shape, rhs,\n                                 GetTensorShape(output), output);\n  } else {\n    TF_LITE_KERNEL_LOG(\n        context, \"Currently only hybrid and int8 quantization is supported.\\n\");\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n\nTfLiteTensor* GetTempRhs(TfLiteContext* context, TfLiteNode* node,\n                         const TfLiteTensor* rhs) {\n  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);\n  if (rhs->type == kTfLiteInt8) {\n    // Get the quantization params from the RHS tensor.\n    transposed_rhs->params.scale = rhs->params.scale;\n    transposed_rhs->params.zero_point = rhs->params.zero_point;\n  }\n  return transposed_rhs;\n}\n\nTfLiteTensor* GetTempLhs(TfLiteContext* context, TfLiteNode* node,\n                         const TfLiteTensor* lhs) {\n  TfLiteTensor* transposed_lhs = GetTemporary(context, node, 0);\n  if (lhs->type == kTfLiteInt8) {\n    // Get the quantization params from the LHS tensor.\n    transposed_lhs->params.scale = lhs->params.scale;\n    transposed_lhs->params.zero_point = lhs->params.zero_point;\n  }\n  return transposed_lhs;\n}\n\n// Perform a batch matrix multiply on\n// LHS <..., A, B>  X  RHS<..., B, C>\n// where the leading dimensions of LHS and RHS obey broadcasting rules\n// (this Op will apply broadcasting rules).\n// We assume that LHS and RHS are both row oriented (adjacent values in memory\n// are in the same row) and will output in the same memory layout. However,\n// our fast GEMM libraries assume RCC layout (LHS row oriented,\n// RHS column oriented, output column oriented). Therefore, we perform\n// RHS <..., C, B> X LHS <..., B, A>\n// where output is a C X A column-oriented, which is equivalent to\n// A X C row-oriented.\ntemplate <KernelType kernel_type>\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* lhs = GetInput(context, node, kInputLHSTensor);\n  const TfLiteTensor* rhs = GetInput(context, node, kInputRHSTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  RuntimeShape orig_lhs_shape = GetTensorShape(lhs);\n  RuntimeShape orig_rhs_shape = GetTensorShape(rhs);\n\n  bool adj_y = op_context.params->adj_y;\n  bool adj_x = op_context.params->adj_x;\n\n  const TfLiteTensor* rhs_tensor = adj_y ? rhs : GetTempRhs(context, node, rhs);\n  const TfLiteTensor* lhs_tensor = adj_x ? GetTempLhs(context, node, lhs) : lhs;\n  if (!adj_y) {\n    // TODO(b/154760341) Constant tensors should already be transposed, but\n    // we transpose once if necessary for now.\n    if (!(IsConstantTensor(rhs) && op_data->rhs_transposed)) {\n      TransposeRowsColumns(context, rhs, GetTemporary(context, node, 1));\n      op_data->rhs_transposed = true;\n    }\n  }\n  if (adj_x) {\n    TransposeRowsColumns(context, lhs, GetTemporary(context, node, 0));\n  }\n  RuntimeShape rhs_shape =\n      adj_y ? orig_rhs_shape : SwapRowColumnDims(orig_rhs_shape);\n  RuntimeShape lhs_shape =\n      adj_x ? orig_lhs_shape : SwapRowColumnDims(orig_lhs_shape);\n\n  switch (rhs->type) {\n    case kTfLiteFloat32:\n      // Note we pass RHS args first, LHS args second. See note above.\n      if (kernel_type == kGenericOptimized) {\n        optimized_ops::BatchMatMul(rhs_shape, GetTensorData<float>(rhs_tensor),\n                                   lhs_shape, GetTensorData<float>(lhs_tensor),\n                                   GetTensorShape(output),\n                                   GetTensorData<float>(output),\n                                   CpuBackendContext::GetFromContext(context));\n      } else {\n        reference_ops::BatchMatMul(rhs_shape, GetTensorData<float>(rhs_tensor),\n                                   lhs_shape, GetTensorData<float>(lhs_tensor),\n                                   GetTensorShape(output),\n                                   GetTensorData<float>(output));\n      }\n      break;\n    case kTfLiteInt8:\n      EvalQuantized<kernel_type>(context, node, op_data, lhs_shape, lhs_tensor,\n                                 rhs_shape, rhs_tensor, output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Currently BatchMatMul doesn't support type: %s\",\n                         TfLiteTypeGetName(lhs->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n\n}  // namespace batch_matmul\n\nTfLiteRegistration* Register_BATCH_MATMUL_REF() {\n  static TfLiteRegistration r = {batch_matmul::Init, batch_matmul::Free,\n                                 batch_matmul::Prepare,\n                                 batch_matmul::Eval<batch_matmul::kReference>};\n  return &r;\n}\n\nTfLiteRegistration* Register_BATCH_MATMUL_GENERIC_OPTIMIZED() {\n  static TfLiteRegistration r = {\n      batch_matmul::Init, batch_matmul::Free, batch_matmul::Prepare,\n      batch_matmul::Eval<batch_matmul::kGenericOptimized>};\n  return &r;\n}\n\nTfLiteRegistration* Register_BATCH_MATMUL() {\n  return Register_BATCH_MATMUL_GENERIC_OPTIMIZED();\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite"