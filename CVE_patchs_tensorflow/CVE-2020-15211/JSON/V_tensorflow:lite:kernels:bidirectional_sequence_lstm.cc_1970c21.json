"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <math.h>\n\n#include <algorithm>\n#include <cstddef>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/cpu_backend_context.h\"\n#include \"tensorflow/lite/kernels/internal/kernel_utils.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_utils.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n#include \"tensorflow/lite/kernels/lstm_eval.h\"\n#include \"tensorflow/lite/kernels/op_macros.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace bidirectional_sequence_lstm {\n\n// LINT.IfChange\n\n// Input Tensors of size {max_time, n_batch, n_input}\nconstexpr int kInputTensor = 0;\n\n// Forward LSTM cell tensors.\n// Input weight tensors of size: {n_cell, n_input}\nconstexpr int kFwInputToInputWeightsTensor = 1;  // Optional\nconstexpr int kFwInputToForgetWeightsTensor = 2;\nconstexpr int kFwInputToCellWeightsTensor = 3;\nconstexpr int kFwInputToOutputWeightsTensor = 4;\n\n// Recurrent weight tensors of size {n_cell, n_output}\nconstexpr int kFwRecurrentToInputWeightsTensor = 5;  // Optional\nconstexpr int kFwRecurrentToForgetWeightsTensor = 6;\nconstexpr int kFwRecurrentToCellWeightsTensor = 7;\nconstexpr int kFwRecurrentToOutputWeightsTensor = 8;\n\n// Peephole weights tensors of size {n_cell}, representing a diagonal matrix.\nconstexpr int kFwCellToInputWeightsTensor = 9;    // Optional\nconstexpr int kFwCellToForgetWeightsTensor = 10;  // Optional\nconstexpr int kFwCellToOutputWeightsTensor = 11;  // Optional\n\n// Gates bias tensors of size {n_cell}\nconstexpr int kFwInputGateBiasTensor = 12;  // Optional\nconstexpr int kFwForgetGateBiasTensor = 13;\nconstexpr int kFwCellGateBiasTensor = 14;\nconstexpr int kFwOutputGateBiasTensor = 15;\n\n// Projection weight tensor of size {n_output, n_cell}\nconstexpr int kFwProjectionWeightsTensor = 16;  // Optional\n// Projection bias tensor of size {n_output}\nconstexpr int kFwProjectionBiasTensor = 17;  // Optional\n\n// Backward LSTM cell tensors.\n// Input weight tensors of size: {n_cell, n_input}\nconstexpr int kBwInputToInputWeightsTensor = 18;  // Optional\nconstexpr int kBwInputToForgetWeightsTensor = 19;\nconstexpr int kBwInputToCellWeightsTensor = 20;\nconstexpr int kBwInputToOutputWeightsTensor = 21;\n\n// Recurrent weight tensors of size {n_cell, n_output}\nconstexpr int kBwRecurrentToInputWeightsTensor = 22;  // Optional\nconstexpr int kBwRecurrentToForgetWeightsTensor = 23;\nconstexpr int kBwRecurrentToCellWeightsTensor = 24;\nconstexpr int kBwRecurrentToOutputWeightsTensor = 25;\n\n// Peephole weights tensors of size {n_cell}, representing a diagonal matrix.\nconstexpr int kBwCellToInputWeightsTensor = 26;   // Optional\nconstexpr int kBwCellToForgetWeightsTensor = 27;  // Optional\nconstexpr int kBwCellToOutputWeightsTensor = 28;  // Optional\n\n// Gates bias tensors of size {n_cell}\nconstexpr int kBwInputGateBiasTensor = 29;  // Optional\nconstexpr int kBwForgetGateBiasTensor = 30;\nconstexpr int kBwCellGateBiasTensor = 31;\nconstexpr int kBwOutputGateBiasTensor = 32;\n\n// Projection weight tensor of size {n_output, n_cell}\nconstexpr int kBwProjectionWeightsTensor = 33;  // Optional\n// Projection bias tensor of size {n_output}\nconstexpr int kBwProjectionBiasTensor = 34;  // Optional\n\n// Stateful input tensors that are variables and will be modified by the Op.\n// Activation state tensors of size {n_batch, n_output}\nconstexpr int kFwInputActivationStateTensor = 35;\n// Cell state tensors of size {n_batch, n_cell}\nconstexpr int kFwInputCellStateTensor = 36;\n// Activation state tensors of size {n_batch, n_output}\nconstexpr int kBwInputActivationStateTensor = 37;\n// Cell state tensors of size {n_batch, n_cell}\nconstexpr int kBwInputCellStateTensor = 38;\n\n// Used as auxiliary input and weights when stacking for\n// tf.contrib.rnn.stack_bidirectional_rnn case (with cross links); Used as input\n// to the backward cell when stacking for tf.nn.static_bidirectional_rnn case\n// (without cross links).\nconstexpr int kAuxInputTensor = 39;  // Optional\n// Forward weights.\nconstexpr int kFwAuxInputToInputWeightsTensor = 40;   // Optional\nconstexpr int kFwAuxInputToForgetWeightsTensor = 41;  // Optional\nconstexpr int kFwAuxInputToCellWeightsTensor = 42;    // Optional\nconstexpr int kFwAuxInputToOutputWeightsTensor = 43;  // Optional\n// Backward weights.\nconstexpr int kBwAuxInputToInputWeightsTensor = 44;   // Optional\nconstexpr int kBwAuxInputToForgetWeightsTensor = 45;  // Optional\nconstexpr int kBwAuxInputToCellWeightsTensor = 46;    // Optional\nconstexpr int kBwAuxInputToOutputWeightsTensor = 47;  // Optional\n\n// Output tensors.\nconstexpr int kFwOutputTensor = 0;\nconstexpr int kBwOutputTensor = 1;  // Ignored if merge_outputs is set.\n\n// LINT.ThenChange(//tensorflow/lite/tools/optimize/quantize_weights.cc)\n\n// Temporary tensors.\nenum TemporaryTensor {\n  // Scratch buffers for input, forget, etc. gates\n  kFwScratchBuffer = 0,\n  kBwScratchBuffer = 1,\n  // Quantized tensors needed for the hybrid kernel.\n  kInputQuantized = 2,\n  kFwActivationStateQuantized = 3,\n  kBwActivationStateQuantized = 4,\n  kFwCellStateQuantized = 5,\n  kBwCellStateQuantized = 6,\n  kInputScalingFactors = 7,\n  kAuxInputScalingFactors = 8,\n  kOutputStateScalingFactors = 9,\n  kProductScalingFactors = 10,\n  kRecoveredCellWeights = 11,\n  kAccumScratchBuffer = 12,\n  kInputZeroPoints = 13,\n  kAuxInputZeroPoints = 14,\n  kOutputStateZeroPoints = 15,\n  kFwRowSums = 16,\n  kBwRowSums = 17,\n  kAuxInputQuantized = 18,  // Optional, quantized tensor for auxiliary input.\n  kNumTemporaryTensors = 19,\n};\n\nstruct OpData {\n  int scratch_tensor_index;\n  bool compute_fw_row_sums = false;\n  bool compute_bw_row_sums = false;\n};\n\nvoid* Init(TfLiteContext* context, const char* buffer, size_t length) {\n  auto* op_data = new OpData();\n  context->AddTensors(context, kNumTemporaryTensors,\n                      &op_data->scratch_tensor_index);\n  return op_data;\n}\n\nvoid Free(TfLiteContext* context, void* buffer) {\n  delete reinterpret_cast<OpData*>(buffer);\n}\n\n// Check that input tensor dimensions matches with each other.\nTfLiteStatus CheckLstmTensorDimensionsAndTypes(\n    TfLiteContext* context, TfLiteNode* node, int n_input, int n_output,\n    int n_cell, int input_to_input_weights_tensor,\n    int input_to_forget_weights_tensor, int input_to_cell_weights_tensor,\n    int input_to_output_weights_tensor, int recurrent_to_input_weights_tensor,\n    int recurrent_to_forget_weights_tensor,\n    int recurrent_to_cell_weights_tensor,\n    int recurrent_to_output_weights_tensor, int cell_to_input_weights_tensor,\n    int cell_to_forget_weights_tensor, int cell_to_output_weights_tensor,\n    int input_gate_bias_tensor, int forget_gate_bias_tensor,\n    int cell_gate_bias_tensor, int output_gate_bias_tensor,\n    int projection_weights_tensor, int projection_bias_tensor) {\n  const auto* params = reinterpret_cast<TfLiteBidirectionalSequenceLSTMParams*>(\n      node->builtin_data);\n\n  // Making sure clipping parameters have valid values.\n  // == 0 means no clipping\n  //  > 0 means clipping\n  TF_LITE_ENSURE(context, params->cell_clip >= 0);\n  TF_LITE_ENSURE(context, params->proj_clip >= 0);\n\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, input_to_forget_weights_tensor);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights->dims->data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, input_to_forget_weights->dims->data[1], n_input);\n  TF_LITE_ENSURE(context, (input_to_forget_weights->type == kTfLiteFloat32) ||\n                              (input_to_forget_weights->type == kTfLiteInt8) ||\n                              (input_to_forget_weights->type == kTfLiteUInt8));\n\n  const TfLiteTensor* input_to_input_weights =\n      GetOptionalInputTensor(context, node, input_to_input_weights_tensor);\n  if (input_to_input_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights->dims->size, 2);\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights->dims->data[0], n_cell);\n    TF_LITE_ENSURE_EQ(context, input_to_input_weights->dims->data[1], n_input);\n    TF_LITE_ENSURE_TYPES_EQ(context, input_to_input_weights->type,\n                            input_to_forget_weights->type);\n  }\n\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, input_to_cell_weights_tensor);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights->dims->data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, input_to_cell_weights->dims->data[1], n_input);\n  TF_LITE_ENSURE_TYPES_EQ(context, input_to_cell_weights->type,\n                          input_to_forget_weights->type);\n\n  const TfLiteTensor* input_to_output_weights =\n      GetInput(context, node, input_to_output_weights_tensor);\n  TF_LITE_ENSURE_EQ(context, input_to_output_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, input_to_output_weights->dims->data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, input_to_output_weights->dims->data[1], n_input);\n  TF_LITE_ENSURE_TYPES_EQ(context, input_to_output_weights->type,\n                          input_to_forget_weights->type);\n\n  const TfLiteTensor* recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, recurrent_to_input_weights_tensor);\n  if (recurrent_to_input_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights->dims->size, 2);\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights->dims->data[0],\n                      n_cell);\n    TF_LITE_ENSURE_EQ(context, recurrent_to_input_weights->dims->data[1],\n                      n_output);\n    TF_LITE_ENSURE_TYPES_EQ(context, recurrent_to_input_weights->type,\n                            input_to_forget_weights->type);\n  }\n\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, recurrent_to_forget_weights_tensor);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights->dims->data[0],\n                    n_cell);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_forget_weights->dims->data[1],\n                    n_output);\n  TF_LITE_ENSURE_TYPES_EQ(context, recurrent_to_forget_weights->type,\n                          input_to_forget_weights->type);\n\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, recurrent_to_cell_weights_tensor);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights->dims->data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, recurrent_to_cell_weights->dims->data[1],\n                    n_output);\n  TF_LITE_ENSURE_TYPES_EQ(context, recurrent_to_cell_weights->type,\n                          input_to_forget_weights->type);\n\n  // We make sure the input-gate's parameters are either both present (regular\n  // LSTM) or not at all (CIFG-LSTM).\n  const bool cifg_weights_all_or_none =\n      ((input_to_input_weights != nullptr) &&\n       (recurrent_to_input_weights != nullptr)) ||\n      ((input_to_input_weights == nullptr) &&\n       (recurrent_to_input_weights == nullptr));\n  TF_LITE_ENSURE(context, cifg_weights_all_or_none == true);\n\n  const TfLiteTensor* cell_to_input_weights =\n      GetOptionalInputTensor(context, node, cell_to_input_weights_tensor);\n  if (cell_to_input_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, cell_to_input_weights->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_input_weights->dims->data[0], n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, cell_to_input_weights->type,\n                            input_to_forget_weights->type);\n  }\n\n  const TfLiteTensor* cell_to_forget_weights =\n      GetOptionalInputTensor(context, node, cell_to_forget_weights_tensor);\n  if (cell_to_forget_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, cell_to_forget_weights->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_forget_weights->dims->data[0], n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, cell_to_forget_weights->type,\n                            input_to_forget_weights->type);\n  }\n\n  const TfLiteTensor* cell_to_output_weights =\n      GetOptionalInputTensor(context, node, cell_to_output_weights_tensor);\n  if (cell_to_output_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, cell_to_output_weights->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, cell_to_output_weights->dims->data[0], n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, cell_to_output_weights->type,\n                            input_to_forget_weights->type);\n  }\n\n  // Making sure the peephole weights are there all or none.\n  const bool use_cifg = (input_to_input_weights == nullptr);\n  const bool peephole_weights_all_or_none =\n      ((cell_to_input_weights != nullptr || use_cifg) &&\n       (cell_to_forget_weights != nullptr) &&\n       (cell_to_output_weights != nullptr)) ||\n      ((cell_to_input_weights == nullptr) &&\n       (cell_to_forget_weights == nullptr) &&\n       (cell_to_output_weights == nullptr));\n  TF_LITE_ENSURE(context, peephole_weights_all_or_none == true);\n\n  // Make sure the input gate bias is present only when not a CIFG-LSTM.\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, input_gate_bias_tensor);\n  if (use_cifg) {\n    TF_LITE_ENSURE_EQ(context, input_gate_bias, nullptr);\n  } else {\n    TF_LITE_ENSURE_EQ(context, input_gate_bias->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, input_gate_bias->dims->data[0], n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, input_gate_bias->type, kTfLiteFloat32);\n  }\n\n  const TfLiteTensor* forget_gate_bias =\n      GetInput(context, node, forget_gate_bias_tensor);\n  TF_LITE_ENSURE_EQ(context, forget_gate_bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, forget_gate_bias->dims->data[0], n_cell);\n  TF_LITE_ENSURE_TYPES_EQ(context, forget_gate_bias->type, kTfLiteFloat32);\n\n  const TfLiteTensor* cell_gate_bias =\n      GetInput(context, node, cell_gate_bias_tensor);\n  TF_LITE_ENSURE_EQ(context, cell_gate_bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, cell_gate_bias->dims->data[0], n_cell);\n  TF_LITE_ENSURE_EQ(context, cell_gate_bias->type, kTfLiteFloat32);\n\n  const TfLiteTensor* output_gate_bias =\n      GetInput(context, node, output_gate_bias_tensor);\n  TF_LITE_ENSURE_EQ(context, output_gate_bias->dims->size, 1);\n  TF_LITE_ENSURE_EQ(context, output_gate_bias->dims->data[0], n_cell);\n  TF_LITE_ENSURE_TYPES_EQ(context, output_gate_bias->type, kTfLiteFloat32);\n\n  const TfLiteTensor* projection_weights =\n      GetOptionalInputTensor(context, node, projection_weights_tensor);\n  if (projection_weights != nullptr) {\n    TF_LITE_ENSURE_EQ(context, projection_weights->dims->size, 2);\n    TF_LITE_ENSURE_EQ(context, projection_weights->dims->data[0], n_output);\n    TF_LITE_ENSURE_EQ(context, projection_weights->dims->data[1], n_cell);\n    TF_LITE_ENSURE_TYPES_EQ(context, projection_weights->type,\n                            input_to_forget_weights->type);\n  }\n\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, projection_bias_tensor);\n  if (projection_bias != nullptr) {\n    TF_LITE_ENSURE_EQ(context, projection_bias->dims->size, 1);\n    TF_LITE_ENSURE_EQ(context, projection_bias->dims->data[0], n_output);\n    TF_LITE_ENSURE_TYPES_EQ(context, projection_bias->type, kTfLiteFloat32);\n  }\n\n  // Making sure the projection tensors are consistent:\n  // 1) If projection weight is not present, then projection bias should not be\n  // present.\n  // 2) If projection weight is present, then projection bias is optional.\n  // TODO(ghodrat): make sure this is correct.\n  const bool projecton_tensors_consistent =\n      ((projection_weights != nullptr) || (projection_bias == nullptr));\n  TF_LITE_ENSURE(context, projecton_tensors_consistent == true);\n\n  return kTfLiteOk;\n}\n\nTfLiteStatus CheckInputTensorDimensions(TfLiteContext* context,\n                                        TfLiteNode* node, int n_input,\n                                        int n_output, int n_cell) {\n  TF_LITE_ENSURE_OK(\n      context,\n      CheckLstmTensorDimensionsAndTypes(\n          context, node, n_input, n_output, n_cell,\n          kFwInputToInputWeightsTensor, kFwInputToForgetWeightsTensor,\n          kFwInputToCellWeightsTensor, kFwInputToOutputWeightsTensor,\n          kFwRecurrentToInputWeightsTensor, kFwRecurrentToForgetWeightsTensor,\n          kFwRecurrentToCellWeightsTensor, kFwRecurrentToOutputWeightsTensor,\n          kFwCellToInputWeightsTensor, kFwCellToForgetWeightsTensor,\n          kFwCellToOutputWeightsTensor, kFwInputGateBiasTensor,\n          kFwForgetGateBiasTensor, kFwCellGateBiasTensor,\n          kFwOutputGateBiasTensor, kFwProjectionWeightsTensor,\n          kFwProjectionBiasTensor));\n\n  TF_LITE_ENSURE_OK(\n      context,\n      CheckLstmTensorDimensionsAndTypes(\n          context, node, n_input, n_output, n_cell,\n          kBwInputToInputWeightsTensor, kBwInputToForgetWeightsTensor,\n          kBwInputToCellWeightsTensor, kBwInputToOutputWeightsTensor,\n          kBwRecurrentToInputWeightsTensor, kBwRecurrentToForgetWeightsTensor,\n          kBwRecurrentToCellWeightsTensor, kBwRecurrentToOutputWeightsTensor,\n          kBwCellToInputWeightsTensor, kBwCellToForgetWeightsTensor,\n          kBwCellToOutputWeightsTensor, kBwInputGateBiasTensor,\n          kBwForgetGateBiasTensor, kBwCellGateBiasTensor,\n          kBwOutputGateBiasTensor, kBwProjectionWeightsTensor,\n          kBwProjectionBiasTensor));\n\n  // Check if Forward and Backward tensors match along required dimensions.\n  return kTfLiteOk;\n}\n\n// Resize the output and scratch tensors based on the sizes of the input\n// tensors. Also check that the size of the input tensors match each other.\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* op_data = reinterpret_cast<OpData*>(node->user_data);\n  const auto* params = reinterpret_cast<TfLiteBidirectionalSequenceLSTMParams*>(\n      node->builtin_data);\n\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 48);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size,\n                    params->merge_outputs ? 1 : 2);\n\n  // Inferring batch size, number of outputs and sequence length and\n  // number of cells from the input tensors.\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  TF_LITE_ENSURE_EQ(context, input->dims->size, 3);\n  const bool time_major = params->time_major;\n  const int max_time = time_major ? input->dims->data[0] : input->dims->data[1];\n  const int n_batch = time_major ? input->dims->data[1] : input->dims->data[0];\n  const int n_input = input->dims->data[2];\n\n  const TfLiteTensor* fw_input_to_output_weights =\n      GetInput(context, node, kFwInputToOutputWeightsTensor);\n  const int n_fw_cell = fw_input_to_output_weights->dims->data[0];\n  TF_LITE_ENSURE_EQ(context, fw_input_to_output_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, fw_input_to_output_weights->dims->data[1],\n                    n_input);\n\n  const TfLiteTensor* bw_input_to_output_weights =\n      GetInput(context, node, kBwInputToOutputWeightsTensor);\n  const int n_bw_cell = bw_input_to_output_weights->dims->data[0];\n  TF_LITE_ENSURE_EQ(context, bw_input_to_output_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, bw_input_to_output_weights->dims->data[1],\n                    n_input);\n  TF_LITE_ENSURE_EQ(context, bw_input_to_output_weights->type,\n                    fw_input_to_output_weights->type);\n\n  const TfLiteTensor* fw_recurrent_to_output_weights =\n      GetInput(context, node, kFwRecurrentToOutputWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, fw_recurrent_to_output_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, fw_recurrent_to_output_weights->dims->data[0],\n                    n_fw_cell);\n  TF_LITE_ENSURE_EQ(context, fw_recurrent_to_output_weights->type,\n                    fw_input_to_output_weights->type);\n  const int n_fw_output = fw_recurrent_to_output_weights->dims->data[1];\n\n  const TfLiteTensor* bw_recurrent_to_output_weights =\n      GetInput(context, node, kBwRecurrentToOutputWeightsTensor);\n  TF_LITE_ENSURE_EQ(context, bw_recurrent_to_output_weights->dims->size, 2);\n  TF_LITE_ENSURE_EQ(context, bw_recurrent_to_output_weights->dims->data[0],\n                    n_bw_cell);\n  TF_LITE_ENSURE_EQ(context, bw_recurrent_to_output_weights->type,\n                    fw_input_to_output_weights->type);\n  const int n_bw_output = bw_recurrent_to_output_weights->dims->data[1];\n\n  // Check that input tensor dimensions matches with each other.\n  TF_LITE_ENSURE_OK(\n      context, CheckInputTensorDimensions(context, node, n_input, n_fw_output,\n                                          n_fw_cell));\n\n  // Get (optional) auxiliary inputs and weights.\n  const TfLiteTensor* aux_input =\n      GetOptionalInputTensor(context, node, kAuxInputTensor);\n  const TfLiteTensor* fw_aux_input_to_input_weights =\n      GetOptionalInputTensor(context, node, kFwAuxInputToInputWeightsTensor);\n  const TfLiteTensor* fw_aux_input_to_forget_weights =\n      GetOptionalInputTensor(context, node, kFwAuxInputToForgetWeightsTensor);\n  const TfLiteTensor* fw_aux_input_to_cell_weights =\n      GetOptionalInputTensor(context, node, kFwAuxInputToCellWeightsTensor);\n  const TfLiteTensor* fw_aux_input_to_output_weights =\n      GetOptionalInputTensor(context, node, kFwAuxInputToOutputWeightsTensor);\n  const TfLiteTensor* bw_aux_input_to_input_weights =\n      GetOptionalInputTensor(context, node, kBwAuxInputToInputWeightsTensor);\n  const TfLiteTensor* bw_aux_input_to_forget_weights =\n      GetOptionalInputTensor(context, node, kBwAuxInputToForgetWeightsTensor);\n  const TfLiteTensor* bw_aux_input_to_cell_weights =\n      GetOptionalInputTensor(context, node, kBwAuxInputToCellWeightsTensor);\n  const TfLiteTensor* bw_aux_input_to_output_weights =\n      GetOptionalInputTensor(context, node, kBwAuxInputToOutputWeightsTensor);\n\n  const bool aux_inputs_weights_all_or_none =\n      ((fw_aux_input_to_cell_weights != nullptr) &&\n       (fw_aux_input_to_forget_weights != nullptr) &&\n       (fw_aux_input_to_output_weights != nullptr) &&\n       (bw_aux_input_to_cell_weights != nullptr) &&\n       (bw_aux_input_to_forget_weights != nullptr) &&\n       (bw_aux_input_to_output_weights != nullptr)) ||\n      ((fw_aux_input_to_cell_weights == nullptr) &&\n       (fw_aux_input_to_forget_weights == nullptr) &&\n       (fw_aux_input_to_output_weights == nullptr) &&\n       (bw_aux_input_to_cell_weights == nullptr) &&\n       (bw_aux_input_to_forget_weights == nullptr) &&\n       (bw_aux_input_to_output_weights == nullptr));\n  TF_LITE_ENSURE(context, aux_inputs_weights_all_or_none);\n\n  const bool has_aux_input = (fw_aux_input_to_forget_weights != nullptr);\n\n  if (has_aux_input) {\n    // Check that aux_input has the same dimensions (except last) as the input.\n    TF_LITE_ASSERT_EQ(aux_input->dims->data[0], input->dims->data[0]);\n    TF_LITE_ASSERT_EQ(aux_input->dims->data[1], input->dims->data[1]);\n  }\n\n  // Get the pointer to output, activation_state and cell_state buffer tensors.\n  TfLiteTensor* fw_output = GetOutput(context, node, kFwOutputTensor);\n  TfLiteTensor* fw_activation_state =\n      GetVariableInput(context, node, kFwInputActivationStateTensor);\n  TF_LITE_ENSURE(context, fw_activation_state != nullptr);\n  TfLiteTensor* fw_cell_state =\n      GetVariableInput(context, node, kFwInputCellStateTensor);\n  TF_LITE_ENSURE(context, fw_cell_state != nullptr);\n\n  // Check the shape of input state tensors.\n  // These tensor may be 1D or 2D. It's fine as long as the total size is\n  // correct.\n  TF_LITE_ENSURE_EQ(context, NumElements(fw_activation_state),\n                    n_batch * n_fw_output);\n  TF_LITE_ENSURE_EQ(context, NumElements(fw_cell_state), n_batch * n_fw_cell);\n\n  // Resize the output tensors.\n  TfLiteIntArray* fw_output_size = TfLiteIntArrayCreate(3);\n  fw_output_size->data[0] = time_major ? max_time : n_batch;\n  fw_output_size->data[1] = time_major ? n_batch : max_time;\n  fw_output_size->data[2] =\n      params->merge_outputs ? n_bw_output + n_fw_output : n_fw_output;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, fw_output, fw_output_size));\n\n  // The weights are of consistent type, so it suffices to check one.\n  const bool is_hybrid_op = IsHybridOp(input, fw_input_to_output_weights);\n\n  TfLiteIntArrayFree(node->temporaries);\n  if (is_hybrid_op) {\n    node->temporaries = TfLiteIntArrayCreate(\n        has_aux_input ? kNumTemporaryTensors : kNumTemporaryTensors - 1);\n  } else {\n    node->temporaries = TfLiteIntArrayCreate(2);  // the two scratch buffers.\n  }\n  // Create a scratch buffer tensor.\n  node->temporaries->data[kFwScratchBuffer] =\n      op_data->scratch_tensor_index + kFwScratchBuffer;\n  TfLiteTensor* fw_scratch_buffer =\n      GetTemporary(context, node, kFwScratchBuffer);\n  fw_scratch_buffer->type = input->type;\n  fw_scratch_buffer->allocation_type = kTfLiteArenaRw;\n\n  const TfLiteTensor* fw_input_to_input_weights =\n      GetOptionalInputTensor(context, node, kFwInputToInputWeightsTensor);\n  const bool fw_use_cifg = (fw_input_to_input_weights == nullptr);\n  if (has_aux_input && !fw_use_cifg) {\n    TF_LITE_ENSURE_EQ(context, fw_aux_input_to_input_weights->dims->data[0],\n                      fw_input_to_input_weights->dims->data[0]);\n  }\n  TfLiteIntArray* fw_scratch_buffer_size = TfLiteIntArrayCreate(2);\n  fw_scratch_buffer_size->data[0] = n_batch;\n  if (fw_use_cifg) {\n    // Reserving space for Cell, Forget, Output gates\n    fw_scratch_buffer_size->data[1] = n_fw_cell * 3;\n  } else {\n    // Reserving space for Input, Cell, Forget, Output gates\n    fw_scratch_buffer_size->data[1] = n_fw_cell * 4;\n  }\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, fw_scratch_buffer,\n                                                   fw_scratch_buffer_size));\n  // Same for the backward cell.\n\n  // Check that input tensor dimensions matches with each other.\n  TF_LITE_ENSURE_OK(\n      context, CheckInputTensorDimensions(context, node, n_input, n_bw_output,\n                                          n_bw_cell));\n\n  // Get the pointer to activation_state and cell_state buffer tensors.\n  TfLiteTensor* bw_activation_state =\n      GetVariableInput(context, node, kBwInputActivationStateTensor);\n  TF_LITE_ENSURE(context, bw_activation_state != nullptr);\n  TfLiteTensor* bw_cell_state =\n      GetVariableInput(context, node, kBwInputCellStateTensor);\n  TF_LITE_ENSURE(context, bw_cell_state != nullptr);\n\n  // Resize the output tensors.\n  if (!params->merge_outputs) {\n    TfLiteTensor* bw_output = GetOutput(context, node, kBwOutputTensor);\n    TfLiteIntArray* bw_output_size = TfLiteIntArrayCreate(3);\n    bw_output_size->data[0] = time_major ? max_time : n_batch;\n    bw_output_size->data[1] = time_major ? n_batch : max_time;\n    bw_output_size->data[2] = n_bw_output;\n    TF_LITE_ENSURE_OK(\n        context, context->ResizeTensor(context, bw_output, bw_output_size));\n  }\n\n  // Check the shape of input state tensors.\n  // These tensor may be 1D or 2D. It's fine as long as the total size is\n  // correct.\n  TF_LITE_ENSURE_EQ(context, NumElements(bw_activation_state),\n                    n_batch * n_bw_output);\n  TF_LITE_ENSURE_EQ(context, NumElements(bw_cell_state), n_batch * n_bw_cell);\n\n  // Create a scratch buffer tensor.\n  node->temporaries->data[kBwScratchBuffer] =\n      op_data->scratch_tensor_index + kBwScratchBuffer;\n  TfLiteTensor* bw_scratch_buffer =\n      GetTemporary(context, node, kBwScratchBuffer);\n  bw_scratch_buffer->type = input->type;\n  bw_scratch_buffer->allocation_type = kTfLiteArenaRw;\n\n  const TfLiteTensor* bw_input_to_input_weights =\n      GetOptionalInputTensor(context, node, kBwInputToInputWeightsTensor);\n  const bool bw_use_cifg = (bw_input_to_input_weights == nullptr);\n  if (has_aux_input && !bw_use_cifg) {\n    TF_LITE_ENSURE_EQ(context, bw_aux_input_to_input_weights->dims->data[0],\n                      bw_input_to_input_weights->dims->data[0]);\n  }\n  TfLiteIntArray* bw_scratch_buffer_size = TfLiteIntArrayCreate(2);\n  bw_scratch_buffer_size->data[0] = n_batch;\n  if (bw_use_cifg) {\n    // Reserving space for Cell, Forget, Output gates\n    bw_scratch_buffer_size->data[1] = n_bw_cell * 3;\n  } else {\n    // Reserving space for Input, Cell, Forget, Output gates\n    bw_scratch_buffer_size->data[1] = n_bw_cell * 4;\n  }\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_scratch_buffer,\n                                                   bw_scratch_buffer_size));\n  if (is_hybrid_op) {\n    // Compute the row sums for cached zero_point offset calculation.\n    op_data->compute_fw_row_sums = true;\n    op_data->compute_bw_row_sums = true;\n    // Allocate temporary tensors to store quantized values of input, aux_input\n    // (if present), activation_state and cell_state tensors.\n    node->temporaries->data[kInputQuantized] =\n        op_data->scratch_tensor_index + kInputQuantized;\n    TfLiteTensor* input_quantized =\n        GetTemporary(context, node, kInputQuantized);\n    input_quantized->type = fw_input_to_output_weights->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    node->temporaries->data[kFwActivationStateQuantized] =\n        op_data->scratch_tensor_index + kFwActivationStateQuantized;\n    TfLiteTensor* fw_activation_state_quantized =\n        GetTemporary(context, node, kFwActivationStateQuantized);\n    fw_activation_state_quantized->type = fw_input_to_output_weights->type;\n    fw_activation_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(fw_activation_state_quantized->dims,\n                             fw_activation_state->dims)) {\n      TfLiteIntArray* fw_activation_state_quantized_size =\n          TfLiteIntArrayCopy(fw_activation_state->dims);\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, fw_activation_state_quantized,\n                                         fw_activation_state_quantized_size));\n    }\n    node->temporaries->data[kBwActivationStateQuantized] =\n        op_data->scratch_tensor_index + kBwActivationStateQuantized;\n    TfLiteTensor* bw_activation_state_quantized =\n        GetTemporary(context, node, kBwActivationStateQuantized);\n    bw_activation_state_quantized->type = fw_input_to_output_weights->type;\n    bw_activation_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(bw_activation_state_quantized->dims,\n                             bw_activation_state->dims)) {\n      TfLiteIntArray* bw_activation_state_quantized_size =\n          TfLiteIntArrayCopy(bw_activation_state->dims);\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, bw_activation_state_quantized,\n                                         bw_activation_state_quantized_size));\n    }\n    node->temporaries->data[kFwCellStateQuantized] =\n        op_data->scratch_tensor_index + kFwCellStateQuantized;\n    TfLiteTensor* fw_cell_state_quantized =\n        GetTemporary(context, node, kFwCellStateQuantized);\n    fw_cell_state_quantized->type = fw_input_to_output_weights->type;\n    fw_cell_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(fw_cell_state_quantized->dims,\n                             fw_cell_state->dims)) {\n      TfLiteIntArray* fw_cell_state_quantized_size =\n          TfLiteIntArrayCopy(fw_cell_state->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, fw_cell_state_quantized,\n                                              fw_cell_state_quantized_size));\n    }\n    node->temporaries->data[kBwCellStateQuantized] =\n        op_data->scratch_tensor_index + kBwCellStateQuantized;\n    TfLiteTensor* bw_cell_state_quantized =\n        GetTemporary(context, node, kBwCellStateQuantized);\n    bw_cell_state_quantized->type = fw_input_to_output_weights->type;\n    bw_cell_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(bw_cell_state_quantized->dims,\n                             bw_cell_state->dims)) {\n      TfLiteIntArray* bw_cell_state_quantized_size =\n          TfLiteIntArrayCopy(bw_cell_state->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, bw_cell_state_quantized,\n                                              bw_cell_state_quantized_size));\n    }\n\n    // Allocate temporary tensors to store scaling factors and product scaling\n    // factors. The latter is a convenience storage which allows to quantize\n    // a vector once (which produces the scaling factors) and multiply it with\n    // different matrices (which requires multiplying the scaling factors with\n    // the scaling factor of the matrix).\n    node->temporaries->data[kInputScalingFactors] =\n        op_data->scratch_tensor_index + kInputScalingFactors;\n    TfLiteTensor* input_sf = GetTemporary(context, node, kInputScalingFactors);\n    input_sf->type = kTfLiteFloat32;\n    input_sf->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {n_batch};\n    if (!TfLiteIntArrayEqualsArray(input_sf->dims, 1, scaling_dims)) {\n      TfLiteIntArray* input_sf_size = TfLiteIntArrayCreate(1);\n      input_sf_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, input_sf, input_sf_size));\n    }\n    node->temporaries->data[kAuxInputScalingFactors] =\n        op_data->scratch_tensor_index + kAuxInputScalingFactors;\n    TfLiteTensor* aux_input_sf =\n        GetTemporary(context, node, kAuxInputScalingFactors);\n    aux_input_sf->type = kTfLiteFloat32;\n    aux_input_sf->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(aux_input_sf->dims, 1, scaling_dims)) {\n      TfLiteIntArray* aux_input_sf_size = TfLiteIntArrayCreate(1);\n      aux_input_sf_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, aux_input_sf,\n                                                       aux_input_sf_size));\n    }\n    node->temporaries->data[kOutputStateScalingFactors] =\n        op_data->scratch_tensor_index + kOutputStateScalingFactors;\n    TfLiteTensor* output_state_sf =\n        GetTemporary(context, node, kOutputStateScalingFactors);\n    output_state_sf->type = kTfLiteFloat32;\n    output_state_sf->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(output_state_sf->dims, 1, scaling_dims)) {\n      TfLiteIntArray* output_state_sf_size = TfLiteIntArrayCreate(1);\n      output_state_sf_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_state_sf,\n                                                       output_state_sf_size));\n    }\n    node->temporaries->data[kProductScalingFactors] =\n        op_data->scratch_tensor_index + kProductScalingFactors;\n    TfLiteTensor* prod_scaling_factors =\n        GetTemporary(context, node, kProductScalingFactors);\n    prod_scaling_factors->type = kTfLiteFloat32;\n    prod_scaling_factors->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(prod_scaling_factors->dims, 1,\n                                   scaling_dims)) {\n      TfLiteIntArray* prod_scaling_factors_size = TfLiteIntArrayCreate(1);\n      prod_scaling_factors_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, prod_scaling_factors,\n                                              prod_scaling_factors_size));\n    }\n\n    // Allocate a temporary tensor to store the recovered cell weights. Since\n    // this is used for diagonal matrices, only need to store n_cell values.\n    node->temporaries->data[kRecoveredCellWeights] =\n        op_data->scratch_tensor_index + kRecoveredCellWeights;\n    TfLiteTensor* recovered_cell_weights =\n        GetTemporary(context, node, kRecoveredCellWeights);\n    recovered_cell_weights->type = kTfLiteFloat32;\n    recovered_cell_weights->allocation_type = kTfLiteArenaRw;\n    int recovered_cell_dims[1] = {n_fw_cell};\n    if (!TfLiteIntArrayEqualsArray(recovered_cell_weights->dims, 1,\n                                   recovered_cell_dims)) {\n      TfLiteIntArray* recovered_cell_weights_size = TfLiteIntArrayCreate(1);\n      recovered_cell_weights_size->data[0] = n_fw_cell;\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, recovered_cell_weights,\n                                              recovered_cell_weights_size));\n    }\n\n    // Allocate a temporary tensor to store the accumulated int32 values.\n    node->temporaries->data[kAccumScratchBuffer] =\n        op_data->scratch_tensor_index + kAccumScratchBuffer;\n    TfLiteTensor* accum_scratch =\n        GetTemporary(context, node, kAccumScratchBuffer);\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int n_cell = std::max(n_fw_cell, n_bw_cell);\n    if (has_aux_input) {\n      n_cell = std::max(n_cell, fw_aux_input_to_output_weights->dims->data[0]);\n      n_cell = std::max(n_cell, bw_aux_input_to_output_weights->dims->data[0]);\n    }\n    int accum_scratch_dims[2] = {n_cell, n_batch};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_size = TfLiteIntArrayCreate(2);\n      accum_size->data[0] = n_cell;\n      accum_size->data[1] = n_batch;\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, accum_scratch, accum_size));\n    }\n\n    // Allocate temporary tensors for storing zero-points.\n    node->temporaries->data[kInputZeroPoints] =\n        op_data->scratch_tensor_index + kInputZeroPoints;\n    TfLiteTensor* input_zp = GetTemporary(context, node, kInputZeroPoints);\n    input_zp->type = kTfLiteFloat32;\n    input_zp->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(input_zp->dims, 1, scaling_dims)) {\n      TfLiteIntArray* input_zp_size = TfLiteIntArrayCreate(1);\n      input_zp_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, input_zp, input_zp_size));\n    }\n    node->temporaries->data[kAuxInputZeroPoints] =\n        op_data->scratch_tensor_index + kAuxInputZeroPoints;\n    TfLiteTensor* aux_input_zp =\n        GetTemporary(context, node, kAuxInputZeroPoints);\n    aux_input_zp->type = kTfLiteFloat32;\n    aux_input_zp->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(aux_input_zp->dims, 1, scaling_dims)) {\n      TfLiteIntArray* aux_input_zp_size = TfLiteIntArrayCreate(1);\n      aux_input_zp_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, aux_input_zp,\n                                                       aux_input_zp_size));\n    }\n    node->temporaries->data[kOutputStateZeroPoints] =\n        op_data->scratch_tensor_index + kOutputStateZeroPoints;\n    TfLiteTensor* output_state_zp =\n        GetTemporary(context, node, kOutputStateZeroPoints);\n    output_state_zp->type = kTfLiteFloat32;\n    output_state_zp->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqualsArray(output_state_zp->dims, 1, scaling_dims)) {\n      TfLiteIntArray* output_state_zp_size = TfLiteIntArrayCreate(1);\n      output_state_zp_size->data[0] = n_batch;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_state_zp,\n                                                       output_state_zp_size));\n    }\n\n    // Allocate temporary tensors for caching row sums for hybrid zero-point\n    // calculations.\n    int fw_row_sums_rows = fw_use_cifg ? 6 : 8;\n    if (has_aux_input) {\n      fw_row_sums_rows += fw_use_cifg ? 3 : 4;\n    }\n    const TfLiteTensor* fw_projection_weights =\n        GetOptionalInputTensor(context, node, kFwProjectionWeightsTensor);\n    if (fw_projection_weights != nullptr) {\n      fw_row_sums_rows += ceil(static_cast<float>(n_fw_output) / n_fw_cell);\n    }\n    node->temporaries->data[kFwRowSums] =\n        op_data->scratch_tensor_index + kFwRowSums;\n    TfLiteTensor* fw_row_sums = GetTemporary(context, node, kFwRowSums);\n    fw_row_sums->type = kTfLiteInt32;\n    fw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int fw_row_sums_dims[2] = {fw_row_sums_rows, n_fw_cell};\n    if (!TfLiteIntArrayEqualsArray(fw_row_sums->dims, 2, fw_row_sums_dims)) {\n      TfLiteIntArray* fw_hybrid_scratch_size = TfLiteIntArrayCreate(2);\n      fw_hybrid_scratch_size->data[0] = fw_row_sums_dims[0];\n      fw_hybrid_scratch_size->data[1] = fw_row_sums_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, fw_row_sums,\n                                                       fw_hybrid_scratch_size));\n    }\n\n    int bw_row_sums_rows = bw_use_cifg ? 6 : 8;\n    if (has_aux_input) {\n      bw_row_sums_rows += bw_use_cifg ? 3 : 4;\n    }\n    const TfLiteTensor* bw_projection_weights =\n        GetOptionalInputTensor(context, node, kBwProjectionWeightsTensor);\n    if (bw_projection_weights != nullptr) {\n      bw_row_sums_rows += ceil(static_cast<float>(n_bw_output) / n_bw_cell);\n    }\n    node->temporaries->data[kBwRowSums] =\n        op_data->scratch_tensor_index + kBwRowSums;\n    TfLiteTensor* bw_row_sums = GetTemporary(context, node, kBwRowSums);\n    bw_row_sums->type = kTfLiteInt32;\n    bw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int bw_row_sums_dims[2] = {bw_row_sums_rows, n_bw_cell};\n    if (!TfLiteIntArrayEqualsArray(bw_row_sums->dims, 2, bw_row_sums_dims)) {\n      TfLiteIntArray* bw_row_sums_size = TfLiteIntArrayCreate(2);\n      bw_row_sums_size->data[0] = bw_row_sums_dims[0];\n      bw_row_sums_size->data[1] = bw_row_sums_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_row_sums,\n                                                       bw_row_sums_size));\n    }\n\n    // Only allocate a temporary tensor for quantized auxiliary input if we are\n    // actually going to use it.\n    if (has_aux_input) {\n      node->temporaries->data[kAuxInputQuantized] =\n          op_data->scratch_tensor_index + kAuxInputQuantized;\n      TfLiteTensor* aux_input_quantized =\n          GetTemporary(context, node, kAuxInputQuantized);\n      aux_input_quantized->type = fw_input_to_output_weights->type;\n      aux_input_quantized->allocation_type = kTfLiteArenaRw;\n      if (!TfLiteIntArrayEqual(aux_input_quantized->dims, aux_input->dims)) {\n        TfLiteIntArray* aux_input_quantized_size =\n            TfLiteIntArrayCopy(aux_input->dims);\n        TF_LITE_ENSURE_OK(context,\n                          context->ResizeTensor(context, aux_input_quantized,\n                                                aux_input_quantized_size));\n      }\n    }\n  }\n  return kTfLiteOk;\n}\n\n// The LSTM Op engine.\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = reinterpret_cast<TfLiteBidirectionalSequenceLSTMParams*>(\n      node->builtin_data);\n  auto* op_data = reinterpret_cast<OpData*>(node->user_data);\n  // Input tensor.\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n\n  // Tensors for the forward cell.\n  const TfLiteTensor* fw_input_to_input_weights =\n      GetOptionalInputTensor(context, node, kFwInputToInputWeightsTensor);\n  const TfLiteTensor* fw_input_to_forget_weights =\n      GetInput(context, node, kFwInputToForgetWeightsTensor);\n  const TfLiteTensor* fw_input_to_cell_weights =\n      GetInput(context, node, kFwInputToCellWeightsTensor);\n  const TfLiteTensor* fw_input_to_output_weights =\n      GetInput(context, node, kFwInputToOutputWeightsTensor);\n\n  const TfLiteTensor* fw_recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kFwRecurrentToInputWeightsTensor);\n  const TfLiteTensor* fw_recurrent_to_forget_weights =\n      GetInput(context, node, kFwRecurrentToForgetWeightsTensor);\n  const TfLiteTensor* fw_recurrent_to_cell_weights =\n      GetInput(context, node, kFwRecurrentToCellWeightsTensor);\n  const TfLiteTensor* fw_recurrent_to_output_weights =\n      GetInput(context, node, kFwRecurrentToOutputWeightsTensor);\n\n  const TfLiteTensor* fw_cell_to_input_weights =\n      GetOptionalInputTensor(context, node, kFwCellToInputWeightsTensor);\n  const TfLiteTensor* fw_cell_to_forget_weights =\n      GetOptionalInputTensor(context, node, kFwCellToForgetWeightsTensor);\n  const TfLiteTensor* fw_cell_to_output_weights =\n      GetOptionalInputTensor(context, node, kFwCellToOutputWeightsTensor);\n\n  const TfLiteTensor* fw_input_gate_bias =\n      GetOptionalInputTensor(context, node, kFwInputGateBiasTensor);\n  const TfLiteTensor* fw_forget_gate_bias =\n      GetInput(context, node, kFwForgetGateBiasTensor);\n  const TfLiteTensor* fw_cell_gate_bias =\n      GetInput(context, node, kFwCellGateBiasTensor);\n  const TfLiteTensor* fw_output_gate_bias =\n      GetInput(context, node, kFwOutputGateBiasTensor);\n\n  const TfLiteTensor* fw_projection_weights =\n      GetOptionalInputTensor(context, node, kFwProjectionWeightsTensor);\n  const TfLiteTensor* fw_projection_bias =\n      GetOptionalInputTensor(context, node, kFwProjectionBiasTensor);\n\n  TfLiteTensor* fw_activation_state =\n      GetVariableInput(context, node, kFwInputActivationStateTensor);\n  TF_LITE_ENSURE(context, fw_activation_state != nullptr);\n  TfLiteTensor* fw_cell_state =\n      GetVariableInput(context, node, kFwInputCellStateTensor);\n  TF_LITE_ENSURE(context, fw_cell_state != nullptr);\n  TfLiteTensor* fw_output = GetOutput(context, node, kFwOutputTensor);\n\n  // Tensors for the backward cell.\n  const TfLiteTensor* bw_input_to_input_weights =\n      GetOptionalInputTensor(context, node, kBwInputToInputWeightsTensor);\n  const TfLiteTensor* bw_input_to_forget_weights =\n      GetInput(context, node, kBwInputToForgetWeightsTensor);\n  const TfLiteTensor* bw_input_to_cell_weights =\n      GetInput(context, node, kBwInputToCellWeightsTensor);\n  const TfLiteTensor* bw_input_to_output_weights =\n      GetInput(context, node, kBwInputToOutputWeightsTensor);\n\n  const TfLiteTensor* bw_recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kBwRecurrentToInputWeightsTensor);\n  const TfLiteTensor* bw_recurrent_to_forget_weights =\n      GetInput(context, node, kBwRecurrentToForgetWeightsTensor);\n  const TfLiteTensor* bw_recurrent_to_cell_weights =\n      GetInput(context, node, kBwRecurrentToCellWeightsTensor);\n  const TfLiteTensor* bw_recurrent_to_output_weights =\n      GetInput(context, node, kBwRecurrentToOutputWeightsTensor);\n\n  const TfLiteTensor* bw_cell_to_input_weights =\n      GetOptionalInputTensor(context, node, kBwCellToInputWeightsTensor);\n  const TfLiteTensor* bw_cell_to_forget_weights =\n      GetOptionalInputTensor(context, node, kBwCellToForgetWeightsTensor);\n  const TfLiteTensor* bw_cell_to_output_weights =\n      GetOptionalInputTensor(context, node, kBwCellToOutputWeightsTensor);\n\n  const TfLiteTensor* bw_input_gate_bias =\n      GetOptionalInputTensor(context, node, kBwInputGateBiasTensor);\n  const TfLiteTensor* bw_forget_gate_bias =\n      GetInput(context, node, kBwForgetGateBiasTensor);\n  const TfLiteTensor* bw_cell_gate_bias =\n      GetInput(context, node, kBwCellGateBiasTensor);\n  const TfLiteTensor* bw_output_gate_bias =\n      GetInput(context, node, kBwOutputGateBiasTensor);\n\n  const TfLiteTensor* bw_projection_weights =\n      GetOptionalInputTensor(context, node, kBwProjectionWeightsTensor);\n  const TfLiteTensor* bw_projection_bias =\n      GetOptionalInputTensor(context, node, kBwProjectionBiasTensor);\n\n  // State tensors.\n  TfLiteTensor* bw_activation_state =\n      GetVariableInput(context, node, kBwInputActivationStateTensor);\n  TF_LITE_ENSURE(context, bw_activation_state != nullptr);\n  TfLiteTensor* bw_cell_state =\n      GetVariableInput(context, node, kBwInputCellStateTensor);\n  TF_LITE_ENSURE(context, bw_cell_state != nullptr);\n  TfLiteTensor* bw_output = params->merge_outputs\n                                ? nullptr\n                                : GetOutput(context, node, kBwOutputTensor);\n\n  // Temporary tensors.\n  TfLiteTensor* fw_scratch_buffer =\n      GetTemporary(context, node, kFwScratchBuffer);\n  TfLiteTensor* bw_scratch_buffer =\n      GetTemporary(context, node, kBwScratchBuffer);\n\n  // (Optional) auxiliary inputs.\n  const TfLiteTensor* aux_input =\n      GetOptionalInputTensor(context, node, kAuxInputTensor);\n  const TfLiteTensor* fw_aux_input_to_input_weights =\n      GetOptionalInputTensor(context, node, kFwAuxInputToInputWeightsTensor);\n  const TfLiteTensor* fw_aux_input_to_forget_weights =\n      GetOptionalInputTensor(context, node, kFwAuxInputToForgetWeightsTensor);\n  const TfLiteTensor* fw_aux_input_to_cell_weights =\n      GetOptionalInputTensor(context, node, kFwAuxInputToCellWeightsTensor);\n  const TfLiteTensor* fw_aux_input_to_output_weights =\n      GetOptionalInputTensor(context, node, kFwAuxInputToOutputWeightsTensor);\n  const TfLiteTensor* bw_aux_input_to_input_weights =\n      GetOptionalInputTensor(context, node, kBwAuxInputToInputWeightsTensor);\n  const TfLiteTensor* bw_aux_input_to_forget_weights =\n      GetOptionalInputTensor(context, node, kBwAuxInputToForgetWeightsTensor);\n  const TfLiteTensor* bw_aux_input_to_cell_weights =\n      GetOptionalInputTensor(context, node, kBwAuxInputToCellWeightsTensor);\n  const TfLiteTensor* bw_aux_input_to_output_weights =\n      GetOptionalInputTensor(context, node, kBwAuxInputToOutputWeightsTensor);\n\n  const bool has_previous_bw_output = (aux_input != nullptr);\n  const bool use_aux_input = (fw_aux_input_to_forget_weights != nullptr);\n\n  // Populate a TfLiteLSTMParams struct for the evaluation functions.\n  TfLiteLSTMParams lstm_params = {params->activation, params->cell_clip,\n                                  params->proj_clip, kTfLiteLSTMFullKernel,\n                                  params->asymmetric_quantize_inputs};\n\n  const int bw_output_offset =\n      params->merge_outputs ? fw_recurrent_to_output_weights->dims->data[1] : 0;\n  const auto actual_bw_output = params->merge_outputs ? fw_output : bw_output;\n\n  const bool time_major = params->time_major;\n\n  // We want to cover the following cases:\n  //\n  // If not stacking (not connected after other bidi lstms):\n  //   both fw & bw will just use `input`; aux_input will be null.\n  //\n  // If stacking with cross_links, TensorFlow equivalent\n  // (tf.contrib.rnn.stack_bidirectional_rnn):\n  //   both fw & bw will use `input`, but aux_input will be none null.\n  //   Note, this time, whether connected after other bidi lstms both works.\n  //\n  // If stacking without cross_links, but connected after other bidi lstms,\n  // TensorFlow equivalent (tf.nn.static_bidirectional_rnn):\n  //   fw will use `input`, bw will use aux_input, and the `real aux_input`\n  //   will be null.\n\n  const bool non_stacking_mode = !use_aux_input && has_previous_bw_output;\n  const TfLiteTensor* bw_input = non_stacking_mode ? aux_input : input;\n  const TfLiteTensor* real_aux_input = non_stacking_mode ? nullptr : aux_input;\n\n  switch (fw_input_to_output_weights->type) {\n    case kTfLiteFloat32: {\n      TfLiteStatus fw_pass_status = lstm_eval::EvalFloat(\n          input, fw_input_to_input_weights, fw_input_to_forget_weights,\n          fw_input_to_cell_weights, fw_input_to_output_weights,\n          fw_recurrent_to_input_weights, fw_recurrent_to_forget_weights,\n          fw_recurrent_to_cell_weights, fw_recurrent_to_output_weights,\n          fw_cell_to_input_weights, fw_cell_to_forget_weights,\n          fw_cell_to_output_weights,\n          /*input_layer_norm_coefficients=*/nullptr,\n          /*forget_layer_norm_coefficients=*/nullptr,\n          /*cell_layer_norm_coefficients=*/nullptr,\n          /*output_layer_norm_coefficients=*/nullptr, real_aux_input,\n          fw_aux_input_to_input_weights, fw_aux_input_to_forget_weights,\n          fw_aux_input_to_cell_weights, fw_aux_input_to_output_weights,\n          fw_input_gate_bias, fw_forget_gate_bias, fw_cell_gate_bias,\n          fw_output_gate_bias, fw_projection_weights, fw_projection_bias,\n          &lstm_params,\n          /*forward_sequence=*/true, time_major, /*output_offset=*/0,\n          fw_scratch_buffer, fw_activation_state, fw_cell_state, fw_output);\n      TF_LITE_ENSURE_OK(context, fw_pass_status);\n\n      TfLiteStatus bw_pass_status = lstm_eval::EvalFloat(\n          bw_input, bw_input_to_input_weights, bw_input_to_forget_weights,\n          bw_input_to_cell_weights, bw_input_to_output_weights,\n          bw_recurrent_to_input_weights, bw_recurrent_to_forget_weights,\n          bw_recurrent_to_cell_weights, bw_recurrent_to_output_weights,\n          bw_cell_to_input_weights, bw_cell_to_forget_weights,\n          bw_cell_to_output_weights,\n          /*input_layer_norm_coefficients=*/nullptr,\n          /*forget_layer_norm_coefficients=*/nullptr,\n          /*cell_layer_norm_coefficients=*/nullptr,\n          /*output_layer_norm_coefficients=*/nullptr, real_aux_input,\n          bw_aux_input_to_input_weights, bw_aux_input_to_forget_weights,\n          bw_aux_input_to_cell_weights, bw_aux_input_to_output_weights,\n          bw_input_gate_bias, bw_forget_gate_bias, bw_cell_gate_bias,\n          bw_output_gate_bias, bw_projection_weights, bw_projection_bias,\n          &lstm_params,\n          /*forward_sequence=*/false, time_major, bw_output_offset,\n          bw_scratch_buffer, bw_activation_state, bw_cell_state,\n          actual_bw_output);\n      TF_LITE_ENSURE_OK(context, bw_pass_status);\n      return kTfLiteOk;\n    }\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      TfLiteTensor* input_quantized =\n          GetTemporary(context, node, kInputQuantized);\n      TfLiteTensor* fw_activation_state_quantized =\n          GetTemporary(context, node, kFwActivationStateQuantized);\n      TfLiteTensor* bw_activation_state_quantized =\n          GetTemporary(context, node, kBwActivationStateQuantized);\n      TfLiteTensor* fw_cell_state_quantized =\n          GetTemporary(context, node, kFwCellStateQuantized);\n      TfLiteTensor* bw_cell_state_quantized =\n          GetTemporary(context, node, kBwCellStateQuantized);\n      TfLiteTensor* prod_scaling_factors =\n          GetTemporary(context, node, kProductScalingFactors);\n      TfLiteTensor* recovered_cell_weights =\n          GetTemporary(context, node, kRecoveredCellWeights);\n      TfLiteTensor* aux_input_quantized =\n          use_aux_input ? GetTemporary(context, node, kAuxInputQuantized)\n                        : nullptr;\n      TfLiteTensor* accum_scratch =\n          GetTemporary(context, node, kAccumScratchBuffer);\n      TfLiteTensor* fw_row_sums = GetTemporary(context, node, kFwRowSums);\n      TfLiteTensor* bw_row_sums = GetTemporary(context, node, kBwRowSums);\n      const int fw_row_sums_size = fw_row_sums->dims->data[0];\n      const int bw_row_sums_size = bw_row_sums->dims->data[0];\n      TfLiteStatus fw_pass_status = lstm_eval::EvalHybrid(\n          input, fw_input_to_input_weights,\n          /*input_to_input_weights_ledger*/ nullptr, fw_input_to_forget_weights,\n          /*input_to_forget_weights_ledger*/ nullptr, fw_input_to_cell_weights,\n          /*input_to_cell_weights_ledger*/ nullptr, fw_input_to_output_weights,\n          /*input_to_output_weights_ledger*/ nullptr,\n          fw_recurrent_to_input_weights,\n          /*recurrent_to_input_weights_ledger*/ nullptr,\n          fw_recurrent_to_forget_weights,\n          /*recurrent_to_forget_weights_ledger*/ nullptr,\n          fw_recurrent_to_cell_weights,\n          /*recurrent_to_cell_weights_ledger*/ nullptr,\n          fw_recurrent_to_output_weights,\n          /*recurrent_to_output_weights_ledger*/ nullptr,\n          fw_cell_to_input_weights, fw_cell_to_forget_weights,\n          fw_cell_to_output_weights,\n          /*input_layer_norm_coefficients=*/nullptr,\n          /*forget_layer_norm_coefficients=*/nullptr,\n          /*cell_layer_norm_coefficients=*/nullptr,\n          /*output_layer_norm_coefficients=*/nullptr, real_aux_input,\n          fw_aux_input_to_input_weights, fw_aux_input_to_forget_weights,\n          fw_aux_input_to_cell_weights, fw_aux_input_to_output_weights,\n          fw_input_gate_bias, fw_forget_gate_bias, fw_cell_gate_bias,\n          fw_output_gate_bias, fw_projection_weights,\n          /*projection_weights_ledger*/ nullptr, fw_projection_bias,\n          &lstm_params,\n          /*forward_sequence=*/true, /*time_major=*/true, /*output_offset=*/0,\n          fw_scratch_buffer, GetTemporary(context, node, kInputScalingFactors),\n          GetTemporary(context, node, kAuxInputScalingFactors),\n          GetTemporary(context, node, kOutputStateScalingFactors),\n          prod_scaling_factors, recovered_cell_weights, input_quantized,\n          aux_input_quantized, fw_activation_state_quantized,\n          fw_cell_state_quantized, fw_activation_state, fw_cell_state,\n          accum_scratch, fw_output,\n          GetTemporary(context, node, kInputZeroPoints),\n          GetTemporary(context, node, kAuxInputZeroPoints),\n          GetTemporary(context, node, kOutputStateZeroPoints), fw_row_sums,\n          fw_row_sums_size, &op_data->compute_fw_row_sums,\n          CpuBackendContext::GetFromContext(context));\n      TF_LITE_ENSURE_OK(context, fw_pass_status);\n\n      TfLiteStatus bw_pass_status = lstm_eval::EvalHybrid(\n          bw_input, bw_input_to_input_weights,\n          /*input_to_input_weights_ledger*/ nullptr, bw_input_to_forget_weights,\n          /*input_to_forget_weights_ledger*/ nullptr, bw_input_to_cell_weights,\n          /*input_to_cell_weights_ledger*/ nullptr, bw_input_to_output_weights,\n          /*input_to_output_weights_ledger*/ nullptr,\n          bw_recurrent_to_input_weights,\n          /*recurrent_to_input_weights_ledger*/ nullptr,\n          bw_recurrent_to_forget_weights,\n          /*recurrent_to_forget_weights_ledger*/ nullptr,\n          bw_recurrent_to_cell_weights,\n          /*recurrent_to_cell_weights_ledger*/ nullptr,\n          bw_recurrent_to_output_weights,\n          /*recurrent_to_output_weights_ledger*/ nullptr,\n          bw_cell_to_input_weights, bw_cell_to_forget_weights,\n          bw_cell_to_output_weights,\n          /*input_layer_norm_coefficients=*/nullptr,\n          /*forget_layer_norm_coefficients=*/nullptr,\n          /*cell_layer_norm_coefficients=*/nullptr,\n          /*output_layer_norm_coefficients=*/nullptr, real_aux_input,\n          bw_aux_input_to_input_weights, bw_aux_input_to_forget_weights,\n          bw_aux_input_to_cell_weights, bw_aux_input_to_output_weights,\n          bw_input_gate_bias, bw_forget_gate_bias, bw_cell_gate_bias,\n          bw_output_gate_bias, bw_projection_weights,\n          /*projection_weights_ledger*/ nullptr, bw_projection_bias,\n          &lstm_params,\n          /*forward_sequence=*/false, /*time_major=*/true, bw_output_offset,\n          bw_scratch_buffer, GetTemporary(context, node, kInputScalingFactors),\n          GetTemporary(context, node, kAuxInputScalingFactors),\n          GetTemporary(context, node, kOutputStateScalingFactors),\n          prod_scaling_factors, recovered_cell_weights, input_quantized,\n          aux_input_quantized, bw_activation_state_quantized,\n          bw_cell_state_quantized, bw_activation_state, bw_cell_state,\n          accum_scratch, actual_bw_output,\n          GetTemporary(context, node, kInputZeroPoints),\n          GetTemporary(context, node, kAuxInputZeroPoints),\n          GetTemporary(context, node, kOutputStateZeroPoints), bw_row_sums,\n          bw_row_sums_size, &op_data->compute_bw_row_sums,\n          CpuBackendContext::GetFromContext(context));\n      TF_LITE_ENSURE_OK(context, bw_pass_status);\n      return kTfLiteOk;\n    }\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s is not currently supported.\",\n                         TfLiteTypeGetName(fw_input_to_output_weights->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n\n}  // namespace bidirectional_sequence_lstm\n\nTfLiteRegistration* Register_BIDIRECTIONAL_SEQUENCE_LSTM() {\n  static TfLiteRegistration r = {\n      bidirectional_sequence_lstm::Init, bidirectional_sequence_lstm::Free,\n      bidirectional_sequence_lstm::Prepare, bidirectional_sequence_lstm::Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite"