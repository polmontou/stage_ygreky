"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/lite/kernels/internal/optimized/integer_ops/mul.h\"\n\n#include <stddef.h>\n#include <stdint.h>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/compatibility.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/cpu_check.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/neon_check.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/kernels/internal/quantization_util.h\"\n#include \"tensorflow/lite/kernels/internal/reference/integer_ops/mul.h\"\n#include \"tensorflow/lite/kernels/internal/reference/mul.h\"\n#include \"tensorflow/lite/kernels/internal/reference/process_broadcast_shapes.h\"\n#include \"tensorflow/lite/kernels/internal/reference/reference_ops.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/types.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace mul {\n\n// This file has three implementation of Mul.\nenum KernelType {\n  kReference,\n  kGenericOptimized,  // Neon-free\n  kNeonOptimized,\n};\n\nconstexpr int kInputTensor1 = 0;\nconstexpr int kInputTensor2 = 1;\nconstexpr int kOutputTensor = 0;\n\nstruct OpData {\n  // Parameters used in the quantized paths where the output is 8bit\n  int32 output_activation_min;\n  int32 output_activation_max;\n\n  // Parameters used in all quantized paths\n  int32_t output_multiplier;\n  int output_shift;\n};\n\nvoid* Init(TfLiteContext* context, const char* buffer, size_t length) {\n  auto* data = new OpData;\n  return data;\n}\n\nvoid Free(TfLiteContext* context, void* buffer) {\n  delete reinterpret_cast<OpData*>(buffer);\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMulParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const bool requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n      output->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n    double real_multiplier =\n        input1->params.scale * input2->params.scale / output->params.scale;\n    QuantizeMultiplier(real_multiplier, &data->output_multiplier,\n                       &data->output_shift);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n\ntemplate <KernelType kernel_type>\nvoid EvalMul(TfLiteContext* context, TfLiteNode* node, TfLiteMulParams* params,\n             const OpData* data, const TfLiteTensor* input1,\n             const TfLiteTensor* input2, TfLiteTensor* output) {\n  tflite::ArithmeticParams op_params;\n  const bool need_broadcast = optimized_ops::ProcessBroadcastShapes(\n      GetTensorShape(input1), GetTensorShape(input2), &op_params);\n#define TF_LITE_MUL(type, opname, data_type)                             \\\n  data_type output_activation_min, output_activation_max;                \\\n  CalculateActivationRange(params->activation, &output_activation_min,   \\\n                           &output_activation_max);                      \\\n  SetActivationParams(output_activation_min, output_activation_max,      \\\n                      &op_params);                                       \\\n  type::opname(op_params, GetTensorShape(input1),                        \\\n               GetTensorData<data_type>(input1), GetTensorShape(input2), \\\n               GetTensorData<data_type>(input2), GetTensorShape(output), \\\n               GetTensorData<data_type>(output))\n\n  if (output->type == kTfLiteInt32) {\n    if (kernel_type == kReference) {\n      if (need_broadcast) {\n        TF_LITE_MUL(reference_ops, BroadcastMul4DSlow, int32_t);\n      } else {\n        TF_LITE_MUL(reference_ops, Mul, int32_t);\n      }\n    } else {\n      if (need_broadcast) {\n        TF_LITE_MUL(optimized_ops, BroadcastMul4DSlow, int32_t);\n      } else {\n        TF_LITE_MUL(optimized_ops, Mul, int32_t);\n      }\n    }\n  } else if (output->type == kTfLiteFloat32) {\n    if (kernel_type == kReference) {\n      if (need_broadcast) {\n        TF_LITE_MUL(reference_ops, BroadcastMul4DSlow, float);\n      } else {\n        TF_LITE_MUL(reference_ops, Mul, float);\n      }\n    } else {\n      if (need_broadcast) {\n        TF_LITE_MUL(optimized_ops, BroadcastMulDispatch, float);\n      } else {\n        TF_LITE_MUL(optimized_ops, Mul, float);\n      }\n    }\n  }\n#undef TF_LITE_MUL\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           TfLiteMulParams* params, const OpData* data,\n                           const TfLiteTensor* input1,\n                           const TfLiteTensor* input2, TfLiteTensor* output) {\n  if (input1->type == input2->type && input1->type == output->type &&\n      (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8 ||\n       input1->type == kTfLiteInt16)) {\n    tflite::ArithmeticParams op_params;\n    SetActivationParams(data->output_activation_min,\n                        data->output_activation_max, &op_params);\n    op_params.input1_offset = -input1->params.zero_point;\n    op_params.input2_offset = -input2->params.zero_point;\n    op_params.output_offset = output->params.zero_point;\n    op_params.output_multiplier = data->output_multiplier;\n    op_params.output_shift = data->output_shift;\n    bool need_broadcast = optimized_ops::ProcessBroadcastShapes(\n        GetTensorShape(input1), GetTensorShape(input2), &op_params);\n#define TF_LITE_MUL(type, opname, dtype)                             \\\n  type::opname(op_params, GetTensorShape(input1),                    \\\n               GetTensorData<dtype>(input1), GetTensorShape(input2), \\\n               GetTensorData<dtype>(input2), GetTensorShape(output), \\\n               GetTensorData<dtype>(output))\n    if (input1->type == kTfLiteInt8) {\n      if (kernel_type == kReference) {\n        if (need_broadcast) {\n          TF_LITE_MUL(reference_integer_ops, BroadcastMul4DSlow, int8_t);\n        } else {\n          TF_LITE_MUL(reference_integer_ops, Mul, int8_t);\n        }\n      } else {\n        if (need_broadcast) {\n          TF_LITE_MUL(optimized_integer_ops, BroadcastMulDispatch, int8_t);\n        } else {\n          TF_LITE_MUL(optimized_integer_ops, Mul, int8_t);\n        }\n      }\n    } else if (input1->type == kTfLiteInt16) {\n      // We have this check, because in case of int16\n      // input1_val*input2_val can overflow int32:\n      // see MulElementwise -\n      // tensorflow/lite/kernels/internal/reference/integer_ops/mul.h in case of\n      // 16-bit this function is used in symmetric quantization, so offset\n      // should be zero.\n      TF_LITE_ENSURE_EQ(context, op_params.input1_offset, 0.0);\n      TF_LITE_ENSURE_EQ(context, op_params.input2_offset, 0.0);\n      TF_LITE_ENSURE_EQ(context, op_params.output_offset, 0.0);\n\n      if (need_broadcast) {\n        TF_LITE_MUL(reference_integer_ops, BroadcastMul4DSlow, int16_t);\n      } else {\n        TF_LITE_MUL(reference_integer_ops, Mul, int16_t);\n      }\n    } else {\n      // type == kTfLiteUInt8\n      if (kernel_type == kReference) {\n        if (need_broadcast) {\n          TF_LITE_MUL(reference_ops, BroadcastMul4DSlow, uint8_t);\n        } else {\n          TF_LITE_MUL(reference_ops, Mul, uint8_t);\n        }\n      } else {\n        if (need_broadcast) {\n          TF_LITE_MUL(optimized_ops, BroadcastMulDispatch, uint8_t);\n        } else {\n          TF_LITE_MUL(optimized_ops, Mul, uint8_t);\n        }\n      }\n    }\n#undef TF_LITE_MUL\n  } else if (input1->type == kTfLiteInt16 && input2->type == kTfLiteInt16 &&\n             (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8)) {\n#define TF_LITE_MUL(type, opname, output_dtype)                        \\\n  tflite::ArithmeticParams op_params;                                  \\\n  SetActivationParams(data->output_activation_min,                     \\\n                      data->output_activation_max, &op_params);        \\\n  op_params.output_offset = output->params.zero_point;                 \\\n  type::opname(op_params, GetTensorShape(input1),                      \\\n               GetTensorData<int16_t>(input1), GetTensorShape(input2), \\\n               GetTensorData<int16_t>(input2), GetTensorShape(output), \\\n               GetTensorData<output_dtype>(output))\n    if (output->type == kTfLiteInt8) {\n      TF_LITE_MUL(reference_integer_ops, Mul, int8_t);\n    } else {\n      if (kernel_type == kReference) {\n        TF_LITE_MUL(reference_ops, Mul, uint8_t);\n      } else {\n        TF_LITE_MUL(optimized_ops, Mul, uint8_t);\n      }\n    }\n#undef TF_LITE_MUL\n  } else {\n    context->ReportError(\n        context, \"Unsupported combination of input and output types in Mul.\");\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMulParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n    EvalMul<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n             output->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(context,\n                         \"Mul only supports FLOAT32, INT32 and quantized UINT8,\"\n                         \" INT8 and INT16 now, got %d.\",\n                         output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n\n}  // namespace mul\n\nTfLiteRegistration* Register_MUL_REF() {\n  static TfLiteRegistration r = {mul::Init, mul::Free, mul::Prepare,\n                                 mul::Eval<mul::kReference>};\n  return &r;\n}\n\nTfLiteRegistration* Register_MUL_GENERIC_OPT() {\n  static TfLiteRegistration r = {mul::Init, mul::Free, mul::Prepare,\n                                 mul::Eval<mul::kGenericOptimized>};\n  return &r;\n}\n\nTfLiteRegistration* Register_MUL_NEON_OPT() {\n  static TfLiteRegistration r = {mul::Init, mul::Free, mul::Prepare,\n                                 mul::Eval<mul::kNeonOptimized>};\n  return &r;\n}\n\nTfLiteRegistration* Register_MUL() {\n#ifdef USE_NEON\n  return Register_MUL_NEON_OPT();\n#else\n  return Register_MUL_GENERIC_OPT();\n#endif\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite"