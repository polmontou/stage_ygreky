"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/lite/kernels/internal/reference/resize_nearest_neighbor.h\"\n\n#include <stdint.h>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/compatibility.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/neon_check.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/kernels/internal/reference/reference_ops.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/types.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace resize_nearest_neighbor {\n\n// This file has three implementations of RESIZE_NEAREST_NEIGHBOR.\nenum KernelType {\n  kReference,\n  kGenericOptimized,\n  kNeonOptimized,\n};\n\nconstexpr int kInputTensor = 0;\nconstexpr int kSizeTensor = 1;\nconstexpr int kOutputTensor = 0;\n\nTfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* input,\n                                const TfLiteTensor* size,\n                                TfLiteTensor* output) {\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  const int32* size_data = GetTensorData<int32>(size);\n  output_size->data[1] = size_data[0];\n  output_size->data[2] = size_data[1];\n  output_size->data[3] = input->dims->data[3];\n  return context->ResizeTensor(context, output, output_size);\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // TODO(ahentz): Our current implementations rely on the input being 4D,\n  // and the size being 1D tensor with exactly 2 elements.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(size), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, size->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, size->dims->data[0], 2);\n\n  output->type = input->type;\n\n  if (!IsConstantTensor(size)) {\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n  return ResizeOutputTensor(context, input, size, output);\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteResizeNearestNeighborParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor(context, input, size, output));\n  }\n\n  tflite::ResizeNearestNeighborParams op_params;\n  op_params.align_corners = params->align_corners;\n  op_params.half_pixel_centers = params->half_pixel_centers;\n\n  if (output->type == kTfLiteFloat32) {\n    reference_ops::ResizeNearestNeighbor(\n        op_params, GetTensorShape(input), GetTensorData<int32>(input),\n        GetTensorShape(size), GetTensorData<int32>(size),\n        GetTensorShape(output), GetTensorData<int32>(output));\n  } else if (output->type == kTfLiteUInt8) {\n    if (kernel_type == kReference) {\n      reference_ops::ResizeNearestNeighbor(\n          op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n          GetTensorShape(size), GetTensorData<int32>(size),\n          GetTensorShape(output), GetTensorData<uint8_t>(output));\n    }\n    if (kernel_type == kGenericOptimized || kernel_type == kNeonOptimized) {\n      optimized_ops::ResizeNearestNeighbor(\n          op_params, GetTensorShape(input), GetTensorData<uint8_t>(input),\n          GetTensorShape(size), GetTensorData<int32>(size),\n          GetTensorShape(output), GetTensorData<uint8_t>(output));\n    }\n  } else if (output->type == kTfLiteInt8) {\n    reference_ops::ResizeNearestNeighbor(\n        op_params, GetTensorShape(input), GetTensorData<int8_t>(input),\n        GetTensorShape(size), GetTensorData<int32>(size),\n        GetTensorShape(output), GetTensorData<int8_t>(output));\n  } else if (output->type == kTfLiteInt16) {\n    reference_ops::ResizeNearestNeighbor(\n        op_params, GetTensorShape(input), GetTensorData<int16_t>(input),\n        GetTensorShape(size), GetTensorData<int32>(size),\n        GetTensorShape(output), GetTensorData<int16_t>(output));\n  } else {\n    TF_LITE_KERNEL_LOG(\n        context, \"Output type is %s, requires float, uint8, int8 or int16.\",\n        TfLiteTypeGetName(output->type));\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n\n}  // namespace resize_nearest_neighbor\n\nTfLiteRegistration* Register_RESIZE_NEAREST_NEIGHBOR_REF() {\n  static TfLiteRegistration r = {\n      nullptr, nullptr, resize_nearest_neighbor::Prepare,\n      resize_nearest_neighbor::Eval<resize_nearest_neighbor::kReference>};\n  return &r;\n}\n\nTfLiteRegistration* Register_RESIZE_NEAREST_NEIGHBOR_GENERIC_OPT() {\n  static TfLiteRegistration r = {\n      nullptr, nullptr, resize_nearest_neighbor::Prepare,\n      resize_nearest_neighbor::Eval<\n          resize_nearest_neighbor::kGenericOptimized>};\n  return &r;\n}\n\nTfLiteRegistration* Register_RESIZE_NEAREST_NEIGHBOR_NEON_OPT() {\n  static TfLiteRegistration r = {\n      nullptr, nullptr, resize_nearest_neighbor::Prepare,\n      resize_nearest_neighbor::Eval<resize_nearest_neighbor::kNeonOptimized>};\n  return &r;\n}\n\nTfLiteRegistration* Register_RESIZE_NEAREST_NEIGHBOR() {\n#ifdef USE_NEON\n  return Register_RESIZE_NEAREST_NEIGHBOR_NEON_OPT();\n#else\n  return Register_RESIZE_NEAREST_NEIGHBOR_GENERIC_OPT();\n#endif\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite"