"/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <stdint.h>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/reference/reference_ops.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace reverse_sequence {\nnamespace {\n\nconstexpr int kInputTensor = 0;\nconstexpr int kSeqLengthsTensor = 1;\nconstexpr int kOutputTensor = 0;\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* seq_lengths = GetInput(context, node, kSeqLengthsTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(seq_lengths), 1);\n\n  if (input->type != kTfLiteInt32 && input->type != kTfLiteFloat32 &&\n      input->type != kTfLiteUInt8 && input->type != kTfLiteInt16 &&\n      input->type != kTfLiteInt64) {\n    context->ReportError(context,\n                         \"Type '%s' is not supported by reverse_sequence.\",\n                         TfLiteTypeGetName(input->type));\n    return kTfLiteError;\n  }\n\n  if (seq_lengths->type != kTfLiteInt32 && seq_lengths->type != kTfLiteInt64) {\n    context->ReportError(\n        context, \"Seq_lengths type '%s' is not supported by reverse_sequence.\",\n        TfLiteTypeGetName(seq_lengths->type));\n    return kTfLiteError;\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCopy(input->dims);\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input->type);\n\n  return context->ResizeTensor(context, output, output_shape);\n}\n\ntemplate <typename T, typename TS>\nTfLiteStatus ReverseSequenceImpl(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* seq_lengths_tensor =\n      GetInput(context, node, kSeqLengthsTensor);\n  const TS* seq_lengths = GetTensorData<TS>(seq_lengths_tensor);\n\n  auto* params =\n      reinterpret_cast<TfLiteReverseSequenceParams*>(node->builtin_data);\n  int seq_dim = params->seq_dim;\n  int batch_dim = params->batch_dim;\n\n  TF_LITE_ENSURE(context, seq_dim >= 0);\n  TF_LITE_ENSURE(context, batch_dim >= 0);\n  TF_LITE_ENSURE(context, seq_dim != batch_dim);\n  TF_LITE_ENSURE(context, seq_dim < NumDimensions(input));\n  TF_LITE_ENSURE(context, batch_dim < NumDimensions(input));\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(seq_lengths_tensor, 0),\n                    SizeOfDimension(input, batch_dim));\n  for (int i = 0; i < NumDimensions(seq_lengths_tensor); ++i) {\n    TF_LITE_ENSURE(context, seq_lengths[i] <= SizeOfDimension(input, seq_dim));\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  reference_ops::ReverseSequence<T, TS>(\n      seq_lengths, seq_dim, batch_dim, GetTensorShape(input),\n      GetTensorData<T>(input), GetTensorShape(output),\n      GetTensorData<T>(output));\n\n  return kTfLiteOk;\n}\n\ntemplate <typename T>\nTfLiteStatus ReverseSequenceHelper(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* seq_lengths_tensor =\n      GetInput(context, node, kSeqLengthsTensor);\n  switch (seq_lengths_tensor->type) {\n    case kTfLiteInt32: {\n      return ReverseSequenceImpl<T, int32_t>(context, node);\n    }\n    case kTfLiteInt64: {\n      return ReverseSequenceImpl<T, int64_t>(context, node);\n    }\n    default: {\n      context->ReportError(\n          context,\n          \"Seq_lengths type '%s' is not supported by reverse_sequence.\",\n          TfLiteTypeGetName(seq_lengths_tensor->type));\n      return kTfLiteError;\n    }\n  }\n  return kTfLiteOk;\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (output->type) {\n    case kTfLiteFloat32: {\n      return ReverseSequenceHelper<float>(context, node);\n    }\n    case kTfLiteUInt8: {\n      return ReverseSequenceHelper<uint8_t>(context, node);\n    }\n    case kTfLiteInt16: {\n      return ReverseSequenceHelper<int16_t>(context, node);\n    }\n    case kTfLiteInt32: {\n      return ReverseSequenceHelper<int32_t>(context, node);\n    }\n    case kTfLiteInt64: {\n      return ReverseSequenceHelper<int64_t>(context, node);\n    }\n    default: {\n      context->ReportError(context,\n                           \"Type '%s' is not supported by reverse_sequence.\",\n                           TfLiteTypeGetName(output->type));\n      return kTfLiteError;\n    }\n  }\n  return kTfLiteOk;\n}  // namespace\n\n}  // namespace\n}  // namespace reverse_sequence\n\nTfLiteRegistration* Register_REVERSE_SEQUENCE() {\n  static TfLiteRegistration r = {nullptr, nullptr, reverse_sequence::Prepare,\n                                 reverse_sequence::Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite"