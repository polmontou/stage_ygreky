"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include <cstddef>\n#include <cstdint>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/kernel_utils.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace unidirectional_sequence_rnn {\n\nnamespace {\n\nstruct OpData {\n  int scratch_tensor_index;\n  bool compute_row_sums = false;\n};\n\n}  // namespace\n\n// Input tensors.\nconstexpr int kInputTensor = 0;\nconstexpr int kWeightsTensor = 1;\nconstexpr int kRecurrentWeightsTensor = 2;\nconstexpr int kBiasTensor = 3;\nconstexpr int kHiddenStateTensor = 4;\n\n// Output tensor.\nconstexpr int kOutputTensor = 0;\n\nvoid* Init(TfLiteContext* context, const char* buffer, size_t length) {\n  auto* op_data = new OpData();\n  context->AddTensors(context, /*tensors_to_add=*/6,\n                      &op_data->scratch_tensor_index);\n  return op_data;\n}\n\nvoid Free(TfLiteContext* context, void* buffer) {\n  delete reinterpret_cast<OpData*>(buffer);\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* input_weights = GetInput(context, node, kWeightsTensor);\n  const TfLiteTensor* recurrent_weights =\n      GetInput(context, node, kRecurrentWeightsTensor);\n  const TfLiteTensor* bias = GetInput(context, node, kBiasTensor);\n  const TfLiteTensor* hidden_state =\n      GetInput(context, node, kHiddenStateTensor);\n\n  // Check all the parameters of tensor match within themselves and match the\n  // input configuration.\n  auto* params = reinterpret_cast<TfLiteSequenceRNNParams*>(node->builtin_data);\n  const bool time_major = params->time_major;\n  const int batch_size =\n      (time_major) ? input->dims->data[1] : input->dims->data[0];\n  const int max_time =\n      (time_major) ? input->dims->data[0] : input->dims->data[1];\n  const int num_units = input_weights->dims->data[0];\n  TF_LITE_ENSURE_EQ(context, input->dims->data[2],\n                    input_weights->dims->data[1]);\n  TF_LITE_ENSURE_EQ(context, input_weights->dims->data[0], bias->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, recurrent_weights->dims->data[0],\n                    bias->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, recurrent_weights->dims->data[1],\n                    bias->dims->data[0]);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  TF_LITE_ENSURE_TYPES_EQ(context, input_weights->type,\n                          recurrent_weights->type);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hidden_state), 2);\n  TF_LITE_ENSURE_EQ(context, hidden_state->dims->data[0], batch_size);\n  TF_LITE_ENSURE_EQ(context, hidden_state->dims->data[1], num_units);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // Resize output.\n  TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(3);\n  output_size_array->data[0] = (time_major) ? max_time : batch_size;\n  output_size_array->data[1] = (time_major) ? batch_size : max_time;\n  output_size_array->data[2] = num_units;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_size_array));\n\n  const bool is_hybrid = IsHybridOp(input, input_weights);\n\n  // Allocate temporary tensors to store quantized values of input and\n  // hidden_state tensors.\n  if (is_hybrid) {\n    auto* op_data = reinterpret_cast<OpData*>(node->user_data);\n    op_data->compute_row_sums = true;\n    TfLiteIntArrayFree(node->temporaries);\n    node->temporaries = TfLiteIntArrayCreate(6);\n    node->temporaries->data[0] = op_data->scratch_tensor_index;\n    TfLiteTensor* input_quantized = GetTemporary(context, node, /*index=*/0);\n    input_quantized->type = input_weights->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n    node->temporaries->data[1] = op_data->scratch_tensor_index + 1;\n    TfLiteTensor* hidden_state_quantized =\n        GetTemporary(context, node, /*index=*/1);\n    hidden_state_quantized->type = input_weights->type;\n    hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(hidden_state_quantized->dims,\n                             hidden_state->dims)) {\n      TfLiteIntArray* hidden_state_quantized_size =\n          TfLiteIntArrayCopy(hidden_state->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, hidden_state_quantized,\n                                              hidden_state_quantized_size));\n    }\n    node->temporaries->data[2] = op_data->scratch_tensor_index + 2;\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, /*index=*/2);\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n    node->temporaries->data[3] = op_data->scratch_tensor_index + 3;\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, /*index=*/3);\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {num_units, batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2);\n      accum_scratch_size->data[0] = accum_scratch_dims[0];\n      accum_scratch_size->data[1] = accum_scratch_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch,\n                                                       accum_scratch_size));\n    }\n    node->temporaries->data[4] = op_data->scratch_tensor_index + 4;\n    TfLiteTensor* zero_points = GetTemporary(context, node, /*index=*/4);\n    zero_points->type = kTfLiteInt32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n    node->temporaries->data[5] = op_data->scratch_tensor_index + 5;\n    TfLiteTensor* row_sums = GetTemporary(context, node, /*index=*/5);\n    row_sums->type = kTfLiteInt32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_dims[2] = {2, num_units};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 2, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(2);\n      row_sums_size->data[0] = row_sums_dims[0];\n      row_sums_size->data[1] = row_sums_dims[1];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n  return kTfLiteOk;\n}\n\nTfLiteStatus EvalFloat(const TfLiteTensor* input,\n                       const TfLiteTensor* input_weights,\n                       const TfLiteTensor* recurrent_weights,\n                       const TfLiteTensor* bias,\n                       const TfLiteSequenceRNNParams* params,\n                       TfLiteTensor* hidden_state, TfLiteTensor* output) {\n  // Initialize the pointer bias.\n  const float* bias_ptr = GetTensorData<float>(bias);\n\n  const bool time_major = params->time_major;\n  const int batch_size =\n      (time_major) ? input->dims->data[1] : input->dims->data[0];\n  const int max_time =\n      (time_major) ? input->dims->data[0] : input->dims->data[1];\n  const int num_units = input_weights->dims->data[0];\n  const int input_size = input->dims->data[2];\n\n  // Initialize input_weights and recurrent_weights.\n  const float* input_weights_ptr = GetTensorData<float>(input_weights);\n  const float* recurrent_weights_ptr = GetTensorData<float>(recurrent_weights);\n\n  if (time_major) {\n    // Initialize the pointer to hidden state.\n    float* hidden_state_ptr_batch = GetTensorData<float>(hidden_state);\n    // Unroll the sequence and use batch operations for efficiency.\n    for (int s = 0; s < max_time; s++) {\n      // Initialize the pointer to input and output.\n      const float* input_ptr_batch =\n          GetTensorData<float>(input) + s * input_size * batch_size;\n      float* output_ptr_batch =\n          GetTensorData<float>(output) + s * num_units * batch_size;\n\n      kernel_utils::RnnBatchStep(\n          input_ptr_batch, input_weights_ptr, recurrent_weights_ptr, bias_ptr,\n          input_size, num_units, batch_size, num_units, params->activation,\n          hidden_state_ptr_batch, output_ptr_batch);\n    }\n  } else {\n    // For each batch\n    for (int b = 0; b < batch_size; b++) {\n      // Initialize the pointer to hidden state.\n      float* hidden_state_ptr_batch =\n          GetTensorData<float>(hidden_state) + b * num_units;\n      for (int s = 0; s < max_time; s++) {\n        // Initialize the pointer to input and output.\n        const float* input_ptr_batch = GetTensorData<float>(input) +\n                                       b * input_size * max_time +\n                                       s * input_size;\n        float* output_ptr_batch = GetTensorData<float>(output) +\n                                  b * num_units * max_time + s * num_units;\n\n        kernel_utils::RnnBatchStep(\n            input_ptr_batch, input_weights_ptr, recurrent_weights_ptr, bias_ptr,\n            input_size, num_units, /*batch_size=*/1, num_units,\n            params->activation, hidden_state_ptr_batch, output_ptr_batch);\n      }\n    }\n  }\n  return kTfLiteOk;\n}\n\nTfLiteStatus EvalHybrid(\n    const TfLiteTensor* input, const TfLiteTensor* input_weights,\n    const TfLiteTensor* recurrent_weights, const TfLiteTensor* bias,\n    const TfLiteSequenceRNNParams* params, TfLiteTensor* input_scratch,\n    TfLiteTensor* hidden_state_scratch, TfLiteTensor* scaling_factors,\n    TfLiteTensor* hidden_state, TfLiteTensor* output, TfLiteTensor* zero_points,\n    TfLiteTensor* accum_scratch, TfLiteTensor* row_sums,\n    bool* compute_row_sums) {\n  const bool time_major = params->time_major;\n  const int batch_size =\n      (time_major) ? input->dims->data[1] : input->dims->data[0];\n  const int max_time =\n      (time_major) ? input->dims->data[0] : input->dims->data[1];\n  const int num_units = input_weights->dims->data[0];\n  const int input_size = input->dims->data[2];\n\n  // Initialize the pointer bias.\n  const float* bias_ptr = GetTensorData<float>(bias);\n\n  // Initialize input_weights, recurrent_weights, and temporary storage for\n  // quantized values.\n  const int8_t* input_weights_ptr = GetTensorData<int8_t>(input_weights);\n  const int8_t* recurrent_weights_ptr =\n      GetTensorData<int8_t>(recurrent_weights);\n  int8_t* quantized_input_ptr = GetTensorData<int8_t>(input_scratch);\n  int8_t* quantized_hidden_state_ptr =\n      GetTensorData<int8_t>(hidden_state_scratch);\n\n  // Get the scale of the quantized weights.\n  float input_weights_scale = input_weights->params.scale;\n  float recurrent_weights_scale = recurrent_weights->params.scale;\n  float* scaling_factors_ptr = GetTensorData<float>(scaling_factors);\n  int32_t* accum_scratch_ptr = GetTensorData<int32_t>(accum_scratch);\n  int32_t* zero_points_ptr = nullptr;\n  int32_t* row_sums_ptr = nullptr;\n\n  if (params->asymmetric_quantize_inputs) {\n    zero_points_ptr = GetTensorData<int32_t>(zero_points);\n    row_sums_ptr = GetTensorData<int32_t>(row_sums);\n  }\n\n  if (time_major) {\n    // Initialize the pointer to hidden state.\n    float* hidden_state_ptr_batch = GetTensorData<float>(hidden_state);\n    // Unroll the sequence and use batch operations for efficiency.\n    for (int s = 0; s < max_time; s++) {\n      // Initialize the pointer to input and output.\n      const float* input_ptr_batch =\n          GetTensorData<float>(input) + s * input_size * batch_size;\n      float* output_ptr_batch =\n          GetTensorData<float>(output) + s * num_units * batch_size;\n\n      kernel_utils::RnnBatchStep(\n          input_ptr_batch, input_weights_ptr, input_weights_scale,\n          recurrent_weights_ptr, recurrent_weights_scale, bias_ptr, input_size,\n          num_units, batch_size, num_units, params->activation,\n          quantized_input_ptr, quantized_hidden_state_ptr, scaling_factors_ptr,\n          hidden_state_ptr_batch, output_ptr_batch,\n          params->asymmetric_quantize_inputs, zero_points_ptr,\n          accum_scratch_ptr, row_sums_ptr, compute_row_sums);\n    }\n  } else {\n    // For each batch\n    for (int b = 0; b < batch_size; b++) {\n      // Initialize the pointer to hidden state.\n      float* hidden_state_ptr_batch =\n          GetTensorData<float>(hidden_state) + b * num_units;\n      for (int s = 0; s < max_time; s++) {\n        // Initialize the pointer to input and output.\n        const float* input_ptr_batch = GetTensorData<float>(input) +\n                                       b * input_size * max_time +\n                                       s * input_size;\n        float* output_ptr_batch = GetTensorData<float>(output) +\n                                  b * num_units * max_time + s * num_units;\n        kernel_utils::RnnBatchStep(\n            input_ptr_batch, input_weights_ptr, input_weights_scale,\n            recurrent_weights_ptr, recurrent_weights_scale, bias_ptr,\n            input_size, num_units, /*batch_size=*/1, num_units,\n            params->activation, quantized_input_ptr, quantized_hidden_state_ptr,\n            scaling_factors_ptr, hidden_state_ptr_batch, output_ptr_batch,\n            params->asymmetric_quantize_inputs, zero_points_ptr,\n            accum_scratch_ptr, row_sums_ptr, compute_row_sums);\n      }\n    }\n  }\n  return kTfLiteOk;\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteSequenceRNNParams*>(node->builtin_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* input_weights = GetInput(context, node, kWeightsTensor);\n  const TfLiteTensor* recurrent_weights =\n      GetInput(context, node, kRecurrentWeightsTensor);\n  const TfLiteTensor* bias = GetInput(context, node, kBiasTensor);\n  // The hidden_state is a variable input tensor that can be modified.\n  TfLiteTensor* hidden_state =\n      const_cast<TfLiteTensor*>(GetInput(context, node, kHiddenStateTensor));\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (input_weights->type) {\n    case kTfLiteFloat32:\n      return EvalFloat(input, input_weights, recurrent_weights, bias, params,\n                       hidden_state, output);\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      // TODO(mirkov): implement eval with quantized inputs as well.\n      auto* op_data = reinterpret_cast<OpData*>(node->user_data);\n      TfLiteTensor* input_quantized = GetTemporary(context, node, 0);\n      TfLiteTensor* hidden_state_quantized = GetTemporary(context, node, 1);\n      TfLiteTensor* scaling_factors = GetTemporary(context, node, 2);\n      TfLiteTensor* accum_scratch = GetTemporary(context, node, 3);\n      TfLiteTensor* zero_points = GetTemporary(context, node, 4);\n      TfLiteTensor* row_sums = GetTemporary(context, node, 5);\n      return EvalHybrid(input, input_weights, recurrent_weights, bias, params,\n                        input_quantized, hidden_state_quantized,\n                        scaling_factors, hidden_state, output, zero_points,\n                        accum_scratch, row_sums, &op_data->compute_row_sums);\n    }\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %d not currently supported.\",\n                         TfLiteTypeGetName(input_weights->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n\n}  // namespace unidirectional_sequence_rnn\n\nTfLiteRegistration* Register_UNIDIRECTIONAL_SEQUENCE_RNN() {\n  static TfLiteRegistration r = {\n      unidirectional_sequence_rnn::Init, unidirectional_sequence_rnn::Free,\n      unidirectional_sequence_rnn::Prepare, unidirectional_sequence_rnn::Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite"