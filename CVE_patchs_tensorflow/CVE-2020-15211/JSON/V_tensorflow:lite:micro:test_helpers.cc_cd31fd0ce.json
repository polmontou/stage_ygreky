"/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/lite/micro/test_helpers.h\"\n\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <initializer_list>\n#include <new>\n\n#include \"flatbuffers/flatbuffers.h\"  // from @flatbuffers\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/core/api/error_reporter.h\"\n#include \"tensorflow/lite/kernels/internal/compatibility.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n#include \"tensorflow/lite/micro/all_ops_resolver.h\"\n#include \"tensorflow/lite/micro/micro_utils.h\"\n#include \"tensorflow/lite/schema/schema_generated.h\"\n\nnamespace tflite {\nnamespace testing {\nnamespace {\n\nclass StackAllocator : public flatbuffers::Allocator {\n public:\n  StackAllocator() : data_(data_backing_), data_size_(0) {}\n\n  uint8_t* allocate(size_t size) override {\n    TFLITE_DCHECK((data_size_ + size) <= kStackAllocatorSize);\n    uint8_t* result = data_;\n    data_ += size;\n    data_size_ += size;\n    return result;\n  }\n\n  void deallocate(uint8_t* p, size_t) override {}\n\n  static StackAllocator& instance() {\n    // Avoid using true dynamic memory allocation to be portable to bare metal.\n    static char inst_memory[sizeof(StackAllocator)];\n    static StackAllocator* inst = new (inst_memory) StackAllocator;\n    return *inst;\n  }\n\n  static constexpr size_t kStackAllocatorSize = 8192;\n\n private:\n  uint8_t data_backing_[kStackAllocatorSize];\n  uint8_t* data_;\n  int data_size_;\n};\n\nflatbuffers::FlatBufferBuilder* BuilderInstance() {\n  static char inst_memory[sizeof(flatbuffers::FlatBufferBuilder)];\n  static flatbuffers::FlatBufferBuilder* inst =\n      new (inst_memory) flatbuffers::FlatBufferBuilder(\n          StackAllocator::kStackAllocatorSize, &StackAllocator::instance());\n  return inst;\n}\n\n// A wrapper around FlatBuffer API to help build model easily.\nclass ModelBuilder {\n public:\n  typedef int32_t Tensor;\n  typedef int Operator;\n  typedef int Node;\n\n  // `builder` needs to be available until BuildModel is called.\n  explicit ModelBuilder(flatbuffers::FlatBufferBuilder* builder)\n      : builder_(builder) {}\n\n  // Registers an operator that will be used in the model.\n  Operator RegisterOp(BuiltinOperator op, const char* custom_code,\n                      int32_t version);\n\n  // Adds a tensor to the model.\n  Tensor AddTensor(TensorType type, std::initializer_list<int32_t> shape) {\n    return AddTensorImpl(type, /* is_variable */ false, shape);\n  }\n\n  // Adds a variable tensor to the model.\n  Tensor AddVariableTensor(TensorType type,\n                           std::initializer_list<int32_t> shape) {\n    return AddTensorImpl(type, /* is_variable */ true, shape);\n  }\n\n  // Adds a node to the model with given input and output Tensors.\n  Node AddNode(Operator op, std::initializer_list<Tensor> inputs,\n               std::initializer_list<Tensor> outputs);\n\n  void AddMetadata(const char* description_string,\n                   const int32_t* metadata_buffer_data, size_t num_elements);\n\n  // Constructs the flatbuffer model using `builder_` and return a pointer to\n  // it. The returned model has the same lifetime as `builder_`.\n  // Note the default value of 0 for num_subgraph_inputs means all tensor inputs\n  // are in subgraph input list.\n  const Model* BuildModel(std::initializer_list<Tensor> inputs,\n                          std::initializer_list<Tensor> outputs,\n                          size_t num_subgraph_inputs = 0);\n\n private:\n  // Adds a tensor to the model.\n  Tensor AddTensorImpl(TensorType type, bool is_variable,\n                       std::initializer_list<int32_t> shape);\n\n  flatbuffers::FlatBufferBuilder* builder_;\n\n  static constexpr int kMaxOperatorCodes = 10;\n  flatbuffers::Offset<tflite::OperatorCode> operator_codes_[kMaxOperatorCodes];\n  int next_operator_code_id_ = 0;\n\n  static constexpr int kMaxOperators = 50;\n  flatbuffers::Offset<tflite::Operator> operators_[kMaxOperators];\n  int next_operator_id_ = 0;\n\n  static constexpr int kMaxTensors = 50;\n  flatbuffers::Offset<tflite::Tensor> tensors_[kMaxTensors];\n\n  static constexpr int kMaxMetadataBuffers = 10;\n\n  static constexpr int kMaxMetadatas = 10;\n  flatbuffers::Offset<Metadata> metadata_[kMaxMetadatas];\n\n  flatbuffers::Offset<Buffer> metadata_buffers_[kMaxMetadataBuffers];\n\n  int nbr_of_metadata_buffers_ = 0;\n\n  int next_tensor_id_ = 0;\n};\n\nModelBuilder::Operator ModelBuilder::RegisterOp(BuiltinOperator op,\n                                                const char* custom_code,\n                                                int32_t version) {\n  TFLITE_DCHECK(next_operator_code_id_ <= kMaxOperatorCodes);\n  operator_codes_[next_operator_code_id_] =\n      tflite::CreateOperatorCodeDirect(*builder_, op, custom_code, version);\n  next_operator_code_id_++;\n  return next_operator_code_id_ - 1;\n}\n\nModelBuilder::Node ModelBuilder::AddNode(\n    ModelBuilder::Operator op,\n    std::initializer_list<ModelBuilder::Tensor> inputs,\n    std::initializer_list<ModelBuilder::Tensor> outputs) {\n  TFLITE_DCHECK(next_operator_id_ <= kMaxOperators);\n  operators_[next_operator_id_] = tflite::CreateOperator(\n      *builder_, op, builder_->CreateVector(inputs.begin(), inputs.size()),\n      builder_->CreateVector(outputs.begin(), outputs.size()),\n      BuiltinOptions_NONE);\n  next_operator_id_++;\n  return next_operator_id_ - 1;\n}\n\nvoid ModelBuilder::AddMetadata(const char* description_string,\n                               const int32_t* metadata_buffer_data,\n                               size_t num_elements) {\n  metadata_[ModelBuilder::nbr_of_metadata_buffers_] =\n      CreateMetadata(*builder_, builder_->CreateString(description_string),\n                     1 + ModelBuilder::nbr_of_metadata_buffers_);\n\n  metadata_buffers_[nbr_of_metadata_buffers_] = tflite::CreateBuffer(\n      *builder_, builder_->CreateVector((uint8_t*)metadata_buffer_data,\n                                        sizeof(uint32_t) * num_elements));\n\n  ModelBuilder::nbr_of_metadata_buffers_++;\n}\n\nconst Model* ModelBuilder::BuildModel(\n    std::initializer_list<ModelBuilder::Tensor> inputs,\n    std::initializer_list<ModelBuilder::Tensor> outputs,\n    size_t num_subgraph_inputs) {\n  // Model schema requires an empty buffer at idx 0.\n  size_t buffer_size = 1 + ModelBuilder::nbr_of_metadata_buffers_;\n  flatbuffers::Offset<Buffer> buffers[kMaxMetadataBuffers];\n  buffers[0] = tflite::CreateBuffer(*builder_);\n\n  // Place the metadata buffers first in the buffer since the indices for them\n  // have already been set in AddMetadata()\n  for (int i = 1; i < ModelBuilder::nbr_of_metadata_buffers_ + 1; ++i) {\n    buffers[i] = metadata_buffers_[i - 1];\n  }\n\n  // TFLM only supports single subgraph.\n  constexpr size_t subgraphs_size = 1;\n\n  // Find out number of subgraph inputs.\n  if (num_subgraph_inputs == 0) {\n    // This is the default case.\n    num_subgraph_inputs = inputs.size();\n  } else {\n    // A non-zero value of num_subgraph_inputs means that some of\n    // the operator input tensors are not subgraph inputs.\n    TFLITE_DCHECK(num_subgraph_inputs < inputs.size());\n  }\n\n  const flatbuffers::Offset<SubGraph> subgraphs[subgraphs_size] = {\n      tflite::CreateSubGraph(\n          *builder_, builder_->CreateVector(tensors_, next_tensor_id_),\n          builder_->CreateVector(inputs.begin(), num_subgraph_inputs),\n          builder_->CreateVector(outputs.begin(), outputs.size()),\n          builder_->CreateVector(operators_, next_operator_id_),\n          builder_->CreateString(\"test_subgraph\"))};\n\n  flatbuffers::Offset<Model> model_offset;\n  if (ModelBuilder::nbr_of_metadata_buffers_ > 0) {\n    model_offset = tflite::CreateModel(\n        *builder_, 0,\n        builder_->CreateVector(operator_codes_, next_operator_code_id_),\n        builder_->CreateVector(subgraphs, subgraphs_size),\n        builder_->CreateString(\"teset_model\"),\n        builder_->CreateVector(buffers, buffer_size), 0,\n        builder_->CreateVector(metadata_,\n                               ModelBuilder::nbr_of_metadata_buffers_));\n  } else {\n    model_offset = tflite::CreateModel(\n        *builder_, 0,\n        builder_->CreateVector(operator_codes_, next_operator_code_id_),\n        builder_->CreateVector(subgraphs, subgraphs_size),\n        builder_->CreateString(\"teset_model\"),\n        builder_->CreateVector(buffers, buffer_size));\n  }\n\n  tflite::FinishModelBuffer(*builder_, model_offset);\n  void* model_pointer = builder_->GetBufferPointer();\n  const Model* model = flatbuffers::GetRoot<Model>(model_pointer);\n  return model;\n}\n\nModelBuilder::Tensor ModelBuilder::AddTensorImpl(\n    TensorType type, bool is_variable, std::initializer_list<int32_t> shape) {\n  TFLITE_DCHECK(next_tensor_id_ <= kMaxTensors);\n  tensors_[next_tensor_id_] = tflite::CreateTensor(\n      *builder_, builder_->CreateVector(shape.begin(), shape.size()), type,\n      /* buffer */ 0, /* name */ 0, /* quantization */ 0,\n      /* is_variable */ is_variable,\n      /* sparsity */ 0);\n  next_tensor_id_++;\n  return next_tensor_id_ - 1;\n}\n\nconst Model* BuildSimpleStatefulModel() {\n  using flatbuffers::Offset;\n  flatbuffers::FlatBufferBuilder* fb_builder = BuilderInstance();\n\n  ModelBuilder model_builder(fb_builder);\n\n  const int op_id =\n      model_builder.RegisterOp(BuiltinOperator_CUSTOM, \"simple_stateful_op\", 0);\n  const int input_tensor = model_builder.AddTensor(TensorType_UINT8, {3});\n  const int median_tensor = model_builder.AddTensor(TensorType_UINT8, {3});\n  const int invoke_count_tensor =\n      model_builder.AddTensor(TensorType_INT32, {1});\n\n  model_builder.AddNode(op_id, {input_tensor},\n                        {median_tensor, invoke_count_tensor});\n  return model_builder.BuildModel({input_tensor},\n                                  {median_tensor, invoke_count_tensor});\n}\n\nconst Model* BuildSimpleModelWithBranch() {\n  using flatbuffers::Offset;\n  flatbuffers::FlatBufferBuilder* fb_builder = BuilderInstance();\n\n  ModelBuilder model_builder(fb_builder);\n  /* Model structure\n           | t0\n    +------|\n    |      v\n    |   +---------+\n    |   |   n0    |\n    |   |         |\n    |   +---------+\n    v           +\n                |\n  +---------+   | t1\n  |   n1    |   |\n  |         |   |\n  +---------+   |\n     |          |\n t2  |          v\n     |   +---------+\n     +-->|    n2   |\n         |         |\n         +-------|-+\n                 |t3\n                 v\n  */\n  const int op_id =\n      model_builder.RegisterOp(BuiltinOperator_CUSTOM, \"mock_custom\",\n                               /* version= */ 0);\n  const int t0 = model_builder.AddTensor(TensorType_FLOAT32, {2, 2, 3});\n  const int t1 = model_builder.AddTensor(TensorType_FLOAT32, {2, 2, 3});\n  const int t2 = model_builder.AddTensor(TensorType_FLOAT32, {2, 2, 3});\n  const int t3 = model_builder.AddTensor(TensorType_FLOAT32, {2, 2, 3});\n  model_builder.AddNode(op_id, {t0}, {t1});      // n0\n  model_builder.AddNode(op_id, {t0}, {t2});      // n1\n  model_builder.AddNode(op_id, {t1, t2}, {t3});  // n2\n  return model_builder.BuildModel({t0}, {t3});\n}\n\nconst Model* BuildModelWithOfflinePlanning(int number_of_tensors,\n                                           const int32_t* metadata_buffer,\n                                           NodeConnection* node_conn,\n                                           int num_conns,\n                                           int num_subgraph_inputs) {\n  using flatbuffers::Offset;\n  flatbuffers::FlatBufferBuilder* fb_builder = BuilderInstance();\n\n  ModelBuilder model_builder(fb_builder);\n\n  const int op_id =\n      model_builder.RegisterOp(BuiltinOperator_CUSTOM, \"mock_custom\",\n                               /* version= */ 0);\n\n  for (int i = 0; i < number_of_tensors; ++i) {\n    model_builder.AddTensor(TensorType_FLOAT32, {2, 2, 3});\n  }\n\n  for (int i = 0; i < num_conns; ++i) {\n    model_builder.AddNode(op_id, node_conn[i].input, node_conn[i].output);\n  }\n\n  model_builder.AddMetadata(\n      \"OfflineMemoryAllocation\", metadata_buffer,\n      number_of_tensors + tflite::testing::kOfflinePlannerHeaderSize);\n\n  return model_builder.BuildModel(\n      node_conn[0].input, node_conn[num_conns - 1].output, num_subgraph_inputs);\n}\n\nconst Model* BuildSimpleMockModel() {\n  using flatbuffers::Offset;\n  flatbuffers::FlatBufferBuilder* builder = BuilderInstance();\n\n  constexpr size_t buffer_data_size = 1;\n  const uint8_t buffer_data[buffer_data_size] = {21};\n  constexpr size_t buffers_size = 2;\n  const Offset<Buffer> buffers[buffers_size] = {\n      CreateBuffer(*builder),\n      CreateBuffer(*builder,\n                   builder->CreateVector(buffer_data, buffer_data_size))};\n  constexpr size_t tensor_shape_size = 1;\n  const int32_t tensor_shape[tensor_shape_size] = {1};\n  constexpr size_t tensors_size = 4;\n  const Offset<Tensor> tensors[tensors_size] = {\n      CreateTensor(*builder,\n                   builder->CreateVector(tensor_shape, tensor_shape_size),\n                   TensorType_INT32, 0,\n                   builder->CreateString(\"test_input_tensor\"), 0, false),\n      CreateTensor(*builder,\n                   builder->CreateVector(tensor_shape, tensor_shape_size),\n                   TensorType_UINT8, 1,\n                   builder->CreateString(\"test_weight_tensor\"), 0, false),\n      CreateTensor(*builder,\n                   builder->CreateVector(tensor_shape, tensor_shape_size),\n                   TensorType_INT32, 0,\n                   builder->CreateString(\"test_output_tensor\"), 0, false),\n      CreateTensor(*builder,\n                   builder->CreateVector(tensor_shape, tensor_shape_size),\n                   TensorType_INT32, 0,\n                   builder->CreateString(\"test_output2_tensor\"), 0, false),\n  };\n  constexpr size_t inputs_size = 1;\n  const int32_t inputs[inputs_size] = {0};\n  constexpr size_t outputs_size = 2;\n  const int32_t outputs[outputs_size] = {2, 3};\n  constexpr size_t operator_inputs_size = 2;\n  const int32_t operator_inputs[operator_inputs_size] = {0, 1};\n  constexpr size_t operator_outputs_size = 1;\n  const int32_t operator_outputs[operator_outputs_size] = {2};\n  const int32_t operator2_outputs[operator_outputs_size] = {3};\n  constexpr size_t operators_size = 2;\n  const Offset<Operator> operators[operators_size] = {\n      CreateOperator(\n          *builder, 0,\n          builder->CreateVector(operator_inputs, operator_inputs_size),\n          builder->CreateVector(operator_outputs, operator_outputs_size),\n          BuiltinOptions_NONE),\n      CreateOperator(\n          *builder, 0,\n          builder->CreateVector(operator_inputs, operator_inputs_size),\n          builder->CreateVector(operator2_outputs, operator_outputs_size),\n          BuiltinOptions_NONE),\n  };\n  constexpr size_t subgraphs_size = 1;\n  const Offset<SubGraph> subgraphs[subgraphs_size] = {\n      CreateSubGraph(*builder, builder->CreateVector(tensors, tensors_size),\n                     builder->CreateVector(inputs, inputs_size),\n                     builder->CreateVector(outputs, outputs_size),\n                     builder->CreateVector(operators, operators_size),\n                     builder->CreateString(\"test_subgraph\"))};\n  constexpr size_t operator_codes_size = 1;\n  const Offset<OperatorCode> operator_codes[operator_codes_size] = {\n      CreateOperatorCodeDirect(*builder, BuiltinOperator_CUSTOM, \"mock_custom\",\n                               0)};\n  const Offset<Model> model_offset = CreateModel(\n      *builder, 0, builder->CreateVector(operator_codes, operator_codes_size),\n      builder->CreateVector(subgraphs, subgraphs_size),\n      builder->CreateString(\"test_model\"),\n      builder->CreateVector(buffers, buffers_size));\n  FinishModelBuffer(*builder, model_offset);\n  void* model_pointer = builder->GetBufferPointer();\n  const Model* model = flatbuffers::GetRoot<Model>(model_pointer);\n  return model;\n}\n\nconst Model* BuildComplexMockModel() {\n  using flatbuffers::Offset;\n  flatbuffers::FlatBufferBuilder* builder = BuilderInstance();\n\n  constexpr size_t buffer_data_size = 1;\n  const uint8_t buffer_data_1[buffer_data_size] = {21};\n  const uint8_t buffer_data_2[buffer_data_size] = {21};\n  const uint8_t buffer_data_3[buffer_data_size] = {21};\n  constexpr size_t buffers_size = 7;\n  const Offset<Buffer> buffers[buffers_size] = {\n      // Op 1 buffers:\n      CreateBuffer(*builder),\n      CreateBuffer(*builder),\n      CreateBuffer(*builder,\n                   builder->CreateVector(buffer_data_1, buffer_data_size)),\n      // Op 2 buffers:\n      CreateBuffer(*builder),\n      CreateBuffer(*builder,\n                   builder->CreateVector(buffer_data_2, buffer_data_size)),\n      // Op 3 buffers:\n      CreateBuffer(*builder),\n      CreateBuffer(*builder,\n                   builder->CreateVector(buffer_data_3, buffer_data_size)),\n  };\n  constexpr size_t tensor_shape_size = 1;\n  const int32_t tensor_shape[tensor_shape_size] = {1};\n\n  constexpr size_t tensors_size = 10;\n  const Offset<Tensor> tensors[tensors_size] = {\n      // Op 1 inputs:\n      CreateTensor(\n          *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n          TensorType_INT32, 0, builder->CreateString(\"test_input_tensor_1\"), 0,\n          false /* is_variable */),\n      CreateTensor(\n          *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n          TensorType_INT32, 1, builder->CreateString(\"test_variable_tensor_1\"),\n          0, true /* is_variable */),\n      CreateTensor(\n          *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n          TensorType_UINT8, 2, builder->CreateString(\"test_weight_tensor_1\"), 0,\n          false /* is_variable */),\n      // Op 1 output / Op 2 input:\n      CreateTensor(\n          *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n          TensorType_INT32, 0, builder->CreateString(\"test_output_tensor_1\"), 0,\n          false /* is_variable */),\n      // Op 2 inputs:\n      CreateTensor(\n          *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n          TensorType_INT32, 1, builder->CreateString(\"test_variable_tensor_2\"),\n          0, true /* is_variable */),\n      CreateTensor(\n          *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n          TensorType_UINT8, 2, builder->CreateString(\"test_weight_tensor_2\"), 0,\n          false /* is_variable */),\n      // Op 2 output / Op 3 input:\n      CreateTensor(\n          *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n          TensorType_INT32, 0, builder->CreateString(\"test_output_tensor_2\"), 0,\n          false /* is_variable */),\n      // Op 3 inputs:\n      CreateTensor(\n          *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n          TensorType_INT32, 1, builder->CreateString(\"test_variable_tensor_3\"),\n          0, true /* is_variable */),\n      CreateTensor(\n          *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n          TensorType_UINT8, 2, builder->CreateString(\"test_weight_tensor_3\"), 0,\n          false /* is_variable */),\n      // Op 3 output:\n      CreateTensor(\n          *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n          TensorType_INT32, 0, builder->CreateString(\"test_output_tensor_3\"), 0,\n          false /* is_variable */),\n  };\n\n  constexpr size_t operators_size = 3;\n  Offset<Operator> operators[operators_size];\n  {\n    // Set Op 1 attributes:\n    constexpr size_t operator_inputs_size = 3;\n    const int32_t operator_inputs[operator_inputs_size] = {0, 1, 2};\n    constexpr size_t operator_outputs_size = 1;\n    const int32_t operator_outputs[operator_outputs_size] = {3};\n\n    operators[0] = {CreateOperator(\n        *builder, 0,\n        builder->CreateVector(operator_inputs, operator_inputs_size),\n        builder->CreateVector(operator_outputs, operator_outputs_size),\n        BuiltinOptions_NONE)};\n  }\n\n  {\n    // Set Op 2 attributes\n    constexpr size_t operator_inputs_size = 3;\n    const int32_t operator_inputs[operator_inputs_size] = {3, 4, 5};\n    constexpr size_t operator_outputs_size = 1;\n    const int32_t operator_outputs[operator_outputs_size] = {6};\n\n    operators[1] = {CreateOperator(\n        *builder, 0,\n        builder->CreateVector(operator_inputs, operator_inputs_size),\n        builder->CreateVector(operator_outputs, operator_outputs_size),\n        BuiltinOptions_NONE)};\n  }\n\n  {\n    // Set Op 3 attributes\n    constexpr size_t operator_inputs_size = 3;\n    const int32_t operator_inputs[operator_inputs_size] = {6, 7, 8};\n    constexpr size_t operator_outputs_size = 1;\n    const int32_t operator_outputs[operator_outputs_size] = {9};\n\n    operators[2] = {CreateOperator(\n        *builder, 0,\n        builder->CreateVector(operator_inputs, operator_inputs_size),\n        builder->CreateVector(operator_outputs, operator_outputs_size),\n        BuiltinOptions_NONE)};\n  }\n\n  constexpr size_t inputs_size = 1;\n  const int32_t inputs[inputs_size] = {0};\n  constexpr size_t outputs_size = 1;\n  const int32_t outputs[outputs_size] = {9};\n\n  constexpr size_t subgraphs_size = 1;\n  const Offset<SubGraph> subgraphs[subgraphs_size] = {\n      CreateSubGraph(*builder, builder->CreateVector(tensors, tensors_size),\n                     builder->CreateVector(inputs, inputs_size),\n                     builder->CreateVector(outputs, outputs_size),\n                     builder->CreateVector(operators, operators_size),\n                     builder->CreateString(\"test_subgraph\"))};\n\n  constexpr size_t operator_codes_size = 1;\n  const Offset<OperatorCode> operator_codes[operator_codes_size] = {\n      CreateOperatorCodeDirect(*builder, BuiltinOperator_CUSTOM, \"mock_custom\",\n                               0)};\n\n  const Offset<Model> model_offset = CreateModel(\n      *builder, 0, builder->CreateVector(operator_codes, operator_codes_size),\n      builder->CreateVector(subgraphs, subgraphs_size),\n      builder->CreateString(\"test_model\"),\n      builder->CreateVector(buffers, buffers_size));\n\n  FinishModelBuffer(*builder, model_offset);\n  void* model_pointer = builder->GetBufferPointer();\n  const Model* model = flatbuffers::GetRoot<Model>(model_pointer);\n  return model;\n}\n\n}  // namespace\n\nconst TfLiteRegistration* SimpleStatefulOp::getRegistration() {\n  return GetMutableRegistration();\n}\n\nTfLiteRegistration* SimpleStatefulOp::GetMutableRegistration() {\n  static TfLiteRegistration r;\n  r.init = Init;\n  r.prepare = Prepare;\n  r.invoke = Invoke;\n  return &r;\n}\n\nvoid* SimpleStatefulOp::Init(TfLiteContext* context, const char* buffer,\n                             size_t length) {\n  TFLITE_DCHECK(context->AllocateBufferForEval == nullptr);\n  TFLITE_DCHECK(context->GetScratchBuffer == nullptr);\n  TFLITE_DCHECK(context->RequestScratchBufferInArena == nullptr);\n\n  void* raw = context->AllocatePersistentBuffer(context, sizeof(OpData));\n  OpData* data = reinterpret_cast<OpData*>(raw);\n  *data = {};\n  return raw;\n}\n\nTfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,\n                                       TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  // Make sure that the input is in uint8_t with at least 1 data entry.\n  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);\n  if (input->type != kTfLiteUInt8) return kTfLiteError;\n  if (NumElements(input->dims) == 0) return kTfLiteError;\n\n  // Allocate a temporary buffer with the same size of input for sorting.\n  TF_LITE_ENSURE_STATUS(context->RequestScratchBufferInArena(\n      context, sizeof(uint8_t) * NumElements(input->dims),\n      &data->sorting_buffer));\n  // We can interleave scratch / persistent buffer allocation.\n  data->invoke_count = reinterpret_cast<int*>(\n      context->AllocatePersistentBuffer(context, sizeof(int)));\n  *data->invoke_count = 0;\n\n  return kTfLiteOk;\n}\n\nTfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,\n                                      TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  *data->invoke_count += 1;\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const uint8_t* input_data = GetTensorData<uint8_t>(input);\n  int size = NumElements(input->dims);\n\n  uint8_t* sorting_buffer = reinterpret_cast<uint8_t*>(\n      context->GetScratchBuffer(context, data->sorting_buffer));\n  // Copy inputs data to the sorting buffer. We don't want to mutate the input\n  // tensor as it might be used by a another node.\n  for (int i = 0; i < size; i++) {\n    sorting_buffer[i] = input_data[i];\n  }\n\n  // In place insertion sort on `sorting_buffer`.\n  for (int i = 1; i < size; i++) {\n    for (int j = i; j > 0 && sorting_buffer[j] < sorting_buffer[j - 1]; j--) {\n      std::swap(sorting_buffer[j], sorting_buffer[j - 1]);\n    }\n  }\n\n  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);\n  uint8_t* median_data = GetTensorData<uint8_t>(median);\n  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);\n  int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);\n\n  median_data[0] = sorting_buffer[size / 2];\n  invoke_count_data[0] = *data->invoke_count;\n  return kTfLiteOk;\n}\n\nconst TfLiteRegistration* MockCustom::getRegistration() {\n  return GetMutableRegistration();\n}\n\nTfLiteRegistration* MockCustom::GetMutableRegistration() {\n  static TfLiteRegistration r;\n  r.init = Init;\n  r.prepare = Prepare;\n  r.invoke = Invoke;\n  r.free = Free;\n  return &r;\n}\n\nvoid* MockCustom::Init(TfLiteContext* context, const char* buffer,\n                       size_t length) {\n  // We don't support delegate in TFL micro. This is a weak check to test if\n  // context struct being zero-initialized.\n  TFLITE_DCHECK(context->ReplaceNodeSubsetsWithDelegateKernels == nullptr);\n  freed_ = false;\n  // Do nothing.\n  return nullptr;\n}\n\nvoid MockCustom::Free(TfLiteContext* context, void* buffer) { freed_ = true; }\n\nTfLiteStatus MockCustom::Prepare(TfLiteContext* context, TfLiteNode* node) {\n  return kTfLiteOk;\n}\n\nTfLiteStatus MockCustom::Invoke(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n  const int32_t* input_data = input->data.i32;\n  const TfLiteTensor* weight = tflite::GetInput(context, node, 1);\n  const uint8_t* weight_data = weight->data.uint8;\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  int32_t* output_data = output->data.i32;\n  output_data[0] =\n      0;  // Catch output tensor sharing memory with an input tensor\n  output_data[0] = input_data[0] + weight_data[0];\n  return kTfLiteOk;\n}\n\nbool MockCustom::freed_ = false;\n\nAllOpsResolver GetOpResolver() {\n  AllOpsResolver op_resolver;\n  op_resolver.AddCustom(\"mock_custom\", MockCustom::GetMutableRegistration());\n  op_resolver.AddCustom(\"simple_stateful_op\",\n                        SimpleStatefulOp::GetMutableRegistration());\n\n  return op_resolver;\n}\n\nconst Model* GetSimpleMockModel() {\n  static Model* model = nullptr;\n  if (!model) {\n    model = const_cast<Model*>(BuildSimpleMockModel());\n  }\n  return model;\n}\n\nconst Model* GetComplexMockModel() {\n  static Model* model = nullptr;\n  if (!model) {\n    model = const_cast<Model*>(BuildComplexMockModel());\n  }\n  return model;\n}\n\nconst Model* GetSimpleModelWithBranch() {\n  static Model* model = nullptr;\n  if (!model) {\n    model = const_cast<Model*>(BuildSimpleModelWithBranch());\n  }\n  return model;\n}\n\nconst Model* GetModelWithOfflinePlanning(int num_tensors,\n                                         const int32_t* metadata_buffer,\n                                         NodeConnection* node_conn,\n                                         int num_conns,\n                                         int num_subgraph_inputs) {\n  const Model* model = BuildModelWithOfflinePlanning(\n      num_tensors, metadata_buffer, node_conn, num_conns, num_subgraph_inputs);\n  return model;\n}\n\nconst Model* GetSimpleStatefulModel() {\n  static Model* model = nullptr;\n  if (!model) {\n    model = const_cast<Model*>(BuildSimpleStatefulModel());\n  }\n  return model;\n}\n\nconst Tensor* Create1dFlatbufferTensor(int size, bool is_variable) {\n  using flatbuffers::Offset;\n  flatbuffers::FlatBufferBuilder* builder = BuilderInstance();\n  constexpr size_t tensor_shape_size = 1;\n  const int32_t tensor_shape[tensor_shape_size] = {size};\n  const Offset<Tensor> tensor_offset = CreateTensor(\n      *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n      TensorType_INT32, 0, builder->CreateString(\"test_tensor\"), 0,\n      is_variable);\n  builder->Finish(tensor_offset);\n  void* tensor_pointer = builder->GetBufferPointer();\n  const Tensor* tensor = flatbuffers::GetRoot<Tensor>(tensor_pointer);\n  return tensor;\n}\n\nconst Tensor* CreateQuantizedFlatbufferTensor(int size) {\n  using flatbuffers::Offset;\n  flatbuffers::FlatBufferBuilder* builder = BuilderInstance();\n  const Offset<QuantizationParameters> quant_params =\n      CreateQuantizationParameters(\n          *builder,\n          /*min=*/builder->CreateVector<float>({0.1f}),\n          /*max=*/builder->CreateVector<float>({0.2f}),\n          /*scale=*/builder->CreateVector<float>({0.3f}),\n          /*zero_point=*/builder->CreateVector<int64_t>({100ll}));\n\n  constexpr size_t tensor_shape_size = 1;\n  const int32_t tensor_shape[tensor_shape_size] = {size};\n  const Offset<Tensor> tensor_offset = CreateTensor(\n      *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n      TensorType_INT32, 0, builder->CreateString(\"test_tensor\"), quant_params,\n      false);\n  builder->Finish(tensor_offset);\n  void* tensor_pointer = builder->GetBufferPointer();\n  const Tensor* tensor = flatbuffers::GetRoot<Tensor>(tensor_pointer);\n  return tensor;\n}\n\nconst Tensor* CreateMissingQuantizationFlatbufferTensor(int size) {\n  using flatbuffers::Offset;\n  flatbuffers::FlatBufferBuilder* builder = BuilderInstance();\n  const Offset<QuantizationParameters> quant_params =\n      CreateQuantizationParameters(*builder, 0, 0, 0, 0,\n                                   QuantizationDetails_NONE, 0, 0);\n  constexpr size_t tensor_shape_size = 1;\n  const int32_t tensor_shape[tensor_shape_size] = {size};\n  const Offset<Tensor> tensor_offset = CreateTensor(\n      *builder, builder->CreateVector(tensor_shape, tensor_shape_size),\n      TensorType_INT32, 0, builder->CreateString(\"test_tensor\"), quant_params,\n      false);\n  builder->Finish(tensor_offset);\n  void* tensor_pointer = builder->GetBufferPointer();\n  const Tensor* tensor = flatbuffers::GetRoot<Tensor>(tensor_pointer);\n  return tensor;\n}\n\nconst flatbuffers::Vector<flatbuffers::Offset<Buffer>>*\nCreateFlatbufferBuffers() {\n  using flatbuffers::Offset;\n  flatbuffers::FlatBufferBuilder* builder = BuilderInstance();\n  constexpr size_t buffers_size = 1;\n  const Offset<Buffer> buffers[buffers_size] = {\n      CreateBuffer(*builder),\n  };\n  const flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Buffer>>>\n      buffers_offset = builder->CreateVector(buffers, buffers_size);\n  builder->Finish(buffers_offset);\n  void* buffers_pointer = builder->GetBufferPointer();\n  const flatbuffers::Vector<flatbuffers::Offset<Buffer>>* result =\n      flatbuffers::GetRoot<flatbuffers::Vector<flatbuffers::Offset<Buffer>>>(\n          buffers_pointer);\n  return result;\n}\n\nint TestStrcmp(const char* a, const char* b) {\n  if ((a == nullptr) || (b == nullptr)) {\n    return -1;\n  }\n  while ((*a != 0) && (*a == *b)) {\n    a++;\n    b++;\n  }\n  return *reinterpret_cast<const unsigned char*>(a) -\n         *reinterpret_cast<const unsigned char*>(b);\n}\n\n// Wrapper to forward kernel errors to the interpreter's error reporter.\nvoid ReportOpError(struct TfLiteContext* context, const char* format, ...) {\n#ifndef TF_LITE_STRIP_ERROR_STRINGS\n  ErrorReporter* error_reporter = static_cast<ErrorReporter*>(context->impl_);\n  va_list args;\n  va_start(args, format);\n  TF_LITE_REPORT_ERROR(error_reporter, format, args);\n  va_end(args);\n#endif\n}\n\n// Create a TfLiteIntArray from an array of ints.  The first element in the\n// supplied array must be the size of the array expressed as an int.\nTfLiteIntArray* IntArrayFromInts(const int* int_array) {\n  return const_cast<TfLiteIntArray*>(\n      reinterpret_cast<const TfLiteIntArray*>(int_array));\n}\n\n// Create a TfLiteFloatArray from an array of floats.  The first element in the\n// supplied array must be the size of the array expressed as a float.\nTfLiteFloatArray* FloatArrayFromFloats(const float* floats) {\n  static_assert(sizeof(float) == sizeof(int),\n                \"assumes sizeof(float) == sizeof(int) to perform casting\");\n  int size = static_cast<int>(floats[0]);\n  *reinterpret_cast<int32_t*>(const_cast<float*>(floats)) = size;\n  return reinterpret_cast<TfLiteFloatArray*>(const_cast<float*>(floats));\n}\n\nTfLiteTensor CreateTensor(TfLiteIntArray* dims, bool is_variable) {\n  TfLiteTensor result;\n  result.dims = dims;\n  result.params = {};\n  result.quantization = {kTfLiteNoQuantization, nullptr};\n  result.is_variable = is_variable;\n  result.allocation_type = kTfLiteMemNone;\n  return result;\n}\n\nTfLiteTensor CreateFloatTensor(const float* data, TfLiteIntArray* dims,\n                               bool is_variable) {\n  TfLiteTensor result = CreateTensor(dims, is_variable);\n  result.type = kTfLiteFloat32;\n  result.data.f = const_cast<float*>(data);\n  result.bytes = ElementCount(*dims) * sizeof(float);\n  return result;\n}\n\nvoid PopulateFloatTensor(TfLiteTensor* tensor, float* begin, float* end) {\n  float* p = begin;\n  float* v = tensor->data.f;\n  while (p != end) {\n    *v++ = *p++;\n  }\n}\n\nTfLiteTensor CreateBoolTensor(const bool* data, TfLiteIntArray* dims,\n                              bool is_variable) {\n  TfLiteTensor result = CreateTensor(dims, is_variable);\n  result.type = kTfLiteBool;\n  result.data.b = const_cast<bool*>(data);\n  result.bytes = ElementCount(*dims) * sizeof(bool);\n  return result;\n}\n\nTfLiteTensor CreateInt32Tensor(const int32_t* data, TfLiteIntArray* dims,\n                               bool is_variable) {\n  TfLiteTensor result = CreateTensor(dims, is_variable);\n  result.type = kTfLiteInt32;\n  result.data.i32 = const_cast<int32_t*>(data);\n  result.bytes = ElementCount(*dims) * sizeof(int32_t);\n  return result;\n}\n\nTfLiteTensor CreateQuantizedTensor(const uint8_t* data, TfLiteIntArray* dims,\n                                   float scale, int zero_point,\n                                   bool is_variable) {\n  TfLiteTensor result = CreateTensor(dims, is_variable);\n  result.type = kTfLiteUInt8;\n  result.data.uint8 = const_cast<uint8_t*>(data);\n  result.params = {scale, zero_point};\n  result.quantization = {kTfLiteAffineQuantization, nullptr};\n  result.bytes = ElementCount(*dims) * sizeof(uint8_t);\n  return result;\n}\n\nTfLiteTensor CreateQuantizedTensor(const int8_t* data, TfLiteIntArray* dims,\n                                   float scale, int zero_point,\n                                   bool is_variable) {\n  TfLiteTensor result = CreateTensor(dims, is_variable);\n  result.type = kTfLiteInt8;\n  result.data.int8 = const_cast<int8_t*>(data);\n  result.params = {scale, zero_point};\n  result.quantization = {kTfLiteAffineQuantization, nullptr};\n  result.bytes = ElementCount(*dims) * sizeof(int8_t);\n  return result;\n}\n\nTfLiteTensor CreateQuantizedTensor(const int16_t* data, TfLiteIntArray* dims,\n                                   float scale, int zero_point,\n                                   bool is_variable) {\n  TfLiteTensor result = CreateTensor(dims, is_variable);\n  result.type = kTfLiteInt16;\n  result.data.i16 = const_cast<int16_t*>(data);\n  result.params = {scale, zero_point};\n  result.quantization = {kTfLiteAffineQuantization, nullptr};\n  result.bytes = ElementCount(*dims) * sizeof(int16_t);\n  return result;\n}\n\nTfLiteTensor CreateQuantizedBiasTensor(const float* data, int32_t* quantized,\n                                       TfLiteIntArray* dims, float input_scale,\n                                       float weights_scale, bool is_variable) {\n  float bias_scale = input_scale * weights_scale;\n  tflite::SymmetricQuantize(data, quantized, ElementCount(*dims), bias_scale);\n  TfLiteTensor result = CreateTensor(dims, is_variable);\n  result.type = kTfLiteInt32;\n  result.data.i32 = const_cast<int32_t*>(quantized);\n  // Quantized int32_t tensors always have a zero point of 0, since the range of\n  // int32_t values is large, and because zero point costs extra cycles during\n  // processing.\n  result.params = {bias_scale, 0};\n  result.quantization = {kTfLiteAffineQuantization, nullptr};\n  result.bytes = ElementCount(*dims) * sizeof(int32_t);\n  return result;\n}\n\n// Quantizes int32_t bias tensor with per-channel weights determined by input\n// scale multiplied by weight scale for each channel.\nTfLiteTensor CreatePerChannelQuantizedBiasTensor(\n    const float* input, int32_t* quantized, TfLiteIntArray* dims,\n    float input_scale, float* weight_scales, float* scales, int* zero_points,\n    TfLiteAffineQuantization* affine_quant, int quantized_dimension,\n    bool is_variable) {\n  int input_size = ElementCount(*dims);\n  int num_channels = dims->data[quantized_dimension];\n  // First element is reserved for array length\n  zero_points[0] = num_channels;\n  scales[0] = static_cast<float>(num_channels);\n  float* scales_array = &scales[1];\n  for (int i = 0; i < num_channels; i++) {\n    scales_array[i] = input_scale * weight_scales[i];\n    zero_points[i + 1] = 0;\n  }\n\n  SymmetricPerChannelQuantize(input, quantized, input_size, num_channels,\n                              scales_array);\n\n  affine_quant->scale = FloatArrayFromFloats(scales);\n  affine_quant->zero_point = IntArrayFromInts(zero_points);\n  affine_quant->quantized_dimension = quantized_dimension;\n\n  TfLiteTensor result = CreateTensor(dims, is_variable);\n  result.type = kTfLiteInt32;\n  result.data.i32 = const_cast<int32_t*>(quantized);\n  result.quantization = {kTfLiteAffineQuantization, affine_quant};\n  result.bytes = ElementCount(*dims) * sizeof(int32_t);\n  return result;\n}\n\nTfLiteTensor CreateSymmetricPerChannelQuantizedTensor(\n    const float* input, int8_t* quantized, TfLiteIntArray* dims, float* scales,\n    int* zero_points, TfLiteAffineQuantization* affine_quant,\n    int quantized_dimension, bool is_variable) {\n  int channel_count = dims->data[quantized_dimension];\n  scales[0] = static_cast<float>(channel_count);\n  zero_points[0] = channel_count;\n\n  SignedSymmetricPerChannelQuantize(input, dims, quantized_dimension, quantized,\n                                    &scales[1]);\n\n  for (int i = 0; i < channel_count; i++) {\n    zero_points[i + 1] = 0;\n  }\n\n  affine_quant->scale = FloatArrayFromFloats(scales);\n  affine_quant->zero_point = IntArrayFromInts(zero_points);\n  affine_quant->quantized_dimension = quantized_dimension;\n\n  TfLiteTensor result = CreateTensor(dims, is_variable);\n  result.type = kTfLiteInt8;\n  result.data.int8 = const_cast<int8_t*>(quantized);\n  result.quantization = {kTfLiteAffineQuantization, affine_quant};\n  result.bytes = ElementCount(*dims) * sizeof(int8_t);\n  return result;\n}\n\nsize_t GetModelTensorCount(const Model* model) {\n  auto* subgraphs = model->subgraphs();\n  if (subgraphs) {\n    return (*subgraphs)[0]->tensors()->size();\n  }\n  return 0;\n}\n\n}  // namespace testing\n}  // namespace tflite"