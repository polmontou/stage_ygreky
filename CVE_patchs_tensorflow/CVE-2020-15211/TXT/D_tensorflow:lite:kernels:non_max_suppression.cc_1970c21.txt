diff --git a/tensorflow/lite/kernels/non_max_suppression.cc b/tensorflow/lite/kernels/non_max_suppression.cc
index d6e13cdbd33..70f80e68cd0 100644
--- a/tensorflow/lite/kernels/non_max_suppression.cc
+++ b/tensorflow/lite/kernels/non_max_suppression.cc
@@ -79,20 +79,25 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
   }
 
   // Boxes & Scores.
-  const TfLiteTensor* input_boxes = GetInput(context, node, kInputTensorBoxes);
+  const TfLiteTensor* input_boxes;
+  TF_LITE_ENSURE_OK(
+      context, GetInputSafe(context, node, kInputTensorBoxes, &input_boxes));
   TF_LITE_ENSURE_EQ(context, input_boxes->type, kTfLiteFloat32);
   TF_LITE_ENSURE_EQ(context, NumDimensions(input_boxes), 2);
   TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_boxes, 1), 4);
   const int num_boxes = SizeOfDimension(input_boxes, 0);
-  const TfLiteTensor* input_scores =
-      GetInput(context, node, kInputTensorScores);
+  const TfLiteTensor* input_scores;
+  TF_LITE_ENSURE_OK(
+      context, GetInputSafe(context, node, kInputTensorScores, &input_scores));
   TF_LITE_ENSURE_EQ(context, input_scores->type, kTfLiteFloat32);
   TF_LITE_ENSURE_EQ(context, NumDimensions(input_scores), 1);
   TF_LITE_ENSURE_EQ(context, num_boxes, SizeOfDimension(input_scores, 0));
 
   // Max output size.
-  const TfLiteTensor* input_max_output_size =
-      GetInput(context, node, kInputTensorMaxOutputSize);
+  const TfLiteTensor* input_max_output_size;
+  TF_LITE_ENSURE_OK(context,
+                    GetInputSafe(context, node, kInputTensorMaxOutputSize,
+                                 &input_max_output_size));
   TF_LITE_ENSURE_EQ(context, input_max_output_size->type, kTfLiteInt32);
   TF_LITE_ENSURE_EQ(context, NumDimensions(input_max_output_size), 0);
   const bool is_max_output_size_const = IsConstantTensor(input_max_output_size);
@@ -103,30 +108,43 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
   }
 
   // IoU & Score thresholds.
-  const TfLiteTensor* input_iou_threshold =
-      GetInput(context, node, kInputTensorIouThreshold);
+  const TfLiteTensor* input_iou_threshold;
+  TF_LITE_ENSURE_OK(context,
+                    GetInputSafe(context, node, kInputTensorIouThreshold,
+                                 &input_iou_threshold));
   TF_LITE_ENSURE_EQ(context, input_iou_threshold->type, kTfLiteFloat32);
   TF_LITE_ENSURE_EQ(context, NumDimensions(input_iou_threshold), 0);
-  const TfLiteTensor* input_score_threshold =
-      GetInput(context, node, kInputTensorScoreThreshold);
+  const TfLiteTensor* input_score_threshold;
+  TF_LITE_ENSURE_OK(context,
+                    GetInputSafe(context, node, kInputTensorScoreThreshold,
+                                 &input_score_threshold));
   TF_LITE_ENSURE_EQ(context, input_iou_threshold->type, kTfLiteFloat32);
   TF_LITE_ENSURE_EQ(context, NumDimensions(input_score_threshold), 0);
 
   if (is_soft_nms) {
-    const TfLiteTensor* input_sigma =
-        GetInput(context, node, kInputTensorSigma);
+    const TfLiteTensor* input_sigma;
+    TF_LITE_ENSURE_OK(
+        context, GetInputSafe(context, node, kInputTensorSigma, &input_sigma));
     TF_LITE_ENSURE_EQ(context, input_sigma->type, kTfLiteFloat32);
     TF_LITE_ENSURE_EQ(context, NumDimensions(input_sigma), 0);
 
     TF_LITE_ENSURE_EQ(context, NumOutputs(node), 3);
-    TfLiteTensor* output_selected_indices =
-        GetOutput(context, node, kSoftNMSOutputTensorSelectedIndices);
+    TfLiteTensor* output_selected_indices;
+    TF_LITE_ENSURE_OK(
+        context,
+        GetOutputSafe(context, node, kSoftNMSOutputTensorSelectedIndices,
+                      &output_selected_indices));
     output_selected_indices->type = kTfLiteInt32;
-    TfLiteTensor* output_selected_scores =
-        GetOutput(context, node, kSoftNMSOutputTensorSelectedScores);
+    TfLiteTensor* output_selected_scores;
+    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node,
+                                             kSoftNMSOutputTensorSelectedScores,
+                                             &output_selected_scores));
     output_selected_scores->type = kTfLiteFloat32;
-    TfLiteTensor* output_num_selected_indices =
-        GetOutput(context, node, kSoftNMSOutputTensorNumSelectedIndices);
+    TfLiteTensor* output_num_selected_indices;
+    TF_LITE_ENSURE_OK(
+        context,
+        GetOutputSafe(context, node, kSoftNMSOutputTensorNumSelectedIndices,
+                      &output_num_selected_indices));
     output_num_selected_indices->type = kTfLiteInt32;
     SetTensorSizes(context, output_num_selected_indices, {});
 
@@ -139,11 +157,15 @@ TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
     }
   } else {
     TF_LITE_ENSURE_EQ(context, NumOutputs(node), 2);
-    TfLiteTensor* output_selected_indices =
-        GetOutput(context, node, kNMSOutputTensorSelectedIndices);
+    TfLiteTensor* output_selected_indices;
+    TF_LITE_ENSURE_OK(
+        context, GetOutputSafe(context, node, kNMSOutputTensorSelectedIndices,
+                               &output_selected_indices));
     output_selected_indices->type = kTfLiteInt32;
-    TfLiteTensor* output_num_selected_indices =
-        GetOutput(context, node, kNMSOutputTensorNumSelectedIndices);
+    TfLiteTensor* output_num_selected_indices;
+    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node,
+                                             kNMSOutputTensorNumSelectedIndices,
+                                             &output_num_selected_indices));
     output_num_selected_indices->type = kTfLiteInt32;
     SetTensorSizes(context, output_num_selected_indices, {});
 
@@ -179,20 +201,29 @@ void ResetUnusedElementsToZeroes(const int max_output_size,
 TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
   const bool is_soft_nms = NumInputs(node) == 6;
 
-  const TfLiteTensor* input_boxes = GetInput(context, node, kInputTensorBoxes);
+  const TfLiteTensor* input_boxes;
+  TF_LITE_ENSURE_OK(
+      context, GetInputSafe(context, node, kInputTensorBoxes, &input_boxes));
   const int num_boxes = SizeOfDimension(input_boxes, 0);
-  const TfLiteTensor* input_scores =
-      GetInput(context, node, kInputTensorScores);
-  const TfLiteTensor* input_max_output_size =
-      GetInput(context, node, kInputTensorMaxOutputSize);
+  const TfLiteTensor* input_scores;
+  TF_LITE_ENSURE_OK(
+      context, GetInputSafe(context, node, kInputTensorScores, &input_scores));
+  const TfLiteTensor* input_max_output_size;
+  TF_LITE_ENSURE_OK(context,
+                    GetInputSafe(context, node, kInputTensorMaxOutputSize,
+                                 &input_max_output_size));
   const int max_output_size_value = *GetTensorData<int>(input_max_output_size);
   TF_LITE_ENSURE(context, (max_output_size_value >= 0));
   const bool is_max_output_size_const = IsConstantTensor(input_max_output_size);
-  const TfLiteTensor* input_iou_threshold =
-      GetInput(context, node, kInputTensorIouThreshold);
+  const TfLiteTensor* input_iou_threshold;
+  TF_LITE_ENSURE_OK(context,
+                    GetInputSafe(context, node, kInputTensorIouThreshold,
+                                 &input_iou_threshold));
   const float iou_threshold = *GetTensorData<float>(input_iou_threshold);
-  const TfLiteTensor* input_score_threshold =
-      GetInput(context, node, kInputTensorScoreThreshold);
+  const TfLiteTensor* input_score_threshold;
+  TF_LITE_ENSURE_OK(context,
+                    GetInputSafe(context, node, kInputTensorScoreThreshold,
+                                 &input_score_threshold));
   const float score_threshold = *GetTensorData<float>(input_score_threshold);
 
   TfLiteTensor* output_selected_indices = nullptr;
@@ -200,8 +231,9 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
   TfLiteTensor* output_num_selected_indices = nullptr;
 
   if (is_soft_nms) {
-    const TfLiteTensor* input_sigma =
-        GetInput(context, node, kInputTensorSigma);
+    const TfLiteTensor* input_sigma;
+    TF_LITE_ENSURE_OK(
+        context, GetInputSafe(context, node, kInputTensorSigma, &input_sigma));
     const float soft_nms_sigma = *GetTensorData<float>(input_sigma);
     if (soft_nms_sigma < 0) {
       context->ReportError(context, "Invalid sigma value for soft NMS: %f",
@@ -209,12 +241,17 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
       return kTfLiteError;
     }
 
-    output_selected_indices =
-        GetOutput(context, node, kSoftNMSOutputTensorSelectedIndices);
-    output_selected_scores =
-        GetOutput(context, node, kSoftNMSOutputTensorSelectedScores);
-    output_num_selected_indices =
-        GetOutput(context, node, kSoftNMSOutputTensorNumSelectedIndices);
+    TF_LITE_ENSURE_OK(
+        context,
+        GetOutputSafe(context, node, kSoftNMSOutputTensorSelectedIndices,
+                      &output_selected_indices));
+    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node,
+                                             kSoftNMSOutputTensorSelectedScores,
+                                             &output_selected_scores));
+    TF_LITE_ENSURE_OK(
+        context,
+        GetOutputSafe(context, node, kSoftNMSOutputTensorNumSelectedIndices,
+                      &output_num_selected_indices));
     if (!is_max_output_size_const) {
       SetTensorSizes(context, output_selected_indices, {max_output_size_value});
       SetTensorSizes(context, output_selected_scores, {max_output_size_value});
@@ -228,10 +265,12 @@ TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
         max_output_size_value, *output_num_selected_indices->data.i32,
         output_selected_indices->data.i32, output_selected_scores->data.f);
   } else {
-    output_selected_indices =
-        GetOutput(context, node, kNMSOutputTensorSelectedIndices);
-    output_num_selected_indices =
-        GetOutput(context, node, kNMSOutputTensorNumSelectedIndices);
+    TF_LITE_ENSURE_OK(
+        context, GetOutputSafe(context, node, kNMSOutputTensorSelectedIndices,
+                               &output_selected_indices));
+    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node,
+                                             kNMSOutputTensorNumSelectedIndices,
+                                             &output_num_selected_indices));
     if (!is_max_output_size_const) {
       SetTensorSizes(context, output_selected_indices, {max_output_size_value});
     }