"diff --git a/tensorflow/core/kernels/image/crop_and_resize_op.cc b/tensorflow/core/kernels/image/crop_and_resize_op.cc\nindex 5c196df9cfe..4efc4ae8846 100644\n--- a/tensorflow/core/kernels/image/crop_and_resize_op.cc\n+++ b/tensorflow/core/kernels/image/crop_and_resize_op.cc\n@@ -207,7 +207,7 @@ class CropAndResizeOp : public AsyncOpKernel {\n namespace functor {\n template <typename T>\n struct CropAndResize<CPUDevice, T> {\n-  bool operator()(const OpKernelContext* context,\n+  bool operator()(OpKernelContext* context,\n                   typename TTypes<T, 4>::ConstTensor image,\n                   typename TTypes<float, 2>::ConstTensor boxes,\n                   typename TTypes<int32, 1>::ConstTensor box_index,\n@@ -222,6 +222,17 @@ struct CropAndResize<CPUDevice, T> {\n     const int crop_width = crops.dimension(2);\n     const int depth = crops.dimension(3);\n \n+    // Since `functor::CropAndResize` operates on float, we first validate\n+    // that we don't overflow (since overflow causes undefined behavior which\n+    // could result in segfault in this scenario).\n+    const Eigen::Tensor<bool, 0, Eigen::RowMajor> only_finite_elements =\n+        boxes.isfinite().all();\n+    if (!only_finite_elements()) {\n+      context->SetStatus(errors::InvalidArgument(\n+          \"Boxes contains at least one element that is not finite\"));\n+      return false;\n+    }\n+\n     // Sharding across boxes.\n     auto CropAndResizePerBox = [&](int64 start_box, int64 limit_box) {\n       for (int b = start_box; b < limit_box; ++b) {"