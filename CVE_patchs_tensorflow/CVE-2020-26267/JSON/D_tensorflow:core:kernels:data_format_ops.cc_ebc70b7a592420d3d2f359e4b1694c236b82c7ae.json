"diff --git a/tensorflow/core/kernels/data_format_ops.cc b/tensorflow/core/kernels/data_format_ops.cc\nindex b52d4d6c888..00724b630ee 100644\n--- a/tensorflow/core/kernels/data_format_ops.cc\n+++ b/tensorflow/core/kernels/data_format_ops.cc\n@@ -18,16 +18,52 @@ limitations under the License.\n #define EIGEN_USE_THREADS\n \n #include \"tensorflow/core/kernels/data_format_ops.h\"\n+\n+#include <map>\n+\n #include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n #include \"tensorflow/core/framework/op_kernel.h\"\n #include \"tensorflow/core/framework/register_types.h\"\n #include \"tensorflow/core/framework/tensor.h\"\n+#include \"tensorflow/core/platform/errors.h\"\n \n namespace tensorflow {\n \n typedef Eigen::ThreadPoolDevice CPUDevice;\n typedef Eigen::GpuDevice GPUDevice;\n \n+// Ensure that `src` and `dst` define a valid permutation.\n+// Ops defined in this file assume that user specifies a permutation via two\n+// string attributes. This check validates that these attributes properly define\n+// it to prevent security vulnerabilities.\n+static bool IsValidPermutation(const std::string& src, const std::string& dst) {\n+  if (src.size() != dst.size()) {\n+    return false;\n+  }\n+\n+  std::map<char, bool> characters;\n+\n+  // Every character in `src` must be present only once\n+  for (const auto c : src) {\n+    if (characters[c]) {\n+      return false;\n+    }\n+    characters[c] = true;\n+  }\n+\n+  // Every character in `dst` must show up in `src` exactly once\n+  for (const auto c : dst) {\n+    if (!characters[c]) {\n+      return false;\n+    }\n+    characters[c] = false;\n+  }\n+\n+  // At this point, characters[] has been switched to true and false exactly\n+  // once for all character in `src` (and `dst`) so we have a valid permutation\n+  return true;\n+}\n+\n template <typename Device, typename T>\n class DataFormatDimMapOp : public OpKernel {\n  public:\n@@ -38,15 +74,19 @@ class DataFormatDimMapOp : public OpKernel {\n     string dst_format;\n     OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n     OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n-                errors::InvalidArgument(strings::StrCat(\n-                    \"Source format must of length 4 or 5, received \"\n+                errors::InvalidArgument(\n+                    \"Source format must be of length 4 or 5, received \"\n                     \"src_format = \",\n-                    src_format)));\n+                    src_format));\n+    OP_REQUIRES(context, dst_format.size() == 4 || dst_format.size() == 5,\n+                errors::InvalidArgument(\"Destination format must be of length \"\n+                                        \"4 or 5, received dst_format = \",\n+                                        dst_format));\n     OP_REQUIRES(\n-        context, dst_format.size() == 4 || dst_format.size() == 5,\n-        errors::InvalidArgument(strings::StrCat(\n-            \"Destination format must of length 4 or 5, received dst_format = \",\n-            dst_format)));\n+        context, IsValidPermutation(src_format, dst_format),\n+        errors::InvalidArgument(\n+            \"Destination and source format must determine a permutation, got \",\n+            src_format, \" and \", dst_format));\n     dst_idx_ = Tensor(DT_INT32, {static_cast<int64>(src_format.size())});\n     for (int i = 0; i < src_format.size(); ++i) {\n       for (int j = 0; j < dst_format.size(); ++j) {\n@@ -78,8 +118,22 @@ class DataFormatVecPermuteOp : public OpKernel {\n       : OpKernel(context) {\n     string src_format;\n     OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n+    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n+                errors::InvalidArgument(\n+                    \"Source format must be of length 4 or 5, received \"\n+                    \"src_format = \",\n+                    src_format));\n     string dst_format;\n     OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n+    OP_REQUIRES(context, dst_format.size() == 4 || dst_format.size() == 5,\n+                errors::InvalidArgument(\"Destination format must be of length \"\n+                                        \"4 or 5, received dst_format = \",\n+                                        dst_format));\n+    OP_REQUIRES(\n+        context, IsValidPermutation(src_format, dst_format),\n+        errors::InvalidArgument(\n+            \"Destination and source format must determine a permutation, got \",\n+            src_format, \" and \", dst_format));\n     src_format_ = src_format;\n     dst_format_ = dst_format;\n   }\n@@ -127,6 +181,10 @@ class DataFormatVecPermuteOp : public OpKernel {\n       };\n       keep_only_spatial_dimensions(&src_format_str);\n       keep_only_spatial_dimensions(&dst_format_str);\n+      OP_REQUIRES(context,\n+                  src_format_str.size() == 2 && dst_format_str.size() == 2,\n+                  errors::InvalidArgument(\n+                      \"Format specifier must contain H and W for 2D case\"));\n     }\n     ComputeDstIndex(src_format_str, dst_format_str, input.dims(), &dst_idx);\n "