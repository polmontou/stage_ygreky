"diff --git a/tensorflow/python/lib/core/py_seq_tensor.cc b/tensorflow/python/lib/core/py_seq_tensor.cc\nindex 8770b362a4e..5d4916f48fc 100644\n--- a/tensorflow/python/lib/core/py_seq_tensor.cc\n+++ b/tensorflow/python/lib/core/py_seq_tensor.cc\n@@ -21,6 +21,7 @@ limitations under the License.\n #include \"tensorflow/core/lib/core/errors.h\"\n #include \"tensorflow/core/lib/core/stringpiece.h\"\n #include \"tensorflow/core/lib/strings/str_util.h\"\n+#include \"tensorflow/core/platform/macros.h\"\n #include \"tensorflow/core/platform/types.h\"\n #include \"tensorflow/python/lib/core/numpy.h\"\n #include \"tensorflow/python/lib/core/py_util.h\"\n@@ -396,6 +397,21 @@ typedef Converter<int32> Int32Converter;\n \n // Floating-point support\n \n+// Returns `true` if `out` overflows when converted from `as_double`.\n+template <class T>\n+static inline bool CheckForOverflow(double as_double, T* out) {\n+  return (sizeof(T) < sizeof(double) && std::isinf(*out) &&\n+          std::isfinite(as_double));\n+}\n+\n+// There is no `std::isinf` that takes `Eigen::half` as argument but Eigen\n+// provides `Eigen::half_impl::isinf` instead.\n+template <>\n+inline bool CheckForOverflow<Eigen::half>(double as_double, Eigen::half* out) {\n+  return (sizeof(Eigen::half) < sizeof(double) &&\n+          Eigen::half_impl::isinf(*out) && std::isfinite(as_double));\n+}\n+\n template <class T>\n static const char* ConvertOneFloat(PyObject* v, T* out) {\n   if (PyErr_Occurred()) {\n@@ -405,20 +421,19 @@ static const char* ConvertOneFloat(PyObject* v, T* out) {\n     const double as_double = PyFloat_AS_DOUBLE(v);\n     *out = static_cast<T>(as_double);\n     // Check for overflow\n-    if (TF_PREDICT_FALSE(sizeof(T) < sizeof(double) && std::isinf(*out) &&\n-                         std::isfinite(as_double))) {\n+    if (TF_PREDICT_FALSE(CheckForOverflow<T>(as_double, out))) {\n       return ErrorOutOfRangeDouble;\n     }\n     return nullptr;\n   }\n #if PY_MAJOR_VERSION < 3\n   if (PyInt_Check(v)) {\n-    *out = PyInt_AS_LONG(v);\n+    *out = static_cast<T>(PyInt_AS_LONG(v));\n     return nullptr;\n   }\n #endif\n   if (PyLong_Check(v)) {\n-    *out = PyLong_AsDouble(v);\n+    *out = static_cast<T>(PyLong_AsDouble(v));\n     if (PyErr_Occurred()) return ErrorOutOfRangeDouble;\n     return nullptr;\n   }\n@@ -467,13 +482,7 @@ struct ConverterTraits<Eigen::half> {\n   static const tensorflow::DataType kTypeEnum = DT_HALF;\n \n   static const char* ConvertScalar(PyObject* v, Eigen::half* out) {\n-    // NOTE(nareshmodi): Is there a way to convert to C double without the\n-    // intermediate Python double? This will help with ConvertOneFloat as well.\n-    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n-    double v_double = PyFloat_AS_DOUBLE(as_float.get());\n-    *out = Eigen::half(v_double);\n-\n-    return nullptr;\n+    return ConvertOneFloat<Eigen::half>(v, out);\n   }\n };\n \n@@ -613,7 +622,9 @@ Status PySeqToTensor(PyObject* obj, DataType dtype, Tensor* ret) {\n       break;\n \n     case DT_HALF:\n-      RETURN_STRING_AS_STATUS(NumpyHalfConverter::Convert(obj, &state, ret));\n+      if (NumpyHalfConverter::Convert(obj, &state, ret) == nullptr)\n+        return Status::OK();\n+      break;\n \n     case DT_INT64:\n       if (Int64Converter::Convert(obj, &state, ret) == nullptr)"