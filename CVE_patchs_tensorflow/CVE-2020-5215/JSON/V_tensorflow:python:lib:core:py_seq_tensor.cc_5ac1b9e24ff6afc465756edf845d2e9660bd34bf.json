"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/python/lib/core/py_seq_tensor.h\"\n\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/python/lib/core/numpy.h\"\n#include \"tensorflow/python/lib/core/py_util.h\"\n#include \"tensorflow/python/lib/core/safe_ptr.h\"\n\nnamespace tensorflow {\nnamespace {\n\ninline bool PyIsInstance(PyObject* obj, PyTypeObject* t) {\n  return PyObject_IsInstance(obj, reinterpret_cast<PyObject*>(t));\n}\n\ninline PyObject* PyType(PyObject* obj) {\n  return reinterpret_cast<PyObject*>(obj->ob_type);\n}\n\nbool IsPyString(PyObject* obj) {\n  return PyBytes_Check(obj) || PyUnicode_Check(obj);\n}\n\nbool IsPyInt(PyObject* obj) {\n#if PY_MAJOR_VERSION >= 3\n  return PyLong_Check(obj) ||\n         PyIsInstance(obj, &PyIntegerArrType_Type);  // NumPy integers\n#else\n  return PyInt_Check(obj) || PyLong_Check(obj) ||\n         PyIsInstance(obj, &PyIntegerArrType_Type);  // NumPy integers\n#endif\n}\n\nbool IsPyDouble(PyObject* obj) {\n  return PyIsInstance(obj, &PyDoubleArrType_Type);  // NumPy double type.\n}\n\nbool IsNumpyHalf(PyObject* obj) {\n  return PyIsInstance(obj, &PyHalfArrType_Type);\n}\n\nbool IsPyFloat(PyObject* obj) {\n  return PyFloat_Check(obj) ||\n         PyIsInstance(obj, &PyFloatingArrType_Type);  // NumPy float types\n}\n\nstruct ConverterState {\n  // The inferred tensor shape.\n  TensorShape inferred_shape;\n\n  // The inferred tensor data type.\n  DataType inferred_dtype;\n\n  // The following fields are used by ZeroDimArrayToScalar.\n  // We cache the last result of the check for a zero dimensional array: the\n  // function is called many times in a conversion, and most of the time is\n  // to check for the same type. This cache can reduce the conversion time by\n  // about 25%.\n  PyTypeObject* last_zerodim_type;\n  bool last_zerodim_check;\n\n  ConverterState() : inferred_dtype(DT_INVALID), last_zerodim_type(nullptr) {}\n};\n\n// If the input is a zero dimensional PyArray return it converted to a scalar.\n// Otherwise return the input and increment its reference count.\n// Users must Py_DECREF the output of this method.\nPyObject* ZeroDimArrayToScalar(PyObject* obj, ConverterState* state) {\n  auto type = Py_TYPE(obj);\n  auto pyarray_obj = reinterpret_cast<PyArrayObject*>(obj);\n  if (type != state->last_zerodim_type) {\n    state->last_zerodim_type = type;\n    state->last_zerodim_check =\n        PyObject_TypeCheck(obj, &PyArray_Type) &&\n        !PyObject_TypeCheck(obj, &PyGenericArrType_Type);\n  }\n\n  if (state->last_zerodim_check && PyArray_NDIM(pyarray_obj) == 0) {\n    obj = PyArray_ToScalar(PyArray_DATA(pyarray_obj), pyarray_obj);\n  } else {\n    Py_INCREF(obj);\n  }\n  return obj;\n}\n\n// Sets *elem to a NEW reference to an element in seq on success.\n// REQUIRES: PySequence_Check(seq) && PySequence_Length(seq) > 0.\nStatus SampleElementFromSequence(PyObject* seq, PyObject** elem) {\n  *elem = PySequence_GetItem(seq, 0);\n  if (*elem != nullptr) return Status::OK();\n  // seq may implement the sequence protocol (i.e., implement __getitem__)\n  // but may legitimately not have a 0-th element (__getitem__(self, 0)\n  // raises a KeyError). For example:\n  // seq = pandas.Series([0, 1, 2], index=[2, 4, 6])\n  //\n  // We don't actually care for the element at key 0, any element will do\n  // for inferring the element types. All elements are expected to\n  // have the same type, and this will be validated when converting\n  // to an EagerTensor.\n  PyErr_Clear();\n  Safe_PyObjectPtr iter(PyObject_GetIter(seq));\n  if (PyErr_Occurred()) {\n    return errors::InvalidArgument(\"Cannot infer dtype of a \",\n                                   Py_TYPE(seq)->tp_name,\n                                   \" object: \", PyExceptionFetch());\n  }\n  *elem = PyIter_Next(iter.get());\n  if (PyErr_Occurred()) {\n    return errors::InvalidArgument(\n        \"Cannot infer dtype of a \", Py_TYPE(seq)->tp_name,\n        \" object, as iter(<object>).next() failed: \", PyExceptionFetch());\n  }\n  if (*elem == nullptr) {\n    return errors::InvalidArgument(\"Cannot infer dtype of a \",\n                                   Py_TYPE(seq)->tp_name,\n                                   \" object since it is an empty sequence\");\n  }\n  return Status::OK();\n}\n\ntstring PyRepr(PyObject* obj);\nbool IsPyDimension(PyObject* obj);\n\nStatus InferShapeAndType(PyObject* obj, ConverterState* state) {\n  std::vector<Safe_PyObjectPtr> refs_to_clean;\n  while (true) {\n    // Convert any zero dimensional numpy arrays to scalars first of all.\n    // We also have to make sure a reference to the safe_obj is kept.\n    obj = ZeroDimArrayToScalar(obj, state);\n    refs_to_clean.push_back(make_safe(obj));\n    // We test strings first, in case a string is considered a sequence.\n    if (IsPyString(obj)) {\n      state->inferred_dtype = DT_STRING;\n    } else if (PySequence_Check(obj)) {\n      auto length = PySequence_Length(obj);\n      if (length > 0) {\n        state->inferred_shape.AddDim(length);\n        PyObject* elem = nullptr;\n        TF_RETURN_IF_ERROR(SampleElementFromSequence(obj, &elem));\n        obj = elem;\n        refs_to_clean.push_back(make_safe(obj));\n        continue;\n      } else if (length == 0) {\n        state->inferred_shape.AddDim(length);\n        state->inferred_dtype = DT_INVALID;  // Invalid dtype for empty tensors.\n      } else {\n        // The sequence does not have a valid length (PySequence_Length < 0).\n        if (PyErr_Occurred()) {\n          // PySequence_Length failed and set an exception. Fetch the message\n          // and convert it to a failed status.\n          return errors::InvalidArgument(PyExceptionFetch());\n        } else {\n          // This is almost certainly dead code: PySequence_Length failed but\n          // did not set an exception.\n          return errors::InvalidArgument(\n              \"Attempted to convert an invalid sequence to a Tensor.\");\n        }\n      }\n    } else if (IsPyDouble(obj)) {\n      state->inferred_dtype = DT_DOUBLE;\n    } else if (IsNumpyHalf(obj)) {\n      state->inferred_dtype = DT_HALF;\n    } else if (IsPyFloat(obj)) {\n      state->inferred_dtype = DT_FLOAT;\n    } else if (PyBool_Check(obj) || PyIsInstance(obj, &PyBoolArrType_Type)) {\n      // Have to test for bool before int, since IsInt(True/False) == true.\n      state->inferred_dtype = DT_BOOL;\n    } else if (IsPyInt(obj)) {\n      state->inferred_dtype = DT_INT64;\n    } else if (IsPyDimension(obj)) {\n      state->inferred_dtype = DT_INT64;\n    } else if (PyComplex_Check(obj) ||\n               PyIsInstance(obj, &PyComplexFloatingArrType_Type)) {  // NumPy\n      state->inferred_dtype = DT_COMPLEX128;\n    } else {\n      return errors::InvalidArgument(\"Attempt to convert a value (\",\n                                     PyRepr(obj),\n                                     \") with an unsupported type (\",\n                                     PyRepr(PyType(obj)), \") to a Tensor.\");\n    }\n    return Status::OK();\n  }\n}\n\n// Error messages\n\nconst char ErrorConverting[] =\n    \"Error while converting Python sequence to Tensor.\";\nconst char ErrorRectangular[] =\n    \"Can't convert non-rectangular Python sequence to Tensor.\";\nconst char ErrorMixedTypes[] =\n    \"Can't convert Python sequence with mixed types to Tensor.\";\nconst char ErrorOutOfRange[] =\n    \"Can't convert Python sequence with out-of-range integer to Tensor.\";\nconst char ErrorOutOfRangeDouble[] =\n    \"Can't convert Python sequence with a value out of range for a \"\n    \"double-precision float.\";\nconst char ErrorConvertingUnicodeString[] =\n    \"Error converting unicode string while converting Python sequence to \"\n    \"Tensor.\";\nconst char ErrorFoundInt64[] =\n    \"Can't convert Python sequence with out-of-range integer to int32 Tensor.\";\nconst char ErrorFoundFloat[] =\n    \"Can't convert Python sequence with floating point values to integer \"\n    \"Tensor.\";\n\n// Defines a converter that recursively converts an object into\n// an array of type T using the conversion function defined by the\n// traits class in a ConvertScalar function.\n//\n// Note that these helper functions require shape.dims() >= 1.\ntemplate <class T>\nstruct ConverterTraits {\n  static const tensorflow::DataType kTypeEnum;\n  static const char* ConvertScalar(PyObject* v, T* out);\n};\n\ntemplate <class T>\nstruct Converter {\n  static const char* Helper(PyObject* obj, int depth, ConverterState* state,\n                            T** buf) {\n    if (TF_PREDICT_FALSE(obj == nullptr)) {\n      return ErrorConverting;\n    }\n\n    Safe_PyObjectPtr seq = make_safe(PySequence_Fast(obj, \"\"));\n    if (TF_PREDICT_FALSE(seq == nullptr)) return ErrorRectangular;\n\n    const int64 s = state->inferred_shape.dim_size(depth);\n    if (TF_PREDICT_FALSE(s != PySequence_Fast_GET_SIZE(seq.get()))) {\n      return ErrorRectangular;\n    }\n\n    if (state->inferred_shape.dims() - depth > 1) {\n      /* Iterate over outer dim, and recursively convert each element. */\n      for (int64 i = 0; i < s; ++i) {\n        const char* error = Helper(PySequence_Fast_GET_ITEM(seq.get(), i),\n                                   depth + 1, state, buf);\n        if (TF_PREDICT_FALSE(error != nullptr)) return error;\n      }\n    } else {\n      PyObject** l = PySequence_Fast_ITEMS(seq.get());\n      for (int64 i = 0; i < s; ++i) {\n        auto scalar = ZeroDimArrayToScalar(l[i], state);\n        const char* error = ConverterTraits<T>::ConvertScalar(scalar, *buf);\n        Py_DECREF(scalar);\n        if (TF_PREDICT_FALSE(error != nullptr)) return error;\n        ++*buf;\n      }\n    }\n    return nullptr;\n  }\n\n  static const char* Convert(PyObject* obj, ConverterState* state,\n                             Tensor* dest) {\n    /* TODO(josh11b): Allocator & attributes? */\n    Tensor result(ConverterTraits<T>::kTypeEnum, state->inferred_shape);\n    if (state->inferred_shape.dims() == 0) { /* Scalar case */\n      T value;\n      auto scalar = ZeroDimArrayToScalar(obj, state);\n      const char* error = ConverterTraits<T>::ConvertScalar(scalar, &value);\n      Py_DECREF(scalar);\n      if (error != nullptr) return error;\n      result.scalar<T>()() = value;\n    } else {\n      T* buf = result.flat<T>().data();\n      const char* error = Helper(obj, 0, state, &buf);\n      if (error != nullptr) return error;\n    }\n    *dest = result;\n    return nullptr;\n  }\n};\n\n// Int support\n\ntemplate <>\nstruct ConverterTraits<int64> {\n  static const tensorflow::DataType kTypeEnum = DT_INT64;\n\n  static const char* ConvertScalar(PyObject* v, int64* out) {\n#if PY_MAJOR_VERSION < 3\n    if (TF_PREDICT_TRUE(PyInt_Check(v))) {\n      *out = PyInt_AS_LONG(v);\n      return nullptr;\n    }\n#endif\n    if (TF_PREDICT_TRUE(PyLong_Check(v) || IsPyDimension(v))) {\n      int overflow = 0;\n      // Have to use LongLong for 64 bits, since long is 32 bits on Windows.\n      *out = PyLong_AsLongLongAndOverflow(v, &overflow);\n      if (TF_PREDICT_FALSE(overflow)) return ErrorOutOfRange;\n      return nullptr;\n    }\n    if (PyIsInstance(v, &PyIntegerArrType_Type)) {  // NumPy integers\n#if PY_MAJOR_VERSION < 3\n      Safe_PyObjectPtr as_int = make_safe(PyNumber_Int(v));\n#else\n      Safe_PyObjectPtr as_int = make_safe(PyNumber_Long(v));\n#endif\n      return ConvertScalar(as_int.get(), out);\n    }\n    if (IsPyFloat(v)) return ErrorFoundFloat;\n    return ErrorMixedTypes;\n  }\n};\n\ntypedef Converter<int64> Int64Converter;\n\ntemplate <>\nstruct ConverterTraits<uint64> {\n  static const tensorflow::DataType kTypeEnum = DT_UINT64;\n\n  static const char* ConvertScalar(PyObject* v, uint64* out) {\n#if PY_MAJOR_VERSION < 3\n    if (TF_PREDICT_TRUE(PyInt_Check(v))) {\n      *out = PyInt_AsUnsignedLongLongMask(v);\n      return nullptr;\n    }\n#endif\n    if (TF_PREDICT_TRUE(PyLong_Check(v) || IsPyDimension(v))) {\n      *out = PyLong_AsUnsignedLongLong(v);\n      return nullptr;\n    }\n    if (PyIsInstance(v, &PyIntegerArrType_Type)) {  // NumPy integers\n#if PY_MAJOR_VERSION < 3\n      Safe_PyObjectPtr as_int = make_safe(PyNumber_Int(v));\n#else\n      Safe_PyObjectPtr as_int = make_safe(PyNumber_Long(v));\n#endif\n      return ConvertScalar(as_int.get(), out);\n    }\n    if (IsPyFloat(v)) return ErrorFoundFloat;\n    return ErrorMixedTypes;\n  }\n};\n\ntypedef Converter<uint64> UInt64Converter;\n\ntemplate <>\nstruct ConverterTraits<int32> {\n  static const tensorflow::DataType kTypeEnum = DT_INT32;\n\n  static const char* ConvertScalar(PyObject* v, int32* out) {\n    int64 i;\n#if PY_MAJOR_VERSION < 3\n    if (TF_PREDICT_TRUE(PyInt_Check(v))) {\n      i = PyInt_AS_LONG(v);\n    } else\n#endif\n        if (PyLong_Check(v) || IsPyDimension(v)) {\n      int overflow = 0;\n      // Have to use LongLong for 64 bits, since long is 32 bits on Windows.\n      i = PyLong_AsLongLongAndOverflow(v, &overflow);\n      if (TF_PREDICT_FALSE(overflow)) return ErrorOutOfRange;\n    } else if (PyIsInstance(v, &PyIntegerArrType_Type)) {  // NumPy integers\n#if PY_MAJOR_VERSION < 3\n      Safe_PyObjectPtr as_int = make_safe(PyNumber_Int(v));\n#else\n      Safe_PyObjectPtr as_int = make_safe(PyNumber_Long(v));\n#endif\n      return ConvertScalar(as_int.get(), out);\n    } else if (IsPyFloat(v)) {\n      return ErrorFoundFloat;\n    } else {\n      return ErrorMixedTypes;\n    }\n    *out = static_cast<uint32>(static_cast<uint64>(i));\n    // Check for 32-bit overflow.\n    if (TF_PREDICT_FALSE(i != *out)) return ErrorFoundInt64;\n    return nullptr;\n  }\n};\n\ntypedef Converter<int32> Int32Converter;\n\n// Floating-point support\n\ntemplate <class T>\nstatic const char* ConvertOneFloat(PyObject* v, T* out) {\n  if (PyErr_Occurred()) {\n    return nullptr;\n  }\n  if (TF_PREDICT_TRUE(PyFloat_Check(v))) {\n    const double as_double = PyFloat_AS_DOUBLE(v);\n    *out = static_cast<T>(as_double);\n    // Check for overflow\n    if (TF_PREDICT_FALSE(sizeof(T) < sizeof(double) && std::isinf(*out) &&\n                         std::isfinite(as_double))) {\n      return ErrorOutOfRangeDouble;\n    }\n    return nullptr;\n  }\n#if PY_MAJOR_VERSION < 3\n  if (PyInt_Check(v)) {\n    *out = PyInt_AS_LONG(v);\n    return nullptr;\n  }\n#endif\n  if (PyLong_Check(v)) {\n    *out = PyLong_AsDouble(v);\n    if (PyErr_Occurred()) return ErrorOutOfRangeDouble;\n    return nullptr;\n  }\n  if (PyIsInstance(v, &PyFloatingArrType_Type)) {  // NumPy float types\n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_float.get(), out);\n  }\n  if (PyIsInstance(v, &PyIntegerArrType_Type)) {  // NumPy integers\n#if PY_MAJOR_VERSION < 3\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Int(v));\n#else\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Long(v));\n#endif\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_int.get(), out);\n  }\n  return ErrorMixedTypes;\n}\n\ntemplate <>\nstruct ConverterTraits<float> {\n  static const tensorflow::DataType kTypeEnum = DT_FLOAT;\n  static const char* ConvertScalar(PyObject* v, float* out) {\n    return ConvertOneFloat<float>(v, out);\n  }\n};\n\ntemplate <>\nstruct ConverterTraits<double> {\n  static const tensorflow::DataType kTypeEnum = DT_DOUBLE;\n  static const char* ConvertScalar(PyObject* v, double* out) {\n    return ConvertOneFloat<double>(v, out);\n  }\n};\n\ntypedef Converter<double> DoubleConverter;\ntypedef Converter<float> FloatConverter;\n\ntemplate <>\nstruct ConverterTraits<Eigen::half> {\n  static const tensorflow::DataType kTypeEnum = DT_HALF;\n\n  static const char* ConvertScalar(PyObject* v, Eigen::half* out) {\n    // NOTE(nareshmodi): Is there a way to convert to C double without the\n    // intermediate Python double? This will help with ConvertOneFloat as well.\n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    double v_double = PyFloat_AS_DOUBLE(as_float.get());\n    *out = Eigen::half(v_double);\n\n    return nullptr;\n  }\n};\n\ntypedef Converter<Eigen::half> NumpyHalfConverter;\n\n// String support\n\ntemplate <>\nstruct ConverterTraits<tstring> {\n  static const tensorflow::DataType kTypeEnum = DT_STRING;\n\n  static const char* ConvertScalar(PyObject* v, tstring* out) {\n    if (PyBytes_Check(v)) {\n      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));\n      return nullptr;\n    }\n    if (PyUnicode_Check(v)) {\n#if PY_MAJOR_VERSION >= 3\n      Py_ssize_t size;\n      const char* str = PyUnicode_AsUTF8AndSize(v, &size);\n      if (str == nullptr) return ErrorConvertingUnicodeString;\n      out->assign(str, size);\n      return nullptr;\n#else\n      PyObject* py_str = PyUnicode_AsUTF8String(v);\n      if (py_str == nullptr) return ErrorConvertingUnicodeString;\n      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));\n      Py_DECREF(py_str);\n      return nullptr;\n#endif\n    }\n    return ErrorMixedTypes;\n  }\n};\n\ntypedef Converter<tstring> StringConverter;\n\n// Converts Python object `c` that should hold a Python string into a\n// C++ string in *out.  Returns nullptr on success, or a message on error.\n// Defined below, but forward declared here for use in PyRepr.\ntstring PyRepr(PyObject* obj) {\n  if (obj == nullptr) {\n    return \"<null>\";\n  }\n  Safe_PyObjectPtr repr_obj = make_safe(PyObject_Repr(obj));\n  if (repr_obj) {\n    tstring repr_str;\n    if (ConverterTraits<tstring>::ConvertScalar(repr_obj.get(), &repr_str) ==\n        nullptr) {\n      return repr_str;\n    }\n  }\n  return \"<error computing repr()>\";\n}\n\nbool IsPyDimension(PyObject* obj) {\n  const char* tp_name = obj->ob_type->tp_name;\n  if (strcmp(tp_name, \"Dimension\") != 0) return false;\n  bool ret = str_util::EndsWith(\n      PyRepr(PyType(obj)),\n      \"tensorflow.python.framework.tensor_shape.Dimension'>\");\n  return ret;\n}\n\n// Complex support\n\ntemplate <>\nstruct ConverterTraits<complex128> {\n  static const tensorflow::DataType kTypeEnum = DT_COMPLEX128;\n  static const char* ConvertScalar(PyObject* v, complex128* out) {\n    if (PyComplex_Check(v)) {\n      *out = complex128(PyComplex_RealAsDouble(v), PyComplex_ImagAsDouble(v));\n      return nullptr;\n    } else if (PyIsInstance(v, &PyComplexFloatingArrType_Type)) {  // NumPy\n      auto as_complex = PyComplex_AsCComplex(v);\n      *out = complex128(as_complex.real, as_complex.imag);\n      return nullptr;\n    }\n    return ErrorMixedTypes;\n  }\n};\n\ntypedef Converter<complex128> Complex128Converter;\n\n// Bool support\n\ntemplate <>\nstruct ConverterTraits<bool> {\n  typedef bool Type;\n  static const tensorflow::DataType kTypeEnum = DT_BOOL;\n\n  static const char* ConvertScalar(PyObject* v, bool* out) {\n    if (v == Py_True) {\n      *out = true;\n    } else if (v == Py_False) {\n      *out = false;\n    } else if (PyIsInstance(v, &PyBoolArrType_Type)) {  // NumPy\n      *out = PyObject_IsTrue(v);\n    } else {\n      return ErrorMixedTypes;\n    }\n    return nullptr;\n  }\n};\n\ntypedef Converter<bool> BoolConverter;\n\n}  // namespace\n\n#define RETURN_STRING_AS_STATUS(...)                             \\\n  do {                                                           \\\n    const char* _error = (__VA_ARGS__);                          \\\n    if (TF_PREDICT_TRUE(_error == nullptr)) return Status::OK(); \\\n    return errors::InvalidArgument(_error);                      \\\n  } while (0)\n\nStatus PySeqToTensor(PyObject* obj, DataType dtype, Tensor* ret) {\n  ConverterState state;\n  TF_RETURN_IF_ERROR(InferShapeAndType(obj, &state));\n  DataType requested_dtype = DT_INVALID;\n  if (dtype != DT_INVALID) {\n    requested_dtype = dtype;\n  }\n  // NOTE(josh11b): If don't successfully convert to the requested type,\n  // we just try instead to create a tensor of the inferred type and\n  // let the caller convert it to the requested type using a cast\n  // operation.\n  switch (requested_dtype) {\n    case DT_FLOAT:\n      if (FloatConverter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_DOUBLE:\n      if (DoubleConverter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_HALF:\n      RETURN_STRING_AS_STATUS(NumpyHalfConverter::Convert(obj, &state, ret));\n\n    case DT_INT64:\n      if (Int64Converter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_INT32:\n      if (Int32Converter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_UINT64:\n      if (UInt64Converter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_COMPLEX128:\n      if (Complex128Converter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_STRING:\n      if (StringConverter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    case DT_BOOL:\n      if (BoolConverter::Convert(obj, &state, ret) == nullptr)\n        return Status::OK();\n      break;\n\n    default:\n      break;\n  }\n  switch (state.inferred_dtype) {\n    case DT_FLOAT:\n      // TODO(josh11b): Handle mixed floats and complex numbers?\n      if (requested_dtype == DT_INVALID) {\n        // TensorFlow uses float32s to represent floating point numbers\n        // by default (for space and speed over using doubles).\n        RETURN_STRING_AS_STATUS(FloatConverter::Convert(obj, &state, ret));\n      } else {\n        // We are going to do a cast to the user's requested dtype\n        // after this.  We use doubles for this intermediate result so\n        // we don't lose precision that might be representable in the\n        // final type.\n        RETURN_STRING_AS_STATUS(DoubleConverter::Convert(obj, &state, ret));\n      }\n\n    case DT_DOUBLE:\n      RETURN_STRING_AS_STATUS(DoubleConverter::Convert(obj, &state, ret));\n\n    case DT_HALF:\n      RETURN_STRING_AS_STATUS(NumpyHalfConverter::Convert(obj, &state, ret));\n\n    case DT_INT64:\n      if (requested_dtype == DT_INVALID) {\n        const char* error = Int32Converter::Convert(obj, &state, ret);\n        if (error == ErrorFoundInt64) {\n          error = Int64Converter::Convert(obj, &state, ret);\n        }\n        if (error == ErrorFoundFloat) {\n          error = FloatConverter::Convert(obj, &state, ret);\n        }\n        // TODO(josh11b): May also want to fall back to using doubles if\n        // error == ErrorOutOfRange?\n        RETURN_STRING_AS_STATUS(error);\n      } else {\n        const char* error = Int64Converter::Convert(obj, &state, ret);\n        if (error == ErrorFoundFloat) {\n          error = DoubleConverter::Convert(obj, &state, ret);\n        }\n        RETURN_STRING_AS_STATUS(error);\n      }\n\n    case DT_STRING:\n      RETURN_STRING_AS_STATUS(StringConverter::Convert(obj, &state, ret));\n\n    case DT_COMPLEX128:\n      RETURN_STRING_AS_STATUS(Complex128Converter::Convert(obj, &state, ret));\n\n    case DT_BOOL:\n      RETURN_STRING_AS_STATUS(BoolConverter::Convert(obj, &state, ret));\n\n    case DT_INVALID:  // Only occurs for empty tensors.\n      *ret = Tensor(requested_dtype == DT_INVALID ? DT_FLOAT : requested_dtype,\n                    state.inferred_shape);\n      return Status::OK();\n\n    default:\n      return errors::Unimplemented(\"Missing Python -> Tensor conversion for \",\n                                   DataTypeString(state.inferred_dtype));\n  }\n\n  return Status::OK();\n}\n\n}  // namespace tensorflow"