"diff --git a/tensorflow/core/kernels/sparse_cross_op.cc b/tensorflow/core/kernels/sparse_cross_op.cc\nindex 583235b4a30..43b3bedc745 100644\n--- a/tensorflow/core/kernels/sparse_cross_op.cc\n+++ b/tensorflow/core/kernels/sparse_cross_op.cc\n@@ -27,6 +27,7 @@ limitations under the License.\n #include \"tensorflow/core/framework/tensor.h\"\n #include \"tensorflow/core/framework/tensor_shape.h\"\n #include \"tensorflow/core/framework/types.h\"\n+#include \"tensorflow/core/framework/types.pb.h\"\n #include \"tensorflow/core/lib/core/stringpiece.h\"\n #include \"tensorflow/core/lib/strings/str_util.h\"\n #include \"tensorflow/core/platform/fingerprint.h\"\n@@ -460,10 +461,19 @@ int64 CalculateBatchSize(const OpInputList& shapes_list_in,\n Status ValidateInput(const OpInputList& indices_list_in,\n                      const OpInputList& values_list_in,\n                      const OpInputList& shapes_list_in,\n-                     const OpInputList& dense_list_in) {\n+                     const OpInputList& dense_list_in,\n+                     const DataType& internal_type) {\n   const auto size = indices_list_in.size();\n+  // Only perform internal_type check for SparseCrossOp.\n+  // Check if the internal_type is not invalid before doing so.\n+  bool check_type = internal_type != DT_INVALID;\n   // Validates indices_list_in OpInputList.\n   for (int i = 0; i < size; i++) {\n+    if (check_type && indices_list_in[i].dtype() != DT_INT64) {\n+      return errors::InvalidArgument(\"Input indices should be of type \",\n+                                     DT_INT64, \" but received \",\n+                                     indices_list_in[i].dtype());\n+    }\n     if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {\n       return errors::InvalidArgument(\n           \"Input indices should be a matrix but received shape \",\n@@ -482,6 +492,14 @@ Status ValidateInput(const OpInputList& indices_list_in,\n                                    values_list_in.size());\n   }\n   for (int i = 0; i < size; i++) {\n+    // Make sure to avoid the expected type to be string, but input values to be\n+    // int64.\n+    if (check_type && internal_type == DT_STRING &&\n+        values_list_in[i].dtype() == DT_INT64) {\n+      return errors::InvalidArgument(\"Input values should be of internal type \",\n+                                     internal_type, \" but received \",\n+                                     values_list_in[i].dtype());\n+    }\n     if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {\n       return errors::InvalidArgument(\n           \"Input values should be a vector but received shape \",\n@@ -502,6 +520,11 @@ Status ValidateInput(const OpInputList& indices_list_in,\n                                    shapes_list_in.size());\n   }\n   for (int i = 0; i < size; i++) {\n+    if (check_type && shapes_list_in[i].dtype() != DT_INT64) {\n+      return errors::InvalidArgument(\"Input shape should be of type \", DT_INT64,\n+                                     \" but received \",\n+                                     shapes_list_in[i].dtype());\n+    }\n     if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {\n       return errors::InvalidArgument(\n           \"Input shapes should be a vector but received shape \",\n@@ -517,6 +540,14 @@ Status ValidateInput(const OpInputList& indices_list_in,\n \n   // Validates dense_list_in OpInputList\n   for (int i = 0; i < dense_list_in.size(); ++i) {\n+    // Make sure to avoid the expected type to be string, but input values to be\n+    // int64.\n+    if (check_type && internal_type == DT_STRING &&\n+        dense_list_in[i].dtype() == DT_INT64) {\n+      return errors::InvalidArgument(\"Dense inputs should be of internal type \",\n+                                     internal_type, \" but received \",\n+                                     dense_list_in[i].dtype());\n+    }\n     if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {\n       return errors::InvalidArgument(\n           \"Dense inputs should be a matrix but received shape \",\n@@ -698,6 +729,7 @@ class SparseCrossOp : public OpKernel {\n     int64 signed_hash_key_;\n     OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n     hash_key_ = static_cast<uint64>(signed_hash_key_);\n+    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n   }\n \n   void Compute(OpKernelContext* context) override {\n@@ -711,8 +743,10 @@ class SparseCrossOp : public OpKernel {\n     OP_REQUIRES_OK(context,\n                    context->input_list(\"dense_inputs\", &dense_list_in));\n \n-    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n-                                          shapes_list_in, dense_list_in));\n+    DataType internal_type = internal_type_;\n+    OP_REQUIRES_OK(\n+        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n+                               dense_list_in, internal_type));\n \n     std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =\n         GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,\n@@ -756,6 +790,7 @@ class SparseCrossOp : public OpKernel {\n  private:\n   int64 num_buckets_;\n   uint64 hash_key_;\n+  DataType internal_type_;\n };\n \n class SparseCrossV2Op : public OpKernel {\n@@ -773,8 +808,11 @@ class SparseCrossV2Op : public OpKernel {\n     OP_REQUIRES_OK(context,\n                    context->input_list(\"dense_inputs\", &dense_list_in));\n \n-    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n-                                          shapes_list_in, dense_list_in));\n+    // Set internal_type to invalid_type so that the check will be ignored.\n+    DataType internal_type = DT_INVALID;\n+    OP_REQUIRES_OK(\n+        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n+                               dense_list_in, internal_type));\n \n     const Tensor* sep_t;\n     OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));\n@@ -832,8 +870,11 @@ class SparseCrossHashedOp : public OpKernel {\n     OP_REQUIRES_OK(context,\n                    context->input_list(\"dense_inputs\", &dense_list_in));\n \n-    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n-                                          shapes_list_in, dense_list_in));\n+    // Set internal_type to invalid_type so that the check will be ignored.\n+    DataType internal_type = DT_INVALID;\n+    OP_REQUIRES_OK(\n+        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n+                               dense_list_in, internal_type));\n \n     const Tensor* num_buckets_t;\n     OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));"