"diff --git a/tensorflow/core/kernels/quantized_conv_ops.cc b/tensorflow/core/kernels/quantized_conv_ops.cc\nindex a4d36cca3e4..a339de8cfc8 100644\n--- a/tensorflow/core/kernels/quantized_conv_ops.cc\n+++ b/tensorflow/core/kernels/quantized_conv_ops.cc\n@@ -18,6 +18,8 @@ limitations under the License.\n #include <algorithm>\n #include <vector>\n \n+#include \"tensorflow/core/platform/errors.h\"\n+\n #define EIGEN_USE_THREADS\n \n #define GEMMLOWP_ALLOW_SLOW_SCALAR_FALLBACK\n@@ -227,8 +229,12 @@ class Im2ColConvFunctor {\n       return;\n     }\n \n-    CHECK_GT(output_width, 0);\n-    CHECK_GT(output_height, 0);\n+    OP_REQUIRES(\n+        context, output_width > 0,\n+        errors::InvalidArgument(\"output_width must be strictly positive\"));\n+    OP_REQUIRES(\n+        context, output_height > 0,\n+        errors::InvalidArgument(\"output_height must be strictly positive\"));\n     int filter_left_offset;\n     int filter_top_offset;\n     if (padding == VALID) {\n@@ -255,6 +261,9 @@ class Im2ColConvFunctor {\n     // by the width, then the height. This is the standard memory order in the\n     // image world if it helps to visualize it.\n     const int filter_value_count = filter_width * filter_height * input_depth;\n+    OP_REQUIRES(context, filter_value_count > 0,\n+                errors::InvalidArgument(\n+                    \"filter patch must contain at least one element\"));\n     const int64 patches_per_chunk =\n         kMaxChunkSize / (filter_value_count * sizeof(T1));\n     const int64 chunk_value_count ="