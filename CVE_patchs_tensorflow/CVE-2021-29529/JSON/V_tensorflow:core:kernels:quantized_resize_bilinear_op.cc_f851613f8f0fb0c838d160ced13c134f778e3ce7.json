"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Implements a quantized version of the resize bilinear op.\n\n#define EIGEN_USE_THREADS\n\n#if defined(__ARM_NEON__) || defined(__ARM_NEON)\n#define USE_NEON\n#define QUANTIZED_RESIZE_BILINEAR_USE_NEON\n#include <arm_neon.h>\n#endif\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/quantization_utils.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/util/image_resizer_state.h\"\n\nnamespace tensorflow {\n\nstatic constexpr bool USE_REFERENCE = false;\n\nnamespace {\n// Compute the interpolation indices only once.\ntemplate <typename T_SCALE>\nstruct InterpolationCache {\n  std::vector<int64> lower;  // Lower source index used in the interpolation\n  std::vector<int64> upper;  // Upper source index used in the interpolation\n  // 1-D linear interpolation scale (see:\n  // https://en.wikipedia.org/wiki/Bilinear_interpolation)\n  std::vector<float> lerp;\n  std::vector<T_SCALE> ilerp;\n};\n\ntemplate <typename T_SCALE, typename Scaler>\ninline void ComputeInterpolationWeights(\n    const int64 out_size, const int64 in_size, const float scale,\n    const int resolution, InterpolationCache<T_SCALE>* interpolation) {\n  const Scaler scaler;\n  interpolation->lower.resize(out_size + 1);\n  interpolation->upper.resize(out_size + 1);\n  interpolation->lerp.resize(out_size + 1);\n  interpolation->ilerp.resize(out_size + 1);\n\n  interpolation->lower[out_size] = 0;\n  interpolation->upper[out_size] = 0;\n  for (int64 i = out_size - 1; i >= 0; --i) {\n    const float in = scaler(i, scale);\n    const float in_f = std::floor(in);\n    interpolation->lower[i] =\n        std::max(static_cast<int64>(in_f), static_cast<int64>(0));\n    interpolation->upper[i] =\n        std::min(static_cast<int64>(std::ceil(in)), in_size - 1);\n    interpolation->lerp[i] = in - in_f;\n    interpolation->ilerp[i] =\n        static_cast<T_SCALE>((in - in_f) * (1 << resolution));\n  }\n}\n\ntemplate <typename T_SCALE>\ninline InterpolationCache<T_SCALE> BuildLerpCache(\n    const int64 out_size, const int64 in_size, const float scale,\n    const int index_step, const int resolution, const bool half_pixel_centers) {\n  InterpolationCache<T_SCALE> cache;\n  // Compute the cached interpolation weights on the x and y dimensions.\n  if (half_pixel_centers) {\n    ComputeInterpolationWeights<T_SCALE, HalfPixelScaler>(\n        out_size, in_size, scale, resolution, &cache);\n  } else {\n    ComputeInterpolationWeights<T_SCALE, LegacyScaler>(out_size, in_size, scale,\n                                                       resolution, &cache);\n  }\n  CHECK(index_step > 0);\n  if (index_step > 1) {\n    for (int i = 0; i < cache.lower.size(); ++i) {\n      cache.lower[i] *= index_step;\n      cache.upper[i] *= index_step;\n    }\n  }\n  return cache;\n}\n\n/**\n * Computes the bilinear interpolation from the appropriate 4 float points\n * and the linear interpolation weights.\n */\ntemplate <typename T>\ninline T ComputeLerpReference(const T in_top_left, const T in_top_right,\n                              const T in_bottom_left, const T in_bottom_right,\n                              const float x_lerp, const float y_lerp,\n                              const float min, const float max) {\n  const float top_left = QuantizedToFloat<T>(in_top_left, min, max);\n  const float top_right = QuantizedToFloat<T>(in_top_right, min, max);\n  const float bottom_left = QuantizedToFloat<T>(in_bottom_left, min, max);\n  const float bottom_right = QuantizedToFloat<T>(in_bottom_right, min, max);\n  const float top = top_left + (top_right - top_left) * x_lerp;\n  const float bottom = bottom_left + (bottom_right - bottom_left) * x_lerp;\n  const float out = top + (bottom - top) * y_lerp;\n  return FloatToQuantized<T>(out, min, max);\n}\n\ntemplate <typename T, typename T_SCALE, typename T_CALC>\ninline T_CALC MulOffset(T a, T b, T_SCALE c) {\n  return (static_cast<T_CALC>(a) - static_cast<T_CALC>(b)) *\n         static_cast<T_CALC>(c);\n}\n\ntemplate <int RESOLUTION, typename T, typename T_SCALE, typename T_CALC>\ninline T ComputeLerp(const T top_left, const T top_right, const T bottom_left,\n                     const T bottom_right, const T_SCALE x_lerp,\n                     const T_SCALE y_lerp) {\n  constexpr T_CALC RESOLUTION_MULT = (1 << RESOLUTION);\n  const T_CALC top = static_cast<T_CALC>(top_left) * RESOLUTION_MULT +\n                     MulOffset<T, T_SCALE, T_CALC>(top_right, top_left, x_lerp);\n  const T_CALC bottom =\n      static_cast<T_CALC>(bottom_left) * RESOLUTION_MULT +\n      MulOffset<T, T_SCALE, T_CALC>(bottom_right, bottom_left, x_lerp);\n  const T_CALC out = top + (bottom - top) / RESOLUTION_MULT * y_lerp;\n  return static_cast<T>(\n      static_cast<int32>((out + RESOLUTION_MULT / 2) / RESOLUTION_MULT));\n}\n\n#ifdef QUANTIZED_RESIZE_BILINEAR_USE_NEON\ninline uint8x8_t ToUint8x8(const quint8* v0, const quint8* v1, const quint8* v2,\n                           const quint8* v3, const quint8* v4, const quint8* v5,\n                           const quint8* v6, const quint8* v7) {\n  static const uint8x8_t ZERO_8x8 = vmov_n_u8(0);\n  uint8x8_t ret = vld1_lane_u8(reinterpret_cast<const uint8*>(v0), ZERO_8x8, 0);\n  ret = vld1_lane_u8(reinterpret_cast<const uint8*>(v1), ret, 1);\n  ret = vld1_lane_u8(reinterpret_cast<const uint8*>(v2), ret, 2);\n  ret = vld1_lane_u8(reinterpret_cast<const uint8*>(v3), ret, 3);\n  ret = vld1_lane_u8(reinterpret_cast<const uint8*>(v4), ret, 4);\n  ret = vld1_lane_u8(reinterpret_cast<const uint8*>(v5), ret, 5);\n  ret = vld1_lane_u8(reinterpret_cast<const uint8*>(v6), ret, 6);\n  ret = vld1_lane_u8(reinterpret_cast<const uint8*>(v7), ret, 7);\n  return ret;\n}\n\ninline int16x8_t ToInt16x8(const int16* v0, const int16* v1, const int16* v2,\n                           const int16* v3, const int16* v4, const int16* v5,\n                           const int16* v6, const int16* v7) {\n  static const int16x8_t ZERO_16x8 = vmovq_n_s16(0);\n  int16x8_t ret = vld1q_lane_s16(v0, ZERO_16x8, 0);\n  ret = vld1q_lane_s16(v1, ret, 1);\n  ret = vld1q_lane_s16(v2, ret, 2);\n  ret = vld1q_lane_s16(v3, ret, 3);\n  ret = vld1q_lane_s16(v4, ret, 4);\n  ret = vld1q_lane_s16(v5, ret, 5);\n  ret = vld1q_lane_s16(v6, ret, 6);\n  ret = vld1q_lane_s16(v7, ret, 7);\n  return ret;\n}\n\ninline int32x2_t ToInt32x2(const qint32* v0, const qint32* v1) {\n  static const int32x2_t ZERO_32x2 = vmov_n_s32(0);\n  const int32x2_t ret0 =\n      vld1_lane_s32(reinterpret_cast<const int32*>(v0), ZERO_32x2, 0);\n  const int32x2_t ret1 =\n      vld1_lane_s32(reinterpret_cast<const int32*>(v1), ret0, 1);\n  return ret1;\n}\n\ntemplate <int RESOLUTION, bool X_LERP_SAME>\ninline int32x2_t ComputeLerpx2(\n    const qint32* top_left0, const qint32* top_right0,\n    const qint32* bottom_left0, const qint32* bottom_right0,\n    const qint32* top_left1, const qint32* top_right1,\n    const qint32* bottom_left1, const qint32* bottom_right1,\n    const int32* x_lerp, const int32x2_t y_lerpsx) {\n  const int32x2_t x_lerpsx =\n      X_LERP_SAME ? vld1_dup_s32(reinterpret_cast<const int32*>(x_lerp))\n                  : vld1_s32(reinterpret_cast<const int32*>(x_lerp));\n\n  const int32x2_t top_leftsx = ToInt32x2(top_left0, top_left1);\n  const int32x2_t top_rightsx = ToInt32x2(top_right0, top_right1);\n  const int32x2_t bottom_leftsx = ToInt32x2(bottom_left0, bottom_left1);\n  const int32x2_t bottom_rightsx = ToInt32x2(bottom_right0, bottom_right1);\n\n  const int32x2_t retval =\n      ComputeLerp32x2<RESOLUTION>(top_leftsx, top_rightsx, bottom_leftsx,\n                                  bottom_rightsx, x_lerpsx, y_lerpsx);\n  return retval;\n}\n\ntemplate <int RESOLUTION>\ninline uint8x8_t ComputeLerpx8(\n    const quint8* tl0, const quint8* tr0, const quint8* bl0, const quint8* br0,\n    const int16* xlp0, const quint8* tl1, const quint8* tr1, const quint8* bl1,\n    const quint8* br1, const int16* xlp1, const quint8* tl2, const quint8* tr2,\n    const quint8* bl2, const quint8* br2, const int16* xlp2, const quint8* tl3,\n    const quint8* tr3, const quint8* bl3, const quint8* br3, const int16* xlp3,\n    const quint8* tl4, const quint8* tr4, const quint8* bl4, const quint8* br4,\n    const int16* xlp4, const quint8* tl5, const quint8* tr5, const quint8* bl5,\n    const quint8* br5, const int16* xlp5, const quint8* tl6, const quint8* tr6,\n    const quint8* bl6, const quint8* br6, const int16* xlp6, const quint8* tl7,\n    const quint8* tr7, const quint8* bl7, const quint8* br7, const int16* xlp7,\n    const int16x8_t ys_lerpsx) {\n  const uint8x8_t tl8x8 = ToUint8x8(tl0, tl1, tl2, tl3, tl4, tl5, tl6, tl7);\n  const uint8x8_t tr8x8 = ToUint8x8(tr0, tr1, tr2, tr3, tr4, tr5, tr6, tr7);\n  const uint8x8_t bl8x8 = ToUint8x8(bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7);\n  const uint8x8_t br8x8 = ToUint8x8(br0, br1, br2, br3, br4, br5, br6, br7);\n  const int16x8_t xs_lerpsx =\n      ToInt16x8(xlp0, xlp1, xlp2, xlp3, xlp4, xlp5, xlp6, xlp7);\n  return ComputeLerp8x8<RESOLUTION>(tl8x8, tr8x8, bl8x8, br8x8, xs_lerpsx,\n                                    ys_lerpsx);\n}\n\n// Expand address at compile time to improve performance\ntemplate <int RESOLUTION, int ID0, int CH0, int ID1, int CH1, int ID2, int CH2,\n          int ID3, int CH3, int ID4, int CH4, int ID5, int CH5, int ID6,\n          int CH6, int ID7, int CH7>\ninline uint8x8_t ComputeLerpx8Tmpl(const quint8* const yl, const quint8* yu,\n                                   const int64* xl, const int64* xu,\n                                   const int16* xlp,\n                                   const int16x8_t ys_lerpsx) {\n  return ComputeLerpx8<RESOLUTION>(\n      yl + xl[ID0] + CH0, yl + xu[ID0] + CH0, yu + xl[ID0] + CH0,\n      yu + xu[ID0] + CH0, xlp + ID0, yl + xl[ID1] + CH1, yl + xu[ID1] + CH1,\n      yu + xl[ID1] + CH1, yu + xu[ID1] + CH1, xlp + ID1, yl + xl[ID2] + CH2,\n      yl + xu[ID2] + CH2, yu + xl[ID2] + CH2, yu + xu[ID2] + CH2, xlp + ID2,\n      yl + xl[ID3] + CH3, yl + xu[ID3] + CH3, yu + xl[ID3] + CH3,\n      yu + xu[ID3] + CH3, xlp + ID3, yl + xl[ID4] + CH4, yl + xu[ID4] + CH4,\n      yu + xl[ID4] + CH4, yu + xu[ID4] + CH4, xlp + ID4, yl + xl[ID5] + CH5,\n      yl + xu[ID5] + CH5, yu + xl[ID5] + CH5, yu + xu[ID5] + CH5, xlp + ID5,\n      yl + xl[ID6] + CH6, yl + xu[ID6] + CH6, yu + xl[ID6] + CH6,\n      yu + xu[ID6] + CH6, xlp + ID6, yl + xl[ID7] + CH7, yl + xu[ID7] + CH7,\n      yu + xl[ID7] + CH7, yu + xu[ID7] + CH7, xlp + ID7, ys_lerpsx);\n}\n\n#endif\n\ntemplate <int RESOLUTION, typename T, typename T_SCALE, typename T_CALC>\ninline void OutputLerpForChannels(const InterpolationCache<T_SCALE>& xs,\n                                  const int64 x, const T_SCALE ys_ilerp,\n                                  const int channels, const float min,\n                                  const float max, const T* ys_input_lower_ptr,\n                                  const T* ys_input_upper_ptr,\n                                  T* output_y_ptr) {\n  const int64 xs_lower = xs.lower[x];\n  const int64 xs_upper = xs.upper[x];\n  const T_SCALE xs_ilerp = xs.ilerp[x];\n  for (int c = 0; c < channels; ++c) {\n    const T top_left = ys_input_lower_ptr[xs_lower + c];\n    const T top_right = ys_input_lower_ptr[xs_upper + c];\n    const T bottom_left = ys_input_upper_ptr[xs_lower + c];\n    const T bottom_right = ys_input_upper_ptr[xs_upper + c];\n    const T val = ComputeLerp<RESOLUTION, T, T_SCALE, T_CALC>(\n        top_left, top_right, bottom_left, bottom_right, xs_ilerp, ys_ilerp);\n    output_y_ptr[x * channels + c] = val;\n  }\n}\n\ntemplate <int RES>\ninline void OutputLerp8x8x1(const InterpolationCache<int16>& xs,\n                            const int64 x_start, const int16 ys_ilerp,\n                            const float min, const float max,\n                            const quint8* const ys_input_lower_ptr,\n                            const quint8* const ys_input_upper_ptr,\n                            quint8* output_y_ptr) {\n#ifdef QUANTIZED_RESIZE_BILINEAR_USE_NEON\n  const int16x8_t y_lerpsx = vmovq_n_s16(ys_ilerp);\n\n  const uint8x8_t x0x7 =\n      ComputeLerpx8Tmpl<RES, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0>(\n          ys_input_lower_ptr, ys_input_upper_ptr, &xs.lower[x_start],\n          &xs.upper[x_start], &xs.ilerp[x_start], y_lerpsx);\n\n  vst1_u8(reinterpret_cast<uint8_t*>(output_y_ptr + x_start), x0x7);\n\n#else\n  for (int x = x_start; x < x_start + 8; ++x) {\n    OutputLerpForChannels<RES, quint8, int16, int16>(\n        xs, x, ys_ilerp, 1, min, max, ys_input_lower_ptr, ys_input_upper_ptr,\n        output_y_ptr);\n  }\n#endif\n}\n\ntemplate <int RES>\ninline void OutputLerp8x8x3(const InterpolationCache<int16>& xs,\n                            const int64 x_start, const int16 ys_ilerp,\n                            const float min, const float max,\n                            const quint8* const ys_input_lower_ptr,\n                            const quint8* const ys_input_upper_ptr,\n                            quint8* output_y_ptr) {\n#ifdef QUANTIZED_RESIZE_BILINEAR_USE_NEON\n  const int16x8_t y_lerpsx = vmovq_n_s16(ys_ilerp);\n\n  const uint8x8_t x0c0x2c1 =\n      ComputeLerpx8Tmpl<RES, 0, 0, 0, 1, 0, 2, 1, 0, 1, 1, 1, 2, 2, 0, 2, 1>(\n          ys_input_lower_ptr, ys_input_upper_ptr, &xs.lower[x_start],\n          &xs.upper[x_start], &xs.ilerp[x_start], y_lerpsx);\n\n  vst1_u8(reinterpret_cast<uint8_t*>(output_y_ptr + x_start * 3), x0c0x2c1);\n\n  const uint8x8_t x2c2x5c0 =\n      ComputeLerpx8Tmpl<RES, 2, 2, 3, 0, 3, 1, 3, 2, 4, 0, 4, 1, 4, 2, 5, 0>(\n          ys_input_lower_ptr, ys_input_upper_ptr, &xs.lower[x_start],\n          &xs.upper[x_start], &xs.ilerp[x_start], y_lerpsx);\n\n  vst1_u8(reinterpret_cast<uint8_t*>(output_y_ptr + x_start * 3 + 8), x2c2x5c0);\n\n  const uint8x8_t x5c1x7c2 =\n      ComputeLerpx8Tmpl<RES, 5, 1, 5, 2, 6, 0, 6, 1, 6, 2, 7, 0, 7, 1, 7, 2>(\n          ys_input_lower_ptr, ys_input_upper_ptr, &xs.lower[x_start],\n          &xs.upper[x_start], &xs.ilerp[x_start], y_lerpsx);\n\n  vst1_u8(reinterpret_cast<uint8_t*>(output_y_ptr + x_start * 3 + 16),\n          x5c1x7c2);\n\n#else\n  for (int x = x_start; x < x_start + 8; ++x) {\n    OutputLerpForChannels<RES, quint8, int16, int16>(\n        xs, x, ys_ilerp, 3, min, max, ys_input_lower_ptr, ys_input_upper_ptr,\n        output_y_ptr);\n  }\n#endif\n}\n\ntemplate <int RESOLUTION>\ninline void OutputLerp32x4x1(const InterpolationCache<int32>& xs,\n                             const int64 x_start, const int32 ys_ilerp,\n                             const float min, const float max,\n                             const qint32* const ys_input_lower_ptr,\n                             const qint32* const ys_input_upper_ptr,\n                             qint32* output_y_ptr) {\n#ifdef QUANTIZED_RESIZE_BILINEAR_USE_NEON\n  const int64 xs_lower0 = xs.lower[x_start];\n  const int64 xs_upper0 = xs.upper[x_start];\n  const int32* const xs_ilerp0 = &xs.ilerp[x_start];\n  const int64 xs_lower1 = xs.lower[x_start + 1];\n  const int64 xs_upper1 = xs.upper[x_start + 1];\n  const int64 xs_lower2 = xs.lower[x_start + 2];\n  const int64 xs_upper2 = xs.upper[x_start + 2];\n  const int32* const xs_ilerp2 = &xs.ilerp[x_start + 2];\n  const int64 xs_lower3 = xs.lower[x_start + 3];\n  const int64 xs_upper3 = xs.upper[x_start + 3];\n\n  const int32x2_t y_lerpsx = vmov_n_s32(ys_ilerp);\n\n  const int32x2_t x0x1 = ComputeLerpx2<RESOLUTION, false>(\n      ys_input_lower_ptr + xs_lower0, ys_input_lower_ptr + xs_upper0,\n      ys_input_upper_ptr + xs_lower0, ys_input_upper_ptr + xs_upper0,\n      ys_input_lower_ptr + xs_lower1, ys_input_lower_ptr + xs_upper1,\n      ys_input_upper_ptr + xs_lower1, ys_input_upper_ptr + xs_upper1, xs_ilerp0,\n      y_lerpsx);\n\n  const int32x2_t x1x2 = ComputeLerpx2<RESOLUTION, false>(\n      ys_input_lower_ptr + xs_lower2, ys_input_lower_ptr + xs_upper2,\n      ys_input_upper_ptr + xs_lower2, ys_input_upper_ptr + xs_upper2,\n      ys_input_lower_ptr + xs_lower3, ys_input_lower_ptr + xs_upper3,\n      ys_input_upper_ptr + xs_lower3, ys_input_upper_ptr + xs_upper3, xs_ilerp2,\n      y_lerpsx);\n\n  const int32x4_t x0x1x2x3 = vcombine_s32(x0x1, x1x2);\n\n  vst1q_s32(reinterpret_cast<int32*>(output_y_ptr + x_start), x0x1x2x3);\n\n#else\n  for (int x = x_start; x < x_start + 4; ++x) {\n    OutputLerpForChannels<RESOLUTION, qint32, int32, int64>(\n        xs, x, ys_ilerp, 1, min, max, ys_input_lower_ptr, ys_input_upper_ptr,\n        output_y_ptr);\n  }\n#endif\n}\n\ntemplate <int RESOLUTION>\ninline void OutputLerp32x4x3(const InterpolationCache<int32>& xs,\n                             const int64 x_start, const int32 ys_ilerp,\n                             const float min, const float max,\n                             const qint32* const ys_input_lower_ptr,\n                             const qint32* const ys_input_upper_ptr,\n                             qint32* output_y_ptr) {\n#ifdef QUANTIZED_RESIZE_BILINEAR_USE_NEON\n  const int64 xs_lower0 = xs.lower[x_start];\n  const int64 xs_upper0 = xs.upper[x_start];\n  const int32* const xs_ilerp0 = &xs.ilerp[x_start];\n  const int64 xs_lower1 = xs.lower[x_start + 1];\n  const int64 xs_upper1 = xs.upper[x_start + 1];\n  const int32* const xs_ilerp1 = &xs.ilerp[x_start + 1];\n  const int64 xs_lower2 = xs.lower[x_start + 2];\n  const int64 xs_upper2 = xs.upper[x_start + 2];\n  const int32* const xs_ilerp2 = &xs.ilerp[x_start + 2];\n  const int64 xs_lower3 = xs.lower[x_start + 3];\n  const int64 xs_upper3 = xs.upper[x_start + 3];\n  const int32* const xs_ilerp3 = &xs.ilerp[x_start + 3];\n\n  const int32x2_t y_lerpsx = vmov_n_s32(ys_ilerp);\n\n  const int32x2_t x0c0x0c1 = ComputeLerpx2<RESOLUTION, true>(\n      ys_input_lower_ptr + xs_lower0, ys_input_lower_ptr + xs_upper0,\n      ys_input_upper_ptr + xs_lower0, ys_input_upper_ptr + xs_upper0,\n      ys_input_lower_ptr + xs_lower0 + 1, ys_input_lower_ptr + xs_upper0 + 1,\n      ys_input_upper_ptr + xs_lower0 + 1, ys_input_upper_ptr + xs_upper0 + 1,\n      xs_ilerp0, y_lerpsx);\n\n  const int32x2_t x0c2x1c0 = ComputeLerpx2<RESOLUTION, false>(\n      ys_input_lower_ptr + xs_lower0 + 2, ys_input_lower_ptr + xs_upper0 + 2,\n      ys_input_upper_ptr + xs_lower0 + 2, ys_input_upper_ptr + xs_upper0 + 2,\n      ys_input_lower_ptr + xs_lower1, ys_input_lower_ptr + xs_upper1,\n      ys_input_upper_ptr + xs_lower1, ys_input_upper_ptr + xs_upper1, xs_ilerp0,\n      y_lerpsx);\n\n  const int32x2_t x1c1x1c2 = ComputeLerpx2<RESOLUTION, true>(\n      ys_input_lower_ptr + xs_lower1 + 1, ys_input_lower_ptr + xs_upper1 + 1,\n      ys_input_upper_ptr + xs_lower1 + 1, ys_input_upper_ptr + xs_upper1 + 1,\n      ys_input_lower_ptr + xs_lower1 + 2, ys_input_lower_ptr + xs_upper1 + 2,\n      ys_input_upper_ptr + xs_lower1 + 2, ys_input_upper_ptr + xs_upper1 + 2,\n      xs_ilerp1, y_lerpsx);\n\n  const int32x2_t x2c0x2c1 = ComputeLerpx2<RESOLUTION, true>(\n      ys_input_lower_ptr + xs_lower2, ys_input_lower_ptr + xs_upper2,\n      ys_input_upper_ptr + xs_lower2, ys_input_upper_ptr + xs_upper2,\n      ys_input_lower_ptr + xs_lower2 + 1, ys_input_lower_ptr + xs_upper2 + 1,\n      ys_input_upper_ptr + xs_lower2 + 1, ys_input_upper_ptr + xs_upper2 + 1,\n      xs_ilerp2, y_lerpsx);\n\n  const int32x2_t x2c2x3c0 = ComputeLerpx2<RESOLUTION, false>(\n      ys_input_lower_ptr + xs_lower2 + 2, ys_input_lower_ptr + xs_upper2 + 2,\n      ys_input_upper_ptr + xs_lower2 + 2, ys_input_upper_ptr + xs_upper2 + 2,\n      ys_input_lower_ptr + xs_lower3, ys_input_lower_ptr + xs_upper3,\n      ys_input_upper_ptr + xs_lower3, ys_input_upper_ptr + xs_upper3, xs_ilerp2,\n      y_lerpsx);\n\n  const int32x2_t x3c1x3c2 = ComputeLerpx2<RESOLUTION, true>(\n      ys_input_lower_ptr + xs_lower3 + 1, ys_input_lower_ptr + xs_upper3 + 1,\n      ys_input_upper_ptr + xs_lower3 + 1, ys_input_upper_ptr + xs_upper3 + 1,\n      ys_input_lower_ptr + xs_lower3 + 2, ys_input_lower_ptr + xs_upper3 + 2,\n      ys_input_upper_ptr + xs_lower3 + 2, ys_input_upper_ptr + xs_upper3 + 2,\n      xs_ilerp3, y_lerpsx);\n\n  const int32x4_t x0c0x0c1x0c2x1c0 = vcombine_s32(x0c0x0c1, x0c2x1c0);\n  const int32x4_t x1c1x1c2x2c0x2c1 = vcombine_s32(x1c1x1c2, x2c0x2c1);\n  const int32x4_t x2c2x3c0x3c1x3c2 = vcombine_s32(x2c2x3c0, x3c1x3c2);\n\n  vst1q_s32(reinterpret_cast<int32*>(output_y_ptr + x_start * 3),\n            x0c0x0c1x0c2x1c0);\n  vst1q_s32(reinterpret_cast<int32*>(output_y_ptr + x_start * 3 + 4),\n            x1c1x1c2x2c0x2c1);\n  vst1q_s32(reinterpret_cast<int32*>(output_y_ptr + x_start * 3 + 8),\n            x2c2x3c0x3c1x3c2);\n\n#else\n  for (int x = x_start; x < x_start + 4; ++x) {\n    OutputLerpForChannels<RESOLUTION, qint32, int32, int64>(\n        xs, x, ys_ilerp, 3, min, max, ys_input_lower_ptr, ys_input_upper_ptr,\n        output_y_ptr);\n  }\n#endif\n}\n\ntemplate <typename T>\nvoid ResizeImageReference(typename TTypes<T, 4>::ConstTensor images,\n                          const int batch_size, const int64 in_height,\n                          const int64 in_width, const int64 out_height,\n                          const int64 out_width, const int channels,\n                          const float height_scale, const float width_scale,\n                          const float in_min, const float in_max,\n                          const bool half_pixel_centers,\n                          typename TTypes<T, 4>::Tensor* output) {\n  CHECK_NOTNULL(output);\n\n  const InterpolationCache<float> xs = BuildLerpCache<float>(\n      out_width, in_width, width_scale, channels, 0, half_pixel_centers);\n  const InterpolationCache<float> ys = BuildLerpCache<float>(\n      out_height, in_height, height_scale, 1, 0, half_pixel_centers);\n\n  const int64 in_row_size = in_width * channels;\n  const int64 in_batch_num_values = in_height * in_row_size;\n  const int64 out_row_size = out_width * channels;\n\n  const T* input_b_ptr = images.data();\n\n  T* output_y_ptr = output->data();\n  for (int b = 0; b < batch_size; ++b) {\n    for (int64 y = 0; y < out_height; ++y) {\n      const T* ys_input_lower_ptr = input_b_ptr + ys.lower[y] * in_row_size;\n      const T* ys_input_upper_ptr = input_b_ptr + ys.upper[y] * in_row_size;\n      const float ys_lerp = ys.lerp[y];\n      for (int64 x = 0; x < out_width; ++x) {\n        const int64 xs_lower = xs.lower[x];\n        const int64 xs_upper = xs.upper[x];\n        const float xs_lerp = xs.lerp[x];\n        for (int c = 0; c < channels; ++c) {\n          const T top_left = ys_input_lower_ptr[xs_lower + c];\n          const T top_right = ys_input_lower_ptr[xs_upper + c];\n          const T bottom_left = ys_input_upper_ptr[xs_lower + c];\n          const T bottom_right = ys_input_upper_ptr[xs_upper + c];\n          const T val = ComputeLerpReference<T>(\n              top_left, top_right, bottom_left, bottom_right, xs_lerp, ys_lerp,\n              in_min, in_max);\n          output_y_ptr[x * channels + c] = val;\n        }\n      }\n      output_y_ptr += out_row_size;\n    }\n    input_b_ptr += in_batch_num_values;\n  }\n}\n\ntemplate <typename T>\nvoid ResizeImage(typename TTypes<T, 4>::ConstTensor images,\n                 const int batch_size, const int64 in_height,\n                 const int64 in_width, const int64 out_height,\n                 const int64 out_width, const int channels,\n                 const float height_scale, const float width_scale,\n                 const float in_min, const float in_max,\n                 const bool half_pixel_centers,\n                 typename TTypes<T, 4>::Tensor* output) {\n  ResizeImageReference<T>(images, batch_size, in_height, in_width, out_height,\n                          out_width, channels, height_scale, width_scale,\n                          in_min, in_max, half_pixel_centers, output);\n}\n\ntemplate <>\nvoid ResizeImage<qint32>(typename TTypes<qint32, 4>::ConstTensor images,\n                         const int batch_size, const int64 in_height,\n                         const int64 in_width, const int64 out_height,\n                         const int64 out_width, const int channels,\n                         const float height_scale, const float width_scale,\n                         const float in_min, const float in_max,\n                         const bool half_pixel_centers,\n                         typename TTypes<qint32, 4>::Tensor* output) {\n  // 30 is maximum resolution for signed int.\n  constexpr int RESOLUTION = 30;\n  constexpr int SIMD_STEP = 4;\n\n  CHECK_NOTNULL(output);\n\n  const InterpolationCache<int32> xs =\n      BuildLerpCache<int32>(out_width, in_width, width_scale, channels,\n                            RESOLUTION, half_pixel_centers);\n  const InterpolationCache<int32> ys = BuildLerpCache<int32>(\n      out_height, in_height, height_scale, 1, RESOLUTION, half_pixel_centers);\n\n  const int64 in_row_size = in_width * channels;\n  const int64 in_batch_num_values = in_height * in_row_size;\n  const int64 out_row_size = out_width * channels;\n\n  const qint32* input_b_ptr = images.data();\n\n  qint32* output_y_ptr = output->data();\n\n  for (int b = 0; b < batch_size; ++b) {\n    for (int64 y = 0; y < out_height; ++y) {\n      const qint32* ys_input_lower_ptr =\n          input_b_ptr + ys.lower[y] * in_row_size;\n      const qint32* ys_input_upper_ptr =\n          input_b_ptr + ys.upper[y] * in_row_size;\n      const int32 ys_ilerp = ys.ilerp[y];\n      // Optimized for channels == 1 or channels == 3 as this\n      // is typical channels.\n      int64 x = 0;\n      if (channels == 1) {\n        for (; x < out_width - SIMD_STEP + 1; x += SIMD_STEP) {\n          OutputLerp32x4x1<RESOLUTION>(xs, x, ys_ilerp, in_min, in_max,\n                                       ys_input_lower_ptr, ys_input_upper_ptr,\n                                       output_y_ptr);\n        }\n      } else if (channels == 3) {\n        for (; x < out_width - SIMD_STEP + 1; x += SIMD_STEP) {\n          OutputLerp32x4x3<RESOLUTION>(xs, x, ys_ilerp, in_min, in_max,\n                                       ys_input_lower_ptr, ys_input_upper_ptr,\n                                       output_y_ptr);\n        }\n      }\n      for (; x < out_width; ++x) {\n        OutputLerpForChannels<RESOLUTION, qint32, int32, int64>(\n            xs, x, ys_ilerp, channels, in_min, in_max, ys_input_lower_ptr,\n            ys_input_upper_ptr, output_y_ptr);\n      }\n      output_y_ptr += out_row_size;\n    }\n    input_b_ptr += in_batch_num_values;\n  }\n}\n\ntemplate <>\nvoid ResizeImage<quint8>(typename TTypes<quint8, 4>::ConstTensor images,\n                         const int batch_size, const int64 in_height,\n                         const int64 in_width, const int64 out_height,\n                         const int64 out_width, const int channels,\n                         const float height_scale, const float width_scale,\n                         const float in_min, const float in_max,\n                         const bool half_pixel_centers,\n                         typename TTypes<quint8, 4>::Tensor* output) {\n  // 7 is maximum resolution for unsigned byte.\n  constexpr int RESOLUTION = 7;\n  constexpr int SIMD_STEP = 8;\n\n  CHECK_NOTNULL(output);\n\n  const InterpolationCache<int16> xs =\n      BuildLerpCache<int16>(out_width, in_width, width_scale, channels,\n                            RESOLUTION, half_pixel_centers);\n  const InterpolationCache<int16> ys = BuildLerpCache<int16>(\n      out_height, in_height, height_scale, 1, RESOLUTION, half_pixel_centers);\n\n  const int64 in_row_size = in_width * channels;\n  const int64 in_batch_num_values = in_height * in_row_size;\n  const int64 out_row_size = out_width * channels;\n\n  const quint8* input_b_ptr = images.data();\n\n  quint8* output_y_ptr = output->data();\n\n  for (int b = 0; b < batch_size; ++b) {\n    for (int64 y = 0; y < out_height; ++y) {\n      const quint8* ys_input_lower_ptr =\n          input_b_ptr + ys.lower[y] * in_row_size;\n      const quint8* ys_input_upper_ptr =\n          input_b_ptr + ys.upper[y] * in_row_size;\n      const int32 ys_ilerp = ys.ilerp[y];\n      // Optimized for channels == 1 or channels == 3 as this\n      // is typical channels.\n      // TODO(satok): Support more generic NEON optimized implementation\n      // for different channels.\n      int64 x = 0;\n      if (channels == 1) {\n        for (; x < out_width - SIMD_STEP + 1; x += SIMD_STEP) {\n          OutputLerp8x8x1<RESOLUTION>(xs, x, ys_ilerp, in_min, in_max,\n                                      ys_input_lower_ptr, ys_input_upper_ptr,\n                                      output_y_ptr);\n        }\n      } else if (channels == 3) {\n        for (; x < out_width - SIMD_STEP + 1; x += SIMD_STEP) {\n          OutputLerp8x8x3<RESOLUTION>(xs, x, ys_ilerp, in_min, in_max,\n                                      ys_input_lower_ptr, ys_input_upper_ptr,\n                                      output_y_ptr);\n        }\n      }\n      for (; x < out_width; ++x) {\n        OutputLerpForChannels<RESOLUTION, quint8, int16, int16>(\n            xs, x, ys_ilerp, channels, in_min, in_max, ys_input_lower_ptr,\n            ys_input_upper_ptr, output_y_ptr);\n      }\n      output_y_ptr += out_row_size;\n    }\n    input_b_ptr += in_batch_num_values;\n  }\n}\n\ntemplate <typename T>\nvoid ResizeBilinear(const typename TTypes<T, 4>::ConstTensor& images,\n                    const float height_scale, const float width_scale,\n                    const float in_min, const float in_max,\n                    const bool half_pixel_centers,\n                    typename TTypes<T, 4>::Tensor* output) {\n  CHECK_NOTNULL(output);\n\n  const int batch_size = images.dimension(0);\n  const int64 in_height = images.dimension(1);\n  const int64 in_width = images.dimension(2);\n  const int channels = images.dimension(3);\n\n  const int64 out_height = output->dimension(1);\n  const int64 out_width = output->dimension(2);\n\n  // Handle no-op resizes efficiently.\n  if (out_height == in_height && out_width == in_width) {\n    *output = images.template cast<T>();\n    return;\n  }\n\n  if (USE_REFERENCE) {\n    ResizeImageReference<T>(images, batch_size, in_height, in_width, out_height,\n                            out_width, channels, height_scale, width_scale,\n                            in_min, in_max, half_pixel_centers, output);\n  } else {\n    ResizeImage<T>(images, batch_size, in_height, in_width, out_height,\n                   out_width, channels, height_scale, width_scale, in_min,\n                   in_max, half_pixel_centers, output);\n  }\n}\n\n}  // namespace\n\ntemplate <class T>\nclass QuantizedResizeBilinearOp : public OpKernel {\n public:\n  explicit QuantizedResizeBilinearOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"align_corners\", &align_corners_));\n    OP_REQUIRES_OK(\n        context, context->GetAttr(\"half_pixel_centers\", &half_pixel_centers_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const float in_min = context->input(2).flat<float>()(0);\n    const float in_max = context->input(3).flat<float>()(0);\n\n    ImageResizerState st(align_corners_, false);\n    st.ValidateAndCreateOutput(context);\n\n    if (!context->status().ok()) return;\n\n    // Return if the output is empty.\n    if (st.output->NumElements() == 0) return;\n\n    typename TTypes<T, 4>::ConstTensor image_data(\n        context->input(0).tensor<T, 4>());\n    typename TTypes<T, 4>::Tensor output_data(st.output->tensor<T, 4>());\n\n    ResizeBilinear<T>(image_data, st.height_scale, st.width_scale, in_min,\n                      in_max, half_pixel_centers_, &output_data);\n    Tensor* out_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &out_min));\n    out_min->flat<float>()(0) = in_min;\n\n    Tensor* out_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &out_max));\n    out_max->flat<float>()(0) = in_max;\n  }\n\n private:\n  bool align_corners_;\n  bool half_pixel_centers_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(QuantizedResizeBilinearOp<T>);\n};\n\n#define REGISTER_CPU_KERNEL(type)                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizedResizeBilinear\") \\\n                              .Device(DEVICE_CPU)         \\\n                              .HostMemory(\"size\")         \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          QuantizedResizeBilinearOp<type>)\n\nREGISTER_CPU_KERNEL(::tensorflow::quint8);\nREGISTER_CPU_KERNEL(::tensorflow::qint32);\nREGISTER_CPU_KERNEL(float);\n\n}  // namespace tensorflow"