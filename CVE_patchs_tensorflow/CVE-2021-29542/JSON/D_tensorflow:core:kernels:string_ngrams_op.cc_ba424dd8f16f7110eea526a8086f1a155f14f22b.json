"diff --git a/tensorflow/core/kernels/string_ngrams_op.cc b/tensorflow/core/kernels/string_ngrams_op.cc\nindex 8aed2b3831a..7008a1d766a 100644\n--- a/tensorflow/core/kernels/string_ngrams_op.cc\n+++ b/tensorflow/core/kernels/string_ngrams_op.cc\n@@ -61,16 +61,28 @@ class StringNGramsOp : public tensorflow::OpKernel {\n     OP_REQUIRES_OK(context, context->input(\"data_splits\", &splits));\n     const auto& splits_vec = splits->flat<SPLITS_TYPE>();\n \n-    // Validate that the splits are valid indices into data\n+    // Validate that the splits are valid indices into data, only if there are\n+    // splits specified.\n     const int input_data_size = data->flat<tstring>().size();\n     const int splits_vec_size = splits_vec.size();\n-    for (int i = 0; i < splits_vec_size; ++i) {\n-      bool valid_splits = splits_vec(i) >= 0;\n-      valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n-      OP_REQUIRES(\n-          context, valid_splits,\n-          errors::InvalidArgument(\"Invalid split value \", splits_vec(i),\n-                                  \", must be in [0,\", input_data_size, \"]\"));\n+    if (splits_vec_size > 0) {\n+      int prev_split = splits_vec(0);\n+      OP_REQUIRES(context, prev_split == 0,\n+                  errors::InvalidArgument(\"First split value must be 0, got \",\n+                                          prev_split));\n+      for (int i = 1; i < splits_vec_size; ++i) {\n+        bool valid_splits = splits_vec(i) >= prev_split;\n+        valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n+        OP_REQUIRES(context, valid_splits,\n+                    errors::InvalidArgument(\n+                        \"Invalid split value \", splits_vec(i), \", must be in [\",\n+                        prev_split, \", \", input_data_size, \"]\"));\n+        prev_split = splits_vec(i);\n+      }\n+      OP_REQUIRES(context, prev_split == input_data_size,\n+                  errors::InvalidArgument(\n+                      \"Last split value must be data size. Expected \",\n+                      input_data_size, \", got \", prev_split));\n     }\n \n     int num_batch_items = splits_vec.size() - 1;\n@@ -174,13 +186,31 @@ class StringNGramsOp : public tensorflow::OpKernel {\n         ngram->append(left_pad_);\n         ngram->append(separator_);\n       }\n+      // Only output first num_tokens - 1 pairs of data and separator\n       for (int n = 0; n < num_tokens - 1; ++n) {\n         ngram->append(data[data_start_index + n]);\n         ngram->append(separator_);\n       }\n-      ngram->append(data[data_start_index + num_tokens - 1]);\n-      for (int n = 0; n < right_padding; ++n) {\n-        ngram->append(separator_);\n+      // Handle case when there are no tokens or no right padding as these can\n+      // result in consecutive separators.\n+      if (num_tokens > 0) {\n+        // If we have tokens, then output last and then pair each separator with\n+        // the right padding that follows, to ensure ngram ends either with the\n+        // token or with the right pad.\n+        ngram->append(data[data_start_index + num_tokens - 1]);\n+        for (int n = 0; n < right_padding; ++n) {\n+          ngram->append(separator_);\n+          ngram->append(right_pad_);\n+        }\n+      } else {\n+        // If we don't have tokens, then the last item inserted into the ngram\n+        // has been the separator from the left padding loop above. Hence,\n+        // output right pad and separator and make sure to finish with a\n+        // padding, not a separator.\n+        for (int n = 0; n < right_padding - 1; ++n) {\n+          ngram->append(right_pad_);\n+          ngram->append(separator_);\n+        }\n         ngram->append(right_pad_);\n       }\n "