"/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include <vector>\n\n#include \"tensorflow/core/framework/fake_input.h\"\n#include \"tensorflow/core/framework/node_def_builder.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n#include \"tensorflow/core/framework/shape_inference_testutil.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_testutil.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/kernels/ops_testutil.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/core/status_test_util.h\"\n\nnamespace tensorflow {\nnamespace text {\n\nusing tensorflow::FakeInput;\nusing tensorflow::NodeDefBuilder;\nusing tensorflow::Status;\nusing tensorflow::TensorShape;\n\nclass NgramKernelTest : public tensorflow::OpsTestBase {\n public:\n  void MakeOp(string separator, std::vector<int> ngram_width, string left_pad,\n              string right_pad, int pad_width, bool preserve) {\n    TF_ASSERT_OK(NodeDefBuilder(\"tested_op\", \"StringNGrams\")\n                     .Attr(\"separator\", separator)\n                     .Attr(\"ngram_widths\", ngram_width)\n                     .Attr(\"left_pad\", left_pad)\n                     .Attr(\"right_pad\", right_pad)\n                     .Attr(\"pad_width\", pad_width)\n                     .Attr(\"preserve_short_sequences\", preserve)\n                     .Input(FakeInput())\n                     .Input(FakeInput())\n                     .Finalize(node_def()));\n    TF_ASSERT_OK(InitOp());\n  }\n\n  void assert_string_equal(const std::vector<tstring> &expected,\n                           const Tensor &value) {\n    Tensor expected_tensor(allocator(), DT_STRING,\n                           TensorShape({static_cast<int64>(expected.size())}));\n    test::FillValues<tstring>(&expected_tensor, expected);\n    test::ExpectTensorEqual<tstring>(expected_tensor, value);\n  }\n  void assert_int64_equal(const std::vector<int64> &expected,\n                          const Tensor &value) {\n    Tensor expected_tensor(allocator(), DT_INT64,\n                           TensorShape({static_cast<int64>(expected.size())}));\n    test::FillValues<int64>(&expected_tensor, expected);\n    test::ExpectTensorEqual<int64>(expected_tensor, value);\n  }\n};\n\nTEST_F(NgramKernelTest, TestPaddedTrigrams) {\n  MakeOp(\"|\", {3}, \"LP\", \"RP\", -1, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(                             //\n      {\"LP|LP|a\", \"LP|a|b\", \"a|b|c\", \"b|c|d\", \"c|d|RP\", \"d|RP|RP\",  // 0\n       \"LP|LP|e\", \"LP|e|f\", \"e|f|RP\", \"f|RP|RP\"});                  // 1\n  std::vector<int64> expected_splits({0, 6, 10});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestPaddedBigramsAndTrigrams) {\n  MakeOp(\"|\", {2, 3}, \"LP\", \"RP\", -1, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(\n      {\"LP|a\", \"a|b\", \"b|c\", \"c|d\", \"d|RP\", \"LP|LP|a\", \"LP|a|b\", \"a|b|c\",\n       \"b|c|d\", \"c|d|RP\", \"d|RP|RP\",                                       // 0\n       \"LP|e\", \"e|f\", \"f|RP\", \"LP|LP|e\", \"LP|e|f\", \"e|f|RP\", \"f|RP|RP\"});  // 1\n  std::vector<int64> expected_splits({0, 11, 18});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestPaddedBigrams) {\n  MakeOp(\"|\", {2}, \"LP\", \"RP\", -1, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(      //\n      {\"LP|a\", \"a|b\", \"b|c\", \"c|d\", \"d|RP\",  // 0\n       \"LP|e\", \"e|f\", \"f|RP\"});              // 1\n  std::vector<int64> expected_splits({0, 5, 8});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestPaddingIsAtMostNGramSizeMinus1) {\n  MakeOp(\"|\", {2}, \"LP\", \"RP\", 4, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(      //\n      {\"LP|a\", \"a|b\", \"b|c\", \"c|d\", \"d|RP\",  // 0\n       \"LP|e\", \"e|f\", \"f|RP\"});              // 1\n  std::vector<int64> expected_splits({0, 5, 8});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestPaddedUnigramAndBigrams) {\n  MakeOp(\"|\", {1, 2}, \"LP\", \"RP\", -1, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(                          //\n      {\"a\", \"b\", \"c\", \"d\", \"LP|a\", \"a|b\", \"b|c\", \"c|d\", \"d|RP\",  // 0\n       \"e\", \"f\", \"LP|e\", \"e|f\", \"f|RP\"});                        // 1\n  std::vector<int64> expected_splits({0, 9, 14});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestOverlappingPaddedNGrams) {\n  // This test validates that n-grams with both left and right padding in a\n  // single ngram token are created correctly.\n  MakeOp(\"|\", {3}, \"LP\", \"RP\", -1, false);\n  // Batch items are:\n  // 0: \"a\"\n  // 1: \"b\", \"c\", \"d\"\n  // 2: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({4}), {0, 1, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(                    //\n      {\"LP|LP|a\", \"LP|a|RP\", \"a|RP|RP\",                    // ngrams for elem. 0\n       \"LP|LP|b\", \"LP|b|c\", \"b|c|d\", \"c|d|RP\", \"d|RP|RP\",  // ngrams for elem. 1\n       \"LP|LP|e\", \"LP|e|f\", \"e|f|RP\", \"f|RP|RP\"});         // ngrams for elem. 2\n  std::vector<int64> expected_splits({0, 3, 8, 12});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestOverlappingPaddedMultiCharNGrams) {\n  MakeOp(\"|\", {3}, \"LP\", \"RP\", -1, false);\n  // Batch items are:\n  // 0: \"a\"\n  // 1: \"b\", \"c\", \"d\"\n  // 2: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}),\n                             {\"aa\", \"bb\", \"cc\", \"dd\", \"ee\", \"ff\"});\n  AddInputFromArray<int64>(TensorShape({4}), {0, 1, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(                             //\n      {\"LP|LP|aa\", \"LP|aa|RP\", \"aa|RP|RP\",                          //\n       \"LP|LP|bb\", \"LP|bb|cc\", \"bb|cc|dd\", \"cc|dd|RP\", \"dd|RP|RP\",  //\n       \"LP|LP|ee\", \"LP|ee|ff\", \"ee|ff|RP\", \"ff|RP|RP\"});            //\n  std::vector<int64> expected_splits({0, 3, 8, 12});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestMultiOverlappingPaddedNGrams) {\n  // This test validates that n-grams with more than 1 padding value on each\n  // side are created correctly.\n  MakeOp(\"|\", {5}, \"LP\", \"RP\", -1, false);\n  // Batch items are:\n  // 0: \"a\"\n  AddInputFromArray<tstring>(TensorShape({1}), {\"a\"});\n  AddInputFromArray<int64>(TensorShape({2}), {0, 1});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"LP|LP|LP|LP|a\", \"LP|LP|LP|a|RP\",\n                                        \"LP|LP|a|RP|RP\", \"LP|a|RP|RP|RP\",\n                                        \"a|RP|RP|RP|RP\"});\n  std::vector<int64> expected_splits({0, 5});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestUnpaddedTrigrams) {\n  MakeOp(\"|\", {3}, \"\", \"\", 0, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"a|b|c\", \"b|c|d\"});\n  std::vector<int64> expected_splits({0, 2, 2});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestUnpaddedTrigramsWithEmptySequence) {\n  MakeOp(\"|\", {3}, \"\", \"\", 0, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({4}), {0, 4, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"a|b|c\", \"b|c|d\"});\n  std::vector<int64> expected_splits({0, 2, 2, 2});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestUnpaddedTrigramsWithPreserveShort) {\n  MakeOp(\"|\", {3}, \"\", \"\", 0, true);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"a|b|c\", \"b|c|d\", \"e|f\"});\n  std::vector<int64> expected_splits({0, 2, 3});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestUnpaddedTrigramsWithPreserveShortAndEmptySequence) {\n  MakeOp(\"|\", {3}, \"\", \"\", 0, true);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({4}), {0, 4, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"a|b|c\", \"b|c|d\", \"e|f\"});\n  std::vector<int64> expected_splits({0, 2, 2, 3});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestUnpaddedTrigramsAndQuadgramsWithPreserveShort) {\n  MakeOp(\"|\", {4, 3}, \"\", \"\", 0, true);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"a|b|c|d\", \"a|b|c\", \"b|c|d\", \"e|f\"});\n  std::vector<int64> expected_splits({0, 3, 4});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestUnpaddedBigramsAndTrigrams) {\n  MakeOp(\"|\", {2, 3}, \"\", \"\", 0, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(\n      {\"a|b\", \"b|c\", \"c|d\", \"a|b|c\", \"b|c|d\", \"e|f\"});\n  std::vector<int64> expected_splits({0, 5, 6});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestUnpaddedBigramsAndTrigramsWithPreserveShort) {\n  MakeOp(\"|\", {2, 3}, \"\", \"\", 0, true);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  // Note that in this case, because the bigram 'e|f' was already generated,\n  // the op will not generate a special preserve_short bigram.\n  std::vector<tstring> expected_values(\n      {\"a|b\", \"b|c\", \"c|d\", \"a|b|c\", \"b|c|d\", \"e|f\"});\n  std::vector<int64> expected_splits({0, 5, 6});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestUnpaddedTrigramsAndBigramsWithPreserveShort) {\n  MakeOp(\"|\", {3, 2}, \"\", \"\", 0, true);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  // Note that in this case, because the bigram 'e|f' was already generated,\n  // the op will not generate a special preserve_short bigram.\n  std::vector<tstring> expected_values(\n      {\"a|b|c\", \"b|c|d\", \"a|b\", \"b|c\", \"c|d\", \"e|f\"});\n  std::vector<int64> expected_splits({0, 5, 6});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestUnpaddedBigrams) {\n  MakeOp(\"|\", {2}, \"\", \"\", 0, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"a|b\", \"b|c\", \"c|d\", \"e|f\"});\n  std::vector<int64> expected_splits({0, 3, 4});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestOverlappingUnpaddedNGrams) {\n  MakeOp(\"|\", {3}, \"\", \"\", 0, false);\n  // Batch items are:\n  // 0: \"a\"\n  // 1: \"b\", \"c\", \"d\"\n  // 2: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({4}), {0, 1, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"b|c|d\"});\n  std::vector<int64> expected_splits({0, 0, 1, 1});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestOverlappingUnpaddedNGramsNoOutput) {\n  MakeOp(\"|\", {5}, \"\", \"\", 0, false);\n  // Batch items are:\n  // 0: \"a\"\n  // 1: \"b\", \"c\", \"d\"\n  // 2: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({4}), {0, 1, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({});\n  std::vector<int64> expected_splits({0, 0, 0, 0});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestSinglyPaddedTrigrams) {\n  MakeOp(\"|\", {3}, \"LP\", \"RP\", 1, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"LP|a|b\", \"a|b|c\", \"b|c|d\",\n                                        \"c|d|RP\",  //\n                                        \"LP|e|f\", \"e|f|RP\"});\n  std::vector<int64> expected_splits({0, 4, 6});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestSinglyPaddedBigrams) {\n  MakeOp(\"|\", {2}, \"LP\", \"RP\", 1, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"LP|a\", \"a|b\", \"b|c\", \"c|d\", \"d|RP\",  //\n                                        \"LP|e\", \"e|f\", \"f|RP\"});\n  std::vector<int64> expected_splits({0, 5, 8});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestSinglyPaddedBigramsAnd5grams) {\n  MakeOp(\"|\", {2, 5}, \"LP\", \"RP\", 1, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(                                  //\n      {\"LP|a\", \"a|b\", \"b|c\", \"c|d\", \"d|RP\", \"LP|a|b|c|d\", \"a|b|c|d|RP\",  //\n       \"LP|e\", \"e|f\", \"f|RP\"});\n  std::vector<int64> expected_splits({0, 7, 10});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestSinglyPadded5gramsWithPreserveShort) {\n  MakeOp(\"|\", {5}, \"LP\", \"RP\", 1, true);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(  //\n      {\"LP|a|b|c|d\", \"a|b|c|d|RP\",       //\n       \"LP|e|f|RP\"});\n  std::vector<int64> expected_splits({0, 2, 3});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestOverlappingSinglyPaddedNGrams) {\n  MakeOp(\"|\", {3}, \"LP\", \"RP\", 1, false);\n  // Batch items are:\n  // 0: \"a\"\n  // 1: \"b\", \"c\", \"d\"\n  // 2: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({4}), {0, 1, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(\n      {\"LP|a|RP\",                    // ngrams for elem. 0\n       \"LP|b|c\", \"b|c|d\", \"c|d|RP\",  // ngrams for elem. 1\n       \"LP|e|f\", \"e|f|RP\"});         // ngrams for elem. 2\n  std::vector<int64> expected_splits({0, 1, 4, 6});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestOverlappingSinglyPaddedNGramsNoOutput) {\n  MakeOp(\"|\", {5}, \"LP\", \"RP\", 1, false);\n  // Batch items are:\n  // 0: \"a\"\n  // 1: \"b\", \"c\", \"d\"\n  // 2: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({4}), {0, 1, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"LP|b|c|d|RP\"});\n  std::vector<int64> expected_splits({0, 0, 1, 1});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestSinglyPaddedUnigrams) {\n  MakeOp(\"|\", {1}, \"LP\", \"RP\", 1, false);\n  // Batch items are:\n  // 0: \"a\", \"b\", \"c\", \"d\"\n  // 1: \"e\", \"f\"\n  AddInputFromArray<tstring>(TensorShape({6}), {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 4, 6});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"});\n  std::vector<int64> expected_splits({0, 4, 6});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestEmptyInput) {\n  MakeOp(\"|\", {1}, \"LP\", \"RP\", 3, false);\n  AddInputFromArray<tstring>(TensorShape({0}), {});\n  AddInputFromArray<int64>(TensorShape({0}), {});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({});\n  std::vector<int64> expected_splits({});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestNoTokens) {\n  MakeOp(\"|\", {3}, \"L\", \"R\", -1, false);\n  // Batch items are:\n  // 0:\n  // 1: \"a\"\n  AddInputFromArray<tstring>(TensorShape({1}), {\"a\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 0, 1});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values(\n      {\"L|L|R\", \"L|R|R\",             // no input in first split\n       \"L|L|a\", \"L|a|R\", \"a|R|R\"});  // second split\n  std::vector<int64> expected_splits({0, 2, 5});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, TestNoTokensNoPad) {\n  MakeOp(\"|\", {3}, \"\", \"\", 0, false);\n  // Batch items are:\n  // 0:\n  // 1: \"a\"\n  AddInputFromArray<tstring>(TensorShape({1}), {\"a\"});\n  AddInputFromArray<int64>(TensorShape({3}), {0, 0, 1});\n  TF_ASSERT_OK(RunOpKernel());\n\n  std::vector<tstring> expected_values({});\n  std::vector<int64> expected_splits({0, 0, 0});\n\n  assert_string_equal(expected_values, *GetOutput(0));\n  assert_int64_equal(expected_splits, *GetOutput(1));\n}\n\nTEST_F(NgramKernelTest, ShapeFn) {\n  ShapeInferenceTestOp op(\"StringNGrams\");\n  INFER_OK(op, \"?;?\", \"[?];[?]\");\n  INFER_OK(op, \"[1];?\", \"[?];[?]\");\n  INFER_OK(op, \"[1];[2]\", \"[?];in1\");\n  INFER_ERROR(\"Shape must be rank 1 but is rank 0\", op, \"[];?\");\n  INFER_ERROR(\"Shape must be rank 1 but is rank 0\", op, \"?;[]\");\n}\n\n}  // namespace text\n}  // namespace tensorflow"