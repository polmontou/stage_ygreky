"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define EIGEN_USE_THREADS\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/kernels/quantization_utils.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\n// A slow but straightforward implementation of batch normalization.\ntemplate <typename T1, typename T2>\nvoid ReferenceBatchNorm(const Tensor& input, const float input_min,\n                        const float input_max, const Tensor& mean,\n                        float mean_min, float mean_max, const Tensor& var,\n                        float var_min, float var_max, const Tensor& beta,\n                        float beta_min, float beta_max, const Tensor& gamma,\n                        float gamma_min, float gamma_max,\n                        float variance_epsilon, bool scale_after_normalization,\n                        Tensor* output, float* output_min, float* output_max) {\n  auto input_flat = input.flat<T1>();\n  auto mean_flat = mean.flat<T1>();\n  auto var_flat = var.flat<T1>();\n  auto beta_flat = beta.flat<T1>();\n  auto gamma_flat = gamma.flat<T1>();\n  auto output_flat = output->flat<T2>();\n\n  const int depth = mean.dim_size(0);\n  const int row_count = input_flat.size() / depth;\n\n  *output_min = std::numeric_limits<float>::max();\n  *output_max = std::numeric_limits<float>::lowest();\n  for (int pass = 0; pass < 2; ++pass) {\n    const bool is_range_pass = (pass == 0);\n    for (int row_index = 0; row_index < row_count; ++row_index) {\n      for (int channel = 0; channel < depth; ++channel) {\n        const int input_index = (row_index * depth) + channel;\n        const float input_value =\n            QuantizedToFloat(input_flat(input_index), input_min, input_max);\n        const float mean_value =\n            QuantizedToFloat(mean_flat(channel), mean_min, mean_max);\n        const float var_value =\n            QuantizedToFloat(var_flat(channel), var_min, var_max);\n        const float beta_value =\n            QuantizedToFloat(beta_flat(channel), beta_min, beta_max);\n        const float gamma_value =\n            QuantizedToFloat(gamma_flat(channel), gamma_min, gamma_max);\n        float output_value;\n        if (scale_after_normalization) {\n          output_value = (((input_value - mean_value) /\n                           sqrtf(var_value + variance_epsilon)) *\n                          gamma_value) +\n                         beta_value;\n        } else {\n          output_value = ((input_value - mean_value) /\n                          sqrtf(var_value + variance_epsilon)) +\n                         beta_value;\n        }\n        if (is_range_pass) {\n          *output_min = std::min(output_value, *output_min);\n          *output_max = std::max(output_value, *output_max);\n        } else {\n          output_flat(input_index) =\n              FloatToQuantized<T2>(output_value, *output_min, *output_max);\n        }\n      }\n    }\n  }\n}\n\n// An implementation of batch normalization that does the main calculations\n// using only fixed-point arithmetic. There's a prologue with some floating\n// calculations, but assuming the weights are constant these could be hoisted to\n// an offline process, or baked into the weights.\ntemplate <typename T1, typename T2>\nvoid FixedPointBatchNorm(const Tensor& input, const float input_min,\n                         const float input_max, const Tensor& mean,\n                         float mean_min, float mean_max, const Tensor& var,\n                         float var_min, float var_max, const Tensor& beta,\n                         float beta_min, float beta_max, const Tensor& gamma,\n                         float gamma_min, float gamma_max,\n                         float variance_epsilon, bool scale_after_normalization,\n                         Tensor* output, float* output_min, float* output_max) {\n  auto input_flat = input.flat<T1>();\n  auto mean_flat = mean.flat<T1>();\n  auto var_flat = var.flat<T1>();\n  auto beta_flat = beta.flat<T1>();\n  auto gamma_flat = gamma.flat<T1>();\n  auto output_flat = output->flat<T2>();\n\n  const int depth = mean.dim_size(0);\n  const int row_count = input_flat.size() / depth;\n\n  // The range here is chosen so that typical input values fit in without any\n  // overflow or loss of precision, going from +1m to -1m with 10 bits of fixed\n  // point precision.\n  *output_min = -(1 << 20);\n  *output_max = (1 << 20);\n\n  Tensor scale_tensor(DataTypeToEnum<T2>::v(), {depth});\n  auto scale_flat = scale_tensor.flat<T2>();\n  Tensor offset_tensor(DataTypeToEnum<T2>::v(), {depth});\n  auto offset_flat = offset_tensor.flat<T2>();\n  for (int channel = 0; channel < depth; ++channel) {\n    const float mean_value =\n        QuantizedToFloat(mean_flat(channel), mean_min, mean_max);\n    const float var_value =\n        QuantizedToFloat(var_flat(channel), var_min, var_max);\n    const float beta_value =\n        QuantizedToFloat(beta_flat(channel), beta_min, beta_max);\n    const float gamma_value =\n        QuantizedToFloat(gamma_flat(channel), gamma_min, gamma_max);\n    float scale_value;\n    if (scale_after_normalization) {\n      scale_value = (1.0f / sqrtf(var_value + variance_epsilon)) * gamma_value;\n    } else {\n      scale_value = (1.0f / sqrtf(var_value + variance_epsilon));\n    }\n    const float offset_value = (-mean_value * scale_value) + beta_value;\n    scale_flat(channel) =\n        FloatToQuantized<T2>(scale_value, *output_min, *output_max);\n    offset_flat(channel) =\n        FloatToQuantized<T2>(offset_value, *output_min, *output_max);\n  }\n\n  const T2 one_in_output_space =\n      FloatToQuantized<T2>(1.0f, *output_min, *output_max);\n  for (int row_index = 0; row_index < row_count; ++row_index) {\n    for (int channel = 0; channel < depth; ++channel) {\n      const int input_index = (row_index * depth) + channel;\n      const T2 input_value =\n          RequantizeInNewRange<T1, T2>(input_flat(input_index), input_min,\n                                       input_max, *output_min, *output_max);\n      const T2 scale_value = scale_flat(channel);\n      const T2 offset_value = offset_flat(channel);\n      const T2 output_value =\n          ((input_value * scale_value) / one_in_output_space) + offset_value;\n      output_flat(input_index) = output_value;\n    }\n  }\n}\n\n}  // namespace\n\ntemplate <typename T1, typename T2>\nclass QuantizedBatchNormOp : public OpKernel {\n public:\n  explicit QuantizedBatchNormOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"variance_epsilon\", &variance_epsilon_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"scale_after_normalization\",\n                                             &scale_after_normalization_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float input_min = context->input(1).flat<float>()(0);\n    const float input_max = context->input(2).flat<float>()(0);\n    const Tensor& mean = context->input(3);\n    const float mean_min = context->input(4).flat<float>()(0);\n    const float mean_max = context->input(5).flat<float>()(0);\n    const Tensor& var = context->input(6);\n    const float var_min = context->input(7).flat<float>()(0);\n    const float var_max = context->input(8).flat<float>()(0);\n    const Tensor& beta = context->input(9);\n    const float beta_min = context->input(10).flat<float>()(0);\n    const float beta_max = context->input(11).flat<float>()(0);\n    const Tensor& gamma = context->input(12);\n    const float gamma_min = context->input(13).flat<float>()(0);\n    const float gamma_max = context->input(14).flat<float>()(0);\n\n    OP_REQUIRES(context, input.dims() == 4,\n                errors::InvalidArgument(\"input must be 4-dimensional\",\n                                        input.shape().DebugString()));\n    OP_REQUIRES(context, mean.dims() == 1,\n                errors::InvalidArgument(\"mean must be 1-dimensional\",\n                                        mean.shape().DebugString()));\n    OP_REQUIRES(context, var.dims() == 1,\n                errors::InvalidArgument(\"var must be 1-dimensional\",\n                                        var.shape().DebugString()));\n    OP_REQUIRES(context, beta.dims() == 1,\n                errors::InvalidArgument(\"beta must be 1-dimensional\",\n                                        beta.shape().DebugString()));\n    OP_REQUIRES(context, gamma.dims() == 1,\n                errors::InvalidArgument(\"gamma must be 1-dimensional\",\n                                        gamma.shape().DebugString()));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    float output_min;\n    float output_max;\n    FixedPointBatchNorm<T1, T2>(input, input_min, input_max, mean, mean_min,\n                                mean_max, var, var_min, var_max, beta, beta_min,\n                                beta_max, gamma, gamma_min, gamma_max,\n                                variance_epsilon_, scale_after_normalization_,\n                                output, &output_min, &output_max);\n\n    Tensor* output_min_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, {}, &output_min_tensor));\n    output_min_tensor->flat<float>()(0) = output_min;\n\n    Tensor* output_max_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, {}, &output_max_tensor));\n    output_max_tensor->flat<float>()(0) = output_max;\n  }\n\n private:\n  float variance_epsilon_;\n  bool scale_after_normalization_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"QuantizedBatchNormWithGlobalNormalization\")\n                            .Device(DEVICE_CPU)\n                            .TypeConstraint<quint8>(\"Tinput\")\n                            .TypeConstraint<qint32>(\"out_type\"),\n                        QuantizedBatchNormOp<quint8, qint32>);\n\n}  // namespace tensorflow"