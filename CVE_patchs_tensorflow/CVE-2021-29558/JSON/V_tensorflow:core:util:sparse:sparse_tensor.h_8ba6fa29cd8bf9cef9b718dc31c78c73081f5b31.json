"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_CORE_UTIL_SPARSE_SPARSE_TENSOR_H_\n#define TENSORFLOW_CORE_UTIL_SPARSE_SPARSE_TENSOR_H_\n\n#include <limits>\n#include <numeric>\n#include <vector>\n\n#include \"absl/base/macros.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/sparse/dim_comparator.h\"\n#include \"tensorflow/core/util/sparse/group_iterator.h\"\n\nnamespace tensorflow {\nnamespace sparse {\n\nclass SparseTensor {\n public:\n  typedef typename gtl::ArraySlice<int64> VarDimArray;\n  typedef typename gtl::InlinedVector<int64, 8> ShapeArray;\n\n  static Status Create(Tensor ix, Tensor vals, const VarDimArray shape,\n                       const VarDimArray order, SparseTensor* result);\n\n  static Status Create(Tensor ix, Tensor vals, const TensorShape& shape,\n                       SparseTensor* result);\n\n  static Status Create(Tensor ix, Tensor vals, const VarDimArray shape,\n                       SparseTensor* result);\n\n  static Status Create(Tensor ix, Tensor vals, const TensorShape& shape,\n                       const VarDimArray order, SparseTensor* result);\n\n  SparseTensor() : dims_(0) {}\n\n  ABSL_DEPRECATED(\"Use Create() functions instead of constructors directly.\")\n  SparseTensor(Tensor ix, Tensor vals, const TensorShape& shape)\n      : SparseTensor(std::move(ix), std::move(vals), TensorShapeToVector(shape),\n                     UndefinedOrder(TensorShapeToVector(shape))) {}\n\n  ABSL_DEPRECATED(\"Use Create() functions instead of constructors directly.\")\n  SparseTensor(Tensor ix, Tensor vals, const VarDimArray shape)\n      : SparseTensor(std::move(ix), std::move(vals), shape,\n                     UndefinedOrder(shape)) {}\n\n  ABSL_DEPRECATED(\"use Create() functions instead of constructors directly.\")\n  SparseTensor(Tensor ix, Tensor vals, const TensorShape& shape,\n               const VarDimArray order)\n      : SparseTensor(std::move(ix), std::move(vals), TensorShapeToVector(shape),\n                     order) {}\n\n  ABSL_DEPRECATED(\"Use Create() functions instead of constructors directly.\")\n  SparseTensor(Tensor ix, Tensor vals, const VarDimArray shape,\n               const VarDimArray order);\n\n  SparseTensor(const SparseTensor& other)\n      : SparseTensor(other.ix_, other.vals_, other.shape_, other.order_) {}\n\n  SparseTensor(SparseTensor&& other)\n      : SparseTensor(std::move(other.ix_), std::move(other.vals_),\n                     std::move(other.shape_), std::move(other.order_)) {}\n\n  SparseTensor& operator=(const SparseTensor& other) {\n    ix_ = other.ix_;\n    vals_ = other.vals_;\n    shape_ = other.shape_;\n    order_ = other.order_;\n    dims_ = other.dims_;\n    return *this;\n  }\n\n  SparseTensor& operator=(SparseTensor&& other) {\n    ix_ = std::move(other.ix_);\n    vals_ = std::move(other.vals_);\n    shape_ = std::move(other.shape_);\n    order_ = std::move(other.order_);\n    dims_ = std::move(other.dims_);\n    return *this;\n  }\n\n  std::size_t num_entries() const { return ix_.dim_size(0); }\n\n  int dims() const { return shape_.size(); }\n\n  const Tensor& indices() const { return ix_; }\n\n  const Tensor& values() const { return vals_; }\n\n  DataType dtype() const { return vals_.dtype(); }\n\n  Status IndicesValid() const;\n\n  VarDimArray shape() const { return shape_; }\n\n  VarDimArray order() const { return order_; }\n\n  // Resorts the indices and values according to the dimensions in order.\n  template <typename T>\n  void Reorder(const VarDimArray& order);\n\n  // Returns a group iterable that can be used for clumping indices\n  // and values according to the group indices of interest.\n  //\n  // Precondition: order()[0..group_ix.size()] == group_ix.\n  //\n  // See the README.md in this directory for more usage information.\n  GroupIterable group(const VarDimArray& group_ix) const {\n    DCHECK_LE(group_ix.size(), dims_);\n    for (std::size_t di = 0; di < group_ix.size(); ++di) {\n      DCHECK_GE(group_ix[di], 0) << \"Group dimension out of range\";\n      DCHECK_LT(group_ix[di], dims_) << \"Group dimension out of range\";\n      DCHECK_EQ(group_ix[di], order_[di])\n          << \"Group dimension does not match sorted order\";\n    }\n    return GroupIterable(ix_, vals_, dims_, group_ix);\n  }\n\n  // Stores the sparse indices into the dense tensor out.\n  // Preconditions:\n  //   out->shape().dims() == shape().dims()\n  //   out->shape().dim_size(d) >= shape(d) for all d\n  //\n  // Returns true on success.  False on failure (mismatched dimensions\n  // or out-of-bounds indices).\n  //\n  // If initialize==True, ToDense first overwrites all coefficients in out to 0.\n  //\n  template <typename T>\n  bool ToDense(Tensor* out, bool initialize = true);\n\n  // Concat() will concatenate all the tensors according to their first order\n  // dimension.  All tensors must have identical shape except for\n  // the first order dimension.  All tensors orders' first dimension\n  // must match.\n  //\n  // If all of the tensors have identical ordering, then the output\n  // will have this ordering.  Otherwise the output is set as not\n  // having any order and a Reorder<T>() should be called on it before\n  // performing any subsequent operations.\n  template <typename T>\n  static SparseTensor Concat(const gtl::ArraySlice<SparseTensor>& tensors);\n\n  // Split() will split the input SparseTensor into a list of num_split\n  // SparseTensor given a splitting dimension. If the input dimension range\n  // isn't an integer multiple of split_dim, we add one extra dimension for\n  // each slice.\n  template <typename T>\n  static Status Split(const SparseTensor& tensor, const int split_dim,\n                      const int num_split, std::vector<SparseTensor>* result);\n\n  // Slice() will slice the input SparseTensor into a SparseTensor based on\n  // specified start and size. Both start and size are 1-D array with each\n  // element of the array representing one dimension. The start is the start\n  // index at each dimension and the size is the size at each dimension.\n  template <typename T>\n  static SparseTensor Slice(const SparseTensor& tensor,\n                            const gtl::ArraySlice<int64>& start,\n                            const gtl::ArraySlice<int64>& size);\n\n  // Picks out the dimensions according to `dim_indices`.\n  std::vector<int64> PickDims(gtl::ArraySlice<int64> dim_indices) const {\n    std::vector<int64> res(dim_indices.size());\n    for (size_t i = 0; i < dim_indices.size(); ++i) {\n      res[i] = shape_[dim_indices[i]];\n    }\n    return res;\n  }\n\n private:\n  static inline ShapeArray UndefinedOrder(const VarDimArray shape) {\n    return ShapeArray(shape.size(), -1);\n  }\n\n  static inline ShapeArray TensorShapeToVector(const TensorShape& shape) {\n    ShapeArray vec(shape.dims());\n    for (int i = 0; i < shape.dims(); ++i) vec[i] = shape.dim_size(i);\n    return vec;\n  }\n\n  // Optimized implementation of `IndicesValid` for 1-D sparse tensors.\n  // REQUIRES: `shape_.size() == 1`.\n  bool IndicesValidVectorFastPath() const;\n\n  // Optimized implementation of `IndicesValid` for 2-D sparse tensors whose\n  // indices fit within the range of an `int32`.\n  // REQUIRES: `shape_.size() == 2`.\n  bool IndicesValidMatrix32BitFastPath() const;\n\n  template <bool standard_order>\n  Status IndicesValidHelper() const;\n\n  // Helper for ToDense<T>()\n  template <typename T>\n  bool ValidateAndInitializeToDense(Tensor* out, bool initialize);\n\n  // Helper for Split() that returns the slice index.\n  static inline int GetSliceIndex(const int dim, const int split_size,\n                                  const int residual) {\n    DCHECK_GT(split_size, 0);\n    DCHECK_GE(dim, 0);\n    if (residual == 0) return dim / split_size;\n    const int offset = residual * (split_size + 1);\n    if (dim < offset) {\n      return dim / (split_size + 1);\n    } else {\n      return residual + ((dim - offset) / split_size);\n    }\n  }\n\n  // Helper for Split() that returns the dimension in the slice.\n  static inline int GetDimensionInSlice(const int dim, const int split_size,\n                                        const int residual) {\n    DCHECK_GT(split_size, 0);\n    DCHECK_GE(dim, 0);\n    if (residual == 0) return dim % split_size;\n    const int offset = residual * (split_size + 1);\n    if (dim < offset) {\n      return dim % (split_size + 1);\n    } else {\n      return (dim - offset) % split_size;\n    }\n  }\n\n  // Helper for Split() that returns the shape given a slice index.\n  static inline int GetSliceShape(const int slice_index, const int split_size,\n                                  const int residual) {\n    DCHECK_GT(split_size, 0);\n    DCHECK_GE(slice_index, 0);\n    if (residual == 0) return split_size;\n    if (slice_index < residual) {\n      return split_size + 1;\n    } else {\n      return split_size;\n    }\n  }\n\n  Tensor ix_;\n  Tensor vals_;\n  ShapeArray shape_;\n  ShapeArray order_;\n  int dims_;\n};\n\n// This operation updates the indices and values Tensor rows, so it is\n// an in-place algorithm.  It requires O(N log N) time and O(N)\n// temporary space.\ntemplate <typename T>\ninline void SparseTensor::Reorder(const VarDimArray& order) {\n  DCHECK_EQ(DataTypeToEnum<T>::v(), dtype())\n      << \"Reorder requested with the wrong datatype\";\n  DCHECK_EQ(order.size(), dims_) << \"Order length must be SparseTensor rank\";\n  auto ix_t = ix_.matrix<int64>();\n  auto vals_t = vals_.vec<T>();\n\n  std::vector<int64> reorder(num_entries());\n  std::iota(reorder.begin(), reorder.end(), 0);\n\n  // Sort to get order of indices\n  switch (order.size()) {\n#define CASE_SORT(ORDER_SIZE)                                    \\\n  case ORDER_SIZE: {                                             \\\n    FixedDimComparator<ORDER_SIZE> sorter(ix_t, order, shape()); \\\n    std::sort(reorder.begin(), reorder.end(), sorter);           \\\n    break;                                                       \\\n  }\n    CASE_SORT(0);\n    CASE_SORT(1);\n    CASE_SORT(2);\n    CASE_SORT(3);\n    CASE_SORT(4);\n    CASE_SORT(5);\n#undef CASE_SORT\n    default: {\n      DimComparator sorter(ix_t, order, shape());\n      std::sort(reorder.begin(), reorder.end(), sorter);\n    }\n  }\n\n  // We have a forward reordering, but what we'll need is a\n  // permutation (the inverse).  This can be calculated with O(1)\n  // additional\n  // and O(n) time (INVPERM) but we just do the simple thing here.\n  std::vector<size_t> permutation(reorder.size());\n  for (std::size_t n = 0; n < reorder.size(); ++n) {\n    permutation[reorder[n]] = n;\n  }\n\n  // Update indices & values by converting the permutations to\n  // a product of transpositions.  Iterate over the cycles in the\n  // permutation, and convert each of those into a product of\n  // transpositions (swaps):\n  //   https://en.wikipedia.org/wiki/Cyclic_permutation\n  // This is N swaps, 2*N comparisons.\n  for (std::size_t n = 0; n + 1 < permutation.size(); ++n) {\n    while (n != permutation[n]) {\n      std::size_t r = permutation[n];\n      std::swap_ranges(&(ix_t(n, 0)), &(ix_t(n + 1, 0)), &(ix_t(r, 0)));\n      std::swap(vals_t(n), vals_t(r));\n      std::swap(permutation[n], permutation[r]);\n    }\n  }\n\n  order_ = ShapeArray(order.begin(), order.end());\n}\n\ntemplate <typename T>\ninline bool SparseTensor::ValidateAndInitializeToDense(Tensor* out,\n                                                       bool initialize) {\n  DCHECK_EQ(DataTypeToEnum<T>::v(), dtype())\n      << \"ToDense requested with the wrong datatype\";\n\n  DCHECK_EQ(out->shape().dims(), dims_)\n      << \"Incompatible dimensions between SparseTensor and output\";\n\n  DCHECK_EQ(out->dtype(), DataTypeToEnum<T>::v())\n      << \"Output must be type: \" << DataTypeToEnum<T>::v()\n      << \" but got: \" << out->dtype();\n\n  // Make sure the dense output is the same rank and has room\n  // to hold the SparseTensor.\n  const auto& out_shape = out->shape();\n  if (shape_.size() != out_shape.dims()) return false;\n  for (int d = 0; d < shape_.size(); ++d) {\n    if (shape_[d] > out_shape.dim_size(d)) return false;\n  }\n\n  if (initialize) {\n    auto out_t = out->flat<T>();\n    out_t.setConstant(T());\n  }\n\n  return true;\n}\n\ntemplate <typename T>\ninline bool SparseTensor::ToDense(Tensor* out, bool initialize) {\n  if (!ValidateAndInitializeToDense<T>(out, initialize)) return false;\n\n  auto out_t = out->flat<T>();\n  auto vals_t = vals_.vec<T>();\n  auto ix_t = ix_.matrix<int64>();\n  const int64* const ix_ptr = ix_t.data();\n\n  if (dims_ == 1) {\n    // Fast path for sparse vectors.\n    const int64 out_length = out->shape().dim_size(0);\n    for (int n = 0; n < vals_t.dimension(0); ++n) {\n      const int64 index = internal::SubtleMustCopy(ix_ptr[n]);\n      if (!FastBoundsCheck(index, out_length)) return false;\n      out_t(index) = vals_t(n);\n    }\n    return true;\n  } else if (dims_ == 2) {\n    // Fast path for sparse matrices.\n    const auto& out_shape = out->shape();\n    const int64 out_rows = out_shape.dim_size(0);\n    const int64 out_cols = out_shape.dim_size(1);\n    for (int n = 0; n < vals_t.dimension(0); ++n) {\n      const int64 row_index = internal::SubtleMustCopy(ix_ptr[n * 2]);\n      const int64 col_index = internal::SubtleMustCopy(ix_ptr[n * 2 + 1]);\n      if (!(FastBoundsCheck(row_index, out_rows) &&\n            FastBoundsCheck(col_index, out_cols))) {\n        return false;\n      }\n      out_t(row_index * out_cols + col_index) = vals_t(n);\n    }\n    return true;\n  } else {\n    // General path for N-dimensional sparse tensors.\n    gtl::InlinedVector<int64, 4> strides(dims_);\n    const auto& out_shape = out->shape().dim_sizes();\n    if (dims_ > 0) {\n      strides[dims_ - 1] = 1;\n    }\n    for (int d = dims_ - 2; d >= 0; --d) {\n      strides[d] = strides[d + 1] * out_shape[d + 1];\n    }\n\n    for (int n = 0; n < vals_t.dimension(0); ++n) {\n      bool invalid_dims = false;\n      int64 ix = 0;\n      for (int d = 0; d < dims_; ++d) {\n        const int64 ix_n_d = internal::SubtleMustCopy(ix_ptr[n * dims_ + d]);\n        if (!FastBoundsCheck(ix_n_d, out_shape[d])) {\n          invalid_dims = true;\n        }\n        ix += strides[d] * ix_n_d;\n      }\n      if (invalid_dims) return false;\n      out_t(ix) = vals_t(n);\n    }\n    return true;\n  }\n}\n\ntemplate <typename T>\ninline SparseTensor SparseTensor::Concat(\n    const gtl::ArraySlice<SparseTensor>& tensors) {\n  DCHECK_GE(tensors.size(), size_t{1}) << \"Cannot concat 0 SparseTensors\";\n  const int dims = tensors[0].dims_;\n  DCHECK_GE(dims, 1) << \"Cannot concat 0-dimensional SparseTensors\";\n  auto order_0 = tensors[0].order();\n  const int primary_dim = order_0[0];\n  ShapeArray final_order(order_0.begin(), order_0.end());\n  ShapeArray final_shape(tensors[0].shape().begin(), tensors[0].shape().end());\n  final_shape[primary_dim] = 0;  // We'll build this up as we go along.\n  int num_entries = 0;\n\n  bool fully_ordered = true;\n  for (const SparseTensor& st : tensors) {\n    DCHECK_EQ(st.dims_, dims) << \"All SparseTensors must have the same rank.\";\n    DCHECK_EQ(DataTypeToEnum<T>::v(), st.dtype())\n        << \"Concat requested with the wrong data type\";\n    DCHECK_GE(st.order()[0], 0) << \"SparseTensor must be ordered\";\n    DCHECK_EQ(st.order()[0], primary_dim)\n        << \"All SparseTensors' order[0] must match.  This is the concat dim.\";\n    if (st.order() != final_order) fully_ordered = false;\n    const VarDimArray& st_shape = st.shape();\n    for (int d = 0; d < dims - 1; ++d) {\n      const int cdim = (d < primary_dim) ? d : d + 1;\n      DCHECK_EQ(final_shape[cdim], st_shape[cdim])\n          << \"All SparseTensors' shapes must match except on the concat dim.  \"\n          << \"Concat dim: \" << primary_dim\n          << \", mismatched shape at dim: \" << cdim\n          << \".  Expecting shape like: [\" << str_util::Join(final_shape, \",\")\n          << \"] but saw shape: [\" << str_util::Join(st_shape, \",\") << \"]\";\n    }\n\n    // Update dimension of final shape\n    final_shape[primary_dim] =\n        (final_shape[primary_dim] + st_shape[primary_dim]);\n\n    num_entries += st.num_entries();  // Update number of entries\n  }\n\n  // If nonconsistent ordering among inputs, set final order to -1s.\n  if (!fully_ordered) {\n    final_order = UndefinedOrder(final_shape);\n  }\n\n  Tensor output_ix(DT_INT64, TensorShape({num_entries, dims}));\n  Tensor output_vals(DataTypeToEnum<T>::v(), TensorShape({num_entries}));\n\n  TTypes<int64>::Matrix ix_t = output_ix.matrix<int64>();\n  typename TTypes<T>::Vec vals_t = output_vals.vec<T>();\n\n  Eigen::DenseIndex offset = 0;\n  int64 shape_offset = 0;\n  for (const SparseTensor& st : tensors) {\n    const int st_num_entries = st.num_entries();\n\n    // Fill in indices & values.\n    if (st_num_entries > 0) {\n      std::copy_n(&st.vals_.vec<T>()(0), st_num_entries, &vals_t(offset));\n\n      const auto* st_ix = &st.ix_.matrix<int64>()(0, 0);\n      auto* ix_out = &ix_t(offset, 0);\n      for (std::size_t i = 0; i < st_num_entries * dims; ++i) {\n        *ix_out++ = *st_ix++ + ((i % dims == primary_dim) ? shape_offset : 0);\n      }\n    }\n\n    offset += st_num_entries;\n    shape_offset += st.shape()[primary_dim];\n  }\n\n  return SparseTensor(output_ix, output_vals, final_shape, final_order);\n}\n\ntemplate <typename T>\ninline Status SparseTensor::Split(const SparseTensor& input_tensor,\n                                  const int split_dim, const int num_split,\n                                  std::vector<SparseTensor>* result) {\n  std::vector<Tensor> output_indices;\n  std::vector<Tensor> output_values;\n  std::vector<TensorShape> output_shapes;\n  output_indices.reserve(num_split);\n  output_values.reserve(num_split);\n  output_shapes.reserve(num_split);\n\n  std::vector<typename TTypes<int64>::Matrix> output_indices_t;\n  std::vector<typename TTypes<T>::Vec> output_values_t;\n  output_indices_t.reserve(num_split);\n  output_values_t.reserve(num_split);\n  auto input_values_t = input_tensor.values().vec<T>();\n  auto input_indices_t = input_tensor.indices().matrix<int64>();\n\n  std::vector<int> num_values(num_split, 0);\n  const int num_dim = input_tensor.shape().size();\n  const int split_dim_size = input_tensor.shape()[split_dim];\n  const int split_size = split_dim_size / num_split;\n\n  if (!(num_split > 0 && num_split <= split_dim_size)) {\n    return errors::InvalidArgument(\"num_split must be in the interval (0, \",\n                                   split_dim_size, \"]\");\n  }\n  if (!(split_dim >= 0 && split_dim < num_dim)) {\n    return errors::InvalidArgument(\"num_dim must be in the interval [0, \",\n                                   num_dim, \")\");\n  }\n\n  const int residual = split_dim_size % num_split;\n  for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) {\n    const int dim = input_tensor.indices().matrix<int64>()(i, split_dim);\n    int slice_index = GetSliceIndex(dim, split_size, residual);\n    num_values[slice_index]++;\n  }\n\n  for (int i = 0; i < num_split; ++i) {\n    // TODO(ataei): Pass an allocator to avoid allocating large memory buffer.\n    output_indices.emplace_back(DT_INT64,\n                                TensorShape({num_values[i], num_dim}));\n    output_values.emplace_back(DataTypeToEnum<T>::v(),\n                               TensorShape({num_values[i]}));\n    output_shapes.emplace_back(input_tensor.shape());\n    output_indices_t.emplace_back(output_indices[i].matrix<int64>());\n    output_values_t.emplace_back(output_values[i].vec<T>());\n    const int size = GetSliceShape(i, split_size, residual);\n    output_shapes[i].set_dim(split_dim, size);\n  }\n\n  std::vector<int> values_inserted_in_slice(num_split, 0);\n  for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) {\n    const int dim = input_indices_t(i, split_dim);\n    const int slice_index = GetSliceIndex(dim, split_size, residual);\n    const int slice_dim = values_inserted_in_slice[slice_index]++;\n    output_values_t[slice_index](slice_dim) = input_values_t(i);\n    for (int j = 0; j < num_dim; ++j) {\n      const int64 original_dim = input_indices_t(i, j);\n      output_indices_t[slice_index](slice_dim, j) =\n          (j == split_dim)\n              ? GetDimensionInSlice(original_dim, split_size, residual)\n              : original_dim;\n    }\n  }\n\n  result->clear();\n  result->reserve(num_split);\n  for (int i = 0; i < num_split; ++i) {\n    SparseTensor tensor;\n    Status create_status =\n        Create(output_indices[i], output_values[i], output_shapes[i], &tensor);\n    if (!create_status.ok()) {\n      return create_status;\n    }\n    result->push_back(std::move(tensor));\n  }\n  return Status::OK();\n}\n\ntemplate <typename T>\ninline SparseTensor SparseTensor::Slice(const SparseTensor& input_tensor,\n                                        const gtl::ArraySlice<int64>& start,\n                                        const gtl::ArraySlice<int64>& size) {\n  TensorShape output_shape(input_tensor.shape());\n\n  const int dims = input_tensor.dims();\n  for (int dim = 0; dim < dims; dim++) {\n    // Determine the size of the result; if the selected slice goes beyond the\n    // input boundary, the result will correspond to the size of the overlap\n    // between the input and the selected slice.\n    const int64 input_size = output_shape.dim_size(dim);\n    const int64 start_index = start[dim];\n    const int64 slice_size = size[dim];\n    if (start_index + slice_size < input_size) {\n      // The entire selection is within input boundaries.\n      output_shape.set_dim(dim, slice_size);\n    } else if (start_index < input_size) {\n      // The selection starts within input boundaries, but goes beyond them.\n      output_shape.set_dim(dim, input_size - start_index);\n    } else {\n      // The selection is entirely out of input boundaries.\n      output_shape.set_dim(dim, 0);\n    }\n  }\n\n  auto input_indices_t = input_tensor.indices().matrix<int64>();\n  auto input_values_t = input_tensor.values().vec<T>();\n\n  // Find the number of indices that fall inside start and size.\n  int count = 0;\n  for (int i = 0; i < input_tensor.indices().dim_size(0); i++) {\n    // The following will check to see if an input is within the\n    // range specified by start and size.\n    // The for loop below iterates through all dimensions. In case\n    // the index falls outside of the start and size at any dimension,\n    // it will be considered as a \"no hit\" (hit = false). In this\n    // case, it will not be counted as the index that fall inside\n    // the range specified by start and size.\n    bool hit = true;\n    for (int dim = 0; dim < dims; dim++) {\n      if (!(start[dim] <= input_indices_t(i, dim) &&\n            input_indices_t(i, dim) < start[dim] + size[dim])) {\n        hit = false;\n        break;\n      }\n    }\n    if (!hit) {\n      continue;\n    }\n    count++;\n  }\n\n  Tensor output_values(DataTypeToEnum<T>::v(), TensorShape({count}));\n  Tensor output_indices(DT_INT64, TensorShape({count, dims}));\n\n  auto output_values_t = output_values.vec<T>();\n  auto output_indices_t = output_indices.matrix<int64>();\n\n  // Obtain the output indices that fall inside start and size.\n  int index = 0;\n  for (int i = 0; i < input_tensor.indices().dim_size(0) && index < count;\n       i++) {\n    // The logic here is similar as the above except that the above\n    // only count the number of indices while here we actually generate\n    // the output.\n    bool hit = true;\n    for (int dim = 0; dim < dims; dim++) {\n      if (!(start[dim] <= input_indices_t(i, dim) &&\n            input_indices_t(i, dim) < start[dim] + size[dim])) {\n        hit = false;\n        break;\n      }\n    }\n    if (!hit) {\n      continue;\n    }\n    output_values_t(index) = input_values_t(i);\n    for (int dim = 0; dim < dims; dim++) {\n      output_indices_t(index, dim) = input_indices_t(i, dim) - start[dim];\n    }\n    index++;\n  }\n\n  return SparseTensor(output_indices, output_values, output_shape);\n}\n\n}  // namespace sparse\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_CORE_UTIL_SPARSE_SPARSE_TENSOR_H_"