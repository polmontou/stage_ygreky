"diff --git a/tensorflow/core/kernels/edit_distance_op.cc b/tensorflow/core/kernels/edit_distance_op.cc\nindex 4aecdc9e414..386a1af0840 100644\n--- a/tensorflow/core/kernels/edit_distance_op.cc\n+++ b/tensorflow/core/kernels/edit_distance_op.cc\n@@ -64,6 +64,12 @@ Status ValidateShapes(OpKernelContext* ctx, const Tensor& hypothesis_indices,\n     return errors::InvalidArgument(\n         \"truth_shape should be a vector, but got shape: \",\n         truth_shape.shape().DebugString());\n+  if (hypothesis_values.NumElements() != hypothesis_indices.dim_size(0))\n+    return errors::InvalidArgument(\n+        \"Expected hypothesis_values.NumElements == \"\n+        \"#rows(hypothesis_indices), their shapes are: \",\n+        hypothesis_values.shape().DebugString(), \" and \",\n+        hypothesis_indices.shape().DebugString());\n   if (hypothesis_shape.NumElements() != hypothesis_indices.dim_size(1))\n     return errors::InvalidArgument(\n         \"Expected hypothesis_shape.NumElements == \"\n@@ -75,6 +81,12 @@ Status ValidateShapes(OpKernelContext* ctx, const Tensor& hypothesis_indices,\n         \"Input SparseTensors must have rank at least 2, but truth_shape \"\n         \"rank is: \",\n         truth_shape.NumElements());\n+  if (truth_values.NumElements() != truth_indices.dim_size(0))\n+    return errors::InvalidArgument(\n+        \"Expected truth_values.NumElements == \"\n+        \"#rows(truth_indices), their shapes are: \",\n+        truth_values.shape().DebugString(), \" and \",\n+        truth_indices.shape().DebugString());\n   if (truth_shape.NumElements() != truth_indices.dim_size(1))\n     return errors::InvalidArgument(\n         \"Expected truth_shape.NumElements == \"\n@@ -153,6 +165,11 @@ class EditDistanceOp : public OpKernel {\n       output_shape.AddDim(std::max(hypothesis_st_shape.dim_size(d),\n                                    truth_st_shape.dim_size(d)));\n     }\n+    const auto output_elements = output_shape.num_elements();\n+    OP_REQUIRES(\n+        ctx, output_elements > 0,\n+        errors::InvalidArgument(\"Got output shape \", output_shape.DebugString(),\n+                                \" which has 0 elements\"));\n \n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(\"output\", output_shape, &output));\n@@ -185,6 +202,12 @@ class EditDistanceOp : public OpKernel {\n       if (g_truth == g_hypothesis) {\n         auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                       output_strides.begin(), int64{0});\n+        OP_REQUIRES(\n+            ctx, loc < output_elements,\n+            errors::Internal(\"Got an inner product \", loc,\n+                             \" which would require in writing to outside of \"\n+                             \"the buffer for the output tensor (max elements \",\n+                             output_elements, \")\"));\n         output_t(loc) =\n             gtl::LevenshteinDistance<T>(truth_seq, hypothesis_seq, cmp);\n         if (normalize_) output_t(loc) /= truth_seq.size();\n@@ -194,6 +217,12 @@ class EditDistanceOp : public OpKernel {\n       } else if (g_truth > g_hypothesis) {  // zero-length truth\n         auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),\n                                       output_strides.begin(), int64{0});\n+        OP_REQUIRES(\n+            ctx, loc < output_elements,\n+            errors::Internal(\"Got an inner product \", loc,\n+                             \" which would require in writing to outside of \"\n+                             \"the buffer for the output tensor (max elements \",\n+                             output_elements, \")\"));\n         output_t(loc) = hypothesis_seq.size();\n         if (normalize_ && output_t(loc) != 0.0f) {\n           output_t(loc) = std::numeric_limits<float>::infinity();\n@@ -202,6 +231,12 @@ class EditDistanceOp : public OpKernel {\n       } else {  // zero-length hypothesis\n         auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                       output_strides.begin(), int64{0});\n+        OP_REQUIRES(\n+            ctx, loc < output_elements,\n+            errors::Internal(\"Got an inner product \", loc,\n+                             \" which would require in writing to outside of \"\n+                             \"the buffer for the output tensor (max elements \",\n+                             output_elements, \")\"));\n         output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();\n         ++truth_iter;\n       }\n@@ -212,6 +247,12 @@ class EditDistanceOp : public OpKernel {\n       auto hypothesis_seq = hypothesis_j.values<T>();\n       auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),\n                                     output_strides.begin(), int64{0});\n+      OP_REQUIRES(\n+          ctx, loc < output_elements,\n+          errors::Internal(\"Got an inner product \", loc,\n+                           \" which would require in writing to outside of the \"\n+                           \"buffer for the output tensor (max elements \",\n+                           output_elements, \")\"));\n       output_t(loc) = hypothesis_seq.size();\n       if (normalize_ && output_t(loc) != 0.0f) {\n         output_t(loc) = std::numeric_limits<float>::infinity();\n@@ -224,6 +265,12 @@ class EditDistanceOp : public OpKernel {\n       auto truth_seq = truth_i.values<T>();\n       auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                     output_strides.begin(), int64{0});\n+      OP_REQUIRES(\n+          ctx, loc < output_elements,\n+          errors::Internal(\"Got an inner product \", loc,\n+                           \" which would require in writing to outside of the \"\n+                           \"buffer for the output tensor (max elements \",\n+                           output_elements, \")\"));\n       output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();\n       ++truth_iter;\n     }"