"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/kernels/sparse_fill_empty_rows_op.h\"\n\n#include <algorithm>\n#include <numeric>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\nnamespace tensorflow {\n\nusing CPUDevice = Eigen::ThreadPoolDevice;\nusing GPUDevice = Eigen::GpuDevice;\n\nnamespace functor {\n\ntemplate <typename T, typename Tindex>\nstruct SparseFillEmptyRows<CPUDevice, T, Tindex> {\n  Status operator()(OpKernelContext* context, const Tensor& default_value_t,\n                    const Tensor& indices_t, const Tensor& values_t,\n                    const Tensor& dense_shape_t,\n                    typename AsyncOpKernel::DoneCallback done) {\n    (void)done;  // Unused (only used in GPU implementation)\n    const int kOutputIndicesOutput = 0;\n    const int kOutputValuesOutput = 1;\n    const int kEmptyRowIndicatorOutput = 2;\n    const int kReverseIndexMapOutput = 3;\n\n    const T& default_value = default_value_t.scalar<T>()();\n    const auto indices = indices_t.matrix<Tindex>();\n    const auto values = values_t.vec<T>();\n    const auto dense_shape = dense_shape_t.vec<Tindex>();\n\n    const Tindex N = indices_t.shape().dim_size(0);\n    const Tindex dense_rows = dense_shape(0);\n\n    bool* empty_row_indicator = nullptr;\n    if (context->output_required(kEmptyRowIndicatorOutput)) {\n      Tensor* empty_row_indicator_t = nullptr;\n      TF_RETURN_IF_ERROR(context->allocate_output(kEmptyRowIndicatorOutput,\n                                                  TensorShape({dense_rows}),\n                                                  &empty_row_indicator_t));\n      empty_row_indicator = empty_row_indicator_t->vec<bool>().data();\n    }\n    Tindex* reverse_index_map = nullptr;\n    if (context->output_required(kReverseIndexMapOutput)) {\n      Tensor* reverse_index_map_t = nullptr;\n      TF_RETURN_IF_ERROR(context->allocate_output(\n          kReverseIndexMapOutput, TensorShape({N}), &reverse_index_map_t));\n      reverse_index_map = reverse_index_map_t->vec<Tindex>().data();\n    }\n\n    int rank = indices_t.shape().dim_size(1);\n\n    if (dense_rows == 0) {\n      if (N != 0) {\n        return errors::InvalidArgument(\n            \"Received SparseTensor with dense_shape[0] = 0 but \"\n            \"indices.shape[0] = \",\n            N);\n      }\n      Tensor* output_indices_t;\n      TensorShape output_indices_shape({0, rank});\n      TF_RETURN_IF_ERROR(context->allocate_output(\n          kOutputIndicesOutput, output_indices_shape, &output_indices_t));\n      Tensor* output_values_t;\n      TF_RETURN_IF_ERROR(context->allocate_output(\n          kOutputValuesOutput, TensorShape({0}), &output_values_t));\n\n      // Exit early, nothing more to do.\n      return Status::OK();\n    }\n\n    bool rows_are_ordered = true;\n    Tindex last_indices_row = 0;\n    std::vector<Tindex> csr_offset(dense_rows, 0);\n    for (int i = 0; i < N; ++i) {\n      const Tindex row = indices(i, 0);\n      if (row < 0 || row >= dense_rows) {\n        return errors::InvalidArgument(\"indices(\", i, \", 0) is invalid: \", row,\n                                       \" >= \", dense_rows);\n      }\n      ++csr_offset[row];\n      rows_are_ordered = rows_are_ordered & (row >= last_indices_row);\n      last_indices_row = row;\n    }\n    bool all_rows_full = true;\n    for (int row = 0; row < dense_rows; ++row) {\n      // csr_offset here describes the number of elements in this dense row\n      bool row_empty = (csr_offset[row] == 0);\n      if (empty_row_indicator) {\n        empty_row_indicator[row] = row_empty;\n      }\n      all_rows_full = all_rows_full & !row_empty;\n      // In filled version, each row has at least one element.\n      csr_offset[row] = std::max(csr_offset[row], Tindex{1});\n      // Update csr_offset to represent the number of elements up to and\n      // including dense_row + 1:\n      //  csr_offset(0) == #{elements of row 0}\n      //  csr_offset(1) == #{elements of row 1} + #{elements of row 0}\n      //  ..\n      //  csr_offset(i) == starting index for elements in row i + 1.\n      if (row > 0) {\n        csr_offset[row] += csr_offset[row - 1];\n      }\n    }\n\n    if (all_rows_full && rows_are_ordered) {\n      context->set_output(kOutputIndicesOutput, indices_t);\n      context->set_output(kOutputValuesOutput, values_t);\n      if (reverse_index_map) {\n        for (Tindex i = 0; i < N; ++i) {\n          reverse_index_map[i] = i;\n        }\n      }\n    } else {\n      Tensor* output_indices_t;\n      const Tindex N_full = csr_offset[dense_rows - 1];\n      TensorShape output_indices_shape({N_full, rank});\n      TF_RETURN_IF_ERROR(context->allocate_output(\n          kOutputIndicesOutput, output_indices_shape, &output_indices_t));\n      auto output_indices = output_indices_t->matrix<Tindex>();\n\n      Tensor* output_values_t;\n      TF_RETURN_IF_ERROR(context->allocate_output(\n          kOutputValuesOutput, TensorShape({N_full}), &output_values_t));\n      auto output_values = output_values_t->vec<T>();\n\n      std::vector<Tindex> filled_count(dense_rows, 0);\n\n      // Fill in values for rows that are not missing\n      for (Tindex i = 0; i < N; ++i) {\n        const Tindex row = indices(i, 0);\n        Tindex& offset = filled_count[row];\n        const Tindex output_i = ((row == 0) ? 0 : csr_offset[row - 1]) + offset;\n        offset++;  // Increment the filled count for this row.\n        std::copy_n(&indices(i, 0), rank, &output_indices(output_i, 0));\n        output_values(output_i) = values(i);\n        // We'll need this reverse index map to backprop correctly.\n        if (reverse_index_map) {\n          reverse_index_map[i] = output_i;\n        }\n      }\n\n      // Fill in values for rows that are missing\n      for (Tindex row = 0; row < dense_rows; ++row) {\n        const Tindex row_count = filled_count[row];\n        if (row_count == 0) {  // We haven't filled this row\n          const Tindex starting_index = (row == 0) ? 0 : csr_offset[row - 1];\n          // Remaining index values were set to zero already.\n          // Just need to set the row index in the right location.\n          output_indices(starting_index, 0) = row;\n          for (Tindex col = 1; col < rank; ++col) {\n            output_indices(starting_index, col) = 0;\n          }\n          output_values(starting_index) = default_value;\n        }\n      }\n    }\n\n    return Status::OK();\n  }\n};\n\n}  // namespace functor\n\nnamespace {\n\ntemplate <typename Device, typename T, typename Tindex>\nvoid SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  // Note that setting this empty lambda as the default parameter value directly\n  // can cause strange compiler/linker errors, so we do it like this instead.\n  if (!done) {\n    done = [] {};\n  }\n\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  // TODO(ebrevdo): add shape checks between values, indices,\n  // Also add check that dense rank > 0.\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}\n\n}  // namespace\n\ntemplate <typename Device, typename T, typename Tindex>\nclass SparseFillEmptyRowsOp : public OpKernel {\n public:\n  explicit SparseFillEmptyRowsOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    SparseFillEmptyRowsOpImpl<Device, T, Tindex>(context);\n  }\n};\n\n#define REGISTER_KERNELS(D, T, Tindex)                   \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRows\")    \\\n                              .Device(DEVICE_##D)        \\\n                              .HostMemory(\"dense_shape\") \\\n                              .TypeConstraint<T>(\"T\"),   \\\n                          SparseFillEmptyRowsOp<D##Device, T, Tindex>)\n\n#define REGISTER_CPU_KERNELS(T) REGISTER_KERNELS(CPU, T, int64)\nTF_CALL_ALL_TYPES(REGISTER_CPU_KERNELS);\n#undef REGISTER_CPU_KERNELS\n\n#undef REGISTER_KERNELS\n\n#if 0 && (GOOGLE_CUDA || TENSORFLOW_USE_ROCM)\n\n// The GPU implementation is async because it requires waiting for a\n// host->device memcpy before the output is allocated (similar to\n// SegmentSumGPUOp).\ntemplate <typename T, typename Tindex>\nclass SparseFillEmptyRowsGPUOp : public AsyncOpKernel {\n public:\n  explicit SparseFillEmptyRowsGPUOp(OpKernelConstruction* context)\n      : AsyncOpKernel(context) {}\n\n  void ComputeAsync(OpKernelContext* context, DoneCallback done) override {\n    SparseFillEmptyRowsOpImpl<GPUDevice, T, Tindex>(context, done);\n  }\n};\n\n#define REGISTER_KERNELS(T, Tindex)                      \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRows\")    \\\n                              .Device(DEVICE_GPU)        \\\n                              .HostMemory(\"dense_shape\") \\\n                              .TypeConstraint<T>(\"T\"),   \\\n                          SparseFillEmptyRowsGPUOp<T, Tindex>)\n\n// Forward declarations of the functor specializations for GPU.\nnamespace functor {\n#define DECLARE_GPU_SPEC(T, Tindex)                                            \\\n  template <>                                                                  \\\n  Status SparseFillEmptyRows<GPUDevice, T, Tindex>::operator()(                \\\n      OpKernelContext* context, const Tensor& default_value_t,                 \\\n      const Tensor& indices_t, const Tensor& values_t,                         \\\n      const Tensor& dense_shape_t, typename AsyncOpKernel::DoneCallback done); \\\n  extern template struct SparseFillEmptyRows<GPUDevice, T, Tindex>;\n#define DECLARE_GPU_SPEC_INT64(T) DECLARE_GPU_SPEC(T, int64)\nTF_CALL_POD_TYPES(DECLARE_GPU_SPEC_INT64)\n#undef DECLARE_GPU_SPEC_INT64\n#undef DECLARE_GPU_SPEC\n}  // namespace functor\n\n#define REGISTER_KERNELS_TINDEX(T) REGISTER_KERNELS(T, int64)\nTF_CALL_POD_TYPES(REGISTER_KERNELS_TINDEX)\n#undef REGISTER_KERNELS_TINDEX\n\n#undef REGISTER_KERNELS\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace functor {\n\ntemplate <typename T, typename Tindex>\nstruct SparseFillEmptyRowsGrad<CPUDevice, T, Tindex> {\n  Status operator()(OpKernelContext* context,\n                    typename TTypes<Tindex>::ConstVec reverse_index_map,\n                    typename TTypes<T>::ConstVec grad_values,\n                    typename TTypes<T>::Vec d_values,\n                    typename TTypes<T>::Scalar d_default_value) {\n    const CPUDevice& device = context->eigen_device<CPUDevice>();\n    const Tindex N = reverse_index_map.dimension(0);\n    const Tindex N_full = grad_values.dimension(0);\n\n    T& d_default_value_scalar = d_default_value();\n    d_default_value_scalar = T();\n\n    Tensor visited_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(device) = visited.constant(false);\n\n    for (int i = 0; i < N; ++i) {\n      // Locate the index of the output of the forward prop associated\n      // with this location in the input of the forward prop.  Copy\n      // the gradient into it.  Mark it as visited.\n      int64 reverse_index = reverse_index_map(i);\n      if (reverse_index < 0 || reverse_index >= N_full) {\n        return errors::InvalidArgument(\n            \"Elements in reverse index must be in [0, \", N_full, \") but got \",\n            reverse_index);\n      }\n      d_values(i) = grad_values(reverse_index);\n      visited(reverse_index) = true;\n    }\n    for (int j = 0; j < N_full; ++j) {\n      // The default value gradient gets the accumulated remainder of\n      // the backprop values (since the default value was used to fill\n      // in these slots in the forward calculation).\n      if (!visited(j)) {\n        d_default_value_scalar += grad_values(j);\n      }\n    }\n    return Status::OK();\n  }\n};\n\n}  // namespace functor\n\ntemplate <typename Device, typename T, typename Tindex>\nclass SparseFillEmptyRowsGradOp : public OpKernel {\n public:\n  explicit SparseFillEmptyRowsGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor* reverse_index_map_t;\n    const Tensor* grad_values_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"reverse_index_map\", &reverse_index_map_t));\n    OP_REQUIRES_OK(context, context->input(\"grad_values\", &grad_values_t));\n\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),\n        errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",\n                                reverse_index_map_t->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(grad_values_t->shape()),\n                errors::InvalidArgument(\"grad_values must be a vector, saw: \",\n                                        grad_values_t->shape().DebugString()));\n\n    const auto reverse_index_map = reverse_index_map_t->vec<Tindex>();\n    const auto grad_values = grad_values_t->vec<T>();\n\n    const Tindex N = reverse_index_map_t->shape().dim_size(0);\n\n    Tensor* d_values_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"d_values\", TensorShape({N}), &d_values_t));\n    auto d_values = d_values_t->vec<T>();\n    Tensor* d_default_value_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"d_default_value\", TensorShape({}),\n                                            &d_default_value_t));\n    auto d_default_value = d_default_value_t->scalar<T>();\n\n    OP_REQUIRES_OK(context,\n                   functor::SparseFillEmptyRowsGrad<Device, T, Tindex>()(\n                       context, reverse_index_map, grad_values, d_values,\n                       d_default_value));\n  }\n};\n\n#define REGISTER_KERNELS(D, T, Tindex)                    \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRowsGrad\") \\\n                              .Device(DEVICE_##D)         \\\n                              .TypeConstraint<T>(\"T\"),    \\\n                          SparseFillEmptyRowsGradOp<D##Device, T, Tindex>)\n\n#define REGISTER_CPU_KERNELS(T) REGISTER_KERNELS(CPU, T, int64)\nTF_CALL_NUMBER_TYPES(REGISTER_CPU_KERNELS);\n#undef REGISTER_CPU_KERNELS\n\n#if 0 && (GOOGLE_CUDA || TENSORFLOW_USE_ROCM)\n\n// Forward declarations of the functor specializations for GPU.\nnamespace functor {\n#define DECLARE_GPU_SPEC(T, Tindex)                                 \\\n  template <>                                                       \\\n  Status SparseFillEmptyRowsGrad<GPUDevice, T, Tindex>::operator()( \\\n      OpKernelContext* context,                                     \\\n      typename TTypes<Tindex>::ConstVec reverse_index_map,          \\\n      typename TTypes<T>::ConstVec grad_values,                     \\\n      typename TTypes<T>::Vec d_values,                             \\\n      typename TTypes<T>::Scalar d_default_value);                  \\\n  extern template struct SparseFillEmptyRowsGrad<GPUDevice, T, Tindex>;\n#define DECLARE_GPU_SPEC_INT64(T) DECLARE_GPU_SPEC(T, int64)\nTF_CALL_REAL_NUMBER_TYPES(DECLARE_GPU_SPEC_INT64);\n#undef DECLARE_GPU_SPEC_INT64\n#undef DECLARE_GPU_SPEC\n}  // namespace functor\n\n#define REGISTER_GPU_KERNELS(T) REGISTER_KERNELS(GPU, T, int64)\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_GPU_KERNELS);\n#undef REGISTER_GPU_KERNELS\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#undef REGISTER_KERNELS\n}  // namespace tensorflow"