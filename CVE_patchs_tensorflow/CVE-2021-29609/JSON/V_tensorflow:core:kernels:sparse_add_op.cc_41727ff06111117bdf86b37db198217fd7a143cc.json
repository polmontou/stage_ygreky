"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/op_requires.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\nnamespace tensorflow {\n\ntemplate <typename T, typename Treal>\nclass SparseAddOp : public OpKernel {\n public:\n  explicit SparseAddOp(OpKernelConstruction *ctx) : OpKernel(ctx) {}\n\n  void Compute(OpKernelContext *ctx) override {\n    // (0) validations\n    const Tensor *a_indices, *b_indices, *a_values_t, *b_values_t, *a_shape,\n        *b_shape, *thresh_t;\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_indices\", &a_indices));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_indices\", &b_indices));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsMatrix(a_indices->shape()) &&\n                    TensorShapeUtils::IsMatrix(b_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be matrices but received shapes: \",\n                    a_indices->shape().DebugString(), \" and \",\n                    b_indices->shape().DebugString()));\n    const int64 a_nnz = a_indices->dim_size(0);\n    const int64 b_nnz = b_indices->dim_size(0);\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_values\", &a_values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_values\", &b_values_t));\n\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(a_values_t->shape()) &&\n                    TensorShapeUtils::IsVector(b_values_t->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be vectors but received shapes: \",\n                    a_values_t->shape().DebugString(), \" and \",\n                    b_values_t->shape().DebugString()));\n    auto a_values = ctx->input(1).vec<T>();\n    auto b_values = ctx->input(4).vec<T>();\n    OP_REQUIRES(\n        ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,\n        errors::InvalidArgument(\"Expected \", a_nnz, \" and \", b_nnz,\n                                \" non-empty input values, got \",\n                                a_values.size(), \" and \", b_values.size()));\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_shape\", &a_shape));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_shape\", &b_shape));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(a_shape->shape()) &&\n                    TensorShapeUtils::IsVector(b_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shapes should be a vector but received shapes \",\n                    a_shape->shape().DebugString(), \" and \",\n                    b_shape->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, a_shape->IsSameSize(*b_shape),\n        errors::InvalidArgument(\n            \"Operands do not have the same ranks; got shapes: \",\n            a_shape->SummarizeValue(10), \" and \", b_shape->SummarizeValue(10)));\n    const auto a_shape_flat = a_shape->flat<int64>();\n    const auto b_shape_flat = b_shape->flat<int64>();\n    for (int i = 0; i < a_shape->NumElements(); ++i) {\n      OP_REQUIRES(ctx, a_shape_flat(i) == b_shape_flat(i),\n                  errors::InvalidArgument(\n                      \"Operands' shapes do not match: got \", a_shape_flat(i),\n                      \" and \", b_shape_flat(i), \" for dimension \", i));\n    }\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"thresh\", &thresh_t));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(thresh_t->shape()),\n                errors::InvalidArgument(\n                    \"The magnitude threshold must be a scalar: got shape \",\n                    thresh_t->shape().DebugString()));\n    // std::abs() so that it works for complex{64,128} values as well\n    const Treal thresh = thresh_t->scalar<Treal>()();\n\n    // (1) do a pass over inputs, and append values and indices to vectors\n    auto a_indices_mat = a_indices->matrix<int64>();\n    auto b_indices_mat = b_indices->matrix<int64>();\n    std::vector<std::pair<bool, int64>> entries_to_copy;  // from_a?, idx\n    entries_to_copy.reserve(a_nnz + b_nnz);\n    std::vector<T> out_values;\n    const int num_dims = a_shape->dim_size(0);\n\n    OP_REQUIRES(ctx, num_dims > 0,\n                errors::InvalidArgument(\"Invalid input_a shape. Received: \",\n                                        a_shape->DebugString()));\n\n    // The input and output sparse tensors are assumed to be ordered along\n    // increasing dimension number.\n    int64 i = 0, j = 0;\n    T s;\n    while (i < a_nnz && j < b_nnz) {\n      switch (sparse::DimComparator::cmp(a_indices_mat, b_indices_mat, i, j,\n                                         num_dims)) {\n        case -1:\n          entries_to_copy.emplace_back(true, i);\n          out_values.push_back(a_values(i));\n          ++i;\n          break;\n        case 0:\n          s = a_values(i) + b_values(j);\n          if (thresh <= std::abs(s)) {\n            entries_to_copy.emplace_back(true, i);\n            out_values.push_back(s);\n          }\n          ++i;\n          ++j;\n          break;\n        case 1:\n          entries_to_copy.emplace_back(false, j);\n          out_values.push_back(b_values(j));\n          ++j;\n          break;\n      }\n    }\n\n#define HANDLE_LEFTOVERS(A_OR_B, IDX, IS_A)     \\\n  while (IDX < A_OR_B##_nnz) {                  \\\n    entries_to_copy.emplace_back(IS_A, IDX);    \\\n    out_values.push_back(A_OR_B##_values(IDX)); \\\n    ++IDX;                                      \\\n  }\n\n    // at most one of these calls appends new values\n    HANDLE_LEFTOVERS(a, i, true);\n    HANDLE_LEFTOVERS(b, j, false);\n#undef HANDLE_LEFTOVERS\n\n    // (2) allocate and fill output tensors\n    const int64 sum_nnz = out_values.size();\n    Tensor *out_indices_t, *out_values_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),\n                                        &out_indices_t));\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &out_values_t));\n    auto out_indices_mat = out_indices_t->matrix<int64>();\n    auto out_values_flat = out_values_t->vec<T>();\n\n    for (i = 0; i < sum_nnz; ++i) {\n      const bool from_a = entries_to_copy[i].first;\n      const int64 idx = entries_to_copy[i].second;\n      out_indices_mat.chip<0>(i) =\n          from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);\n    }\n    if (sum_nnz > 0) {\n      std::copy_n(out_values.begin(), sum_nnz, &out_values_flat(0));\n    }\n    ctx->set_output(2, *a_shape);\n  }\n};\n\n#define REGISTER_KERNELS(type, thresh_type)                           \\\n  REGISTER_KERNEL_BUILDER(                                            \\\n      Name(\"SparseAdd\").Device(DEVICE_CPU).TypeConstraint<type>(\"T\"), \\\n      SparseAddOp<type, thresh_type>)\n\n// The list below is equivalent to TF_CALL_REAL_NUMBER_TYPES, minus uint8.  This\n// is because std::abs() on uint8 does not compile.\nREGISTER_KERNELS(float, float);\nREGISTER_KERNELS(double, double);\nREGISTER_KERNELS(int64, int64);\nREGISTER_KERNELS(int32, int32);\nREGISTER_KERNELS(int16, int16);\nREGISTER_KERNELS(int8, int8);\nREGISTER_KERNELS(complex64, float);\nREGISTER_KERNELS(complex128, double);\n#undef REGISTER_KERNELS\n}  // namespace tensorflow"