"diff --git a/tensorflow/python/ops/parsing_ops.py b/tensorflow/python/ops/parsing_ops.py\nindex fa739108f91..64de34fbcde 100644\n--- a/tensorflow/python/ops/parsing_ops.py\n+++ b/tensorflow/python/ops/parsing_ops.py\n@@ -850,8 +850,8 @@ def decode_raw(input_bytes,\n                name=None):\n   r\"\"\"Convert raw bytes from input tensor into numeric tensors.\n \n-  The input tensor is interpreted as a sequence of bytes. These bytes are then\n-  decoded as numbers in the format specified by `out_type`.\n+  Every component of the input tensor is interpreted as a sequence of bytes.\n+  These bytes are then decoded as numbers in the format specified by `out_type`.\n \n   >>> tf.io.decode_raw(tf.constant(\"1\"), tf.uint8)\n   <tf.Tensor: shape=(1,), dtype=uint8, numpy=array([49], dtype=uint8)>\n@@ -909,22 +909,35 @@ def decode_raw(input_bytes,\n   >>> tf.io.decode_raw(tf.constant([\"1212\"]), tf.uint16, fixed_length=4)\n   <tf.Tensor: shape=(1, 2), dtype=uint16, numpy=array([[12849, 12849]], ...\n \n-  Note: There is currently a bug in `fixed_length` that can result in data loss:\n-\n-  >>> # truncated to length of type as it matches fixed_length\n-  >>> tf.io.decode_raw(tf.constant([\"1212\"]), tf.uint16, fixed_length=2)\n-  <tf.Tensor: shape=(1, 1), dtype=uint16, numpy=array([[12849]], dtype=uint16)>\n-  >>> # ignores the second component\n-  >>> tf.io.decode_raw(tf.constant([\"12\",\"34\"]), tf.uint16, fixed_length=2)\n-  <tf.Tensor: shape=(2, 1), dtype=uint16, numpy=\n-  array([[12849],\n-         [    0]], dtype=uint16)>\n-  >>> tf.io.decode_raw(tf.constant([\"12\",\"34\"]), tf.uint16, fixed_length=4)\n-  <tf.Tensor: shape=(2, 2), dtype=uint16, numpy=\n-  array([[12849,     0],\n-         [    0,     0]], dtype=uint16)>\n-\n-  This will be fixed on a future release of TensorFlow.\n+  If the input value is larger than `fixed_length`, it is truncated:\n+\n+  >>> x=''.join([chr(1), chr(2), chr(3), chr(4)])\n+  >>> tf.io.decode_raw(x, tf.uint16, fixed_length=2)\n+  <tf.Tensor: shape=(1,), dtype=uint16, numpy=array([513], dtype=uint16)>\n+  >>> hex(513)\n+  '0x201'\n+\n+  If `little_endian` and `fixed_length` are specified, truncation to the fixed\n+  length occurs before endianness conversion:\n+\n+  >>> x=''.join([chr(1), chr(2), chr(3), chr(4)])\n+  >>> tf.io.decode_raw(x, tf.uint16, fixed_length=2, little_endian=False)\n+  <tf.Tensor: shape=(1,), dtype=uint16, numpy=array([258], dtype=uint16)>\n+  >>> hex(258)\n+  '0x102'\n+\n+  If input values all have the same length, then specifying `fixed_length`\n+  equal to the size of the strings should not change output:\n+\n+  >>> x = [\"12345678\", \"87654321\"]\n+  >>> tf.io.decode_raw(x, tf.int16)\n+  <tf.Tensor: shape=(2, 4), dtype=int16, numpy=\n+  array([[12849, 13363, 13877, 14391],\n+         [14136, 13622, 13108, 12594]], dtype=int16)>\n+  >>> tf.io.decode_raw(x, tf.int16, fixed_length=len(x[0]))\n+  <tf.Tensor: shape=(2, 4), dtype=int16, numpy=\n+  array([[12849, 13363, 13877, 14391],\n+         [14136, 13622, 13108, 12594]], dtype=int16)>\n \n   Args:\n     input_bytes:"