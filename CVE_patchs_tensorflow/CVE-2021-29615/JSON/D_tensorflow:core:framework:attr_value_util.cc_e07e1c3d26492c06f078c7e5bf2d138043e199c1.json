"diff --git a/tensorflow/core/framework/attr_value_util.cc b/tensorflow/core/framework/attr_value_util.cc\nindex 712e205c587..76fe36e7f1e 100644\n--- a/tensorflow/core/framework/attr_value_util.cc\n+++ b/tensorflow/core/framework/attr_value_util.cc\n@@ -38,6 +38,9 @@ namespace {\n // Do not construct large tensors to compute their hash or compare for equality.\n constexpr int kMaxAttrValueTensorByteSize = 32 * 1024 * 1024;  // 32mb\n \n+// Limit nesting of tensors to 100 deep to prevent memory overflow.\n+constexpr int kMaxTensorNestDepth = 100;\n+\n // Return the size of the tensor represented by this TensorProto. If shape is\n // not fully defined return -1.\n int64 TensorByteSize(const TensorProto& t) {\n@@ -224,6 +227,54 @@ string SummarizeFunc(const NameAttrList& func) {\n   return strings::StrCat(func.name(), \"[\", absl::StrJoin(entries, \", \"), \"]\");\n }\n \n+bool ParseAttrValueHelper_TensorNestsUnderLimit(int limit, string to_parse) {\n+  int nests = 0;\n+  int maxed_out = to_parse.length();\n+  int open_curly = to_parse.find('{');\n+  int open_bracket = to_parse.find('<');\n+  int close_curly = to_parse.find('}');\n+  int close_bracket = to_parse.find('>');\n+  if (open_curly == -1) {\n+    open_curly = maxed_out;\n+  }\n+  if (open_bracket == -1) {\n+    open_bracket = maxed_out;\n+  }\n+  int min = std::min(open_curly, open_bracket);\n+  do {\n+    if (open_curly == maxed_out && open_bracket == maxed_out) {\n+      return true;\n+    }\n+    if (min == open_curly) {\n+      nests += 1;\n+      open_curly = to_parse.find('{', open_curly + 1);\n+      if (open_curly == -1) {\n+        open_curly = maxed_out;\n+      }\n+    } else if (min == open_bracket) {\n+      nests += 1;\n+      open_bracket = to_parse.find('<', open_bracket + 1);\n+      if (open_bracket == -1) {\n+        open_bracket = maxed_out;\n+      }\n+    } else if (min == close_curly) {\n+      nests -= 1;\n+      close_curly = to_parse.find('}', close_curly + 1);\n+      if (close_curly == -1) {\n+        close_curly = maxed_out;\n+      }\n+    } else if (min == close_bracket) {\n+      nests -= 1;\n+      close_bracket = to_parse.find('>', close_bracket + 1);\n+      if (close_bracket == -1) {\n+        close_bracket = maxed_out;\n+      }\n+    }\n+    min = std::min({open_curly, open_bracket, close_curly, close_bracket});\n+  } while (nests < 100);\n+  return false;\n+}\n+\n }  // namespace\n \n string SummarizeAttrValue(const AttrValue& attr_value) {\n@@ -448,7 +499,12 @@ bool ParseAttrValue(StringPiece type, StringPiece text, AttrValue* out) {\n   } else {\n     to_parse = strings::StrCat(field_name, \": \", text);\n   }\n-\n+  if (field_name == \"tensor\") {\n+    if (!ParseAttrValueHelper_TensorNestsUnderLimit(kMaxTensorNestDepth,\n+                                                    to_parse)) {\n+      return false;\n+    }\n+  }\n   return ProtoParseFromString(to_parse, out);\n }\n "