"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/grappler/optimizers/arithmetic_optimizer.h\"\n\n#include <algorithm>\n#include <deque>\n#include <limits>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#include \"absl/container/flat_hash_map.h\"\n#include \"absl/container/flat_hash_set.h\"\n#include \"absl/strings/str_join.h\"\n#include \"tensorflow/core/framework/attr_value.pb.h\"\n#include \"tensorflow/core/framework/attr_value_util.h\"\n#include \"tensorflow/core/framework/node_def.pb.h\"\n#include \"tensorflow/core/framework/node_def_util.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/tensor.pb.h\"\n#include \"tensorflow/core/framework/tensor_shape.pb.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/grappler/costs/graph_properties.h\"\n#include \"tensorflow/core/grappler/graph_topology_view.h\"\n#include \"tensorflow/core/grappler/grappler_item.h\"\n#include \"tensorflow/core/grappler/op_types.h\"\n#include \"tensorflow/core/grappler/optimizers/constant_folding.h\"\n#include \"tensorflow/core/grappler/optimizers/graph_optimizer_stage.h\"\n#include \"tensorflow/core/grappler/utils.h\"\n#include \"tensorflow/core/grappler/utils/canonicalizer.h\"\n#include \"tensorflow/core/grappler/utils/symbolic_shapes.h\"\n#include \"tensorflow/core/grappler/utils/topological_sort.h\"\n#include \"tensorflow/core/grappler/utils/traversal.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/hash/hash.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/tensor_coding.h\"\n#include \"tensorflow/core/protobuf/error_codes.pb.h\"\n#include \"tensorflow/core/util/device_name_utils.h\"\n#include \"tensorflow/core/util/saved_tensor_slice_util.h\"\n#include \"tensorflow/core/util/strided_slice_op.h\"\n\nusing tensorflow::strings::StrCat;\n\nnamespace tensorflow {\nnamespace grappler {\nnamespace {\n\n// Mark nodes created or optimized by a stage with a tag.\nconstexpr char kAddOpsRewriteTag[] =\n    \"_grappler_ArithmeticOptimizer_AddOpsRewriteStage\";\nconstexpr char kMinimizeBroadcastsTag[] =\n    \"_grappler_ArithmeticOptimizer_MinimizeBroadcasts\";\n\n// Extract values from a Const op to `values`. Returns true if succeeds.\ntemplate <typename T>\nbool ValuesFromConstNode(const NodeDef& node, std::vector<T>* values) {\n  if (node.op() != \"Const\") {\n    return false;\n  }\n\n  if (node.attr().count(\"dtype\") == 0 || node.attr().count(\"value\") == 0 ||\n      node.attr().at(\"dtype\").type() != DataTypeToEnum<T>::value) {\n    return false;\n  }\n\n  // TensorProto represents the content of the tensor in either <type>_val or\n  // tensor_content.\n  const TensorProto& tensor = node.attr().at(\"value\").tensor();\n  typename checkpoint::SaveTypeTraits<T>::RepeatedField* tensor_values =\n      checkpoint::MutableTensorProtoData<T>(const_cast<TensorProto*>(&tensor));\n\n  if (!tensor_values->empty() && tensor.has_tensor_shape()) {\n    // When tensor_shape is set, theoretically the representation of the data\n    // could be compressed. So, before copying values to the returned vector,\n    // make sure no compression happens.\n    const TensorShapeProto& shape = tensor.tensor_shape();\n    if (shape.dim_size() == 1 && shape.dim(0).size() == tensor_values->size()) {\n      values->insert(values->end(), tensor_values->begin(),\n                     tensor_values->end());\n      return true;\n    }\n  }\n\n  const auto tensor_content_size = tensor.tensor_content().size();\n  if (tensor_content_size > 0) {\n    CHECK_EQ(0, tensor_content_size % sizeof(T))\n        << \"tensor_content_size (\" << tensor_content_size\n        << \") is not a multiple of \" << sizeof(T);\n    values->resize(tensor_content_size / sizeof(T));\n    port::CopyToArray(tensor.tensor_content(),\n                      reinterpret_cast<char*>(values->data()));\n    return true;\n  }\n\n  return false;\n}\n\nbool MaybeAddControlInput(const string& new_input, NodeDef* node,\n                          GraphDef* graph, NodeMap* node_map) {\n  bool already_exists = false;\n  for (const string& input : node->input()) {\n    if (input == new_input || AsControlDependency(input) == new_input) {\n      already_exists = true;\n      break;\n    }\n  }\n  if (!already_exists) {\n    const string ctrl_dep =\n        ConstantFolding::AddControlDependency(new_input, graph, node_map);\n    node->add_input(ctrl_dep);\n    node_map->AddOutput(NodeName(new_input), node->name());\n  }\n  return !already_exists;\n}\n\nvoid SetDataTypeToAttr(DataType dtype, const string& attr_name, NodeDef* node) {\n  (*node->mutable_attr())[attr_name].set_type(dtype);\n}\n\nNodeDef* GetTailOfValuePreservingChain(\n    const NodeDef& node, const NodeMap& node_map,\n    const std::unordered_set<string>& nodes_to_preserve) {\n  auto is_value_preserving_non_branching = [&](const NodeDef& node) {\n    return nodes_to_preserve.find(node.name()) == nodes_to_preserve.end() &&\n           IsValuePreserving(node) && NumNonControlOutputs(node, node_map) == 1;\n  };\n  return GetTailOfChain(node, node_map, /*follow_control_input=*/false,\n                        is_value_preserving_non_branching);\n}\n\nNodeDef* GetTailOfIdempotentChain(\n    const NodeDef& node, const NodeMap& node_map,\n    const std::unordered_set<string>& nodes_to_preserve) {\n  auto is_idempotent_non_branching = [&](const NodeDef& node) {\n    return nodes_to_preserve.find(node.name()) == nodes_to_preserve.end() &&\n           IsIdempotent(node) && NumNonControlOutputs(node, node_map) == 1;\n  };\n  return GetTailOfChain(node, node_map, /*follow_control_input=*/false,\n                        is_idempotent_non_branching);\n}\n\n// GetElementUnexhaustive tries to get the value of an element in a tensor and\n// turn it into complex128 type. It only check for a limited number of data\n// types, so it's unexhaustive.\nbool GetElementUnexhaustive(const Tensor& t, int i, const std::set<int>& dtypes,\n                            complex128* element) {\n  if (dtypes.find(t.dtype()) == dtypes.end()) return false;\n  switch (t.dtype()) {\n    case DT_BFLOAT16:\n      *element = complex128(t.flat<bfloat16>()(i));\n      return true;\n    case DT_HALF:\n      *element = complex128(static_cast<double>(t.flat<Eigen::half>()(i)), 0);\n      return true;\n    case DT_INT32:\n      *element = complex128(t.flat<int32>()(i));\n      return true;\n    case DT_INT64:\n      *element = complex128(t.flat<int64>()(i));\n      return true;\n    case DT_FLOAT:\n      *element = complex128(t.flat<float>()(i));\n      return true;\n    case DT_DOUBLE:\n      *element = complex128(t.flat<double>()(i));\n      return true;\n    case DT_COMPLEX64:\n      *element = complex128(t.flat<complex64>()(i));\n      return true;\n    case DT_COMPLEX128:\n      *element = t.flat<complex128>()(i);\n      return true;\n    default:\n      return false;\n  }\n}\n\nbool NodeIsOnCpu(const NodeDef& node) {\n  string task;\n  string device;\n  return DeviceNameUtils::SplitDeviceName(node.device(), &task, &device) &&\n         absl::StrContains(device, DEVICE_CPU);\n}\n\n// True if all regular (non-control) inputs reference the same node or if there\n// are no non-control inputs\nbool AllRegularInputsEqual(const NodeDef& node) {\n  if (!HasRegularInputs(node)) return true;\n  for (int i = 1; i < node.input_size(); ++i) {\n    if (IsControlInput(node.input(i))) {\n      break;\n    }\n    if (node.input(0) != node.input(i)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Graph optimizer context extension specific to ArithmeticOptimizer.\nstruct ArithmeticOptimizerContext {\n  explicit ArithmeticOptimizerContext(SetVector<NodeDef*>* nodes_to_simplify)\n      : nodes_to_simplify(nodes_to_simplify) {}\n  SetVector<NodeDef*>* nodes_to_simplify;\n};\n\n// Base class for single arithmetic optimization: e.g. Bitcast optimization,\n// AddOps optimization, etc...\nclass ArithmeticOptimizerStage : public GraphOptimizerStage<string> {\n public:\n  explicit ArithmeticOptimizerStage(const string& name,\n                                    const GraphOptimizerContext& ctx,\n                                    const ArithmeticOptimizerContext ctx_ext)\n      : GraphOptimizerStage(\"ArithmeticOptimizer\", name, ctx),\n        ctx_ext_(ctx_ext) {}\n  ~ArithmeticOptimizerStage() override = default;\n\n protected:\n  // Simplification graph rewrite can create additional nodes that are inputs\n  // to final simplified node, they can be also added to the arithmetic\n  // optimizer queue for further optimization.\n  void AddToOptimizationQueue(NodeDef* node) {\n    ctx_ext_.nodes_to_simplify->PushBack(node);\n  }\n\n  // Update consumers of node to take new_input as input instead.\n  void UpdateConsumers(NodeDef* node, const string& new_input) {\n    const string& node_name = node->name();\n    const auto consumers = ctx().node_map->GetOutputs(node_name);\n    for (NodeDef* consumer : consumers) {\n      for (int i = 0; i < consumer->input_size(); ++i) {\n        if (consumer->input(i) == node_name &&\n            consumer->name() != NodeName(new_input)) {\n          consumer->set_input(i, new_input);\n          ctx().node_map->UpdateInput(consumer->name(), node_name, new_input);\n        }\n      }\n      AddToOptimizationQueue(consumer);\n    }\n  }\n\n  // TODO(ezhulenev): remove this method from ArithmeticOptimizer when all\n  // optimizations will be migrated to stages\n  void ForwardControlDependencies(\n      NodeDef* target_node, const std::vector<const NodeDef*>& src_nodes) {\n    for (const auto& src : src_nodes) {\n      for (int i = src->input_size() - 1; i >= 0; --i) {\n        if (IsControlInput(src->input(i))) {\n          *target_node->add_input() = src->input(i);\n          ctx().node_map->AddOutput(NodeName(src->input(i)),\n                                    target_node->name());\n        } else {\n          break;\n        }\n      }\n    }\n    DedupControlInputs(target_node);\n  }\n\n  bool IsReallyConstant(const NodeDef& node) const {\n    if (!IsConstant(node)) {\n      return false;\n    }\n    // If the node is fed it's not constant anymore.\n    return ctx().feed_nodes->find(node.name()) == ctx().feed_nodes->end();\n  }\n\n  bool IsInPreserveSet(const NodeDef& node) const {\n    return ctx().nodes_to_preserve->find(node.name()) !=\n           ctx().nodes_to_preserve->end();\n  }\n\n  // TODO(ezhulenev): move to GraphOptimizerStage?\n  bool IsDrivenByControlDependency(const NodeDef& node) const {\n    return std::any_of(\n        node.input().begin(), node.input().end(),\n        [](const string& input) { return IsControlInput(input); });\n  }\n\n  // TODO(ezhulenev): move to GraphOptimizerStage?\n  bool DrivesControlDependency(const NodeDef& node) const {\n    for (const NodeDef* output : ctx().node_map->GetOutputs(node.name())) {\n      for (int i = 0; i < output->input_size(); ++i) {\n        const TensorId tensor = ParseTensorName(output->input(i));\n        if (tensor.node() == node.name() && tensor.index() < 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  bool GetTensorFromConstNode(const string& node_name_or_input,\n                              Tensor* tensor) {\n    const NodeDef* node = ctx().node_map->GetNode(node_name_or_input);\n    return node != nullptr && IsReallyConstant(*node) &&\n           CheckAttrExists(*node, \"value\").ok() &&\n           tensor->FromProto(node->attr().at(\"value\").tensor());\n  }\n\n private:\n  // Extended context required for ArithmeticOptimizer.\n  const ArithmeticOptimizerContext ctx_ext_;\n};\n\n// Subtype of ArithmeticOptimizerStage that does optimization by rewriting a\n// group of nodes from the optimized graph.\n//\n// * AddOpsRewrite:\n//   Rewrite a group of Add/AddN with compact Add/AddN tree\n//\n// * MinimizeBroadcasts:\n//   Rewrite a group of binary associative ops, reordering\n//   inputs, to minimize the cost of broadcast\nclass ArithmeticNodesGroupOptimizerStage : public ArithmeticOptimizerStage {\n public:\n  explicit ArithmeticNodesGroupOptimizerStage(\n      const string& name, const GraphOptimizerContext& ctx,\n      const ArithmeticOptimizerContext ctx_ext)\n      : ArithmeticOptimizerStage(name, ctx, ctx_ext) {}\n  ~ArithmeticNodesGroupOptimizerStage() override = default;\n\n  // Input name with a statically inferred shape from GraphProperties\n  struct InputAndShape {\n    InputAndShape(const string& input, const TensorShapeProto& shape)\n        : input(input), shape(shape) {}\n    string input;\n    TensorShapeProto shape;\n  };\n\n  // Subgraph (subtree) of nodes, that we want to optimize in \"one shot\" (e.g.\n  // all the Add nodes that we plan to rewrite with a single AddN). Subgraph is\n  // obtained by graph traversal, starting from a root node.\n  struct OptimizedNodesGroup {\n    NodeDef* root_node;\n    TensorShapeProto root_shape;\n    // Optimized nodes that will be updated or removed by rewrite\n    std::vector<NodeDef*> optimized_nodes;\n    // Inputs to optimized nodes\n    std::vector<InputAndShape> inputs;\n  };\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    TF_RETURN_IF_ERROR(EnsureNodeIsSupported(node));\n\n    OptimizedNodesGroup group;\n    TF_RETURN_IF_ERROR(CreateOptimizedNodesGroup(node, &group));\n\n    if (!group.optimized_nodes.empty()) {\n      *simplified_node_name = RewriteOptimizedNodesGroup(group);\n    }\n\n    return Status::OK();\n  }\n\n protected:\n  // Modify the optimized graph after nodes group was successfully identified\n  virtual string RewriteOptimizedNodesGroup(\n      const OptimizedNodesGroup& group) = 0;\n\n  // Check if input can become a part of current optimized nodes group.\n  virtual bool IsAbsorbableByOptimizedNodesGroup(\n      const OptimizedNodesGroup& group, const NodeDef& node) const = 0;\n\n  Status AbsorbInputByOptimizedNodesGroup(const string& input,\n                                          OptimizedNodesGroup* group) const {\n    std::deque<const string*> input_tensors;\n    input_tensors.push_front(&input);\n\n    while (!input_tensors.empty()) {\n      const string* input_tensor = input_tensors.front();\n      input_tensors.pop_front();\n\n      // Get a node for the input tensor.\n      NodeDef* input_node;\n      TF_RETURN_IF_ERROR(GetInputNode(*input_tensor, &input_node));\n\n      if (IsAbsorbableByOptimizedNodesGroup(*group, *input_node)) {\n        group->optimized_nodes.push_back(input_node);\n        for (int i = input_node->input_size() - 1; i >= 0; --i) {\n          const string& absorbed_node_input = input_node->input(i);\n          // TODO(ezhulenev): support control inputs\n          if (IsControlInput(absorbed_node_input)) continue;\n          input_tensors.push_front(&absorbed_node_input);\n        }\n      } else {\n        // If input node can't be absorbed, add it to OptimizedNodesGroup input.\n        const OpInfo::TensorProperties* properties;\n        TF_RETURN_IF_ERROR(GetTensorProperties(*input_tensor, &properties));\n        group->inputs.emplace_back(*input_tensor, properties->shape());\n      }\n    }\n\n    return Status::OK();\n  }\n\n  Status CreateOptimizedNodesGroup(NodeDef* root_node,\n                                   OptimizedNodesGroup* group) const {\n    const OpInfo::TensorProperties* root_node_output_properties;\n    TF_RETURN_IF_ERROR(\n        GetTensorProperties(root_node->name(), &root_node_output_properties));\n\n    group->root_node = root_node;\n    group->root_shape = root_node_output_properties->shape();\n\n    group->optimized_nodes.reserve(root_node->input_size());\n    for (int i = 0; i < root_node->input_size(); ++i) {\n      const string& input_i = root_node->input(i);\n      // TODO(ezhulenev): add support for control inputs\n      if (IsControlInput(input_i)) continue;\n      TF_RETURN_IF_ERROR(AbsorbInputByOptimizedNodesGroup(input_i, group));\n    }\n\n    return Status::OK();\n  }\n\n  // Check if all inputs can be broadcasted to the same shape\n  // TODO(ezhulenev): move to GraphOptimizerStage?\n  bool HasAllInputsBroadcastableToShape(\n      const NodeDef& node, const OpInfo::TensorProperties& properties) const {\n    auto is_broadcastable = [this, &properties](const string& input) {\n      const OpInfo::TensorProperties* input_props;\n      Status has_input_properties = GetTensorProperties(input, &input_props);\n      return has_input_properties.ok() &&\n             ShapesBroadcastable(properties, *input_props);\n    };\n    return std::all_of(node.input().begin(), node.input().end(),\n                       is_broadcastable);\n  }\n\n  string ShapeSignature(const TensorShapeProto& shape) const {\n    string signature = strings::StrCat(\"rank:\", shape.dim_size(), \":dim\");\n    for (int i = 0; i < shape.dim_size(); ++i)\n      strings::StrAppend(&signature, \":\", shape.dim(i).size());\n    return signature;\n  }\n\n  void MarkWithTag(const StringPiece tag, NodeDef* node) {\n    AddNodeAttr(tag, true, node);\n  }\n\n  void MarkAllMembersWithTag(const OptimizedNodesGroup& group,\n                             const StringPiece tag) const {\n    AddNodeAttr(tag, true, group.root_node);\n    for (NodeDef* optimized_node : group.optimized_nodes) {\n      AddNodeAttr(tag, true, optimized_node);\n    }\n  }\n\n  bool IsOnTheSameDevice(const OptimizedNodesGroup& group,\n                         const NodeDef& node) const {\n    return group.root_node->device() == node.device();\n  }\n\n  bool IsInPreserveSet(const NodeDef& node) const {\n    return ctx().nodes_to_preserve->find(node.name()) !=\n           ctx().nodes_to_preserve->end();\n  }\n\n  bool IsMarkedWithTag(const NodeDef& node, const StringPiece tag) const {\n    return HasNodeAttr(node, tag);\n  }\n\n  bool IsMarkedWithAnyTag(const NodeDef& node, const StringPiece tag1,\n                          const StringPiece tag2) const {\n    return IsMarkedWithTag(node, tag1) || IsMarkedWithTag(node, tag2);\n  }\n};\n\n// Rewrite a tree of Add/AddN with a single AddN operation, consuming all the\n// original inputs of absorbed nodes.\n//\n// 1) All nodes must have the same device placement.\n//\n// 2) If All nodes in a Add/AddN subgraph have symbolically equal shape, tree is\n//    optimized to a single AddN node.\n//\n//                AddN_1\n//             /    |    \\\n//          Add_1   z   Add_2       -> AddN(x, y, z, w, q, e)\n//          /  \\        /  \\\n//         x    y      w    Add_3\n//                          / \\\n//                         q   e\n//\n// 3) If some nodes have different shape (it needs to be broadcastable to the\n//    shape of a \"root), tree is optimized to AddNs for symbolically equal\n//    shapes, and a tree of Add ops, that minimize broadcasts.\n//\n//                AddN_1                                 Add\n//             /    |    \\                              /  \\\n//          Add_1   z   Add_2       ->               Add    w\n//          /  \\        /  \\                        /   \\\n//         x    y      w    Add_3      AddN(x, y, q, e)  z\n//                          / \\\n//                         q   e\nclass AddOpsRewriteStage : public ArithmeticNodesGroupOptimizerStage {\n public:\n  explicit AddOpsRewriteStage(const GraphOptimizerContext& ctx,\n                              const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticNodesGroupOptimizerStage(\"AddOpsRewrite\", ctx, ctx_ext) {}\n  ~AddOpsRewriteStage() override = default;\n\n  // Check if a node can become a root of AddOpsGroup\n  bool IsSupported(const NodeDef* node) const override {\n    if (!CanOptimize(*node)) return false;\n\n    // shape must be symbolically defined and all inputs compatible with it\n    const OpInfo::TensorProperties* properties;\n    Status has_properties = GetTensorProperties(node->name(), &properties);\n    return has_properties.ok() && ShapeIsSymbolicallyDefined(*properties) &&\n           HasAllInputsBroadcastableToShape(*node, *properties);\n  }\n\n protected:\n  // Check if a node can be absorbed by current OptimizedNodesGroup\n  bool IsAbsorbableByOptimizedNodesGroup(const OptimizedNodesGroup& group,\n                                         const NodeDef& node) const override {\n    if (!CanOptimize(node)) return false;\n\n    if (!IsOnTheSameDevice(group, node)) {\n      return false;\n    }\n    // with a single output data consumer (presumably if we reach this node from\n    // previously absorbed or a root node, it means that this node is not used\n    // as an input to any other op, outside of the group)\n    if (NumNonControlDataOutputs(node, *ctx().node_map) != 1) {\n      return false;\n    }\n    // All input shapes must be broadcastable to the node shape\n    const OpInfo::TensorProperties* properties;\n    Status has_properties = GetTensorProperties(node.name(), &properties);\n    return has_properties.ok() &&\n           HasAllInputsBroadcastableToShape(node, *properties);\n  }\n\n  // Node requirements both for a root node and an absorbed node\n  bool CanOptimize(const NodeDef& node) const {\n    // TODO(ezhulenev): check if AccumulateNV2 can be supported too\n    if (!IsAdd(node) && !IsAddN(node)) {\n      return false;\n    }\n    if (IsInPreserveSet(node) || IsMarkedWithTag(node, kAddOpsRewriteTag)) {\n      return false;\n    }\n    // TODO(ezhulenev): relax this condition for root node\n    return !(IsDrivenByControlDependency(node) ||\n             DrivesControlDependency(node));\n  }\n\n  // Rewrite a group of add ops into a single AddN if all input shapes are\n  // symbolically equal. If not, create AddN for equal shapes first, and then\n  // build an Add tree, minimizing the cost of broadcasts.\n  string RewriteOptimizedNodesGroup(const OptimizedNodesGroup& group) override {\n    VLOG(2) << \"Collapse Add/AddN: root=\" << group.root_node->name()\n            << \" op=\" << group.root_node->op()\n            << \" num_optimized_nodes=\" << group.optimized_nodes.size()\n            << \" num_inputs=\" << group.inputs.size();\n\n    // Do not optimize any of the nodes that are part of this group.\n    MarkAllMembersWithTag(group, kAddOpsRewriteTag);\n\n    // All new nodes will be placed under the scope of a root node.\n    auto root_scope_and_name = ParseNodeScopeAndName(group.root_node->name());\n\n    // Find what shapes are present in the inputs of absorbed nodes.\n    std::unordered_map<string, std::vector<InputAndShape>> shape_sig_to_inputs;\n    for (const auto& input : group.inputs) {\n      shape_sig_to_inputs[ShapeSignature(input.shape)].push_back(input);\n    }\n\n    using SigKV = decltype(shape_sig_to_inputs)::value_type;\n    VLOG(3) << \"Add/AddN group has \" << shape_sig_to_inputs.size()\n            << \" unique shapes: \"\n            << absl::StrJoin(shape_sig_to_inputs, \", \",\n                             [](string* out, SigKV p) {\n                               strings::StrAppend(out, p.first);\n                             });\n\n    // Collect all the shapes from representative elements.\n    std::vector<TensorShapeProto> shapes;\n    shapes.reserve(shape_sig_to_inputs.size());\n    for (const auto& el : shape_sig_to_inputs)\n      shapes.push_back(el.second[0].shape);\n\n    // If all inputs have the same shape, rewrite whole group with a single AddN\n    if (shapes.size() == 1) {\n      string node_name = UniqueOptimizedNodeName(root_scope_and_name);\n      AddInputsOfSymbolicallyEqualShape(*group.root_node, node_name,\n                                        group.inputs);\n      return node_name;\n    }\n\n    // For inputs of different shapes:\n    // 1. Rewrite inputs of the same shape using AddN (leaf nodes)\n    // 2. Build a tree of Add nodes, minimizing cost of broadcast\n    std::sort(shapes.begin(), shapes.end(),\n              [](const TensorShapeProto& left, const TensorShapeProto& right) {\n                return CompareSymbolicallyShapedTensorSizes(left, right);\n              });\n\n    // optimized name for leaf AddN nodes\n    auto leaf_node_name = [&root_scope_and_name, this](int i) {\n      return UniqueOptimizedNodeName(root_scope_and_name,\n                                     strings::StrCat(\"Leaf_\", i));\n    };\n    // optimized name for internal nodes of a tree built up from AddN leaves\n    auto internal_node_name = [&root_scope_and_name, this](int i) {\n      return UniqueOptimizedNodeName(root_scope_and_name,\n                                     strings::StrCat(\"Internal_\", i));\n    };\n\n    // Add/AddN nodes that must be added to the tree\n    std::deque<InputAndShape> add_ops;\n\n    // Prepare leaf AddN nodes for inputs of equal shape\n    for (int i = 0, end = shapes.size(); i < end; ++i) {\n      const auto node_name = leaf_node_name(i);\n      const auto& inputs = shape_sig_to_inputs[ShapeSignature(shapes[i])];\n      add_ops.push_back(AddInputsOfSymbolicallyEqualShape(*group.root_node,\n                                                          node_name, inputs));\n    }\n\n    // Build up a tree of Add ops\n    int internal_nodes = 0;\n    do {\n      const InputAndShape lhs = add_ops.front();\n      add_ops.pop_front();\n      const InputAndShape rhs = add_ops.front();\n      add_ops.pop_front();\n      string name = add_ops.empty()\n                        ? UniqueOptimizedNodeName(root_scope_and_name)\n                        : internal_node_name(internal_nodes++);\n      InputAndShape add = AddAggregatedInputs(*group.root_node, name, lhs, rhs);\n      add_ops.push_front(add);\n    } while (add_ops.size() > 1);\n\n    InputAndShape optimized_root_node = add_ops.front();\n    return optimized_root_node.input;\n  }\n\n  // Add 'AddN' node to aggregate inputs of symbolically equal shape\n  InputAndShape AddInputsOfSymbolicallyEqualShape(\n      const NodeDef& root_node, const string& node_name,\n      const std::vector<InputAndShape>& inputs) {\n    CHECK(!inputs.empty()) << \"Inputs must be non-empty\";\n\n    // Do not create redundant AddN nodes\n    if (inputs.size() == 1 || root_node.attr().count(\"T\") == 0) {\n      return inputs[0];\n    }\n\n    // get shape from representative element\n    auto shape = inputs[0].shape;\n\n    // copy attributes from a root node\n    DataType dtype = root_node.attr().at(\"T\").type();\n\n    // add new AddN node\n    NodeDef* node = AddEmptyNode(node_name);\n    node->set_op(\"AddN\");\n    node->set_device(root_node.device());\n    (*node->mutable_attr())[\"T\"].set_type(dtype);\n    (*node->mutable_attr())[\"N\"].set_i(inputs.size());\n\n    for (const auto& inputAndShape : inputs) {\n      ctx().node_map->AddOutput(inputAndShape.input, node_name);\n      node->add_input(inputAndShape.input);\n    }\n\n    MarkWithTag(kAddOpsRewriteTag, node);\n    return InputAndShape(node_name, shape);\n  }\n\n  // Add a single 'Add' node to sum two inputs\n  InputAndShape AddAggregatedInputs(const NodeDef& root_node,\n                                    const string& node_name,\n                                    const InputAndShape& left,\n                                    const InputAndShape& right) {\n    // copy attributes from a root node\n    DataType dtype = root_node.attr().at(\"T\").type();\n\n    // add new Add node\n    NodeDef* node = AddEmptyNode(node_name);\n    node->set_op((dtype == DT_STRING || dtype == DT_STRING_REF) ? \"Add\"\n                                                                : \"AddV2\");\n    node->set_device(root_node.device());\n    (*node->mutable_attr())[\"T\"].set_type(dtype);\n    node->add_input(left.input);\n    node->add_input(right.input);\n\n    ctx().node_map->AddOutput(left.input, node_name);\n    ctx().node_map->AddOutput(right.input, node_name);\n\n    MarkWithTag(kAddOpsRewriteTag, node);\n    return InputAndShape(\n        node_name, TensorShapeProto());  // shape is not important at this point\n  }\n};\n\n// Use the distributive property of multiplication and division over addition,\n// along with commutativity of the former, to hoist common factors/denominators\n// out of aggregate nodes where ALL the inputs are Mul/Div nodes.\n// This pattern occurs frequently in regularization terms for the gradients\n// during training.\n//\n// For example, we can rewrite an expression of the form:\n//   AddN(Mul(x, y1), Mul(y2, x), Mul(x, y3), ... Mul(x, yn))\n// to the following:\n//   Mul(x, AddN(y1, y2, y3, ... yn))\n// For division, we can rewrite\n//   AddN(Div(y1, x), Div(y2, x), Div(y3, x), ... Div(yn, x))\n// to:\n//   Div(AddN(y1, y2, y3, ... yn), x)\nclass HoistCommonFactorOutOfAggregation : public ArithmeticOptimizerStage {\n public:\n  explicit HoistCommonFactorOutOfAggregation(\n      const GraphOptimizerContext& ctx,\n      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"HoistCommonFactor\", ctx, ctx_ext) {}\n  ~HoistCommonFactorOutOfAggregation() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsAggregate(*node) && NumNonControlInputs(*node) > 1 &&\n           !IsRewritten(node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    TF_RETURN_IF_ERROR(EnsureNodeIsSupported(node));\n\n    bool common_factor_is_denominator = false;\n    std::set<string> common_factors;\n    std::vector<string> ctrl_deps;\n    TF_RETURN_IF_ERROR(GetCommonFactors(\n        node, &common_factors, &common_factor_is_denominator, &ctrl_deps));\n\n    if (common_factors.size() == 1) {\n      const string& common_factor = *common_factors.begin();\n\n      // Gather up the non-shared factors\n      bool shapes_match = true;\n      std::vector<string> unique_factors;\n      TF_RETURN_IF_ERROR(GetUniqueFactors(node, common_factor,\n                                          common_factor_is_denominator,\n                                          &shapes_match, &unique_factors));\n\n      if (shapes_match) {\n        NodeDef* input_0;\n        TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &input_0));\n\n        // Use a copy of the first node for the outer multiplication/division.\n        NodeDef* new_outer_node = AddCopyNode(\n            OuterNodeName(node, common_factor_is_denominator), input_0);\n        // And a copy of aggregation node as one of the inner operands\n        NodeDef* new_add_node = AddCopyNode(InnerAddNodeName(node), node);\n\n        new_outer_node->set_device(node->device());\n        if (common_factor_is_denominator) {\n          new_outer_node->set_input(0, new_add_node->name());\n          new_outer_node->set_input(1, common_factor);\n        } else {\n          new_outer_node->set_input(0, common_factor);\n          new_outer_node->set_input(1, new_add_node->name());\n        }\n\n        ctx().node_map->AddOutput(common_factor, new_outer_node->name());\n        ctx().node_map->AddOutput(new_add_node->name(), new_outer_node->name());\n\n        // Hoist non-shared factors up into the new AddN node.\n        for (int i = 0, end = unique_factors.size(); i < end; ++i) {\n          const string& unique_factor_i = unique_factors[i];\n          new_add_node->set_input(i, unique_factor_i);\n          ctx().node_map->AddOutput(unique_factor_i, new_add_node->name());\n        }\n\n        // Add control deps on add node\n        for (const string& ctrl_dep : ctrl_deps) {\n          *new_add_node->add_input() = ctrl_dep;\n          ctx().node_map->AddOutput(NodeName(ctrl_dep), new_add_node->name());\n        }\n\n        // optimize new inner aggregation node\n        AddToOptimizationQueue(new_add_node);\n        // do not optimize the same node twice\n        rewritten_nodes_.insert(node->name());\n        *simplified_node_name = new_outer_node->name();\n      }\n    }\n    return Status::OK();\n  }\n\n private:\n  // Get a name for new outer node\n  string OuterNodeName(const NodeDef* node, bool is_div) const {\n    auto scope_and_name = ParseNodeScopeAndName(node->name());\n    return is_div ? OptimizedNodeName(scope_and_name, \"Div\")\n                  : OptimizedNodeName(scope_and_name, \"Mul\");\n  }\n\n  // Get a name new inner Add node\n  string InnerAddNodeName(const NodeDef* node) const {\n    auto scope_and_name = ParseNodeScopeAndName(node->name());\n    return OptimizedNodeName(scope_and_name, \"AddV2\");\n  }\n\n  // Determine the set of common factors if the input nodes are all Mul or\n  // Div nodes.\n  Status GetCommonFactors(const NodeDef* node, std::set<string>* common_factors,\n                          bool* common_factor_is_denominator,\n                          std::vector<string>* ctrl_deps) const {\n    CHECK(common_factors->empty());\n    CHECK_NOTNULL(common_factor_is_denominator);\n    *common_factor_is_denominator = false;\n\n    bool has_mul = false;\n    bool has_div = false;\n    for (int i = 0; i < node->input_size(); ++i) {\n      if (i > 0 && common_factors->empty()) break;\n      if (IsControlInput(node->input(i))) {\n        ctrl_deps->push_back(node->input(i));\n        continue;\n      }\n      NodeDef* input;\n      TF_RETURN_IF_ERROR(GetInputNode(node->input(i), &input));\n\n      if ((!IsMul(*input) && !IsAnyDiv(*input)) || (IsMul(*input) && has_div) ||\n          (IsAnyDiv(*input) && has_mul)) {\n        // Break if input is neither a Mul or Div, or if there are both Mul &\n        // Div Ops.\n        common_factors->clear();\n        break;\n      } else if (IsAnyDiv(*input)) {\n        has_div = true;\n        // In case of possible common dividers, we avoid hoisting out if any\n        // input is not float/double, since integer division is not distributive\n        // over addition.\n        const OpInfo::TensorProperties* properties0;\n        const OpInfo::TensorProperties* properties1;\n        TF_RETURN_IF_ERROR(GetTensorProperties(input->input(0), &properties0));\n        TF_RETURN_IF_ERROR(GetTensorProperties(input->input(1), &properties1));\n        if (properties0->dtype() != DT_FLOAT &&\n            properties0->dtype() != DT_DOUBLE &&\n            properties1->dtype() != DT_FLOAT &&\n            properties1->dtype() != DT_DOUBLE) {\n          common_factors->clear();\n          break;\n        }\n      } else if (IsMul(*input)) {\n        has_mul = true;\n      }\n\n      // We only focus on common factors from denominators if any Op is a\n      // Div.\n      std::set<string> factors_i =\n          has_mul ? std::set<string>{input->input(0), input->input(1)}\n                  : std::set<string>{input->input(1)};\n      if (i == 0) {\n        std::swap(*common_factors, factors_i);\n      } else {\n        std::set<string> intersection;\n        std::set_intersection(\n            factors_i.begin(), factors_i.end(), common_factors->begin(),\n            common_factors->end(),\n            std::inserter(intersection, intersection.begin()));\n        std::swap(*common_factors, intersection);\n      }\n      for (int i = 2; i < input->input_size(); ++i) {\n        ctrl_deps->push_back(input->input(i));\n      }\n    }\n\n    *common_factor_is_denominator = has_div;\n    return Status::OK();\n  }\n\n  // Gather up the non-shared factors (the y's in the example).\n  // Unless the aggregation is Add, we have to make sure that all the y's\n  // have the same shape since the other aggregation ops do not support\n  // broadcasting.\n  Status GetUniqueFactors(const NodeDef* node, const string& common_factor,\n                          const bool common_factor_is_denominator,\n                          bool* shapes_match,\n                          std::vector<string>* unique_factors) const {\n    *shapes_match = true;\n    unique_factors->reserve(node->input_size());\n\n    for (int i = 0; i < node->input_size() && *shapes_match; ++i) {\n      const string& input = node->input(i);\n      if (IsControlInput(input)) {\n        break;\n      }\n      NodeDef* inner_node;\n      TF_RETURN_IF_ERROR(GetInputNode(input, &inner_node));\n      const int unique_factor_index =\n          common_factor_is_denominator\n              ? 0\n              : (inner_node->input(0) == common_factor ? 1 : 0);\n      unique_factors->push_back(inner_node->input(unique_factor_index));\n      if (i > 0 && !IsAdd(*node)) {\n        const OpInfo::TensorProperties* lhs;\n        const OpInfo::TensorProperties* rhs;\n        TF_RETURN_IF_ERROR(GetTensorProperties(unique_factors->front(), &lhs));\n        TF_RETURN_IF_ERROR(GetTensorProperties(unique_factors->back(), &rhs));\n        *shapes_match = ShapesSymbolicallyEqual(*lhs, *rhs);\n      }\n    }\n    return Status::OK();\n  }\n\n  bool IsRewritten(const NodeDef* node) const {\n    // if graph rewrite happens in multiple passes without graph pruning between\n    // them, it's possible that rewritten node already exists in a graph\n    return rewritten_nodes_.find(node->name()) != rewritten_nodes_.end() ||\n           ctx().node_map->NodeExists(OuterNodeName(node, false)) ||\n           ctx().node_map->NodeExists(OuterNodeName(node, true)) ||\n           ctx().node_map->NodeExists(InnerAddNodeName(node));\n  }\n\n  // keep names of the nodes that were optimized by this stage\n  std::unordered_set<string> rewritten_nodes_;\n};\n\n// Binary associative ops can be re-ordered to minimize the number of broadcasts\n// and the size of a temporary tensors.\n//\n// Example: [a, c] - scalars, [b, d] - matrices\n//   @ - binary associative op (Add or Mul)\n//   @* - broadcast\n//\n//           @                      @*\n//        /     \\                /      \\\n//      @*       @*      ->     @        @\n//    /   \\    /   \\          /   \\    /   \\\n//   a     b  c     d        a     c  b     d\nclass MinimizeBroadcasts : public ArithmeticNodesGroupOptimizerStage {\n public:\n  explicit MinimizeBroadcasts(const GraphOptimizerContext& ctx,\n                              const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticNodesGroupOptimizerStage(\"MinimizeBroadcasts\", ctx, ctx_ext) {\n  }\n  ~MinimizeBroadcasts() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    if (!IsBinaryAssociative(*node)) return false;\n\n    if (IsMarkedWithAnyTag(*node, kMinimizeBroadcastsTag, kAddOpsRewriteTag))\n      return false;\n\n    // has a symbolically defined shape with broadcastable inputs\n    const OpInfo::TensorProperties* properties;\n    Status has_properties = GetTensorProperties(node->name(), &properties);\n    return has_properties.ok() && ShapeIsSymbolicallyDefined(*properties) &&\n           HasAllInputsBroadcastableToShape(*node, *properties);\n  }\n\n protected:\n  bool IsBinaryAssociative(const NodeDef& node) const {\n    return IsMul(node) || IsAdd(node);\n  }\n\n  bool IsSameOp(const OptimizedNodesGroup& group, const NodeDef& node) const {\n    return group.root_node->op() == node.op();\n  }\n\n  // Check if a node can be absorbed by current OptimizedNodesGroup\n  bool IsAbsorbableByOptimizedNodesGroup(const OptimizedNodesGroup& group,\n                                         const NodeDef& node) const override {\n    if (!IsSameOp(group, node)) {\n      return false;\n    }\n    if (IsInPreserveSet(node)) {\n      return false;\n    }\n    // Nodes optimized by AddOpsRewrite already have optimal broadcasts.\n    if (IsMarkedWithAnyTag(node, kMinimizeBroadcastsTag, kAddOpsRewriteTag)) {\n      return false;\n    }\n    if (IsDrivenByControlDependency(node) || DrivesControlDependency(node)) {\n      return false;\n    }\n    if (!IsOnTheSameDevice(group, node)) {\n      return false;\n    }\n    // Optimized nodes updated in place, and that would break the graph, if the\n    // node has multiple output consumers\n    if (NumNonControlOutputs(node, *ctx().node_map) != 1) {\n      return false;\n    }\n    // All input shapes must be broadcastable to the node shape\n    const OpInfo::TensorProperties* properties;\n    Status has_properties = GetTensorProperties(node.name(), &properties);\n    return has_properties.ok() &&\n           HasAllInputsBroadcastableToShape(node, *properties);\n  }\n\n  std::size_t CountUniqueShapes(const std::vector<InputAndShape>& inputs) {\n    std::set<string> sigs;\n    for (const auto& ias : inputs) {\n      sigs.insert(ShapeSignature(ias.shape));\n    }\n    return sigs.size();\n  }\n\n  string RewriteOptimizedNodesGroup(const OptimizedNodesGroup& group) override {\n    VLOG(2) << \"Minimize broadcast: root=\" << group.root_node->name()\n            << \" op=\" << group.root_node->op()\n            << \" num_optimized_nodes=\" << group.optimized_nodes.size();\n\n    // Do not optimize any of the nodes that are part of this group.\n    MarkAllMembersWithTag(group, kMinimizeBroadcastsTag);\n\n    if (CountUniqueShapes(group.inputs) <= 1) {\n      VLOG(3) << \"Skip min-bcast group with single unique shape\";\n      // nothing to optimize when all shapes are the same\n      return group.root_node->name();\n    }\n\n    auto num_nodes = /*root*/ 1 + group.optimized_nodes.size();\n    auto num_inputs = group.inputs.size();\n    CHECK_EQ(num_nodes, num_inputs - 1)\n        << \"Can't build a tree with \" << num_inputs << \" inputs, using \"\n        << num_nodes << \"binary op nodes.\";\n\n    std::deque<InputAndShape> add_ops(group.inputs.begin(), group.inputs.end());\n    std::deque<NodeDef*> optimized_nodes(group.optimized_nodes.begin(),\n                                         group.optimized_nodes.end());\n\n    // sort inputs by it's shape from smallest to largest\n    std::stable_sort(add_ops.begin(), add_ops.end(),\n                     [](const InputAndShape& lhs, const InputAndShape& rhs) {\n                       return CompareSymbolicallyShapedTensorSizes(lhs.shape,\n                                                                   rhs.shape);\n                     });\n\n    // If there is an odd number of inputs, last one is the largest, and we want\n    // to attach it to the root node, to build a well balanced tree.\n    std::deque<InputAndShape> add_ops_leftover;\n    if (add_ops.size() % 2 != 0) {\n      add_ops_leftover.push_back(add_ops.back());\n      add_ops.pop_back();\n    }\n\n    // At this point it's guaranteed that add_ops have even number of inputs.\n    do {\n      const InputAndShape lhs = add_ops.front();\n      add_ops.pop_front();\n      const InputAndShape rhs = add_ops.front();\n      add_ops.pop_front();\n\n      NodeDef* node;\n      if (!optimized_nodes.empty()) {\n        // re-purpose optimized nodes to build a new tree\n        node = optimized_nodes.back();\n        optimized_nodes.pop_back();\n      } else {\n        // or use root node if none optimized nodes left\n        node = group.root_node;\n      }\n      InputAndShape updated_node = UpdateInputs(lhs.input, rhs.input, node);\n\n      // Pushing updated node to the back of a deque will create a wide and\n      // short tree, pushing to the front will create a tall tree. We prefer to\n      // get a wide tree, it minimizes the potential number of temporary tensors\n      // required to keep in memory, though sometimes we can go up to prevent\n      // propagating a broadcast from leaves to the root. Example:\n      //\n      // inputs: [s, s, s, M] (s - scalar, M - matrix)\n      // @* - op with broadcast\n      //\n      //  (only push_back)           @*     (push_front first op)\n      //                            /  \\\n      //       @*                  @    M\n      //     /   \\                / \\\n      //    @     @*      ->     @   s\n      //   / \\   / \\            / \\\n      //  s   s s   M          s   s\n      if (add_ops.size() >= 2 &&\n          CompareSymbolicallyShapedTensorSizes(add_ops.at(0).shape,\n                                               add_ops.at(1).shape)) {\n        add_ops.push_front(updated_node);\n      } else {\n        add_ops.push_back(updated_node);\n      }\n    } while (add_ops.size() > 1);\n    CHECK_EQ(1, add_ops.size());\n\n    // attach the largest tensor to the root op\n    if (!add_ops_leftover.empty()) {\n      const InputAndShape lhs = add_ops.front();\n      add_ops.pop_front();\n      const InputAndShape rhs = add_ops_leftover.front();\n      InputAndShape updated_node =\n          UpdateInputs(lhs.input, rhs.input, group.root_node);\n      add_ops.push_back(updated_node);\n    }\n\n    return add_ops.front().input;\n  }\n\n  InputAndShape UpdateInputs(const string& input_0, const string& input_1,\n                             NodeDef* node) {\n    string old_input_0 = node->input(0);\n    string old_input_1 = node->input(1);\n\n    // Update inputs only if they changed\n    if (old_input_0 != input_0 || old_input_1 != input_1) {\n      node->set_input(0, input_0);\n      node->set_input(1, input_1);\n      // Invalidate node properties (shape)\n      ctx().graph_properties->ClearOutputProperties(node->name());\n      ctx().graph_properties->ClearInputProperties(node->name());\n      // Update the node map\n      ctx().node_map->RemoveOutput(NodeName(old_input_0), node->name());\n      ctx().node_map->RemoveOutput(NodeName(old_input_1), node->name());\n      ctx().node_map->AddOutput(NodeName(input_0), node->name());\n      ctx().node_map->AddOutput(NodeName(input_1), node->name());\n      // Add updated node to optimization queue\n      AddToOptimizationQueue(node);\n    }\n\n    TensorShapeProto shape;  // shape is not important at this point\n    return InputAndShape(node->name(), shape);\n  }\n};\n\n// Removes inverse transpose nodes\nclass RemoveIdentityTranspose : public ArithmeticOptimizerStage {\n public:\n  explicit RemoveIdentityTranspose(const GraphOptimizerContext& ctx,\n                                   const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveIdentityTranspose\", ctx, ctx_ext) {}\n  ~RemoveIdentityTranspose() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsTranspose(*node) || IsConjugateTranspose(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    TF_RETURN_IF_ERROR(EnsureNodeIsSupported(node));\n    NodeDef* tail = node;\n    tail = GetTailOfIdempotentChain(*tail, *ctx().node_map,\n                                    *ctx().nodes_to_preserve);\n    NodeDef* first_transpose;\n    TF_RETURN_IF_ERROR(GetInputNode(tail->input(0), &first_transpose));\n\n    NodeDef* node_perm;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(1), &node_perm));\n    if (!IsConstant(*node_perm)) {\n      return Status::OK();\n    }\n    std::vector<int64> node_perm_values;\n    TF_RETURN_IF_ERROR(GetPermutation(*node_perm, &node_perm_values));\n    if (first_transpose->op() == node->op()) {\n      // Remove pairs of transposes that cancel each other.\n      NodeDef* first_transpose_perm;\n      TF_RETURN_IF_ERROR(\n          GetInputNode(first_transpose->input(1), &first_transpose_perm));\n      if (!IsConstant(*first_transpose_perm)) {\n        return Status::OK();\n      }\n      std::vector<int64> first_transpose_perm_values;\n      TF_RETURN_IF_ERROR(\n          GetPermutation(*first_transpose_perm, &first_transpose_perm_values));\n      if (AreInversePermutations(node_perm_values,\n                                 first_transpose_perm_values)) {\n        if (tail == node) {\n          // Bypass adjacent pair.\n          *simplified_node_name = first_transpose->input(0);\n        } else {\n          // Bypass pair connected through chain.\n          tail->set_input(0, first_transpose->input(0));\n          ctx().node_map->UpdateInput(tail->name(), first_transpose->name(),\n                                      first_transpose->input(0));\n          ForwardControlDependencies(tail, {first_transpose});\n          *simplified_node_name = node->input(0);\n        }\n      }\n    } else {\n      // Remove simple identity transposes.\n      if (IsIdentityPermutation(node_perm_values)) {\n        if (IsConjugateTranspose(*node)) {\n          const NodeScopeAndName transpose =\n              ParseNodeScopeAndName(node->name());\n          const string optimized_node_name = OptimizedNodeName(transpose);\n          NodeDef* new_op = AddCopyNode(optimized_node_name, node);\n          new_op->set_op(\"Conj\");\n          new_op->mutable_input()->RemoveLast();\n          new_op->mutable_attr()->erase(\"Tperm\");\n          ForwardControlDependencies(new_op, {node});\n          *simplified_node_name = new_op->name();\n        } else {\n          *simplified_node_name = node->input(0);\n        }\n      }\n    }\n    return Status::OK();\n  }\n\n private:\n  Status GetPermutation(const NodeDef& node_perm,\n                        std::vector<int64>* perm64) const {\n    std::vector<int> perm32;\n    if (ValuesFromConstNode(node_perm, &perm32)) {\n      perm64->reserve(perm32.size());\n      for (int val : perm32) {\n        perm64->push_back(static_cast<int64>(val));\n      }\n      return Status::OK();\n    }\n    if (ValuesFromConstNode(node_perm, perm64)) {\n      return Status::OK();\n    }\n    return errors::InvalidArgument(\"Couldn't extract permutation from \",\n                                   node_perm.name());\n  }\n\n  bool AreInversePermutations(const std::vector<int64>& a,\n                              const std::vector<int64>& b) {\n    if (a.size() != b.size()) {\n      return false;\n    }\n    for (int i = 0, end = a.size(); i < end; ++i) {\n      if (a[b[i]] != i) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  bool IsIdentityPermutation(const std::vector<int64>& perm) {\n    for (int64 i = 0, end = perm.size(); i < end; ++i) {\n      if (i != perm[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\n// An involution is an element-wise function f(x) that is its own inverse,\n// i.e. f(f(x)) = x. If we can find a chain of ops\n//   f->op1->op2->...opn->f\n// where op1 through opn preserve the values of their inputs, we can remove\n// the two instances of the involution from the graph, since they cancel\n// each other.\nclass RemoveInvolution : public ArithmeticOptimizerStage {\n public:\n  explicit RemoveInvolution(const GraphOptimizerContext& ctx,\n                            const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveInvolution\", ctx, ctx_ext) {}\n  ~RemoveInvolution() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsInvolution(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    NodeDef* tail = GetTailOfValuePreservingChain(*node, *ctx().node_map,\n                                                  *ctx().nodes_to_preserve);\n\n    NodeDef* involution;\n    TF_RETURN_IF_ERROR(GetInputNode(tail->input(0), &involution));\n\n    if (involution->op() == node->op()) {\n      // Skip both *node and *involution since they cancel each other.\n      if (tail == node) {\n        // The two nodes to eliminate are adjacent.\n        *simplified_node_name = involution->input(0);\n      } else {\n        tail->set_input(0, involution->input(0));\n        ctx().node_map->UpdateInput(tail->name(), involution->name(),\n                                    involution->input(0));\n        *simplified_node_name = node->input(0);\n      }\n    }\n\n    return Status::OK();\n  }\n};\n\n// Remove redundant Bitcasts.\n// 1) Remove Bitcast whose source type and destination type are equal\n// 2) Rewrite Bitcast(Bitcast(x, type1), type2) => Bitcast(x, type2)\nclass RemoveRedundantBitcastStage : public ArithmeticOptimizerStage {\n public:\n  explicit RemoveRedundantBitcastStage(\n      const GraphOptimizerContext& ctx,\n      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveRedundantBitcast\", ctx, ctx_ext) {}\n  ~RemoveRedundantBitcastStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsBitcast(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    TF_RETURN_IF_ERROR(EnsureNodeIsSupported(node));\n\n    // Bypass Bitcast whose source type and destination type are equal.\n    AttrSlice attrs(*node);\n    DataType input_type;\n    TF_RETURN_IF_ERROR(GetNodeAttr(attrs, \"T\", &input_type));\n    DataType output_type;\n    TF_RETURN_IF_ERROR(GetNodeAttr(attrs, \"type\", &output_type));\n    if ((input_type == output_type) && !IsInPreserveSet(*node)) {\n      *simplified_node_name = node->input(0);\n      return Status::OK();\n    }\n\n    NodeDef* bitcast;\n    TF_RETURN_IF_ERROR(GetInputNode(node->name(), &bitcast));\n    NodeDef* operand;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &operand));\n\n    if (IsBitcast(*operand) && !IsInPreserveSet(*operand)) {\n      AttrSlice operand_attrs(*operand);\n      DataType operand_input_type;\n      TF_RETURN_IF_ERROR(GetNodeAttr(operand_attrs, \"T\", &operand_input_type));\n      // Bitcast(Bitcast(x, type1), type2) => Bitcast(x, type2)\n      bitcast->set_input(0, operand->input(0));\n      SetDataTypeToAttr(operand_input_type, \"T\", bitcast);\n      ctx().node_map->UpdateInput(bitcast->name(), bitcast->input(0),\n                                  operand->input(0));\n      AddToOptimizationQueue(bitcast);\n      *simplified_node_name = bitcast->name();\n    }\n\n    return Status::OK();\n  }\n};\n\n// Remove Casts whose source type and destination type are equal.\nclass RemoveRedundantCastStage : public ArithmeticOptimizerStage {\n public:\n  explicit RemoveRedundantCastStage(const GraphOptimizerContext& ctx,\n                                    const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveRedundantCast\", ctx, ctx_ext) {}\n  ~RemoveRedundantCastStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsCast(*node) && !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    TF_RETURN_IF_ERROR(EnsureNodeIsSupported(node));\n\n    // Bypass Cast whose source type and destination type are equal.\n    AttrSlice attrs(*node);\n    DataType input_type;\n    TF_RETURN_IF_ERROR(GetNodeAttr(attrs, \"SrcT\", &input_type));\n    DataType output_type;\n    TF_RETURN_IF_ERROR(GetNodeAttr(attrs, \"DstT\", &output_type));\n    if (input_type == output_type) {\n      *simplified_node_name = node->input(0);\n    }\n    return Status::OK();\n  }\n};\n\nclass RemoveNegationStage : public ArithmeticOptimizerStage {\n public:\n  explicit RemoveNegationStage(const GraphOptimizerContext& ctx,\n                               const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveNegation\", ctx, ctx_ext) {}\n  ~RemoveNegationStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return (IsAdd(*node) || IsSub(*node)) && !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    NodeDef* x;\n    NodeDef* y;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &x));\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(1), &y));\n    bool updated = false;\n    if (IsNeg(*y)) {\n      // a - (-b) = a + b or  a + (-b) = a - b\n      ForwardControlDependencies(node, {y});\n      ctx().node_map->UpdateInput(node->name(), node->input(1), y->input(0));\n      node->set_op(IsAdd(*node) ? \"Sub\" : \"AddV2\");\n      node->set_input(1, y->input(0));\n      updated = true;\n    } else if (IsAdd(*node) && IsNeg(*x)) {\n      // (-a) + b = b - a\n      ForwardControlDependencies(node, {x});\n      ctx().node_map->UpdateInput(node->name(), node->input(0), x->input(0));\n      node->set_op(\"Sub\");\n      node->mutable_input()->SwapElements(0, 1);\n      node->set_input(1, x->input(0));\n      updated = true;\n    }\n    if (updated) {\n      AddToOptimizationQueue(node);\n    }\n    return Status::OK();\n  }\n};\n\nclass RemoveLogicalNotStage : public ArithmeticOptimizerStage {\n public:\n  explicit RemoveLogicalNotStage(const GraphOptimizerContext& ctx,\n                                 const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveLogicalNot\", ctx, ctx_ext) {}\n  ~RemoveLogicalNotStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsLogicalNot(*node) && !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    const string node_name = node->name();\n    NodeDef* input;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &input));\n    if (IsInPreserveSet(*input) ||\n        NumNonControlOutputs(*input, *ctx().node_map) > 1) {\n      return Status::OK();\n    }\n    string new_op;\n    if (IsEqual(*input)) {\n      new_op = \"NotEqual\";\n    } else if (IsNotEqual(*input)) {\n      new_op = \"Equal\";\n    } else if (IsLess(*input)) {\n      new_op = \"GreaterEqual\";\n    } else if (IsLessEqual(*input)) {\n      new_op = \"Greater\";\n    } else if (IsGreater(*input)) {\n      new_op = \"LessEqual\";\n    } else if (IsGreaterEqual(*input)) {\n      new_op = \"Less\";\n    }\n    if (!new_op.empty()) {\n      input->set_op(new_op);\n      *simplified_node_name = input->name();\n    }\n    return Status::OK();\n  }\n};\n\n// This optimization hoists the common prefix of unary ops of the inputs to\n// concat out of the concat, for example:\n//    Concat([Exp(Sin(x)), Exp(Sin(y)), Exp(Sin(z))])\n// becomes\n//    Exp(Sin(Concat([x, y, z]))).\n// Similarly, it will hoist the common postfix of unary ops into Split or\n// SplitV nodes, for example:\n//    [Exp(Sin(y)) for y in Split(x)]\n// becomes\n//    [y for y in Split(Exp(Sin(x))]\n//\n// TODO(rmlarsen): Support casting. We would have to change the type attribute\n// on the concat/split node.\n// TODO(rmlarsen): Handle Enter/Exit.\nclass HoistCWiseUnaryChainsStage : public ArithmeticOptimizerStage {\n public:\n  explicit HoistCWiseUnaryChainsStage(const GraphOptimizerContext& ctx,\n                                      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"\", ctx, ctx_ext) {}\n\n  ~HoistCWiseUnaryChainsStage() override = default;\n\n  struct ChainLink {\n    ChainLink() = default;\n    ChainLink(NodeDef* _node, int _port_origin)\n        : node(_node), port_origin(_port_origin) {}\n    NodeDef* node;    // Node in a chain.\n    int port_origin;  // Port on concat/split node from which this chain\n                      // originates.\n\n    bool operator<(const ChainLink& other) const {\n      if (port_origin < other.port_origin) {\n        return true;\n      } else if (port_origin > other.port_origin) {\n        return false;\n      } else {\n        return node->name() < other.node->name();\n      }\n    }\n  };\n\n  // We use an ordinary set sorted on port and node name, so the order, and\n  // hence the node name used for the hoisted chain, will be deterministic.\n  using ChainLinkSet = std::set<ChainLink>;\n\n  bool IsSupported(const NodeDef* node) const override {\n    if (IsInPreserveSet(*node)) return false;\n    if (IsConcat(*node) && node->attr().count(\"N\") != 0) {\n      const int n = node->attr().at(\"N\").i();\n      return n > 1 && FirstNInputsAreUnique(*node, n);\n    } else if ((IsSplit(*node) || IsSplitV(*node)) &&\n               node->attr().count(\"num_split\") != 0) {\n      const int num_split = node->attr().at(\"num_split\").i();\n      if (NumNonControlOutputs(*node, *ctx().node_map) > num_split) {\n        // TODO(rmlarsen): Remove this constraint when we have optimizations\n        // in place for merging slices into splits.\n        return false;\n      }\n      if (NumControlOutputs(*node, *ctx().node_map) > 0) {\n        // TODO(ezhulenev): Unary ops after Split might have a control path to\n        // the Split node, and we currently do not properly handle cycles.\n        return false;\n      }\n      return num_split > 1 && !IsAlreadyOptimized(*node);\n    }\n    return false;\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    node_is_concat_ = IsConcat(*node);\n    int prefix_length;\n    std::set<string> ctrl_inputs;\n    ChainLinkSet tails;\n    TF_RETURN_IF_ERROR(\n        FindCommonUnaryOpChain(*node, &prefix_length, &tails, &ctrl_inputs));\n    if (prefix_length > 0 && !tails.empty()) {\n      TF_RETURN_IF_ERROR(\n          HoistUnaryOpChain(prefix_length, tails, &ctrl_inputs, node));\n    }\n    return Status::OK();\n  }\n\n private:\n  bool FirstNInputsAreUnique(const NodeDef& node, int n) const {\n    if (n > node.input_size()) return false;\n    absl::flat_hash_set<string> unique_inputs;\n    const int start = node.op() == \"Concat\" ? 1 : 0;\n    const int end = start + n;\n    for (int i = start; i < end; ++i) {\n      unique_inputs.insert(node.input(i));\n    }\n    int unique_input_size = unique_inputs.size();\n    return unique_input_size == n;\n  }\n\n  // Returns the length of the common unary chain of ops that can be\n  // hoisted to the other side of concat or split.\n  Status FindCommonUnaryOpChain(const NodeDef& root_node, int* prefix_length,\n                                ChainLinkSet* tails,\n                                std::set<string>* ctrl_inputs) const {\n    *prefix_length = 0;\n    // Follow the chains starting at each concat input or split output as long\n    // as all the following conditions hold:\n    //   1. The ops in all chains are the same.\n    //   2. The ops are unary elementwise op.\n    //   3. The op output has only a single consumer (concat only).\n    ChainLinkSet cur_tails;\n    TF_RETURN_IF_ERROR(InitializeChains(root_node, &cur_tails));\n    if (cur_tails.size() < 2) {\n      return Status::OK();\n    }\n    ctrl_inputs->clear();\n    bool stop = false;\n    while (!stop && !cur_tails.empty() &&\n           OpsAreSafeToHoist(root_node, cur_tails)) {\n      // We found one more link that can be hoisted.\n      ++(*prefix_length);\n      tails->swap(cur_tails);\n      GatherControlInputs(ctrl_inputs, *tails);\n\n      // Advance tail pointers to the next level.\n      TF_RETURN_IF_ERROR(AdvanceTails(*tails, &cur_tails, &stop));\n    }\n    return Status::OK();\n  }\n\n  // Hoists the chains to the other side of concat or split and attaches the\n  // control inputs gathered from them to the concat or split node.\n  Status HoistUnaryOpChain(const int prefix_length, const ChainLinkSet& tails,\n                           std::set<string>* ctrl_inputs, NodeDef* root_node) {\n    VLOG(3) << \"Hoist unary op chain:\"\n            << \" root=\" << root_node->DebugString()\n            << \" prefix_length=\" << prefix_length << \" ctrl_inputs=[\"\n            << absl::StrJoin(*ctrl_inputs, \", \") << \"]\";\n\n    if (tails.empty()) {\n      return Status::OK();\n    }\n    AddToOptimizationQueue(root_node);\n    optimized_nodes_.insert(root_node->name());\n    if (node_is_concat_) {\n      AddControlInputs(ctrl_inputs, root_node);\n      return HoistChainForConcat(prefix_length, tails, root_node);\n    } else {\n      return HoistChainForSplit(prefix_length, tails, ctrl_inputs, root_node);\n    }\n  }\n\n  void GatherControlInputs(std::set<string>* ctrl_inputs,\n                           const ChainLinkSet& ops) const {\n    for (const auto& link : ops) {\n      const NodeDef* node = link.node;\n      for (int i = node->input_size() - 1; i >= 0; --i) {\n        const string& input = node->input(i);\n        if (!IsControlInput(input)) break;\n        ctrl_inputs->insert(input);\n      }\n    }\n  }\n\n  void AddControlInputs(std::set<string>* new_ctrl_inputs,\n                        NodeDef* node) const {\n    for (int i = node->input_size() - 1; i >= 0; --i) {\n      const string& existing_input = node->input(i);\n      if (!IsControlInput(existing_input)) break;\n      new_ctrl_inputs->erase(existing_input);\n    }\n    for (const string& new_input : *new_ctrl_inputs) {\n      ctx().node_map->AddOutput(NodeName(new_input), node->name());\n      node->add_input(new_input);\n    }\n  }\n\n  Status InitializeChains(const NodeDef& node, ChainLinkSet* tails) const {\n    if (node_is_concat_) {\n      // Handle concat nodes by looking backwards in the graph.\n      TF_RETURN_IF_ERROR(CheckAttrExists(node, \"N\"));\n      const int n = node.attr().at(\"N\").i();\n      const int start = node.op() == \"Concat\" ? 1 : 0;\n      const int end = start + n;\n      if (end > node.input_size()) {\n        return errors::FailedPrecondition(\"Got attr N=\", n,\n                                          \" without enough inputs.\");\n      }\n      // Set up tail pointers to point to the immediate inputs to Concat.\n      for (int input_port = start; input_port < end; ++input_port) {\n        if (IsControlInput(node.input(input_port))) {\n          return errors::FailedPrecondition(\n              \"Got control input \", node.input(input_port),\n              \" where normal input was expected.\");\n        }\n        NodeDef* tail;\n        TF_RETURN_IF_ERROR(GetInputNode(node.input(input_port), &tail));\n        tails->insert(ChainLink(tail, input_port));\n      }\n      return Status::OK();\n    } else {\n      // Handle split nodes by looking forwards in the graph.\n      const auto& outputs = ctx().node_map->GetOutputs(node.name());\n      for (NodeDef* output : outputs) {\n        if (IsControlInput(output->input(0))) continue;\n        TensorId tensor_id = ParseTensorName(output->input(0));\n        if (tensor_id.node() == node.name()) {\n          tails->insert(ChainLink(output, tensor_id.index()));\n        } else {\n          // This output node has a non-control input other than the split node,\n          // abort.\n          tails->clear();\n          return Status::OK();\n        }\n      }\n    }\n    return Status::OK();\n  }\n\n  bool OpsAreSafeToHoist(const NodeDef& root_node,\n                         const ChainLinkSet& ops) const {\n    if (ops.empty()) return true;\n    const NodeDef* op0 = ops.begin()->node;\n    if (ModifiesFrameInfo(*op0) || !IsUnaryElementWise(*op0)) return false;\n    for (const auto& link : ops) {\n      const NodeDef* op = link.node;\n      if (op->device() != root_node.device() || op->op() != op0->op() ||\n          IsInPreserveSet(*op)) {\n        return false;\n      }\n      if (ctx().node_map->GetOutputs(op->name()).size() > 1) {\n        // TODO(rmlarsen): Allow outgoing control edges.\n        return false;\n      }\n      // Do not hoist Relu if it can be fused with its predecessors. This is\n      // important because remapping runs after arithmetic.\n      if (IsRelu(*op) || IsRelu6(*op)) {\n        NodeDef* operand = nullptr;\n        if (!GetInputNode(op->input(0), &operand).ok()) {\n          return false;\n        }\n        if (IsFusedBatchNorm(*operand) || IsBiasAdd(*operand)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  Status AdvanceTails(const ChainLinkSet& tails, ChainLinkSet* new_tails,\n                      bool* stop) const {\n    *stop = true;\n    new_tails->clear();\n    for (const auto& link : tails) {\n      const NodeDef* tail = link.node;\n      if (node_is_concat_) {\n        if (tail->input_size() == 0 || IsControlInput(tail->input(0))) {\n          return Status::OK();\n        }\n        NodeDef* new_tail;\n        TF_RETURN_IF_ERROR(GetInputNode(tail->input(0), &new_tail));\n        // Remember original port.\n        new_tails->insert(ChainLink(new_tail, link.port_origin));\n      } else {\n        for (NodeDef* new_tail : ctx().node_map->GetOutputs(tail->name())) {\n          const TensorId tensor = ParseTensorName(new_tail->input(0));\n          if (tensor.node() != tail->name()) {\n            return Status::OK();\n          }\n          // Skip control outputs.\n          if (tensor.index() >= 0) {\n            // Remember original port.\n            new_tails->insert(ChainLink(new_tail, link.port_origin));\n          }\n        }\n      }\n    }\n    *stop = false;\n    return Status::OK();\n  }\n\n  Status HoistChainForConcat(const int prefix_length, const ChainLinkSet& tails,\n                             NodeDef* concat_node) {\n    const string& concat_name = concat_node->name();\n    const int first_input = concat_node->op() == \"Concat\" ? 1 : 0;\n    for (const auto& link : tails) {\n      NodeDef* tail = CHECK_NOTNULL(link.node);\n      const int concat_port = link.port_origin;\n      CHECK_GE(concat_port, 0);\n      CHECK_LT(concat_port, concat_node->input_size());\n      const string concat_input = concat_node->input(concat_port);\n      // Hook the node following tail directly into the concat node.\n      const string tail_input = tail->input(0);\n      concat_node->set_input(concat_port, tail_input);\n      ctx().node_map->UpdateInput(concat_name, concat_input, tail_input);\n\n      if (concat_port == first_input) {\n        // Update the consumers of concat to consume the end of the chain\n        // instead.\n        UpdateConsumers(concat_node, concat_input);\n        // Reuse nodes in the first chain to process output of concat.\n        tail->set_input(0, concat_name);\n        ctx().node_map->UpdateInput(tail->name(), tail_input, concat_name);\n      }\n    }\n    return Status::OK();\n  }\n\n  Status HoistChainForSplit(const int prefix_length, const ChainLinkSet& tails,\n                            std::set<string>* ctrl_inputs,\n                            NodeDef* split_node) {\n    // Create a new chain before the split node to process the input tensor.\n    const string& split_name = split_node->name();\n    auto root_scope_and_name = ParseNodeScopeAndName(split_name);\n\n    // We use the first tail node in the set as a template to get the list of\n    // ops to apply (starting from the end).\n    NodeDef* cur_tail = tails.begin()->node;\n    NodeDef* cur_copy = AddCopyNode(\n        OptimizedNodeName(root_scope_and_name, cur_tail->name()), cur_tail);\n    cur_copy->clear_input();\n\n    // Update the split to take its input from the tail of the new chain.\n    const int value_slot = split_node->op() == \"SplitV\" ? 0 : 1;\n    const string orig_input = split_node->input(value_slot);\n    split_node->set_input(value_slot, cur_copy->name());\n    ctx().node_map->UpdateInput(split_node->name(), orig_input,\n                                cur_copy->name());\n    TF_RETURN_IF_ERROR(GetInputNode(cur_tail->input(0), &cur_tail));\n\n    // Now walk backwards creating the rest of the chain.\n    while (cur_tail != split_node) {\n      NodeDef* new_copy = AddCopyNode(\n          OptimizedNodeName(root_scope_and_name, cur_tail->name()), cur_tail);\n      new_copy->clear_input();\n      cur_copy->add_input(new_copy->name());\n      ctx().node_map->AddOutput(new_copy->name(), cur_copy->name());\n      cur_copy = new_copy;\n      TF_RETURN_IF_ERROR(GetInputNode(cur_tail->input(0), &cur_tail));\n    }\n    // Connect the original input to the head of the new chain.\n    cur_copy->add_input(orig_input);\n    ctx().node_map->UpdateOutput(NodeName(orig_input), split_name,\n                                 cur_copy->name());\n    // Make sure all the control inputs are satisfied before running the first\n    // node in the new chain.\n    AddControlInputs(ctrl_inputs, cur_copy);\n\n    // Connect all consumers of the tail nodes directly to the\n    // output port of Split from which the chain started.\n    for (const auto& link : tails) {\n      UpdateConsumers(link.node,\n                      link.port_origin == 0\n                          ? split_name\n                          : strings::StrCat(split_name, \":\", link.port_origin));\n    }\n    return Status::OK();\n  }\n\n  bool IsAlreadyOptimized(const NodeDef& node) const {\n    return optimized_nodes_.find(node.name()) != optimized_nodes_.end();\n  }\n\n private:\n  bool node_is_concat_;\n  std::unordered_set<string> optimized_nodes_;\n};\n\nclass RemoveIdempotentStage : public ArithmeticOptimizerStage {\n public:\n  explicit RemoveIdempotentStage(const GraphOptimizerContext& ctx,\n                                 const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveIdempotent\", ctx, ctx_ext) {}\n  ~RemoveIdempotentStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return node->input_size() == 1 && IsIdempotent(*node) &&\n           !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    NodeDef* input;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &input));\n    if (input->op() == node->op() && input->device() == node->device()) {\n      *simplified_node_name = node->input(0);\n    }\n    return Status::OK();\n  }\n};\n\n// Performs the conversion:\n// Div(x, Sqrt(y)) => Mul(x, Rsqrt(y))\n// TODO(srjoglekar): Generalize to optimize cases like (x / pow(y, z)).\nclass SqrtDivToRsqrtMulStage : public ArithmeticOptimizerStage {\n public:\n  explicit SqrtDivToRsqrtMulStage(const GraphOptimizerContext& ctx,\n                                  const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"SqrtDivToRsqrtMul\", ctx, ctx_ext) {}\n  ~SqrtDivToRsqrtMulStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    // Note: div_no_nan(a, sqrt(b)) => mul_no_nan(a, rsqrt(b))\n    // for b == 0 would result in a / Inf instead of 0.\n    return IsAnyDiv(*node) && !IsDivNoNan(*node) && !IsFloorDiv(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    NodeDef* y;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(1), &y));\n    // Optimize only if divisor is a Sqrt whose output is not being consumed\n    // elsewhere.\n    if (IsSqrt(*y) && !IsInPreserveSet(*y) &&\n        (NumNonControlOutputs(*y, *ctx().node_map) == 1)) {\n      if (IsXdivy(*node)) {\n        // xdivy(a, sqrt(b)) => mul_no_nan(rsqrt(b), a)\n        node->set_op(\"MulNoNan\");\n        node->mutable_input()->SwapElements(0, 1);\n      } else {\n        // div(a, sqrt(b)) => mul(a, rsqrt(b))\n        node->set_op(\"Mul\");\n      }\n      y->set_op(\"Rsqrt\");\n      AddToOptimizationQueue(node);\n      AddToOptimizationQueue(y);\n    }\n    return Status::OK();\n  }\n};\n\n// Performs the following conversion for real types:\n//   Square(Sub(x, y)) => Identity(SquaredDifference(x, y) )\nclass FuseSquaredDiffStage : public ArithmeticOptimizerStage {\n public:\n  explicit FuseSquaredDiffStage(const GraphOptimizerContext& ctx,\n                                const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"FuseSquaredDiffStage\", ctx, ctx_ext) {}\n  ~FuseSquaredDiffStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsSquare(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    NodeDef* b;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &b));\n    // Optimize only if base is a Sub whose output is not being consumed\n    // elsewhere.\n    if (IsSub(*b) && !IsInPreserveSet(*b) &&\n        (NumNonControlOutputs(*b, *ctx().node_map) == 1)) {\n      // For complex, SquaredDiff computes conj(x-y)*(x-y), so this rewrite is\n      // invalid.\n      const DataType type = GetDataTypeFromAttr(*b, \"T\");\n      if ((type == DT_COMPLEX64) || (type == DT_COMPLEX128))\n        return Status::OK();\n      node->set_op(\"Identity\");\n      b->set_op(\"SquaredDifference\");\n      AddToOptimizationQueue(node);\n      AddToOptimizationQueue(b);\n    }\n    return Status::OK();\n  }\n};\n\n// Performs the conversion:\n// Log(Softmax(x)) => LogSoftmax(x)\nclass LogSoftmaxStage : public ArithmeticOptimizerStage {\n public:\n  explicit LogSoftmaxStage(const GraphOptimizerContext& ctx,\n                           const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"LogSoftmaxStage\", ctx, ctx_ext) {}\n  ~LogSoftmaxStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override { return IsLog(*node); }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    NodeDef* x;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &x));\n    // Optimize only if arg is a Softmax whose output is not being consumed\n    // elsewhere.\n    if (IsSoftmax(*x) && !IsInPreserveSet(*x) &&\n        (NumNonControlOutputs(*x, *ctx().node_map) == 1)) {\n      // Log(Softmax(x)) => LogSoftmax(Identity(x))\n      node->set_op(\"LogSoftmax\");\n      x->set_op(\"Identity\");\n      AddToOptimizationQueue(node);\n      AddToOptimizationQueue(x);\n    }\n    return Status::OK();\n  }\n};\n\n// Bypass redundant reshape nodes:\n//\n//   Reshape                    Reshape  <-+\n//      ^                                  |\n//      |                                  |\n//   Reshape       becomes      Reshape    |\n//      ^                                  |\n//      |                                  |\n//    input                      input  ---+\n//\n// Additionally,  Reshape and BroadcastTo nodes where the\n// input and target shapes are equal are bypassed.\n//\nclass RemoveRedundantReshapeOrBroadcastTo : public ArithmeticOptimizerStage {\n public:\n  explicit RemoveRedundantReshapeOrBroadcastTo(\n      const GraphOptimizerContext& ctx,\n      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveRedundantReshapeOrBroadcastTo\", ctx,\n                                 ctx_ext) {}\n  ~RemoveRedundantReshapeOrBroadcastTo() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return (IsReshape(*node) || IsBroadcastTo(*node)) &&\n           !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    NodeDef* input;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &input));\n\n    // 1. Bypass reshape followed by reshape.\n    if (IsValueAndOrderPreserving(*node) && IsReshape(*input) &&\n        !IsInPreserveSet(*input)) {\n      ForwardControlDependencies(node, {input});\n      node->set_input(0, input->input(0));\n      ctx().node_map->UpdateInput(node->name(), input->name(), input->input(0));\n      *simplified_node_name = node->name();\n      AddToOptimizationQueue(node);\n      return Status::OK();\n    }\n\n    // 2. If the reshape is a no-op, forward its input to its consumers, unless\n    // it anchors a control dependency since we want to make sure that control\n    // dependency is triggered.\n    if (InputMatchesTargetShape(*node) && !HasControlInputs(*node)) {\n      *simplified_node_name = node->input(0);\n      return Status::OK();\n    }\n\n    return Status::OK();\n  }\n\n private:\n  // Returns whether `reshape` is an identity op.\n  bool InputMatchesTargetShape(const NodeDef& reshape) {\n    const OpInfo::TensorProperties* reshape_props;\n    const OpInfo::TensorProperties* input_props;\n\n    if (!GetTensorProperties(reshape.name(), &reshape_props).ok() ||\n        !GetTensorProperties(reshape.input(0), &input_props).ok()) {\n      return false;\n    }\n\n    return ShapesSymbolicallyEqual(input_props->shape(),\n                                   reshape_props->shape());\n  }\n};\n\n// Reorder casting and value-preserving ops if beneficial.\n//\n// Original motivation: A common pattern after the layout optimizer is\n// casting an uint8 NHWC image to float before transposing it to NCHW. It\n// is beneficial to reorder the cast and the transpose to make the transpose\n// process smaller amount of data. More generally, this optimization converts\n//   Op(Cast(tensor, dst_type))\n// to\n//   Cast(Op(tensor), dst_type)\n// when sizeof(tensor.type) < sizeof(dst_type), and Op is any value-preserving\n// Op, i.e. an op that only reorders the elements in its first input. Similarly,\n// this optimization converts\n//   Cast(Op(tensor), dst_type)\n// to\n//   Op(Cast(tensor, dst_type))\n// when sizeof(tensor.type) > sizeof(dst_type)\n//\nclass ReorderCastLikeAndValuePreserving : public ArithmeticOptimizerStage {\n public:\n  explicit ReorderCastLikeAndValuePreserving(\n      const GraphOptimizerContext& ctx,\n      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"ReorderCastLikeAndValuePreserving\", ctx,\n                                 ctx_ext) {}\n  ~ReorderCastLikeAndValuePreserving() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return (IsValuePreserving(*node) || IsCastLike(*node)) &&\n           !IsCheckNumerics(*node) && NodeIsOnCpuOrGpu(node) &&\n           !IsControlFlow(*node) && !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* consumer, string* simplified_node_name) override {\n    NodeDef* producer;\n    TF_RETURN_IF_ERROR(GetInputNode(consumer->input(0), &producer));\n    const bool producer_is_cast = IsCastLike(*producer);\n    const bool can_optimize =\n        !IsCheckNumerics(*producer) &&\n        ((producer_is_cast && IsValuePreserving(*consumer)) ||\n         (IsValuePreserving(*producer) && IsCastLike(*consumer)));\n    if (!can_optimize || IsControlFlow(*producer) ||\n        IsInPreserveSet(*producer) ||\n        producer->device() != consumer->device()) {\n      return Status::OK();\n    }\n\n    const NodeDef* cast_like_node = producer_is_cast ? producer : consumer;\n    const OpDef* cast_like_op_def = nullptr;\n    TF_RETURN_IF_ERROR(OpRegistry::Global()->LookUpOpDef(cast_like_node->op(),\n                                                         &cast_like_op_def));\n    DataType cast_src_type;\n    TF_RETURN_IF_ERROR(InputTypeForNode(*cast_like_node, *cast_like_op_def, 0,\n                                        &cast_src_type));\n    DataType cast_dst_type;\n    TF_RETURN_IF_ERROR(OutputTypeForNode(*cast_like_node, *cast_like_op_def, 0,\n                                         &cast_dst_type));\n    if (!IsFixedSizeType(cast_src_type) || !IsFixedSizeType(cast_dst_type)) {\n      return Status::OK();\n    } else if (producer_is_cast &&\n               DataTypeSize(cast_dst_type) <= DataTypeSize(cast_src_type)) {\n      return Status::OK();\n    } else if (!producer_is_cast &&\n               DataTypeSize(cast_dst_type) >= DataTypeSize(cast_src_type)) {\n      return Status::OK();\n    }\n\n    // Check that nodes were not already optimized.\n    const string optimized_producer_name = OptimizedNodeName(\n        ParseNodeScopeAndName(producer->name()), DataTypeString(cast_dst_type));\n    const string optimized_consumer_name = OptimizedNodeName(\n        ParseNodeScopeAndName(consumer->name()), DataTypeString(cast_src_type));\n    const bool is_already_optimized =\n        ctx().node_map->NodeExists(optimized_consumer_name) ||\n        ctx().node_map->NodeExists(optimized_producer_name);\n    if (is_already_optimized) {\n      return Status::OK();\n    }\n\n    // Add copies of consumer and producer in reverse order.\n    NodeDef* input;\n    TF_RETURN_IF_ERROR(GetInputNode(producer->input(0), &input));\n    // Create new producer node.\n    NodeDef* new_producer = AddCopyNode(optimized_consumer_name, consumer);\n    new_producer->set_input(0, producer->input(0));\n    ctx().node_map->AddOutput(input->name(), new_producer->name());\n\n    // Create new consumer node.\n    NodeDef* new_consumer = AddCopyNode(optimized_producer_name, producer);\n    new_consumer->set_input(0, new_producer->name());\n\n    NodeDef* new_value_preserving =\n        producer_is_cast ? new_producer : new_consumer;\n    const DataType new_input_type =\n        producer_is_cast ? cast_src_type : cast_dst_type;\n    // Update the input type of the value-preserving node. The input and\n    // output types of the cast-like nodes remain the same.\n    TF_RETURN_IF_ERROR(SetInputType(new_input_type, new_value_preserving));\n    // Make sure there is a kernel registered for the value preserving op\n    // with the new input type.\n    TF_RETURN_IF_ERROR(IsKernelRegisteredForNode(*new_value_preserving));\n    ctx().node_map->AddOutput(new_producer->name(), new_consumer->name());\n\n    AddToOptimizationQueue(new_producer);\n    *simplified_node_name = new_consumer->name();\n\n    return Status::OK();\n  }\n\n private:\n  // Sets the type of the first input to dtype.\n  Status SetInputType(DataType dtype, NodeDef* node) {\n    const OpDef* op_def = nullptr;\n    TF_RETURN_IF_ERROR(OpRegistry::Global()->LookUpOpDef(node->op(), &op_def));\n    const OpDef::ArgDef& input_arg = op_def->input_arg(0);\n    const string& type_attr_name = input_arg.type_attr();\n    if (type_attr_name.empty()) {\n      if (input_arg.type() == DT_INVALID || input_arg.type() != dtype) {\n        return errors::InvalidArgument(\"Could not set input type of \",\n                                       node->op(), \" op to \",\n                                       DataTypeString(dtype));\n      } else {\n        // Op has fixed input type that already matches dtype.\n        return Status::OK();\n      }\n    }\n    SetDataTypeToAttr(dtype, type_attr_name, node);\n    return Status::OK();\n  }\n  // This optimization can be dangerous on devices other than CPU and\n  // GPU. The transpose might not be implemented for image.type, or\n  // might be slower with image.type than with cast_dst_type.\n  bool NodeIsOnCpuOrGpu(const NodeDef* node) const {\n    using absl::StrContains;\n\n    string task;\n    string device;\n\n    return DeviceNameUtils::SplitDeviceName(node->device(), &task, &device) &&\n           (StrContains(device, DEVICE_CPU) || StrContains(device, DEVICE_GPU));\n  }\n\n  bool IsFixedSizeType(DataType dtype) {\n    return dtype != DT_STRING && dtype != DT_VARIANT && dtype != DT_RESOURCE &&\n           !kQuantizedTypes.Contains(dtype);\n  }\n};\n\n// Reorder reshapes around a single unary element-wise op, i.e.:\n//    input -> reshape A -> unary -> reshape B -> output\n// becomes\n//    input -> unary -> reshape A -> reshape B -> output\n//\n// A later pass (RemoveRedundantReshapeOrBroadcastTo) removes both reshapes\nclass ReorderReshapeAroundUnary : public ArithmeticOptimizerStage {\n public:\n  explicit ReorderReshapeAroundUnary(const GraphOptimizerContext& ctx,\n                                     const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"ReorderReshapeAroundUnary\", ctx, ctx_ext) {}\n\n  ~ReorderReshapeAroundUnary() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsReshape(*node) && !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    // Check that we have a chain of (reshape -> unary -> reshape)\n    NodeDef* reshape_b = node;\n    if (!IsReshape(*reshape_b) || IsInPreserveSet(*reshape_b)) {\n      return Status::OK();\n    }\n\n    NodeDef* unary;\n    TF_RETURN_IF_ERROR(GetInputNode(reshape_b->input(0), &unary));\n    if (!IsUnaryElementWise(*unary) || IsInPreserveSet(*unary)) {\n      return Status::OK();\n    }\n\n    NodeDef* reshape_a;\n    TF_RETURN_IF_ERROR(GetInputNode(unary->input(0), &reshape_a));\n    if (!IsReshape(*reshape_a) || IsInPreserveSet(*reshape_a)) {\n      return Status::OK();\n    }\n\n    NodeDef* input;\n    TF_RETURN_IF_ERROR(GetInputNode(reshape_a->input(0), &input));\n\n    const string new_reshape_name =\n        OptimizedNodeName(ParseNodeScopeAndName(reshape_a->name()));\n    if (ctx().node_map->NodeExists(new_reshape_name)) {\n      return Status::OK();\n    }\n\n    // Attach unary to the input, bypassing reshape_a\n    unary->set_input(0, reshape_a->input(0));\n    ctx().node_map->UpdateInput(unary->name(), reshape_a->name(),\n                                reshape_a->input(0));\n    // Invalidate node properties since the shape of unary will be different\n    ctx().graph_properties->ClearOutputProperties(unary->name());\n    ctx().graph_properties->ClearInputProperties(unary->name());\n\n    ForwardControlDependencies(unary, {reshape_a});\n\n    // Create a copy of reshape_a and insert it after unary\n    NodeDef* new_reshape =\n        CopyReshapeAndInsertAfter(reshape_a, unary, new_reshape_name);\n    AddToOptimizationQueue(new_reshape);\n\n    *simplified_node_name = node->name();\n    return Status::OK();\n  }\n\n private:\n  NodeDef* CopyReshapeAndInsertAfter(const NodeDef* reshape, NodeDef* unary,\n                                     const string& new_reshape_name) {\n    // Copy the attributes of the original reshape\n    NodeDef* new_reshape = AddEmptyNode(new_reshape_name);\n    new_reshape->set_op(\"Reshape\");\n    new_reshape->set_device(reshape->device());\n    SetDataTypeToAttr(GetDataTypeFromAttr(*reshape, \"T\"), \"T\", new_reshape);\n    SetDataTypeToAttr(GetDataTypeFromAttr(*reshape, \"Tshape\"), \"Tshape\",\n                      new_reshape);\n\n    // Forward the consumers of unary to reshape\n    UpdateConsumers(unary, new_reshape->name());\n\n    // Add unary and the original shape as inputs\n    new_reshape->add_input(unary->name());\n    ctx().node_map->AddOutput(unary->name(), new_reshape->name());\n    new_reshape->add_input(reshape->input(1));\n    ctx().node_map->AddOutput(reshape->input(1), new_reshape->name());\n\n    return new_reshape;\n  }\n};\n\n// Fold a multiply of a scalar into the following convolution. This folding\n// can jump across nodes that merely reorders data (such as reshape and\n// transpose). For example, we can optimize\n//\n//\n//         Conv2D                             Conv2D\n//        /      \\                           /      \\\n//    Transpose  weights*       ->     Transpose    Mul\n//       |                                |        /   \\\n//      Mul                               |    weights  scale\n//     /   \\                              |\n//   input  scale**                     input\n//\n//  *) weights must be a const\n// **) scale must be a const scalar\n//\n// When `weights` and `scale` are constant, `Mul` in the optimized graph can be\n// constant-folded, also weights tend to be smaller than the activations.\n//\n// TODO(jingyue): Fold scalar multiplies to Conv?DBackpropFilter and\n// Conv?DBackpropInput.\nclass FoldMultiplyIntoConv : public ArithmeticOptimizerStage {\n public:\n  explicit FoldMultiplyIntoConv(const GraphOptimizerContext& ctx,\n                                const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"FoldMultiplyIntoConv\", ctx, ctx_ext) {}\n  ~FoldMultiplyIntoConv() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsConv2D(*node) || IsConv3D(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n#define TF_RETURN_IF_TRUE(...) \\\n  if ((__VA_ARGS__)) return Status::OK()\n\n    NodeDef* conv = node;\n\n    NodeDef* weights;\n    TF_RETURN_IF_ERROR(GetInputNode(conv->input(1), &weights));\n\n    // Fold the multiply to conv only when the weights are constant, so the\n    // multiply can be constant-folded.\n    //\n    // TODO(jingyue): When the weights aren't constant, this should also help\n    // performance a bit and memory usage a lot, since the weights tend to be\n    // smaller than the activations.\n    TF_RETURN_IF_TRUE(!IsConstant(*weights));\n\n    // Verify that this node was not already optimized.\n    const string scaled_weights_node_name =\n        OptimizedNodeName(ParseNodeScopeAndName(weights->name()),\n                          strings::StrCat(\"scaled\", \"_\", conv->name()));\n\n    TF_RETURN_IF_TRUE(ctx().node_map->NodeExists(scaled_weights_node_name));\n\n    // Find the tail of value preserving chain entering the Conv node.\n    NodeDef* tail = GetTailOfValuePreservingChain(*conv, *ctx().node_map,\n                                                  *ctx().nodes_to_preserve);\n\n    NodeDef* source;\n    TF_RETURN_IF_ERROR(GetInputNode(tail->input(0), &source));\n\n    // Check that value preserving chain is the only consumer of the Mul output.\n    TF_RETURN_IF_TRUE(!IsAnyMul(*source));\n    TF_RETURN_IF_TRUE(NumNonControlOutputs(*source, *ctx().node_map) != 1);\n    // And that Mul is not in the preserve set.\n    TF_RETURN_IF_TRUE(IsInPreserveSet(*source));\n\n    const NodeDef* mul = source;\n    int input_idx = 0;\n    int scale_idx = 1;\n    NodeDef* scale;  // scalar multiplier for the input tensor\n    NodeDef* input;\n    TF_RETURN_IF_ERROR(GetInputNode(mul->input(scale_idx), &scale));\n    TF_RETURN_IF_ERROR(GetInputNode(mul->input(input_idx), &input));\n    if (!IsConstant(*scale) && IsConstant(*input)) {\n      VLOG(3) << \"Swapped inputs to mul\";\n      std::swap(scale_idx, input_idx);\n      std::swap(scale, input);\n    }\n    TF_RETURN_IF_TRUE(!IsConstant(*scale));\n\n    // Check that one of the inputs to mul is a constant scalar.\n    const TensorProto& scale_tensor = scale->attr().at(\"value\").tensor();\n    bool scale_is_a_scalar = scale_tensor.has_tensor_shape() &&\n                             scale_tensor.tensor_shape().dim_size() == 0;\n    TF_RETURN_IF_TRUE(!scale_is_a_scalar);\n\n    // Check that 'scale * weight' can be const folded.\n    TF_RETURN_IF_TRUE(!IsConstant(*scale));\n    TF_RETURN_IF_ERROR(CheckAttrsExist(*scale, {\"dtype\"}));\n    TF_RETURN_IF_ERROR(CheckAttrExists(*weights, \"dtype\"));\n    TF_RETURN_IF_TRUE(scale->attr().at(\"dtype\").type() !=\n                      weights->attr().at(\"dtype\").type());\n\n    // At this point all preconditions are met, and we safely do the rewrite.\n    VLOG(3) << \"Fold multiply into conv: conv=\" << conv->name()\n            << \" mul=\" << mul->name() << \" weights=\" << weights->name();\n\n    // Create new node `scaled_weights`.\n    NodeDef* scaled_weights = AddEmptyNode(scaled_weights_node_name);\n    scaled_weights->set_op(source->op());\n    scaled_weights->set_device(weights->device());\n    (*scaled_weights->mutable_attr())[\"T\"] = weights->attr().at(\"dtype\");\n    AddToOptimizationQueue(scaled_weights);\n\n    // Link in its inputs.\n    scaled_weights->add_input(conv->input(1));\n    ctx().node_map->AddOutput(weights->name(), scaled_weights->name());\n    scaled_weights->add_input(mul->input(scale_idx));\n    ctx().node_map->AddOutput(scale->name(), scaled_weights->name());\n    ForwardControlDependencies(scaled_weights, {source});\n\n    // Update `conv`'s weights to `scaled_weights`.\n    conv->set_input(1, scaled_weights->name());\n    ctx().node_map->UpdateInput(conv->name(), weights->name(),\n                                scaled_weights->name());\n    AddToOptimizationQueue(conv);\n\n    // Update `tail` node to bypass `mul` because it's folded to the weights.\n    tail->set_input(0, mul->input(input_idx));\n    ctx().node_map->UpdateInput(tail->name(), mul->name(), input->name());\n    AddToOptimizationQueue(tail);\n    *simplified_node_name = conv->name();\n\n    return Status::OK();\n#undef TF_RETURN_IF_TRUE\n  }\n};\n\n// Fold Transpose into matrix multiplication.\nclass FoldTransposeIntoMatMul : public ArithmeticOptimizerStage {\n public:\n  explicit FoldTransposeIntoMatMul(const GraphOptimizerContext& ctx,\n                                   const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"FoldTransposeIntoMatMul\", ctx, ctx_ext) {}\n  ~FoldTransposeIntoMatMul() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsAnyMatMul(*node) && !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    const NodeScopeAndName matmul = ParseNodeScopeAndName(node->name());\n    const string optimized_node_name = OptimizedNodeName(matmul);\n    if (ctx().node_map->NodeExists(optimized_node_name)) return Status::OK();\n\n    NodeDef* a;\n    NodeDef* b;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &a));\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(1), &b));\n\n    bool is_complex = false;\n    if (node->op() != \"SparseMatMul\") {\n      const DataType type = GetDataTypeFromAttr(*node, \"T\");\n      is_complex = (type == DT_COMPLEX64) || (type == DT_COMPLEX128);\n    }\n\n    const std::set<string> foldable_transpose_ops =\n        !is_complex\n            ? std::set<string>{\"ConjugateTranspose\", \"Transpose\"}\n            : (IsAnyBatchMatMul(*node) ? std::set<string>{\"ConjugateTranspose\"}\n                                       : std::set<string>{\"Transpose\"});\n\n    const bool a_is_foldable = foldable_transpose_ops.count(a->op()) > 0 &&\n                               IsInnerMatrixTransposeNode(*a, ctx().node_map);\n    const bool b_is_foldable = foldable_transpose_ops.count(b->op()) > 0 &&\n                               IsInnerMatrixTransposeNode(*b, ctx().node_map);\n    if (!a_is_foldable && !b_is_foldable) return Status::OK();\n\n    NodeDef* new_op = AddCopyNode(optimized_node_name, node);\n\n    if (a_is_foldable) {\n      const string attr_a = IsAnyBatchMatMul(*node) ? \"adj_x\" : \"transpose_a\";\n      FlipBooleanAttr(attr_a, new_op);\n      new_op->set_input(0, a->input(0));\n      ctx().node_map->UpdateInput(new_op->name(), a->name(), a->input(0));\n    } else {\n      ctx().node_map->UpdateOutput(a->name(), node->name(), new_op->name());\n    }\n\n    if (b_is_foldable) {\n      const string attr_b = IsAnyBatchMatMul(*node) ? \"adj_y\" : \"transpose_b\";\n      FlipBooleanAttr(attr_b, new_op);\n      new_op->set_input(1, b->input(0));\n      ctx().node_map->UpdateInput(new_op->name(), b->name(), b->input(0));\n    } else {\n      ctx().node_map->UpdateOutput(b->name(), node->name(), new_op->name());\n    }\n\n    std::vector<const NodeDef*> deps_to_forward = {node};\n    if (a_is_foldable) deps_to_forward.push_back(a);\n    if (b_is_foldable) deps_to_forward.push_back(b);\n    ForwardControlDependencies(new_op, deps_to_forward);\n    *simplified_node_name = new_op->name();\n\n    return Status::OK();\n  }\n\n private:\n  void FlipBooleanAttr(const string& attr_name, NodeDef* node) {\n    const bool old_value =\n        !node->attr().count(attr_name) ? false : node->attr().at(attr_name).b();\n    (*node->mutable_attr())[attr_name].set_b(!old_value);\n  }\n\n  template <typename T>\n  bool IsInnerMatrixTranspose(const std::vector<T>& perm) {\n    const T n = perm.size();\n    if (n < 2) {\n      return false;\n    }\n    for (T i = 0; i < n - 2; ++i) {\n      if (perm[i] != i) {\n        return false;\n      }\n    }\n    return perm[n - 1] == n - 2 && perm[n - 2] == n - 1;\n  }\n\n  bool IsInnerMatrixTransposeNode(const NodeDef& transpose_node,\n                                  const NodeMap* node_map) {\n    if (transpose_node.op() != \"Transpose\" &&\n        transpose_node.op() != \"ConjugateTranspose\") {\n      return false;\n    }\n    const NodeDef* perm_node = node_map->GetNode(transpose_node.input(1));\n    std::vector<int> perm32;\n    if (ValuesFromConstNode(*perm_node, &perm32)) {\n      return IsInnerMatrixTranspose(perm32);\n    }\n    std::vector<int64> perm64;\n    if (ValuesFromConstNode(*perm_node, &perm64)) {\n      return IsInnerMatrixTranspose(perm64);\n    }\n    return false;\n  }\n};\n\nclass FoldConjugateIntoTranspose : public ArithmeticOptimizerStage {\n public:\n  explicit FoldConjugateIntoTranspose(const GraphOptimizerContext& ctx,\n                                      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"FoldConjugateIntoTranspose\", ctx, ctx_ext) {}\n  ~FoldConjugateIntoTranspose() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsConj(*node) || IsTranspose(*node) || IsConjugateTranspose(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    const NodeScopeAndName matmul = ParseNodeScopeAndName(node->name());\n    const string optimized_node_name = OptimizedNodeName(matmul);\n    if (ctx().node_map->NodeExists(optimized_node_name)) return Status::OK();\n\n    NodeDef* input;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &input));\n\n    const NodeDef* transpose_op = node->op() == \"Conj\" ? input : node;\n    const NodeDef* conj_op = node->op() == \"Conj\" ? node : input;\n\n    if ((IsTranspose(*transpose_op) || IsConjugateTranspose(*transpose_op)) &&\n        IsConj(*conj_op)) {\n      NodeDef* new_op = AddCopyNode(optimized_node_name, transpose_op);\n\n      // Flip the type of transpose op to absorb the conjugation.\n      new_op->set_op(transpose_op->op() == \"Transpose\" ? \"ConjugateTranspose\"\n                                                       : \"Transpose\");\n      new_op->set_input(0, input->input(0));\n      ctx().node_map->UpdateInput(new_op->name(), node->name(),\n                                  input->input(0));\n      ForwardControlDependencies(new_op, {node, input});\n      *simplified_node_name = new_op->name();\n    }\n\n    return Status::OK();\n  }\n};\n\n// Replace Mul node with identical inputs with a Square.\nclass ReplaceMulWithSquare : public ArithmeticOptimizerStage {\n public:\n  explicit ReplaceMulWithSquare(const GraphOptimizerContext& ctx,\n                                const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"ReplaceMulWithSquare\", ctx, ctx_ext) {}\n  ~ReplaceMulWithSquare() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsAnyMul(*node) && node->input(0) == node->input(1);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    const NodeScopeAndName mul = ParseNodeScopeAndName(node->name());\n    const string optimized_node_name = OptimizedNodeName(mul);\n    if (ctx().node_map->NodeExists(optimized_node_name)) return Status::OK();\n\n    const DataType type = GetDataTypeFromAttr(*node, \"T\");\n    bool is_complex = (type == DT_COMPLEX64) || (type == DT_COMPLEX128);\n\n    if (!is_complex || NodeIsOnCpu(*node)) {\n      NodeDef* new_square_node = AddCopyNode(optimized_node_name, node);\n      new_square_node->set_op(\"Square\");\n      for (int i = 1; i < new_square_node->input_size(); ++i) {\n        new_square_node->set_input(i - 1, new_square_node->input(i));\n      }\n      new_square_node->mutable_input()->RemoveLast();\n      for (const string& input : new_square_node->input()) {\n        ctx().node_map->AddOutput(NodeName(input), new_square_node->name());\n      }\n      *simplified_node_name = new_square_node->name();\n    }\n\n    return Status::OK();\n  }\n};\n\n// Replace a combination of Mul with broadcasting by Tile. E.g. replace\n//\n// input(1x22x1x48x1x64) -> Mul (1x22x2x48x2x64) -> output\n// Ones (1x22x2x48x2x64) -^\n//\n// with\n//\n// input -> Tile(1x22x2x48x2x64) -> output\nclass ReplaceMulWithBroadcastByTile : public ArithmeticOptimizerStage {\n public:\n  explicit ReplaceMulWithBroadcastByTile(\n      const GraphOptimizerContext& ctx,\n      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"ReplaceMulWithBroadcastByTile\", ctx,\n                                 ctx_ext) {}\n  ~ReplaceMulWithBroadcastByTile() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsMul(*node) && !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    NodeDef *input, *ones;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &input));\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(1), &ones));\n    if (IsInPreserveSet(*node) || IsInPreserveSet(*input) ||\n        IsInPreserveSet(*ones)) {\n      return Status::OK();\n    }\n\n    // TODO(kkiningh): Generalize using IsOnes from constant_folding.cc\n    if (IsConstant(*input) || !IsOnes(*ones)) return Status::OK();\n\n    // Avoid optimizing the same node twice\n    const NodeScopeAndName scope_and_name = ParseNodeScopeAndName(node->name());\n    const string tile_node_name = OptimizedNodeName(scope_and_name, \"Tile\");\n    const string const_node_name = OptimizedNodeName(scope_and_name, \"Const\");\n    if (ctx().node_map->NodeExists(tile_node_name) ||\n        ctx().node_map->NodeExists(const_node_name)) {\n      return Status::OK();\n    }\n\n    const std::vector<OpInfo::TensorProperties>& props =\n        ctx().graph_properties->GetInputProperties(node->name());\n    if (props.size() != 2) return Status::OK();\n\n    // Ignore ops where the shape doesn't change\n    const TensorShapeProto& input_shape = props[0].shape();\n    const TensorShapeProto& ones_shape = props[1].shape();\n    TensorShapeProto output_shape;\n    if (!ShapeAfterBroadcast(input_shape, ones_shape, &output_shape)) {\n      return Status::OK();\n    }\n    if (ShapesSymbolicallyEqual(input_shape, output_shape)) {\n      return Status::OK();\n    }\n\n    // All inputs must have same input/output dimensions\n    if (input_shape.dim_size() != output_shape.dim_size() ||\n        ones_shape.dim_size() != output_shape.dim_size())\n      return Status::OK();\n\n    // At this point all preconditions are met. Can proceed with rewrite.\n    VLOG(3) << \"Simplify multiply with all ones input: node=\" << node->name()\n            << \"@\" << output_shape << \" ones=\" << ones->name() << \"@\"\n            << ones_shape << \" input=\" << input->name() << \"@\" << input_shape;\n\n    // 1. Create constant node with correct tile multiples\n    Tensor multiples(DT_INT32, TensorShape({output_shape.dim_size()}));\n    for (int i = 0; i < output_shape.dim_size(); ++i) {\n      int64 size = output_shape.dim(i).size() / input_shape.dim(i).size();\n      if (TF_PREDICT_FALSE(size >= INT_MAX)) {\n        return Status(error::OUT_OF_RANGE, \"int32 overflow\");\n      }\n      multiples.flat<int32>()(i) = static_cast<int32>(size);\n    }\n\n    NodeDef* const_node = AddEmptyNode(const_node_name);\n    TF_RETURN_IF_ERROR(ConstantFolding::CreateNodeDef(\n        const_node->name(), TensorValue(&multiples), const_node));\n    const_node->set_device(node->device());\n    ForwardControlDependencies(const_node, {ones});\n    AddToOptimizationQueue(const_node);\n\n    // 2. Replace multiply node with Tile(Const, input);\n    const DataType type = GetDataTypeFromAttr(*node, \"T\");\n    NodeDef* tile_node = AddEmptyNode(tile_node_name);\n    tile_node->set_op(\"Tile\");\n    tile_node->set_device(node->device());\n    SetDataTypeToAttr(type, \"T\", tile_node);\n    SetDataTypeToAttr(DT_INT32, \"Tmultiples\", tile_node);\n    tile_node->add_input(input->name());\n    tile_node->add_input(const_node->name());\n\n    ForwardControlDependencies(tile_node, {node});\n    *simplified_node_name = tile_node->name();\n\n    return Status::OK();\n  }\n\n protected:\n  bool IsOnes(const NodeDef& node) const {\n    if (!IsReallyConstant(node)) return false;\n    if (node.attr().at(\"dtype\").type() != DT_FLOAT) return false;\n\n    Tensor tensor;\n    if (!tensor.FromProto(node.attr().at(\"value\").tensor())) {\n      return false;\n    }\n\n    auto values = tensor.flat<float>();\n    for (int i = 0; i < tensor.NumElements(); ++i) {\n      if (values(i) != 1.0f) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n\n// Image upsampling often produces an unnecessary reshape that is difficult to\n// eliminate in other stages. This stage reduces the number of dimensions\n// involved allowing the reshape to be removed.\n//\n// For example, given\n//   B,W,H,C -> Reshape(B,W,1,H,1,C) -> Tile(1,1,2,1,2,1) -> Reshape(B,2W,2H,C)\n// this pass converts the sequence to\n//   B,W,H,C -> Reshape(B,W,H,C) -> Tile(1,1,2,2) -> Reshape(B,2W,2H,C)\n//\n// The first reshape is now redundant and can be removed in a later pass.\n//\n// Note: This only optimizes the simple (but extremely common) case of 2D\n// upsampling.\n//\n// TODO(kkiningh): Generalize to more complex upsampling patterns.\nclass ReduceUpsamplingDims : public ArithmeticOptimizerStage {\n public:\n  explicit ReduceUpsamplingDims(const GraphOptimizerContext& ctx,\n                                const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"ReduceUpsamplingDims\", ctx, ctx_ext) {}\n  ~ReduceUpsamplingDims() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsReshape(*node) && !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    NodeDef* tile;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &tile));\n    if (!IsTile(*tile) || IsInPreserveSet(*tile)) {\n      return Status::OK();\n    }\n\n    if (NumNonControlOutputs(*tile, *ctx().node_map) != 1) {\n      // Optimization is only worthwile when there is a single output from Tile.\n      // Otherwise, we need to insert addtional Reshape ops that can't be easily\n      // removed.\n      return Status::OK();\n    }\n\n    NodeDef* reshape;\n    TF_RETURN_IF_ERROR(GetInputNode(tile->input(0), &reshape));\n    if (!IsReshape(*reshape) || IsInPreserveSet(*reshape)) {\n      return Status::OK();\n    }\n\n    NodeDef* multiples;\n    TF_RETURN_IF_ERROR(GetInputNode(tile->input(1), &multiples));\n\n    NodeDef* shape;\n    TF_RETURN_IF_ERROR(GetInputNode(reshape->input(1), &shape));\n\n    // Avoid optimizing the same nodes twice\n    const NodeScopeAndName scope_and_name = ParseNodeScopeAndName(node->name());\n    const string new_reshape_name =\n        OptimizedNodeName(scope_and_name, \"Reshape\");\n    const string new_tile_name = OptimizedNodeName(scope_and_name, \"Tile\");\n    const string new_multiples_name =\n        OptimizedNodeName(scope_and_name, \"Multiples\");\n    const string new_shape_name = OptimizedNodeName(scope_and_name, \"Shape\");\n    if (ctx().node_map->NodeExists(new_reshape_name) ||\n        ctx().node_map->NodeExists(new_tile_name) ||\n        ctx().node_map->NodeExists(new_shape_name) ||\n        ctx().node_map->NodeExists(new_multiples_name)) {\n      return Status::OK();\n    }\n\n    // Compuate updated multiples/shape values.\n    AttrValue new_multiples_attr;\n    if (!CreateUpdatedMultiplesProto(multiples,\n                                     new_multiples_attr.mutable_tensor())) {\n      return Status::OK();\n    }\n    AttrValue new_shape_attr;\n    if (!CreateUpdatedShapeProto(shape, new_shape_attr.mutable_tensor())) {\n      return Status::OK();\n    }\n\n    // At this point the graph is validated and can be updated\n    // Note: We can assume shape/multiples are DT_INT32 ony at this point since\n    // they're checked in CreateUpdated*Proto()\n\n    // 1. Create the constant nodes used by the new Reshape/Tile nodes\n    NodeDef* new_multiples = AddEmptyNode(new_multiples_name);\n    new_multiples->set_op(\"Const\");\n    SetDataTypeToAttr(DT_INT32, \"dtype\", new_multiples);\n    new_multiples->mutable_attr()->insert({\"value\", new_multiples_attr});\n    new_multiples->set_device(multiples->device());\n\n    NodeDef* new_shape = AddEmptyNode(new_shape_name);\n    new_shape->set_op(\"Const\");\n    SetDataTypeToAttr(DT_INT32, \"dtype\", new_shape);\n    new_shape->mutable_attr()->insert({\"value\", new_shape_attr});\n    new_shape->set_device(shape->device());\n\n    // 2. Create the new Reshape/Tile nodes\n    NodeDef* new_reshape = AddEmptyNode(new_reshape_name);\n    CopyReshapeWithInput(reshape, new_reshape, /*input=*/reshape->input(0),\n                         /*shape=*/new_shape->name());\n    NodeDef* new_tile = AddEmptyNode(new_tile_name);\n    CopyTileWithInput(tile, new_tile, /*input=*/new_reshape->name(),\n                      /*multiples=*/new_multiples->name());\n\n    // 3. Update consumer of original Tile node and add control\n    node->set_input(0, new_tile->name());\n    ctx().node_map->UpdateInput(node->name(), tile->name(), new_tile->name());\n\n    ForwardControlDependencies(new_tile, {tile});\n    ForwardControlDependencies(new_multiples, {multiples});\n    ForwardControlDependencies(new_reshape, {reshape});\n    ForwardControlDependencies(new_shape, {shape});\n\n    *simplified_node_name = node->name();\n    return Status::OK();\n  }\n\n private:\n  bool CreateUpdatedMultiplesProto(const NodeDef* node, TensorProto* proto) {\n    Tensor multiples;\n    if (!GetTensorFromConstNode(node->name(), &multiples)) {\n      return false;\n    }\n\n    // Dimensions should be [X, Y, N, 1, M, 1]\n    if (multiples.dtype() != DT_INT32 || multiples.NumElements() != 6) {\n      return false;\n    }\n\n    const auto& multiples_values = multiples.flat<int32>();\n    if (multiples_values(3) != 1 || multiples_values(5) != 1) {\n      return false;\n    }\n\n    // Convert to [X, Y, N, M]\n    Tensor new_multiples(DT_INT32, {4});\n    new_multiples.flat<int32>()(0) = multiples_values(0);\n    new_multiples.flat<int32>()(1) = multiples_values(1);\n    new_multiples.flat<int32>()(2) = multiples_values(2);\n    new_multiples.flat<int32>()(3) = multiples_values(4);\n\n    new_multiples.AsProtoTensorContent(proto);\n    return true;\n  }\n\n  bool CreateUpdatedShapeProto(const NodeDef* node, TensorProto* proto) {\n    Tensor shape;\n    if (!GetTensorFromConstNode(node->name(), &shape)) {\n      return false;\n    }\n\n    // Dimensions should be [B, W, 1, H, 1, C]\n    if (shape.dtype() != DT_INT32 || shape.NumElements() != 6) {\n      return false;\n    }\n\n    const auto& shape_values = shape.flat<int32>();\n    if (shape_values(2) != 1 || shape_values(4) != 1) {\n      return false;\n    }\n\n    // Convert to [B, W, H, C]\n    Tensor new_shape(DT_INT32, {4});\n    new_shape.flat<int32>()(0) = shape_values(0);\n    new_shape.flat<int32>()(1) = shape_values(1);\n    new_shape.flat<int32>()(2) = shape_values(3);\n    new_shape.flat<int32>()(3) = shape_values(5);\n\n    new_shape.AsProtoTensorContent(proto);\n    return true;\n  }\n\n  void CopyReshapeWithInput(const NodeDef* reshape, NodeDef* new_reshape,\n                            const string& input, const string& shape) {\n    new_reshape->set_op(\"Reshape\");\n    new_reshape->set_device(reshape->device());\n    SetDataTypeToAttr(GetDataTypeFromAttr(*reshape, \"T\"), \"T\", new_reshape);\n    SetDataTypeToAttr(GetDataTypeFromAttr(*reshape, \"Tshape\"), \"Tshape\",\n                      new_reshape);\n\n    new_reshape->add_input(input);\n    ctx().node_map->AddOutput(NodeName(input), new_reshape->name());\n    new_reshape->add_input(shape);\n    ctx().node_map->AddOutput(NodeName(shape), new_reshape->name());\n\n    AddToOptimizationQueue(new_reshape);\n  }\n\n  void CopyTileWithInput(const NodeDef* tile, NodeDef* new_tile,\n                         const string& input, const string& multiples) {\n    new_tile->set_op(\"Tile\");\n    new_tile->set_device(tile->device());\n    SetDataTypeToAttr(GetDataTypeFromAttr(*tile, \"T\"), \"T\", new_tile);\n    SetDataTypeToAttr(GetDataTypeFromAttr(*tile, \"Tmultiples\"), \"Tmultiples\",\n                      new_tile);\n\n    new_tile->add_input(input);\n    ctx().node_map->AddOutput(NodeName(input), new_tile->name());\n    new_tile->add_input(multiples);\n    ctx().node_map->AddOutput(NodeName(multiples), new_tile->name());\n\n    AddToOptimizationQueue(new_tile);\n  }\n};\n\n// Replace a sequence of Pack nodes with identical inputs with Tile\n// For example, given a Tensor X with shape (I,J,K)\n// Let P(x, n) = Pack([x, x], axis=n)\n//\n// P(P(X, 2), 1)\n//   = Tile(Reshape(Tile(Reshape(x,\n//              [I,    J, 1, K]), [1,    1, 2, 1]),\n//              [I, 1, J, 2, K]), [1, 2, 1, 1, 1]))\n//   = Tile(Reshape(x,\n//              [I, 1, J, 1, K]), [1, 2, 1, 2, 1])\n//   = Reshape(Tile(x, [1, 2, 2]), [I, 2, J, 2, K])\n//\n// The outermost reshape is often redundant and can be removed in another pass\nclass ReplacePackWithTileReshape : public ArithmeticOptimizerStage {\n public:\n  explicit ReplacePackWithTileReshape(const GraphOptimizerContext& ctx,\n                                      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"ReplacePackWithTileReshape\", ctx, ctx_ext) {}\n  ~ReplacePackWithTileReshape() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsPack(*node) && NumNonControlInputs(*node) > 1 &&\n           !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    // 1. traverse the chain of Pack ops to get the original input\n    NodeDef* input = node;\n    std::vector<const NodeDef*> chain;\n    while (IsPack(*input) && NumNonControlInputs(*node) > 1 &&\n           !IsInPreserveSet(*input)) {\n      // Only pack operations with all identical inputs are supported\n      if (!AllRegularInputsEqual(*input)) {\n        break;\n      }\n      chain.push_back(input);\n      TF_RETURN_IF_ERROR(GetInputNode(input->input(0), &input));\n    }\n\n    // Must be at least two Pack operations to consider for replacement\n    if (chain.empty()) {\n      return Status::OK();\n    }\n\n    // Avoid optimizing the same node twice\n    const NodeScopeAndName node_scope_and_name =\n        ParseNodeScopeAndName(node->name());\n    const string new_const_name =\n        OptimizedNodeName(node_scope_and_name, \"Multiples\");\n    const string new_tile_name = OptimizedNodeName(node_scope_and_name, \"Tile\");\n    const string new_shape_name =\n        OptimizedNodeName(node_scope_and_name, \"Shape\");\n    const string new_reshape_name =\n        OptimizedNodeName(node_scope_and_name, \"Reshape\");\n    if (ctx().node_map->NodeExists(new_const_name) ||\n        ctx().node_map->NodeExists(new_tile_name) ||\n        ctx().node_map->NodeExists(new_shape_name) ||\n        ctx().node_map->NodeExists(new_reshape_name)) {\n      return Status::OK();\n    }\n\n    // 2. Calculate the multiples and shape tensor using the chain\n    const OpInfo::TensorProperties* input_props;\n    TF_RETURN_IF_ERROR(GetTensorProperties(input->name(), &input_props));\n    const TensorShapeProto& input_shape = input_props->shape();\n    if (!PartialTensorShape(input_shape).IsFullyDefined()) {\n      return Status::OK();\n    }\n    Tensor multiples(DT_INT32, TensorShape({input_shape.dim_size()}));\n    TF_RETURN_IF_ERROR(CalculateMultiplesFromChain(chain, &multiples));\n\n    const OpInfo::TensorProperties* output_props;\n    TF_RETURN_IF_ERROR(GetTensorProperties(node->name(), &output_props));\n    const TensorShapeProto& output_shape = output_props->shape();\n    if (!PartialTensorShape(output_shape).IsFullyDefined()) {\n      return Status::OK();\n    }\n    Tensor output_shape_tensor(DT_INT32,\n                               TensorShape({output_shape.dim_size()}));\n    for (int i = 0; i < output_shape.dim_size(); ++i) {\n      output_shape_tensor.flat<int32>()(i) = output_shape.dim(i).size();\n    }\n\n    // 3. Create constant node with correct multiples value\n    NodeDef* new_const_node = AddEmptyNode(new_const_name);\n    TF_RETURN_IF_ERROR(ConstantFolding::CreateNodeDef(\n        new_const_node->name(), TensorValue(&multiples), new_const_node));\n    new_const_node->set_device(node->device());\n    MaybeAddControlInput(input->name(), new_const_node, ctx().optimized_graph,\n                         ctx().node_map);\n    AddToOptimizationQueue(new_const_node);\n\n    // 4. Replace the Pack node with Tile(Const(N), input);\n    DataType dtype = GetDataTypeFromAttr(*node, \"T\");\n    NodeDef* new_tile_node = AddEmptyNode(new_tile_name);\n    new_tile_node->set_op(\"Tile\");\n    new_tile_node->set_device(node->device());\n    SetDataTypeToAttr(dtype, \"T\", new_tile_node);\n    SetDataTypeToAttr(DT_INT32, \"Tmultiples\", new_tile_node);\n    new_tile_node->add_input(input->name());\n    ctx().node_map->AddOutput(input->name(), new_tile_node->name());\n    new_tile_node->add_input(new_const_node->name());\n    ctx().node_map->AddOutput(new_const_node->name(), new_tile_node->name());\n\n    // Tile inherits all control dependencies from the original pack chain\n    ForwardControlDependencies(new_tile_node, chain);\n    AddToOptimizationQueue(new_tile_node);\n\n    // 5. Add a new Reshape node to preserve the existing shape\n    NodeDef* new_shape_node = AddEmptyNode(new_shape_name);\n    TF_RETURN_IF_ERROR(ConstantFolding::CreateNodeDef(\n        new_shape_node->name(), TensorValue(&output_shape_tensor),\n        new_shape_node));\n    new_shape_node->set_device(node->device());\n    MaybeAddControlInput(input->name(), new_shape_node, ctx().optimized_graph,\n                         ctx().node_map);\n    AddToOptimizationQueue(new_shape_node);\n\n    NodeDef* new_reshape_node = AddEmptyNode(new_reshape_name);\n    new_reshape_node->set_op(\"Reshape\");\n    new_reshape_node->set_device(node->device());\n    SetDataTypeToAttr(dtype, \"T\", new_reshape_node);\n    SetDataTypeToAttr(DT_INT32, \"Tshape\", new_reshape_node);\n    new_reshape_node->add_input(new_tile_node->name());\n    ctx().node_map->AddOutput(new_tile_node->name(), new_reshape_node->name());\n    new_reshape_node->add_input(new_shape_node->name());\n    ctx().node_map->AddOutput(new_shape_node->name(), new_reshape_node->name());\n\n    *simplified_node_name = new_reshape_node->name();\n\n    return Status::OK();\n  }\n\n protected:\n  Status CalculateMultiplesFromChain(const std::vector<const NodeDef*>& chain,\n                                     Tensor* multiples) {\n    // Keep track of how the multiples correspond to each shape dimension.\n    // For example, given Stack([x, x], axis=1) with rank(x) = 3, we start with\n    //    multiples=[1, 1, 1] , dims=[0, 1, 2]\n    // After processing the stack op\n    //    multiples=[1, 2, 1] , dims=[0, 1, 1, 2]\n    std::vector<int32> dims(multiples->NumElements());\n    std::iota(dims.begin(), dims.end(), 0);\n\n    for (int i = 0; i < multiples->NumElements(); ++i) {\n      multiples->flat<int32>()(i) = 1;\n    }\n\n    for (auto it = chain.rbegin(); it != chain.rend(); ++it) {\n      AttrSlice attrs(**it);\n      int64 axis, n;\n      TF_RETURN_IF_ERROR(GetNodeAttr(attrs, \"axis\", &axis));\n      TF_RETURN_IF_ERROR(GetNodeAttr(attrs, \"N\", &n));\n\n      if (axis >= dims.size()) {\n        // We don't handle the case where Pack is performed on the last axis,\n        // e.g. Pack([x, x], axis=3) where rank(x) == 3\n        return Status(error::OUT_OF_RANGE, \"axis value out of range of dims\");\n      }\n\n      int64 m = multiples->flat<int32>()(dims[axis]) * n;\n      if (TF_PREDICT_FALSE(m > INT_MAX)) {\n        return Status(error::OUT_OF_RANGE, \"int32 overflow\");\n      }\n      multiples->flat<int32>()(dims[axis]) = static_cast<int32>(m);\n\n      // Copy index from immediate right of inserted axis\n      dims.insert(dims.begin() + axis, dims[axis]);\n    }\n\n    return Status::OK();\n  }\n};\n\n// Simplify aggregation (e.g. AddN) nodes:\n//\n// 1. Discard aggregate nodes with a single input and no control dependencies.\n//\n// 2. Try to rewrite aggregations of N >= 2 identical terms (possibly due to\n//    deduping or other rewrites) so we can get rid of the sum entirely.\n//\n//    The expression (using AddN as an example of an aggregate op):\n//      AddN(x, x, x, ... ,x)\n//           <-- N terms -->\n//    can be rewritten to:\n//      Mul(Const(N), x))\n//\nclass SimplifyAggregation : public ArithmeticOptimizerStage {\n public:\n  explicit SimplifyAggregation(const GraphOptimizerContext& ctx,\n                               const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"SimplifyAggregation\", ctx, ctx_ext) {}\n  ~SimplifyAggregation() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsAggregate(*node) && HasRegularInputs(*node) &&\n           GetDataTypeFromAttr(*node, \"T\") !=\n               DT_VARIANT;  // TODO(b/119787146): Enable for variants.\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    // 1. Discard aggregate nodes with a single input and no control deps.\n    if (node->input_size() == 1) {\n      *simplified_node_name = node->input(0);\n      return Status::OK();\n    }\n\n    // 2. Rewrite aggregations of N >= 2 identical terms.\n\n    // All non-control inputs must be identical.\n    bool all_equal = true;\n    int num_inputs = 1;\n    for (int i = 1; i < node->input_size(); ++i) {\n      if (IsControlInput(node->input(i))) break;\n      ++num_inputs;\n      if (node->input(i) != node->input(0)) {\n        all_equal = false;\n        break;\n      }\n    }\n    if (!all_equal) return Status::OK();\n\n    // And node should not be optimized earlier.\n    const NodeScopeAndName node_scope_and_name =\n        ParseNodeScopeAndName(node->name());\n    const string optimized_const_name =\n        OptimizedNodeName(node_scope_and_name, \"Const\");\n    const string optimized_mul_name =\n        OptimizedNodeName(node_scope_and_name, \"Mul\");\n\n    bool is_already_optimized =\n        ctx().node_map->NodeExists(optimized_const_name) ||\n        ctx().node_map->NodeExists(optimized_mul_name);\n\n    if (is_already_optimized) return Status::OK();\n\n    // At this point all preconditions are met, and we safely do the rewrite.\n    VLOG(3) << \"Simplify aggregation with identical inputs: node=\"\n            << node->name() << \" num_inputs=\" << num_inputs;\n\n    // 1. Create constant node with value N.\n    const auto type = GetDataTypeFromAttr(*node, \"T\");\n    Tensor t(type, TensorShape({}));\n    Status status = SetTensorValue(type, num_inputs, &t);\n    if (!status.ok()) {\n      return errors::Internal(\"Failed to create const node: \",\n                              status.error_message());\n    }\n\n    TensorValue value(&t);\n    NodeDef* new_const_node = AddEmptyNode(optimized_const_name);\n    status = ConstantFolding::CreateNodeDef(new_const_node->name(), value,\n                                            new_const_node);\n    if (!status.ok()) {\n      return errors::Internal(\"Failed to create const node: \",\n                              status.error_message());\n    }\n    new_const_node->set_device(node->device());\n    MaybeAddControlInput(NodeName(node->input(0)), new_const_node,\n                         ctx().optimized_graph, ctx().node_map);\n    AddToOptimizationQueue(new_const_node);\n\n    // 2. Replace the aggregate node with Mul(Const(N), x).\n    NodeDef* new_mul_node = AddEmptyNode(optimized_mul_name);\n    new_mul_node->set_op(\"Mul\");\n    new_mul_node->set_device(node->device());\n    SetDataTypeToAttr(type, \"T\", new_mul_node);\n    new_mul_node->add_input(new_const_node->name());\n    ctx().node_map->AddOutput(new_const_node->name(), new_mul_node->name());\n    new_mul_node->add_input(node->input(0));\n    ctx().node_map->AddOutput(node->input(0), new_mul_node->name());\n\n    ForwardControlDependencies(new_mul_node, {node});\n    *simplified_node_name = new_mul_node->name();\n\n    return Status::OK();\n  }\n};\n\nclass ConvertPowStage : public ArithmeticOptimizerStage {\n public:\n  explicit ConvertPowStage(const GraphOptimizerContext& ctx,\n                           const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"ConvertPow\", ctx, ctx_ext) {}\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsPow(*node) &&\n           ctx().graph_properties->HasOutputProperties(node->name()) &&\n           ctx().graph_properties->HasInputProperties(node->name());\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    Tensor pow;\n    if (!GetTensorFromConstNode(node->input(1), &pow)) return Status::OK();\n    complex128 prev, curr;\n    for (int i = 0; i < pow.NumElements(); ++i) {\n      if (!GetElementUnexhaustive(pow, i, {pow.dtype()}, &curr)) {\n        // input data type is not supported by Pow. Skip.\n        return Status::OK();\n      }\n      if (i != 0 && curr != prev) {\n        // pow has different values on different elements. Skip.\n        return Status::OK();\n      }\n      prev = curr;\n    }\n    NodeDef *x, *y;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &x));\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(1), &y));\n    const auto& value_props =\n        ctx().graph_properties->GetInputProperties(node->name())[0];\n    const TensorShapeProto& output_shape =\n        ctx().graph_properties->GetOutputProperties(node->name())[0].shape();\n    if (curr == complex128(2, 0)) {\n      node->set_op(\"Square\");\n      node->set_input(1, AsControlDependency(y->name()));\n      AddToOptimizationQueue(node);\n      AddToOptimizationQueue(y);\n    } else if (curr == complex128(3, 0)) {\n      // TODO(courbet): Use 'Cube' when it's added to TF ops.\n      if (NodeIsOnCpu(*node)) {\n        // We create an inner square node: inner_square = square(x)\n        const NodeScopeAndName scope_and_name =\n            ParseNodeScopeAndName(node->name());\n        const string inner_square_name =\n            OptimizedNodeName(scope_and_name, \"_inner\");\n        NodeDef* inner_square_node = ctx().node_map->GetNode(inner_square_name);\n        if (inner_square_node == nullptr) {\n          inner_square_node = AddCopyNode(inner_square_name, node);\n          inner_square_node->set_op(\"Square\");\n          inner_square_node->mutable_input()->RemoveLast();\n        }\n        ctx().node_map->AddOutput(x->name(), inner_square_node->name());\n        // We modify `node`: node = mul(x, inner_square);\n        node->set_op(\"Mul\");\n        node->set_input(1, inner_square_node->name());\n        node->add_input(AsControlDependency(y->name()));\n\n        AddToOptimizationQueue(node);\n        AddToOptimizationQueue(inner_square_node);\n        AddToOptimizationQueue(y);\n      }\n    } else if (curr == complex128(1, 0) &&\n               ShapesSymbolicallyEqual(value_props.shape(), output_shape)) {\n      // Pow could be used to broadcast, so make sure the shapes of the two\n      // arguments are identical before replacing Pow with Identity.\n      node->set_op(\"Identity\");\n      node->set_input(1, AsControlDependency(y->name()));\n      AddToOptimizationQueue(node);\n      AddToOptimizationQueue(y);\n    } else if (curr == complex128(0.5, 0)) {\n      node->set_op(\"Sqrt\");\n      node->set_input(1, AsControlDependency(y->name()));\n      AddToOptimizationQueue(node);\n      AddToOptimizationQueue(y);\n    } else if (curr == complex128(0, 0) &&\n               ShapesSymbolicallyEqual(value_props.shape(), output_shape) &&\n               PartialTensorShape(output_shape).IsFullyDefined()) {\n      const auto dtype = node->attr().at(\"T\").type();\n      Tensor ones(dtype, output_shape);\n      for (int i = 0; i < ones.NumElements(); ++i) {\n        TF_RETURN_IF_ERROR(SetElementToOne(i, &ones));\n      }\n      node->set_op(\"Const\");\n      (*node->mutable_attr())[\"dtype\"].set_type(dtype);\n      node->mutable_attr()->erase(\"T\");\n      ones.AsProtoTensorContent(\n          (*node->mutable_attr())[\"value\"].mutable_tensor());\n      node->set_input(0, AsControlDependency(x->name()));\n      node->set_input(1, AsControlDependency(y->name()));\n      AddToOptimizationQueue(node);\n      AddToOptimizationQueue(x);\n      AddToOptimizationQueue(y);\n    } else if (curr == complex128(-0.5, 0)) {\n      node->set_op(\"Rsqrt\");\n      node->set_input(1, AsControlDependency(y->name()));\n      AddToOptimizationQueue(node);\n      AddToOptimizationQueue(y);\n    } else if (curr == complex128(-1, 0)) {\n      node->set_op(\"Reciprocal\");\n      node->set_input(1, AsControlDependency(y->name()));\n      AddToOptimizationQueue(node);\n      AddToOptimizationQueue(y);\n    }\n    return Status::OK();\n  }\n\n private:\n  Status SetElementToOne(int i, Tensor* t) {\n    switch (t->dtype()) {\n      case DT_INT32:\n        t->flat<int32>()(i) = 1;\n        return Status::OK();\n      case DT_INT64:\n        t->flat<int64>()(i) = 1L;\n        return Status::OK();\n      case DT_FLOAT:\n        t->flat<float>()(i) = 1.0f;\n        return Status::OK();\n      case DT_DOUBLE:\n        t->flat<double>()(i) = 1.0;\n        return Status::OK();\n      case DT_COMPLEX64:\n        t->flat<complex64>()(i) = complex64(1);\n        return Status::OK();\n      case DT_COMPLEX128:\n        t->flat<complex128>()(i) = complex128(1);\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\"Invalid data type: \", t->dtype());\n    }\n  }\n};\n\nclass ConvertLog1pStage : public ArithmeticOptimizerStage {\n public:\n  explicit ConvertLog1pStage(const GraphOptimizerContext& ctx,\n                             const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"ConvertLog1p\", ctx, ctx_ext) {}\n  ~ConvertLog1pStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override { return IsLog(*node); }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    NodeDef* input;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &input));\n    if (!IsAdd(*input)) {\n      return Status::OK();\n    }\n\n    if (ctx().graph_properties->GetInputProperties(input->name()).size() < 2) {\n      return Status::OK();\n    }\n\n    bool modified = false;\n    TF_RETURN_IF_ERROR(TrySimplifyInternal(node, input, 0, 1, &modified));\n    if (!modified) {\n      TF_RETURN_IF_ERROR(TrySimplifyInternal(node, input, 1, 0, &modified));\n    }\n    if (modified) {\n      *simplified_node_name = node->name();\n    }\n    return Status::OK();\n  }\n\n private:\n  Status TrySimplifyInternal(NodeDef* node, NodeDef* add_node, int i, int j,\n                             bool* modified) {\n    const auto& t =\n        ctx().graph_properties->GetInputProperties(add_node->name())[i];\n    const auto& c =\n        ctx().graph_properties->GetInputProperties(add_node->name())[j];\n    for (int k = 0; k < c.shape().dim_size(); ++k) {\n      // Skip if c shape is not fully determined.\n      if (c.shape().dim(k).size() < 0) {\n        return Status::OK();\n      }\n    }\n    TensorShapeProto broadcast_shape;\n    if (!ShapeAfterBroadcast(t.shape(), c.shape(), &broadcast_shape)) {\n      return Status::OK();\n    }\n    if (!ShapesSymbolicallyEqual(t.shape(), broadcast_shape)) {\n      // skip if the non-constant tensor doesn't have the same shape after\n      // broadcast.\n      return Status::OK();\n    }\n    Tensor constant;\n    if (GetTensorFromConstNode(add_node->input(j), &constant)) {\n      complex128 element;\n      // TODO(rmlarsen): Refactor the more general IsOnes from\n      // constant_folding.cc and use it here. Perhaps also convert log(x - (-1))\n      // or (preferably) add a passes to canonicalize Sub(x, -1) to Add(x, 1),\n      // and Neg(-1) to 1.\n      for (int k = 0; k < constant.NumElements(); ++k) {\n        if (!GetElementUnexhaustive(constant, k,\n                                    {DT_BFLOAT16, DT_HALF, DT_FLOAT, DT_DOUBLE,\n                                     DT_COMPLEX64, DT_COMPLEX128},\n                                    &element)) {\n          // input data type is not supported by log1p. Skip.\n          return Status::OK();\n        }\n        if (element != complex128(1)) {\n          // current element is not 1. Skip.\n          return Status::OK();\n        }\n      }\n      NodeDef *x, *y;\n      TF_RETURN_IF_ERROR(GetInputNode(add_node->input(i), &x));\n      TF_RETURN_IF_ERROR(GetInputNode(add_node->input(j), &y));\n      node->set_op(\"Log1p\");\n      node->set_input(0, add_node->input(i));\n      node->add_input(AsControlDependency(y->name()));\n      ForwardControlDependencies(node, {add_node});\n\n      AddToOptimizationQueue(node);\n      AddToOptimizationQueue(add_node);\n      AddToOptimizationQueue(x);\n      AddToOptimizationQueue(y);\n      *modified = true;\n    }\n    return Status::OK();\n  }\n};\n\nclass ConvertExpm1Stage : public ArithmeticOptimizerStage {\n public:\n  explicit ConvertExpm1Stage(const GraphOptimizerContext& ctx,\n                             const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"ConvertExpm1\", ctx, ctx_ext) {}\n  ~ConvertExpm1Stage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    if (!IsSub(*node)) return false;\n\n    NodeDef* input;\n    if (!GetInputNode(node->input(0), &input).ok()) return false;\n\n    return IsExp(*input);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    if (ctx().graph_properties->GetInputProperties(node->name()).size() < 2) {\n      return Status::OK();\n    }\n    const auto& t = ctx().graph_properties->GetInputProperties(node->name())[0];\n    const auto& c = ctx().graph_properties->GetInputProperties(node->name())[1];\n    TensorShapeProto broadcast_shape;\n    if (!ShapeAfterBroadcast(t.shape(), c.shape(), &broadcast_shape)) {\n      return Status::OK();\n    }\n    if (!ShapesSymbolicallyEqual(t.shape(), broadcast_shape)) {\n      // skip if the non-constant tensor doesn't have the same shape after\n      // broadcast.\n      return Status::OK();\n    }\n    Tensor constant;\n    if (!GetTensorFromConstNode(node->input(1), &constant)) return Status::OK();\n    // TODO(rmlarsen): Use the more general IsOnes helper here.\n    complex128 element;\n    for (int k = 0; k < constant.NumElements(); ++k) {\n      if (!GetElementUnexhaustive(constant, k,\n                                  {DT_BFLOAT16, DT_HALF, DT_FLOAT, DT_DOUBLE,\n                                   DT_COMPLEX64, DT_COMPLEX128},\n                                  &element)) {\n        // input data type is not supported by expm1. Skip.\n        return Status::OK();\n      }\n      if (element != complex128(1)) {\n        // current element is not 1. Skip.\n        return Status::OK();\n      }\n    }\n    NodeDef* exp;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &exp));\n    NodeDef *exp_input, *ones;\n    TF_RETURN_IF_ERROR(GetInputNode(exp->input(0), &exp_input));\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(1), &ones));\n    node->set_op(\"Expm1\");\n    node->set_input(0, exp->input(0));\n    node->set_input(1, AsControlDependency(ones->name()));\n    ForwardControlDependencies(node, {exp});\n\n    AddToOptimizationQueue(node);\n    AddToOptimizationQueue(exp);\n    AddToOptimizationQueue(exp_input);\n    AddToOptimizationQueue(ones);\n    *simplified_node_name = node->name();\n    return Status::OK();\n  }\n};\n\n// Performs conversions like:\n// Max(Sqrt(x)) => Sqrt(Max(x))\n// Checks for a max/min reduction over element-wise monotonic functions, such\n// as Sqrt, Sigmoid, Tanh, etc.\nclass OptimizeMaxOrMinOfMonotonicStage : public ArithmeticOptimizerStage {\n public:\n  explicit OptimizeMaxOrMinOfMonotonicStage(\n      const GraphOptimizerContext& ctx,\n      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"OptimizeMaxOrMinOfMonotonicStage\", ctx,\n                                 ctx_ext) {}\n  ~OptimizeMaxOrMinOfMonotonicStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsAnyMax(*node) || IsAnyMin(*node) || IsAnyMaxPool(*node) ||\n           IsArgMax(*node) || IsArgMin(*node);\n  }\n\n  Status TrySimplify(NodeDef* reduction_node,\n                     string* simplified_node_name) override {\n    if (IsInPreserveSet(*reduction_node)) {\n      return Status::OK();\n    }\n\n    NodeDef* inner_function;\n    TF_RETURN_IF_ERROR(GetInputNode(reduction_node->input(0), &inner_function));\n\n    NodeDef* inner_function_input = nullptr;\n    if (inner_function->input_size() > 0) {\n      TF_RETURN_IF_ERROR(\n          GetInputNode(inner_function->input(0), &inner_function_input));\n    }\n\n    // Optimize only if:\n    // 0. inner_function is not in the preserve set,\n    // 1. inner_function's Op is element-wise monotonic\n    // 2. inner_function's output is not being consumed elsewhere.\n    // 3. is monotonic increasing if reduction_node is a pooling operation\n    //    since we don't have MinPool operations.\n    // 4. inner_functions is not a Relu node with an input from FusedBatchNorm\n    //    or BiasAdd. This pattern will be fused later by remapper.\n    auto can_be_fused_by_remapper = [](const NodeDef& consumer,\n                                       const NodeDef& producer) -> bool {\n      if (IsRelu(consumer) || IsRelu6(consumer)) {\n        if (IsFusedBatchNorm(producer) || IsBiasAdd(producer)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    bool is_non_decreasing = false;\n    if (!IsInPreserveSet(*inner_function) &&\n        IsElementWiseMonotonic(*inner_function, &is_non_decreasing) &&\n        ctx().node_map->GetOutputs(inner_function->name()).size() == 1 &&\n        (is_non_decreasing || !IsAnyMaxPool(*reduction_node)) &&\n        !can_be_fused_by_remapper(*inner_function, *inner_function_input)) {\n      // Swap the first inputs of the inner function Op & the reduction Op.\n      NodeDef* inner_input;\n      TF_RETURN_IF_ERROR(GetInputNode(inner_function->input(0), &inner_input));\n      reduction_node->set_input(0, inner_input->name());\n      ctx().node_map->UpdateInput(reduction_node->name(),\n                                  inner_function->name(), inner_input->name());\n      inner_function->set_input(0, reduction_node->name());\n      UpdateConsumers(reduction_node, inner_function->name());\n      ctx().node_map->UpdateInput(inner_function->name(), inner_input->name(),\n                                  reduction_node->name());\n      if (!is_non_decreasing) {\n        // Flip Min<->Max if the function is non-increasing, e.g.\n        // Max(Neg(x)) = Neg(Min(x)).\n        const string opposite = FlipMinMax(*reduction_node);\n        reduction_node->set_op(opposite);\n      }\n\n      if (IsArgMax(*reduction_node) || IsArgMin(*reduction_node)) {\n        // ArgMax(Sqrt(x)) = ArgMax(x)\n        inner_function->set_op(\"Identity\");\n      }\n\n      AddToOptimizationQueue(reduction_node);\n      AddToOptimizationQueue(inner_function);\n      AddToOptimizationQueue(inner_input);\n    }\n    return Status::OK();\n  }\n\n  void UpdateConsumers(NodeDef* node, const string& new_input) {\n    const string& node_name = node->name();\n    const auto consumers = ctx().node_map->GetOutputs(node_name);\n    for (NodeDef* consumer : consumers) {\n      for (int i = 0; i < consumer->input_size(); ++i) {\n        if (consumer->input(i) == node_name &&\n            consumer->name() != NodeName(new_input)) {\n          consumer->set_input(i, new_input);\n          ctx().node_map->UpdateInput(consumer->name(), node_name, new_input);\n        }\n      }\n      AddToOptimizationQueue(consumer);\n    }\n  }\n\n private:\n  string FlipMinMax(const NodeDef& node) {\n    const string& op = node.op();\n    if (IsAnyMax(node) || IsArgMax(node)) {\n      return str_util::StringReplace(op, \"Max\", \"Min\", false);\n    } else {\n      return str_util::StringReplace(op, \"Min\", \"Max\", false);\n    }\n  }\n};\n\n// Replace a chain of type&shape preserving unary ops with a\n// '_UnaryOpsComposition' node.\n// TODO(ezhulenev): It should be a part of remapper optimizer because it doesn't\n// have to do much with arithmetic (together with FoldMultiplyIntoConv stage?).\nclass UnaryOpsComposition : public ArithmeticOptimizerStage {\n public:\n  explicit UnaryOpsComposition(const GraphOptimizerContext& ctx,\n                               const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"UnaryOpsComposition\", ctx, ctx_ext) {\n    // WARN: This should be consistent with unary_ops_composition.cc.\n    // clang-format off\n    supported_ops_ = {// Ops defined via Eigen scalar ops.\n                      {\"Abs\",        {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Acos\",       {DT_FLOAT,          DT_DOUBLE}},\n                      {\"Acosh\",      {DT_FLOAT,          DT_DOUBLE}},\n                      {\"Asin\",       {DT_FLOAT,          DT_DOUBLE}},\n                      {\"Asinh\",      {DT_FLOAT,          DT_DOUBLE}},\n                      {\"Atan\",       {DT_FLOAT,          DT_DOUBLE}},\n                      {\"Atanh\",      {DT_FLOAT,          DT_DOUBLE}},\n                      {\"Ceil\",       {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Cos\",        {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Cosh\",       {DT_FLOAT,          DT_DOUBLE}},\n                      {\"Expm1\",      {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Exp\",        {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Floor\",      {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Inv\",        {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Log\",        {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Log1p\",      {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Neg\",        {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Reciprocal\", {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Rint\",       {DT_FLOAT,          DT_DOUBLE}},\n                      {\"Round\",      {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Rsqrt\",      {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Sigmoid\",    {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Sin\",        {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Sinh\",       {DT_FLOAT,          DT_DOUBLE}},\n                      {\"Sqrt\",       {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Square\",     {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Tan\",        {DT_FLOAT,          DT_DOUBLE}},\n                      {\"Tanh\",       {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      // Additional ops that are not part of the Eigen.\n                      {\"Elu\",        {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Relu\",       {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Relu6\",      {DT_FLOAT, DT_HALF, DT_DOUBLE}},\n                      {\"Selu\",       {DT_FLOAT, DT_HALF, DT_DOUBLE}}};\n    // clang-format on\n  }\n  ~UnaryOpsComposition() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return CanOptimize(*node) &&\n           // Check that this node was not already a root of a fused chain. If\n           // graph optimization runs twice without pruning in between,\n           // fused_nodes_ will not have this information.\n           !ctx().node_map->NodeExists(OptimizedNodeName(*node));\n  }\n\n  Status TrySimplify(NodeDef* root, string* simplified_node_name) override {\n    TF_RETURN_IF_ERROR(CheckAttrExists(*root, \"T\"));\n    DataType dtype = root->attr().at(\"T\").type();\n\n    // Keep a trace of all supported input nodes that can be fused together.\n    std::vector<string> op_nodes = {root->name()};\n    std::vector<string> op_names = {root->op()};\n\n    // Check if we should follow input(0) while building an op composition.\n    const auto predicate_fn = [&](const NodeDef& input) {\n      if (input.name() == root->name()) return true;\n\n      bool follow_input_node =\n          dtype == GetDataTypeFromAttr(input, \"T\") &&\n          NumNonControlDataOutputs(input, *ctx().node_map) == 1 &&\n          CanOptimize(input);\n\n      if (follow_input_node) {\n        op_nodes.push_back(input.name());\n        op_names.push_back(input.op());\n      }\n\n      return follow_input_node;\n    };\n\n    NodeDef* last_op = GetTailOfChain(\n        *root, *ctx().node_map, /*follow_control_input*/ false, predicate_fn);\n\n    // We were not able to find a chain that can be replaced.\n    if (op_names.size() == 1) return Status::OK();\n\n    // Do not add fused nodes to any other chain.\n    std::for_each(op_nodes.begin(), op_nodes.end(),\n                  [this](const string& name) { AddToFusedNodes(name); });\n\n    // Reverse the trace to get correct composition computation order.\n    std::reverse(op_names.begin(), op_names.end());\n\n    VLOG(2) << \"Fuse unary ops: root=\" << root->name() << \" op_names=[\"\n            << absl::StrJoin(op_names, \", \") << \"]\";\n\n    NodeDef* composition_node = ctx().optimized_graph->add_node();\n    composition_node->set_name(OptimizedNodeName(*root));\n    composition_node->set_op(\"_UnaryOpsComposition\");\n    composition_node->add_input(last_op->input(0));\n    composition_node->set_device(root->device());\n\n    auto attr = composition_node->mutable_attr();\n    SetAttrValue(dtype, &(*attr)[\"T\"]);\n    SetAttrValue(op_names, &(*attr)[\"op_names\"]);\n\n    ctx().node_map->AddNode(composition_node->name(), composition_node);\n    ctx().node_map->AddOutput(NodeName(last_op->input(0)),\n                              composition_node->name());\n\n    *simplified_node_name = composition_node->name();\n\n    return Status::OK();\n  }\n\n private:\n  bool CanOptimize(const NodeDef& node) const {\n    DataType dtype = GetDataTypeFromAttr(node, \"T\");\n    if (!IsSupported(node.op(), dtype)) {\n      return false;\n    }\n    if (IsInPreserveSet(node)) {\n      return false;\n    }\n    if (!NodeIsOnCpu(node)) {\n      return false;\n    }\n    if (NodeIsAlreadyFused(node)) {\n      return false;\n    }\n    return !(IsDrivenByControlDependency(node) ||\n             DrivesControlDependency(node));\n  }\n\n  bool NodeIsAlreadyFused(const NodeDef& node) const {\n    return fused_nodes_.count(node.name()) > 0;\n  }\n\n  string OptimizedNodeName(const NodeDef& node) const {\n    return strings::StrCat(node.name(), \"/unary_ops_composition\");\n  }\n\n  void AddToFusedNodes(const string& name) { fused_nodes_.insert(name); }\n\n  // Check if an op is supported by the _UnaryOpsComposition for the given type.\n  bool IsSupported(const string& op_name, DataType dtype) const {\n    const auto it = supported_ops_.find(op_name);\n    return it != supported_ops_.end() && it->second.count(dtype) > 0;\n  }\n\n  std::unordered_map<string, std::set<DataType>> supported_ops_;\n  std::unordered_set<string> fused_nodes_;\n};\n\n// Replace operations of the form:\n//    x = stack((a_0, a_1, ..., a_{n-1}), axis=k)[:,...,i,...]\n// with\n//    a_i\n// when the strided slice index `i` is applied in the k'th axis.\n//\n// Similarly, replace operations of the form:\n//    x = stack((a_0, a_1, ..., a_{n-1}), axis=k)[:,...,i:i+1,...]\n// with\n//    expand_dims(a_i, axis=k)\n// where the slice operator can be StridedSlice or Slice.\n//\n// TODO(ebrevdo): Extend to also replace operations of the form\n//    concat((a_0, a_1, ..., ), axis=k)[:, ..., s_i:s_{i+1}, ...]\n// with\n//    a_i,\n// when\n//    s_i = cumsum(shape(a)[k] for a in (a_0, ...,))[i]\n// and slicing is in the k'th axis.\nclass RemoveStackSliceSameAxis : public ArithmeticOptimizerStage {\n public:\n  explicit RemoveStackSliceSameAxis(const GraphOptimizerContext& ctx,\n                                    const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveStackStridedSliceSameAxis\", ctx,\n                                 ctx_ext) {}\n  ~RemoveStackSliceSameAxis() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return (IsStridedSlice(*node) || IsSlice(*node)) && !IsInPreserveSet(*node);\n  }\n\n  Status TrySimplify(NodeDef* node, string* simplified_node_name) override {\n    // *node is a StridedSlice NodeDef.\n    NodeDef* pack;\n\n    // Get the input and see if it's a Pack op.\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(0), &pack));\n    if (!IsPack(*pack)) return Status::OK();\n\n    bool return_early;\n    PartialTensorShape pack_output_shape;\n    int pack_axis;\n    TF_RETURN_IF_ERROR(\n        CheckInputs(node, pack, &pack_output_shape, &pack_axis, &return_early));\n    if (return_early) return Status::OK();\n\n    int64 slice_start_value;\n    bool found;\n    bool must_expand_dims;\n    TF_RETURN_IF_ERROR(GetSliceAxis(node, pack, pack_output_shape, pack_axis,\n                                    &slice_start_value, &found,\n                                    &must_expand_dims));\n    if (!found) return Status::OK();\n\n    return RewriteGraph(node, pack, slice_start_value, pack_axis,\n                        must_expand_dims, simplified_node_name);\n  }\n\n protected:\n  Status CheckInputs(const NodeDef* node, const NodeDef* pack,\n                     PartialTensorShape* pack_output_shape, int* pack_axis,\n                     bool* return_early) {\n    *return_early = true;\n    TF_RETURN_IF_ERROR(CheckAttrExists(*pack, \"axis\"));\n\n    *pack_axis = pack->attr().at(\"axis\").i();\n    auto slice_properties =\n        ctx().graph_properties->GetInputProperties(node->name());\n    if (slice_properties.empty() ||\n        slice_properties[0].shape().unknown_rank()) {\n      return Status::OK();\n    }\n    *pack_output_shape = slice_properties[0].shape();\n    const int pack_output_rank = pack_output_shape->dims();\n    if (*pack_axis < 0) {\n      *pack_axis += pack_output_rank;\n    }\n    if (*pack_axis < 0 || *pack_axis >= pack_output_rank) {\n      return errors::InvalidArgument(\n          \"Pack node (\", pack->name(),\n          \") axis attribute is out of bounds: \", pack->attr().at(\"axis\").i());\n    }\n    *return_early = false;\n    return Status::OK();\n  }\n\n  Status GetSliceAxis(const NodeDef* node, const NodeDef* pack,\n                      const PartialTensorShape& pack_output_shape,\n                      int pack_axis, int64* slice_start_value, bool* found,\n                      bool* must_expand_dims) {\n    *found = false;\n    if (IsSlice(*node)) {\n      *must_expand_dims = true;\n      return GetSimpleSliceAxis(node, pack, pack_output_shape, pack_axis,\n                                slice_start_value, found);\n    } else {\n      return GetStridedSliceAxis(node, pack, pack_output_shape, pack_axis,\n                                 slice_start_value, found, must_expand_dims);\n    }\n  }\n\n  Status GetSimpleSliceAxis(const NodeDef* node, const NodeDef* pack,\n                            const PartialTensorShape& pack_output_shape,\n                            int pack_axis, int64* slice_start_value,\n                            bool* found) {\n    NodeDef* slice_begin;\n    NodeDef* slice_size;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(1), &slice_begin));\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(2), &slice_size));\n    for (const auto* n : {slice_begin, slice_size}) {\n      if (!IsReallyConstant(*n)) return Status::OK();\n    }\n\n    Tensor slice_begin_t;\n    Tensor slice_size_t;\n    TF_RETURN_IF_ERROR(CheckAttrExists(*slice_begin, \"value\"));\n    if (!slice_begin_t.FromProto(slice_begin->attr().at(\"value\").tensor())) {\n      return Status::OK();\n    }\n    TF_RETURN_IF_ERROR(CheckAttrExists(*slice_size, \"value\"));\n    if (!slice_size_t.FromProto(slice_size->attr().at(\"value\").tensor())) {\n      return Status::OK();\n    }\n\n    auto copy_tensor_values_to_vector =\n        [node](const Tensor& t, gtl::InlinedVector<int64, 4>* vec) {\n          if (t.dtype() == DT_INT32) {\n            auto t_flat = t.flat<int32>();\n            vec->assign(&t_flat(0), &t_flat(t.NumElements()));\n          } else if (t.dtype() == DT_INT64) {\n            auto t_flat = t.flat<int64>();\n            vec->assign(&t_flat(0), &t_flat(t.NumElements()));\n          } else {\n            return errors::InvalidArgument(\"Node \", node->name(),\n                                           \" has invalid type for Index attr: \",\n                                           DataTypeString(t.dtype()));\n          }\n          return Status::OK();\n        };\n\n    gtl::InlinedVector<int64, 4> slice_begin_vec;\n    gtl::InlinedVector<int64, 4> slice_size_vec;\n    TF_RETURN_IF_ERROR(\n        copy_tensor_values_to_vector(slice_begin_t, &slice_begin_vec));\n    TF_RETURN_IF_ERROR(\n        copy_tensor_values_to_vector(slice_size_t, &slice_size_vec));\n\n    if (slice_begin_vec.size() != slice_size_vec.size()) {\n      return errors::InvalidArgument(\"Node \", node->name(),\n                                     \" has mismatched lengths for begin (\",\n                                     slice_begin_vec.size(), \") and size (\",\n                                     slice_size_vec.size(), \") vectors.\");\n    }\n    int slice_begin_vec_size = slice_begin_vec.size();\n    if (!pack_output_shape.unknown_rank() &&\n        slice_begin_vec_size != pack_output_shape.dims()) {\n      return Status::OK();\n    }\n    if (pack_axis >= slice_begin_vec_size) {\n      return errors::InvalidArgument(\n          \"Input to node \", node->name(), \" had pack_axis \", pack_axis,\n          \" but rank was \", slice_begin_vec_size, \".\");\n    }\n\n    *slice_start_value = slice_begin_vec[pack_axis];\n    if (slice_size_vec[pack_axis] != 1) {\n      // Not slicing a single value out.\n      return Status::OK();\n    }\n\n    for (int i = 0; i < slice_begin_vec_size; ++i) {\n      if (i != pack_axis) {\n        if (slice_begin_vec[i] != 0 ||\n            !(slice_size_vec[i] == -1 ||\n              slice_size_vec[i] == pack_output_shape.dim_size(i))) {\n          // Not slicing on the same axis as the Pack op.\n          return Status::OK();\n        }\n      }\n    }\n\n    if (*slice_start_value < 0 || *slice_start_value >= pack->input_size()) {\n      return errors::InvalidArgument(\n          \"Node \", node->name(), \" requested invalid slice index \",\n          *slice_start_value, \" on axis \", pack_axis,\n          \" from tensor of shape: \", pack_output_shape.DebugString());\n    }\n\n    *found = true;  // slice_start_value is valid.\n    return Status::OK();\n  }\n\n  Status GetStridedSliceAxis(const NodeDef* node, const NodeDef* pack,\n                             const PartialTensorShape& pack_output_shape,\n                             int pack_axis, int64* slice_start_value,\n                             bool* found, bool* must_expand_dims) {\n    TF_RETURN_IF_ERROR(\n        CheckAttrsExist(*node, {\"begin_mask\", \"end_mask\", \"ellipsis_mask\",\n                                \"new_axis_mask\", \"shrink_axis_mask\"}));\n\n    const int begin_mask = node->attr().at(\"begin_mask\").i();\n    const int end_mask = node->attr().at(\"end_mask\").i();\n    const int ellipsis_mask = node->attr().at(\"ellipsis_mask\").i();\n    const int new_axis_mask = node->attr().at(\"new_axis_mask\").i();\n    const int shrink_axis_mask = node->attr().at(\"shrink_axis_mask\").i();\n\n    // Check that the StridedSlice is one of these at pack_axis:\n    //   [..., i, ...]\n    //   [..., i:i+1, ...]\n    //   [..., :1, ...]\n    //   [..., -1:, ...]\n    ///  [..., s_{pack_axis}-1:, ...]\n    NodeDef* slice_begin;\n    NodeDef* slice_end;\n    NodeDef* slice_strides;\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(1), &slice_begin));\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(2), &slice_end));\n    TF_RETURN_IF_ERROR(GetInputNode(node->input(3), &slice_strides));\n\n    for (const auto* n : {slice_begin, slice_end, slice_strides}) {\n      if (!IsReallyConstant(*n)) return Status::OK();\n    }\n\n    Tensor slice_begin_t;\n    Tensor slice_end_t;\n    Tensor slice_strides_t;\n\n    TF_RETURN_IF_ERROR(CheckAttrExists(*slice_begin, \"value\"));\n    if (!slice_begin_t.FromProto(slice_begin->attr().at(\"value\").tensor())) {\n      return Status::OK();\n    }\n    TF_RETURN_IF_ERROR(CheckAttrExists(*slice_end, \"value\"));\n    if (!slice_end_t.FromProto(slice_end->attr().at(\"value\").tensor())) {\n      return Status::OK();\n    }\n    TF_RETURN_IF_ERROR(CheckAttrExists(*slice_strides, \"value\"));\n    if (!slice_strides_t.FromProto(\n            slice_strides->attr().at(\"value\").tensor())) {\n      return Status::OK();\n    }\n    TensorShape processing_shape;\n    TensorShape final_shape;\n    bool is_identity;\n    bool is_simple_slice;\n    bool slice_dim0;\n    gtl::InlinedVector<int64, 4> slice_begin_vec;\n    gtl::InlinedVector<int64, 4> slice_end_vec;\n    gtl::InlinedVector<int64, 4> slice_strides_vec;\n    TF_RETURN_IF_ERROR(ValidateStridedSliceOp(\n        &slice_begin_t, &slice_end_t, slice_strides_t, pack_output_shape,\n        begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask,\n        &processing_shape, &final_shape, &is_identity, &is_simple_slice,\n        &slice_dim0, &slice_begin_vec, &slice_end_vec, &slice_strides_vec));\n\n    if (!is_simple_slice) return Status::OK();\n\n    int begin_index = -1;\n    int64 begin_value = 0;\n    for (int i = 0, end = slice_begin_vec.size(); i < end; ++i) {\n      const int64 v = slice_begin_vec[i];\n      if (v != 0) {\n        if (begin_index != -1) {\n          // At least two start values that are nonzero.\n          return Status::OK();\n        }\n        begin_index = i;\n        begin_value = v;\n      }\n    }\n\n    int end_index = -1;\n    int64 end_value = 0;\n    for (int i = 0, end = slice_begin_vec.size(); i < end; ++i) {\n      const int64 v = slice_end_vec[i];\n      if (v != pack_output_shape.dim_size(i)) {\n        if (end_index != -1) {\n          // At least two end values that are nonzero.\n          return Status::OK();\n        }\n        end_index = i;\n        end_value = v;\n      }\n    }\n\n    if (begin_index == -1 && end_index == -1) return Status::OK();\n    if (begin_index != -1 && end_index != -1 && begin_index != end_index) {\n      // Somehow received different axes for begin/end slicing\n      return Status::OK();\n    }\n    const int slice_axis = (begin_index == -1) ? end_index : begin_index;\n    if (slice_axis != pack_axis) {\n      // Not slicing on the same axis as the Pack op.\n      return Status::OK();\n    }\n    *slice_start_value = (begin_index == -1) ? 0 : begin_value;\n    const int64 slice_end_value =\n        (end_index == -1) ? pack_output_shape.dim_size(slice_axis) : end_value;\n    if (slice_end_value != *slice_start_value + 1) {\n      // Not slicing a single value out.\n      return Status::OK();\n    }\n\n    if (*slice_start_value < 0 || *slice_start_value >= pack->input_size()) {\n      return errors::InvalidArgument(\n          \"Node \", node->name(), \" requested invalid slice index \",\n          *slice_start_value, \" on axis \", slice_axis,\n          \" from tensor of shape: \", pack_output_shape.DebugString());\n    }\n\n    if (shrink_axis_mask == 0) {\n      *must_expand_dims = true;\n    } else if (shrink_axis_mask == (1 << slice_axis)) {\n      *must_expand_dims = false;\n    } else {\n      // Shrinking on a different axis from the one that we are slicing on.\n      return Status::OK();\n    }\n\n    *found = true;  // slice_start_value is valid.\n    return Status::OK();\n  }\n\n  Status RewriteGraph(const NodeDef* node, const NodeDef* pack,\n                      int64 slice_start_value, int pack_axis,\n                      bool must_expand_dims, string* simplified_node_name) {\n    const string& input_slice = pack->input(slice_start_value);\n\n    const OpInfo::TensorProperties* input_slice_properties;\n    TF_RETURN_IF_ERROR(GetTensorProperties(pack->input(slice_start_value),\n                                           &input_slice_properties));\n    PartialTensorShape input_slice_shape(input_slice_properties->shape());\n\n    const OpInfo::TensorProperties* output_properties;\n    TF_RETURN_IF_ERROR(GetTensorProperties(\n        strings::StrCat(node->name(), \":\", 0), &output_properties));\n    PartialTensorShape output_shape(output_properties->shape());\n    NodeDef* output =\n        AddEmptyNode(OptimizedNodeName(ParseNodeScopeAndName(node->name())));\n    if (!must_expand_dims) {\n      output->set_op(\"Identity\");\n      output->set_device(node->device());\n      SetDataTypeToAttr(output_properties->dtype(), \"T\", output);\n      output->add_input(input_slice);\n    } else {\n      NodeDef* axis = AddEmptyNode(\n          OptimizedNodeName(ParseNodeScopeAndName(node->name()), \"Axis\"));\n      axis->set_op(\"Const\");\n      axis->set_device(node->device());\n      // We need to add a control edge from input slice to guarantee that axis\n      // constant will be executed in the same frame as `input_slice`, otherwise\n      // ExpandDims might have mismatched input frames.\n      axis->add_input(absl::StrCat(\"^\", ParseTensorName(input_slice).node()));\n      auto axis_attr = axis->mutable_attr();\n      SetDataTypeToAttr(DT_INT32, \"dtype\", axis);\n      auto* axis_t = (*axis_attr)[\"value\"].mutable_tensor();\n      axis_t->set_dtype(DT_INT32);\n      axis_t->add_int_val(pack_axis);\n      AddToOptimizationQueue(axis);\n      output->set_op(\"ExpandDims\");\n      output->set_device(node->device());\n      SetDataTypeToAttr(output_properties->dtype(), \"T\", output);\n      SetDataTypeToAttr(DT_INT32, \"Tdim\", output);\n      output->add_input(input_slice);\n      output->add_input(axis->name());\n    }\n\n    // Copy dependencies over.\n    ForwardControlDependencies(output, {node, pack});\n    AddToOptimizationQueue(output);\n    *simplified_node_name = output->name();\n\n    return Status::OK();\n  }\n};\n\n// Eliminates unnecessary copies during sparse embedding lookup operations.\n//\n// For non-partitioned variables, the `tf.nn.embedding_lookup_sparse()` function\n// generates code of the form:\n//\n//     embeddings = <a 2D Tensor>\n//     sparse_ids = <a tf.int64 SparseTensor>\n//     segment_ids = sparse_ids.indices[:, 0]\n//     ids, idx = tf.unique(sparse_ids.values)\n//     gathered_rows = tf.gather(params, ids)\n//     result = tf.sparse.segment_<combiner>(gathered_rows, idx, segment_ids)\n//\n// In this case, all of the work in `tf.unique()` and `tf.gather()`\n// can be avoided by passing the full embeddings to\n// `tf.sparse.segment_<combiner>()` and performing the same amount of\n// computation (but fewer copies and allocations) as follows:\n//\n//     embeddings = <a 2D Tensor>\n//     sparse_ids = <a tf.int64 SparseTensor>\n//     segment_ids = sparse_ids.indices[:, 0]\n//     result = tf.sparse.segment_<combiner>(\n//          embeddings, sparse_ids.values, segment_ids)\nclass SimplifyEmbeddingLookupStage : public ArithmeticOptimizerStage {\n public:\n  explicit SimplifyEmbeddingLookupStage(\n      const GraphOptimizerContext& ctx,\n      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"SimplifyEmbeddingLookupStage\", ctx, ctx_ext) {\n  }\n  ~SimplifyEmbeddingLookupStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsAnySparseSegmentReduction(*node);\n  }\n\n  Status TrySimplify(NodeDef* reduction_node,\n                     string* simplified_node_name) override {\n    if (IsInPreserveSet(*reduction_node)) return Status::OK();\n\n    // Input 0 (data) of the reduction node must be a tf.gather() on the 0th\n    // axis.\n    NodeDef* gather_node = nullptr;\n    TF_RETURN_IF_ERROR(GetInputNode(reduction_node->input(0), &gather_node));\n    if (!IsGather(*gather_node) || IsInPreserveSet(*gather_node) ||\n        gather_node->device() != reduction_node->device())\n      return Status::OK();\n    if (gather_node->op() == \"GatherV2\" && !IsAxis0(*gather_node, 2))\n      return Status::OK();\n\n    // Input 1 (indices) of the gather node must be a tf.unique() on the 0th\n    // axis.\n    NodeDef* unique_node = nullptr;\n    TF_RETURN_IF_ERROR(GetInputNode(gather_node->input(1), &unique_node));\n    if (!IsUnique(*unique_node) || IsInPreserveSet(*unique_node) ||\n        unique_node->device() != gather_node->device())\n      return Status::OK();\n    if (unique_node->op() == \"UniqueV2\" && !IsAxis0(*unique_node, 1))\n      return Status::OK();\n\n    DataType unique_element_type;\n    TF_RETURN_IF_ERROR(GetNodeAttr(*unique_node, \"T\", &unique_element_type));\n\n    // Input 1 (indices) of the reduction node must be output 1 of the unique\n    // node.\n    const TensorId idx_tensor = ParseTensorName(reduction_node->input(1));\n    if (idx_tensor != TensorId(unique_node->name(), 1)) return Status::OK();\n\n    // Input 0 (data) of the reduction node becomes input 1 (params) of the\n    // gather node.\n    reduction_node->set_input(0, gather_node->input(0));\n    ctx().node_map->UpdateInput(reduction_node->name(),\n                                reduction_node->input(0),\n                                gather_node->input(0));\n\n    // Input 1 (indices) of the reduction node becomes input 0 (x) of the unique\n    // node.\n    reduction_node->set_input(1, unique_node->input(0));\n    ctx().node_map->UpdateInput(reduction_node->name(),\n                                reduction_node->input(1),\n                                unique_node->input(0));\n    SetDataTypeToAttr(unique_element_type, \"Tidx\", reduction_node);\n\n    *simplified_node_name = reduction_node->name();\n    return Status::OK();\n  }\n\n private:\n  bool IsAxis0(const NodeDef& node, int axis_input) {\n    Tensor axis_tensor;\n    if (!GetTensorFromConstNode(node.input(axis_input), &axis_tensor))\n      return false;\n    if (axis_tensor.NumElements() != 1) return false;\n    if (axis_tensor.dtype() == DT_INT32) {\n      return axis_tensor.flat<int32>()(0) == 0;\n    } else if (axis_tensor.dtype() == DT_INT64) {\n      return axis_tensor.flat<int64>()(0) == 0;\n    } else {\n      return false;\n    }\n  }\n};\n\n// Eliminates unnecessary casts before sparse segment reduction operations.\n//\n// Existing graphs and library code would often insert a cast from DT_INT64 to\n// DT_INT32 on the indices and/or segment_ids inputs to \"SparseSegment*\" ops.\n// Support for for DT_INT64 indices and/or segment_ids now exists, so we can\n// pass the input directly without a cast.\nclass RemoveCastIntoSegmentReductionStage : public ArithmeticOptimizerStage {\n public:\n  explicit RemoveCastIntoSegmentReductionStage(\n      const GraphOptimizerContext& ctx,\n      const ArithmeticOptimizerContext& ctx_ext)\n      : ArithmeticOptimizerStage(\"RemoveCastIntoSegmentReductionStage\", ctx,\n                                 ctx_ext) {}\n  ~RemoveCastIntoSegmentReductionStage() override = default;\n\n  bool IsSupported(const NodeDef* node) const override {\n    return IsAnySparseSegmentReduction(*node);\n  }\n\n  Status TrySimplify(NodeDef* reduction_node,\n                     string* simplified_node_name) override {\n    if (IsInPreserveSet(*reduction_node)) return Status::OK();\n\n    bool optimized = false;\n\n    // Inputs 1 (indices) and 2 (segment_ids) can be either DT_INT32 or\n    // DT_INT64.\n    std::array<std::pair<int, string>, 2> input_details = {\n        std::make_pair(1, \"Tidx\"), std::make_pair(2, \"Tsegmentids\")};\n\n    for (const auto& input : input_details) {\n      int input_index = input.first;\n      const string& type_attr_name = input.second;\n      NodeDef* cast_node = nullptr;\n      TF_RETURN_IF_ERROR(\n          GetInputNode(reduction_node->input(input_index), &cast_node));\n      DataType original_index_type;\n      if (IsCastFromSupportedType(*cast_node, &original_index_type)) {\n        reduction_node->set_input(input_index, cast_node->input(0));\n        ctx().node_map->UpdateInput(reduction_node->name(),\n                                    reduction_node->input(1),\n                                    cast_node->input(0));\n        SetDataTypeToAttr(original_index_type, type_attr_name, reduction_node);\n        optimized = true;\n      }\n    }\n\n    if (optimized) *simplified_node_name = reduction_node->name();\n    return Status::OK();\n  }\n\n private:\n  bool IsCastFromSupportedType(const NodeDef& node, DataType* out_input_type) {\n    if (!IsCast(node)) return false;\n    if (!GetNodeAttr(node, \"SrcT\", out_input_type).ok()) return false;\n    return *out_input_type == DT_INT32 || *out_input_type == DT_INT64;\n  }\n};\n\n}  // namespace\n\nStatus ArithmeticOptimizer::SimplifyArithmeticOps(bool can_use_shapes) {\n  SetVector<NodeDef*> nodes_to_simplify;\n  nodes_to_simplify.Reserve(optimized_graph_->node_size());\n  for (int i = 0; i < optimized_graph_->node_size(); ++i) {\n    nodes_to_simplify.PushBack(optimized_graph_->mutable_node(i));\n  }\n\n  const GraphOptimizerContext ctx(&nodes_to_preserve_, optimized_graph_,\n                                  graph_properties_.get(), node_map_.get(),\n                                  &feed_nodes_, opt_level_);\n  const ArithmeticOptimizerContext ctx_ext(&nodes_to_simplify);\n\n  // Stop pipeline after first stage returning non-empty simplified tensor\n  // name.\n  const auto stop = [](const string& result) { return !result.empty(); };\n  GraphOptimizerStagePipeline<string> pipeline(stop);\n\n  if (options_.combine_add_to_addn && can_use_shapes)\n    pipeline.AddStage<AddOpsRewriteStage>(ctx, ctx_ext);\n  if (options_.fold_conjugate_into_transpose)\n    pipeline.AddStage<FoldConjugateIntoTranspose>(ctx, ctx_ext);\n  if (options_.fold_multiply_into_conv)\n    pipeline.AddStage<FoldMultiplyIntoConv>(ctx, ctx_ext);\n  if (options_.fold_transpose_into_matmul)\n    pipeline.AddStage<FoldTransposeIntoMatMul>(ctx, ctx_ext);\n  if (options_.hoist_common_factor_out_of_aggregation && can_use_shapes)\n    pipeline.AddStage<HoistCommonFactorOutOfAggregation>(ctx, ctx_ext);\n  if (options_.minimize_broadcasts && can_use_shapes)\n    pipeline.AddStage<MinimizeBroadcasts>(ctx, ctx_ext);\n  if (options_.remove_identity_transpose && can_use_shapes)\n    pipeline.AddStage<RemoveIdentityTranspose>(ctx, ctx_ext);\n  if (options_.remove_involution)\n    pipeline.AddStage<RemoveInvolution>(ctx, ctx_ext);\n  if (options_.remove_redundant_bitcast)\n    pipeline.AddStage<RemoveRedundantBitcastStage>(ctx, ctx_ext);\n  if (options_.remove_redundant_cast)\n    pipeline.AddStage<RemoveRedundantCastStage>(ctx, ctx_ext);\n  if (options_.replace_pack_with_tile_reshape)\n    pipeline.AddStage<ReplacePackWithTileReshape>(ctx, ctx_ext);\n  if (options_.replace_mul_with_tile && can_use_shapes)\n    pipeline.AddStage<ReplaceMulWithBroadcastByTile>(ctx, ctx_ext);\n  if (options_.reduce_upsampling_dims)\n    pipeline.AddStage<ReduceUpsamplingDims>(ctx, ctx_ext);\n  if (options_.remove_redundant_reshape)\n    pipeline.AddStage<RemoveRedundantReshapeOrBroadcastTo>(ctx, ctx_ext);\n  if (options_.remove_negation)\n    pipeline.AddStage<RemoveNegationStage>(ctx, ctx_ext);\n  if (options_.replace_mul_with_square)\n    pipeline.AddStage<ReplaceMulWithSquare>(ctx, ctx_ext);\n  if (options_.remove_logical_not)\n    pipeline.AddStage<RemoveLogicalNotStage>(ctx, ctx_ext);\n  if (options_.reorder_cast_like_and_value_preserving)\n    pipeline.AddStage<ReorderCastLikeAndValuePreserving>(ctx, ctx_ext);\n  if (options_.reorder_reshape_around_unary)\n    pipeline.AddStage<ReorderReshapeAroundUnary>(ctx, ctx_ext);\n  if (options_.simplify_aggregation)\n    pipeline.AddStage<SimplifyAggregation>(ctx, ctx_ext);\n  if (options_.hoist_cwise_unary_chains)\n    pipeline.AddStage<HoistCWiseUnaryChainsStage>(ctx, ctx_ext);\n  if (options_.convert_sqrt_div_to_rsqrt_mul)\n    pipeline.AddStage<SqrtDivToRsqrtMulStage>(ctx, ctx_ext);\n  if (options_.remove_idempotent)\n    pipeline.AddStage<RemoveIdempotentStage>(ctx, ctx_ext);\n  if (options_.convert_pow) pipeline.AddStage<ConvertPowStage>(ctx, ctx_ext);\n  if (options_.convert_log1p)\n    pipeline.AddStage<ConvertLog1pStage>(ctx, ctx_ext);\n  if (options_.convert_log_softmax)\n    pipeline.AddStage<LogSoftmaxStage>(ctx, ctx_ext);\n  if (options_.optimize_max_or_min_of_monotonic)\n    pipeline.AddStage<OptimizeMaxOrMinOfMonotonicStage>(ctx, ctx_ext);\n  if (options_.convert_expm1)\n    pipeline.AddStage<ConvertExpm1Stage>(ctx, ctx_ext);\n  if (options_.unary_ops_composition)\n    pipeline.AddStage<UnaryOpsComposition>(ctx, ctx_ext);\n  if (options_.remove_stack_slice_same_axis)\n    pipeline.AddStage<RemoveStackSliceSameAxis>(ctx, ctx_ext);\n  if (options_.simplify_embedding_lookup)\n    pipeline.AddStage<SimplifyEmbeddingLookupStage>(ctx, ctx_ext);\n  if (options_.remove_cast_into_segment_reduction)\n    pipeline.AddStage<RemoveCastIntoSegmentReductionStage>(ctx, ctx_ext);\n  if (options_.fuse_squared_diff)\n    pipeline.AddStage<FuseSquaredDiffStage>(ctx, ctx_ext);\n\n  VLOG(1) << \"Run \" << pipeline.NumStages() << \" arithmetic optimizer stages: \"\n          << absl::StrJoin(pipeline.StageNames(), \", \");\n\n  while (!nodes_to_simplify.Empty()) {\n    GRAPPLER_RETURN_IF_DEADLINE_EXCEEDED();\n    NodeDef* node = nodes_to_simplify.PopBack();\n\n    string simplified_tensor = \"\";\n    bool optimized = pipeline.PassThroughAllStages(node, &simplified_tensor);\n\n    // If the node was not optimized by any of the stages, go to the next one.\n    if (!optimized) continue;\n\n    // re-wire consumers of an old node to the new one\n    if (NodeName(simplified_tensor) != node->name()) {\n      // Always consider simplified_tensor for further optimizations.\n      NodeDef* simplified_node = node_map_->GetNode(simplified_tensor);\n      if (simplified_node != nullptr) {\n        nodes_to_simplify.PushBack(simplified_node);\n      }\n      // When `node` is simplified to another node rather than in-place, the\n      // consumers of `node` are already redirected to `simplified_tensor`.\n      // Re-push the consumers into `nodes_to_simplify` for further\n      // optimizations.\n      const std::vector<NodeDef*> consumers =\n          node_map_->GetOutputsOrderedByNodeName(node->name());\n      for (NodeDef* consumer : consumers) {\n        // Update `consumer`'s use of `node` to `input`'s operand.\n        for (int i = 0; i < consumer->input_size(); ++i) {\n          int operand_pos;\n          string operand_node_name =\n              ParseNodeName(consumer->input(i), &operand_pos);\n          if (operand_node_name == node->name()) {\n            *consumer->mutable_input(i) =\n                (operand_pos < 0\n                     ? AsControlDependency(NodeName(simplified_tensor))\n                     : simplified_tensor);\n          }\n        }\n        node_map_->UpdateInput(consumer->name(), node->name(),\n                               simplified_tensor);\n        nodes_to_simplify.PushBack(consumer);\n      }\n    }\n  }\n  return Status::OK();\n}\n\nStatus ArithmeticOptimizer::Optimize(Cluster* /*cluster*/,\n                                     const GrapplerItem& item,\n                                     GraphDef* optimized_graph) {\n  // Set up helper data structures.\n  nodes_to_preserve_ = item.NodesToPreserve();\n  fetch_nodes_known_ = !item.fetch.empty();\n  GrapplerItem optimized_item(item);\n  optimized_graph_ = &optimized_item.graph;\n\n  node_map_.reset(new NodeMap(optimized_graph_));\n  for (const auto& feed : item.feed) {\n    feed_nodes_.insert(NodeName(feed.first));\n  }\n\n  // // Disable restricted graph rewrites.\n  options_.unary_ops_composition &=\n      item.optimization_options().allow_non_differentiable_rewrites;\n\n  // Perform topological sort on the graph in order to help DedupComputations\n  // and AddOpsRewrite to optimize larger subgraphs starting from the roots\n  // with more inputs.\n  TF_RETURN_IF_ERROR(TopologicalSort(optimized_graph_));\n  GRAPPLER_RETURN_IF_DEADLINE_EXCEEDED();\n\n  graph_properties_.reset(new GraphProperties(optimized_item));\n  const bool assume_valid_feeds = opt_level_ == RewriterConfig::AGGRESSIVE;\n  const Status status =\n      graph_properties_->InferStatically(assume_valid_feeds,\n                                         /*aggressive_shape_inference=*/false,\n                                         /*include_tensor_values=*/false);\n  const bool can_use_shapes = status.ok();\n  if (!can_use_shapes) {\n    VLOG(1) << \"Shape inference failed.\" << status.error_message();\n  }\n\n  // Perform the optimizations.\n  TF_RETURN_IF_ERROR(SimplifyArithmeticOps(can_use_shapes));\n\n  optimized_graph->Swap(optimized_graph_);\n  return Status::OK();\n}\n\nvoid ArithmeticOptimizer::Feedback(Cluster* /*cluster*/,\n                                   const GrapplerItem& /*item*/,\n                                   const GraphDef& /*optimized_graph*/,\n                                   double /*result*/) {\n  // Nothing to do for ArithmeticOptimizer.\n}\n\n}  // namespace grappler\n}  // namespace tensorflow"