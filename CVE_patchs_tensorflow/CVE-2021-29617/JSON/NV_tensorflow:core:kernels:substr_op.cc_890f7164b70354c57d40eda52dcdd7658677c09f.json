"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <cstddef>\n#include <cstdlib>\n#include <string>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/string_util.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/bcast.h\"\n\nnamespace tensorflow {\n\n// Position/length can be 32 or 64-bit integers\ntemplate <typename T>\nclass SubstrOp : public OpKernel {\n public:\n  explicit SubstrOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    string unit;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"unit\", &unit));\n    OP_REQUIRES_OK(ctx, ParseCharUnit(unit, &unit_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    // Get inputs\n    const Tensor& input_tensor = context->input(0);\n    const Tensor& pos_tensor = context->input(1);\n    const Tensor& len_tensor = context->input(2);\n    const TensorShape& input_shape = input_tensor.shape();\n    const TensorShape& pos_shape = pos_tensor.shape();\n    const TensorShape& len_shape = len_tensor.shape();\n    OP_REQUIRES(context, (pos_shape == len_shape),\n                errors::InvalidArgument(\n                    \"pos and len should have the same shape, got: \",\n                    pos_shape.DebugString(), \" vs. \", len_shape.DebugString()));\n\n    bool is_scalar = TensorShapeUtils::IsScalar(pos_shape);\n\n    if (is_scalar || input_shape == pos_shape) {\n      // pos/len are either scalar or match the shape of input_tensor\n      // Do not need to do broadcasting\n\n      // Reshape input\n      auto input = input_tensor.flat<tstring>();\n      // Allocate output\n      Tensor* output_tensor = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(\"output\", input_tensor.shape(),\n                                              &output_tensor));\n      auto output = output_tensor->flat<tstring>();\n      if (is_scalar) {\n        // Perform Op with scalar pos/len\n        const T pos =\n            tensorflow::internal::SubtleMustCopy(pos_tensor.scalar<T>()());\n        const T len =\n            tensorflow::internal::SubtleMustCopy(len_tensor.scalar<T>()());\n        for (size_t i = 0; i < input_tensor.NumElements(); ++i) {\n          StringPiece in(input(i));\n          T byte_pos = pos;\n          T byte_len = len;\n          switch (unit_) {\n            case CharUnit::UTF8_CHAR:\n              OP_REQUIRES(\n                  context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string at index \", i));\n              break;\n            case CharUnit::BYTE:\n              byte_pos = AdjustedPosIndex(byte_pos, in);\n              OP_REQUIRES(\n                  context, FastBoundsCheck(byte_pos, in.size() + 1),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string b'\", in, \"' at index \", i));\n          }\n          StringPiece sub_in = in.substr(byte_pos, byte_len);\n          output(i).assign(sub_in.data(), sub_in.size());\n        }\n      } else {\n        // Perform Op element-wise with tensor pos/len\n        auto pos_flat = pos_tensor.flat<T>();\n        auto len_flat = len_tensor.flat<T>();\n        for (size_t i = 0; i < input_tensor.NumElements(); ++i) {\n          StringPiece in(input(i));\n          const T pos = tensorflow::internal::SubtleMustCopy(pos_flat(i));\n          const T len = tensorflow::internal::SubtleMustCopy(len_flat(i));\n          T byte_pos = pos;\n          T byte_len = len;\n          switch (unit_) {\n            case CharUnit::UTF8_CHAR:\n              OP_REQUIRES(\n                  context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string at index \", i));\n              break;\n            case CharUnit::BYTE:\n              byte_pos = AdjustedPosIndex(byte_pos, in);\n              OP_REQUIRES(\n                  context, FastBoundsCheck(byte_pos, in.size() + 1),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string b'\", in, \"' at index \", i));\n          }\n          StringPiece sub_in = in.substr(byte_pos, byte_len);\n          output(i).assign(sub_in.data(), sub_in.size());\n        }\n      }\n    } else {\n      // Perform op with broadcasting\n      // TODO: Use ternary broadcasting for once available in Eigen. Current\n      //       implementation iterates through broadcasted ops element-wise;\n      //       this should be parallelized.\n\n      // Create BCast helper with shape of input and pos/len\n      BCast bcast(BCast::FromShape(input_shape), BCast::FromShape(pos_shape));\n      OP_REQUIRES(context, bcast.IsValid(),\n                  errors::InvalidArgument(\n                      \"Incompatible shapes: \", input_shape.DebugString(),\n                      \" vs. \", pos_shape.DebugString()));\n      TensorShape output_shape = BCast::ToShape(bcast.result_shape());\n      int ndims = output_shape.dims();\n      Tensor* output_tensor = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                       &output_tensor));\n      switch (ndims) {\n        case 1: {\n          // Reshape tensors according to BCast results\n          auto input = input_tensor.shaped<tstring, 1>(bcast.x_reshape());\n          auto output = output_tensor->shaped<tstring, 1>(bcast.result_shape());\n          auto pos_shaped = pos_tensor.shaped<T, 1>(bcast.y_reshape());\n          auto len_shaped = len_tensor.shaped<T, 1>(bcast.y_reshape());\n\n          // Allocate temporary buffer for broadcasted input tensor\n          Tensor input_buffer;\n          OP_REQUIRES_OK(context, context->allocate_temp(\n                                      DT_STRING, output_shape, &input_buffer));\n          TTypes<tstring, 1>::Tensor input_bcast =\n              input_buffer.shaped<tstring, 1>(bcast.result_shape());\n          input_bcast =\n              input.broadcast(BCast::ToIndexArray<1>(bcast.x_bcast()));\n\n          // Allocate temporary buffer for broadcasted position tensor\n          Tensor pos_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &pos_buffer));\n          typename TTypes<T, 1>::Tensor pos_bcast(\n              pos_buffer.shaped<T, 1>(bcast.result_shape()));\n          pos_bcast =\n              pos_shaped.broadcast(BCast::ToIndexArray<1>(bcast.y_bcast()));\n\n          // Allocate temporary buffer for broadcasted length tensor\n          Tensor len_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &len_buffer));\n          typename TTypes<T, 1>::Tensor len_bcast(\n              len_buffer.shaped<T, 1>(bcast.result_shape()));\n          len_bcast =\n              len_shaped.broadcast(BCast::ToIndexArray<1>(bcast.y_bcast()));\n\n          // Iterate through broadcasted tensors and perform substr\n          for (int i = 0; i < output_shape.dim_size(0); ++i) {\n            StringPiece in(input_bcast(i));\n            const T pos = tensorflow::internal::SubtleMustCopy(pos_bcast(i));\n            const T len = tensorflow::internal::SubtleMustCopy(len_bcast(i));\n            T byte_pos = pos;\n            T byte_len = len;\n            switch (unit_) {\n              case CharUnit::UTF8_CHAR:\n                OP_REQUIRES(\n                    context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                    errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                            \"string at index \", i));\n                break;\n              case CharUnit::BYTE:\n                byte_pos = AdjustedPosIndex(byte_pos, in);\n                OP_REQUIRES(\n                    context,\n                    FastBoundsCheck(byte_pos, input_bcast(i).size() + 1),\n                    errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                            \"string b'\", in, \"' at index \", i));\n            }\n            StringPiece sub_in = in.substr(byte_pos, byte_len);\n            output(i).assign(sub_in.data(), sub_in.size());\n          }\n          break;\n        }\n        case 2: {\n          // Reshape tensors according to BCast results\n          auto input = input_tensor.shaped<tstring, 2>(bcast.x_reshape());\n          auto output = output_tensor->shaped<tstring, 2>(bcast.result_shape());\n          auto pos_shaped = pos_tensor.shaped<T, 2>(bcast.y_reshape());\n          auto len_shaped = len_tensor.shaped<T, 2>(bcast.y_reshape());\n\n          // Allocate temporary buffer for broadcasted input tensor\n          Tensor input_buffer;\n          OP_REQUIRES_OK(context, context->allocate_temp(\n                                      DT_STRING, output_shape, &input_buffer));\n          TTypes<tstring, 2>::Tensor input_bcast =\n              input_buffer.shaped<tstring, 2>(bcast.result_shape());\n          input_bcast =\n              input.broadcast(BCast::ToIndexArray<2>(bcast.x_bcast()));\n\n          // Allocate temporary buffer for broadcasted position tensor\n          Tensor pos_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &pos_buffer));\n          typename TTypes<T, 2>::Tensor pos_bcast(\n              pos_buffer.shaped<T, 2>(bcast.result_shape()));\n          pos_bcast =\n              pos_shaped.broadcast(BCast::ToIndexArray<2>(bcast.y_bcast()));\n\n          // Allocate temporary buffer for broadcasted length tensor\n          Tensor len_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &len_buffer));\n          typename TTypes<T, 2>::Tensor len_bcast(\n              len_buffer.shaped<T, 2>(bcast.result_shape()));\n          len_bcast =\n              len_shaped.broadcast(BCast::ToIndexArray<2>(bcast.y_bcast()));\n\n          // Iterate through broadcasted tensors and perform substr\n          for (int i = 0; i < output_shape.dim_size(0); ++i) {\n            for (int j = 0; j < output_shape.dim_size(1); ++j) {\n              StringPiece in(input_bcast(i, j));\n              const T pos =\n                  tensorflow::internal::SubtleMustCopy(pos_bcast(i, j));\n              const T len =\n                  tensorflow::internal::SubtleMustCopy(len_bcast(i, j));\n              T byte_pos = pos;\n              T byte_len = len;\n              switch (unit_) {\n                case CharUnit::UTF8_CHAR:\n                  OP_REQUIRES(\n                      context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                      errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                              \"string at index \", i));\n                  break;\n                case CharUnit::BYTE:\n                  byte_pos = AdjustedPosIndex(byte_pos, in);\n                  OP_REQUIRES(\n                      context, FastBoundsCheck(byte_pos, in.size() + 1),\n                      errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                              \"string b'\", in, \"' at index (\",\n                                              i, \", \", j, \")\"));\n              }\n              StringPiece sub_in = in.substr(byte_pos, byte_len);\n              output(i, j).assign(sub_in.data(), sub_in.size());\n            }\n          }\n          break;\n        }\n        default: {\n          context->SetStatus(errors::Unimplemented(\n              \"Substr broadcast not implemented for \", ndims, \" dimensions\"));\n        }\n      }\n    }\n  }\n\n private:\n  // This adjusts the requested position. Note it does not perform any bound\n  // checks.\n  static inline T AdjustedPosIndex(const T pos_requested, const StringPiece s) {\n    if (pos_requested < 0) {\n      return s.size() + pos_requested;\n    }\n    return pos_requested;\n  }\n\n  // Return true if successful; otherwise, return false if the `pos` argument\n  // is out of range in the string.\n  static inline bool UpdatePosAndLenForUtf8(const StringPiece in, T* pos,\n                                            T* len) {\n    if (*pos >= 0) {\n      return UpdatePositivePosAndLenForUtf8(in, *pos, *len, pos, len);\n    } else {\n      return UpdateNegativePosAndLenForUtf8(in, *pos, *len, pos, len);\n    }\n  }\n\n  static bool UpdatePositivePosAndLenForUtf8(const StringPiece in, const T pos,\n                                             const T len, T* char_pos,\n                                             T* char_len) {\n    *char_pos = 0;\n    // Determine byte position of the substring start.\n    if (!ForwardNUTF8CharPositions(in, pos, char_pos)) {\n      return false;\n    }\n    // Determine position of the end of the substring.\n    // The length will be capped at the end of the string, and we ignore whether\n    // the string had enough characters to handle it or not.\n    *char_len = *char_pos;\n    ForwardNUTF8CharPositions(in, len, char_len);\n    // The length in bytes is the position end of the substring less the start.\n    *char_len = *char_len - *char_pos;\n    return true;\n  }\n\n  // This function expects a negative position relative to the end of the\n  // string, but will update the character position to a positive number\n  // relative to the beginning of the string.\n  static bool UpdateNegativePosAndLenForUtf8(const StringPiece in, const T pos,\n                                             const T len, T* char_pos,\n                                             T* char_len) {\n    // Initially treat the length as position of the end of the substring.\n    *char_len = in.size();\n    // This is the number of character to skip from the end of the string to\n    // arrive at the position where the substring should end.\n    T utf8_chars_to_skip = -pos - len;\n    if (utf8_chars_to_skip < 0) {\n      utf8_chars_to_skip = 0;\n    }\n    // Find the byte position where the substring should end using the computed\n    // number of characters to skip.\n    if (!BackNUTF8CharPositions(in, utf8_chars_to_skip, char_len)) {\n      return false;\n    }\n    // Next, determine where the substring should begin. The number of chars to\n    // skip is the requested position minus the chars we've previously skipped.\n    *char_pos = *char_len;\n    if (!BackNUTF8CharPositions(in, -pos - utf8_chars_to_skip, char_pos)) {\n      return false;\n    }\n    // The length in bytes is the position end of the substring less the start.\n    *char_len = *char_len - *char_pos;\n    return true;\n  }\n\n  CharUnit unit_ = CharUnit::BYTE;\n};\n\n#define REGISTER_SUBSTR(type)                                      \\\n  REGISTER_KERNEL_BUILDER(                                         \\\n      Name(\"Substr\").Device(DEVICE_CPU).TypeConstraint<type>(\"T\"), \\\n      SubstrOp<type>);\nREGISTER_SUBSTR(int32);\nREGISTER_SUBSTR(int64);\n}  // namespace tensorflow"