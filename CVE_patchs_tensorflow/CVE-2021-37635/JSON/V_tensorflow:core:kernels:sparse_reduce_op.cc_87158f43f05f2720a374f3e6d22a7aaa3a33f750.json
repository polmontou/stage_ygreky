"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/sparse_ops.cc.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\n// TODO(b/31496047): Fix non-standard include order.\n#include <numeric>  // clang-format off\n\nusing tensorflow::sparse::SparseTensor;\nusing tensorflow::gtl::ArraySlice;\n\nnamespace tensorflow {\n\nstruct ReduceDetails {\n  // The dimensions to call Reorder() with.\n  std::vector<int64> reorder_dims;\n\n  // The dimensions to call group() with after Reorder().\n  std::vector<int64> group_by_dims;\n\n  // The shape after reduction.\n  TensorShape reduced_shape;\n};\n\n// Compute common reduce parameters that'll be used for SparseTensor\n// reductions. Usage:\n// ReduceDetails reduction = SparseTensorReduceHelper(sp, axes, keep_dims);\n// sp.Reorder(reduction.reorder_dims);\n// for (const auto& g : sp.group(reduction.group_by_dims)) {\n//   ...\n// }\n// // Set output shape to reduction.reduced_shape.\nReduceDetails SparseTensorReduceHelper(const SparseTensor &sp,\n                                       gtl::ArraySlice<int32> axes_slice,\n                                       bool keep_dims) {\n  ReduceDetails reduction;\n\n  std::vector<int32> reduction_axes(axes_slice.begin(), axes_slice.end());\n  int ndims = sp.dims();\n  for (int64_t i = 0; i < reduction_axes.size(); ++i) {\n    reduction_axes[i] = (reduction_axes[i] + ndims) % ndims;\n  }\n  std::sort(reduction_axes.begin(), reduction_axes.end());\n\n  // (0) Calculate the grouping dimensions:\n  // group_by_dims == {0, .., NDIMS-1} \\ reduction_axes.\n  std::vector<int64> perm(ndims);\n  std::iota(perm.begin(), perm.end(), 0);\n\n  // Requires perm and reduction_axes_ be sorted; group_by_dims will be\n  // sorted as well.\n  std::set_difference(\n      perm.begin(), perm.end(), reduction_axes.begin(), reduction_axes.end(),\n      std::inserter(reduction.group_by_dims, reduction.group_by_dims.begin()));\n\n  // Now append the rest of the axes (the complement of group_by_dims_);\n  // result is used by Reorder().\n  reduction.reorder_dims = reduction.group_by_dims;\n  std::set_difference(perm.begin(), perm.end(), reduction.group_by_dims.begin(),\n                      reduction.group_by_dims.end(),\n                      std::back_inserter(reduction.reorder_dims));\n\n  // (1) Calculate the shape after reduction.\n  auto sp_shape = sp.shape();\n  std::vector<int64> out_dim_sizes;\n  if (keep_dims) {\n    out_dim_sizes.reserve(ndims);\n    auto beg = reduction.group_by_dims.begin();\n    auto end = reduction.group_by_dims.end();\n    for (int d = 0; d < ndims; ++d) {\n      if (std::find(beg, end, d) == end) {\n        out_dim_sizes.push_back(1);  // A reduced axis.\n      } else {\n        out_dim_sizes.push_back(sp_shape[d]);\n      }\n    }\n  } else {\n    out_dim_sizes = sp.PickDims(reduction.group_by_dims);\n  }\n\n  reduction.reduced_shape = TensorShape(out_dim_sizes);\n  return reduction;\n}\n\nStatus ValidateInputs(const Tensor *shape_t, const Tensor *reduction_axes_t) {\n  // indices and values are validated in SparseTensor ctor.\n  if (!TensorShapeUtils::IsVector(shape_t->shape())) {\n    return errors::InvalidArgument(\n        \"Expected input_shape to be a vector; got shape: \",\n        shape_t->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsScalar(reduction_axes_t->shape()) &&\n      !TensorShapeUtils::IsVector(reduction_axes_t->shape())) {\n    return errors::InvalidArgument(\n        \"Expected reduction_axes to be a scalar or a vector; got shape: \",\n        reduction_axes_t->shape().DebugString());\n  }\n\n  const auto reduction_axes_flat = reduction_axes_t->flat<int32>();\n  for (int64_t i = 0; i < reduction_axes_flat.size(); i++) {\n    int32_t axis = reduction_axes_flat(i);\n    if (axis < -shape_t->NumElements() || axis >= shape_t->NumElements()) {\n      return errors::InvalidArgument(\"Invalid reduction dimension \", axis,\n                                     \", for input with \",\n                                     shape_t->NumElements(), \" dimensions.\");\n    }\n  }\n\n  return Status::OK();\n}\n\nstruct SumOp {\n  template <typename T>\n  static void Run(OpKernelContext *ctx, typename TTypes<T>::Scalar &s, const typename TTypes<T>::UnalignedVec &v) {\n      s.device(ctx->eigen_cpu_device()) = v.sum();\n  }\n  static StringPiece Name() {\n      return \"sum\";\n  }\n};\n\nstruct MaxOp {\n  template <typename T>\n  static void Run(OpKernelContext *ctx, typename TTypes<T>::Scalar &s, const typename TTypes<T>::UnalignedVec &v) {\n      s.device(ctx->eigen_cpu_device()) = v.maximum();\n  }\n  static StringPiece Name() {\n      return \"max\";\n  }\n};\n\ntemplate <typename T, typename Op>\nclass SparseReduceOp : public OpKernel {\n public:\n  explicit SparseReduceOp(OpKernelConstruction *ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"keep_dims\", &keep_dims_));\n  }\n\n  void Compute(OpKernelContext *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"reduction_axes\", &reduction_axes_t));\n\n    OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));\n\n    // TODO(zongheng): we will call Reorder() below, which will modify\n    // in-place the underlying indices and values buffers.  To avoid\n    // surprises of this kernel being stateful, we work around the above by\n    // making deep copies here.  Remove this if/when we change Reorder()'s\n    // semantics.\n    const auto shape_vec = shape_t->vec<int64>();\n    SparseTensor sp;\n    OP_REQUIRES_OK(ctx, SparseTensor::Create(\n        tensor::DeepCopy(*indices_t), tensor::DeepCopy(*values_t),\n                    TensorShape(shape_vec), &sp));\n    ReduceDetails reduction = SparseTensorReduceHelper(\n        sp, reduction_axes_t->flat<int32>(), keep_dims_);\n\n    Tensor *out_values;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, reduction.reduced_shape, &out_values));\n    auto out_flat = out_values->flat<T>();\n    out_flat.setZero();\n\n    Tensor tmp_reduced_val;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                           TensorShape({}), &tmp_reduced_val));\n    auto reduced_val = tmp_reduced_val.scalar<T>();\n\n    // Compute strides, and use it to convert coords to flat index.  The\n    // coordinates returned by .group() have the same ndims as group_by_dims.\n    gtl::InlinedVector<int64, 8> output_strides(reduction.group_by_dims.size());\n    if (!output_strides.empty()) {  // Do this iff we don't reduce all.\n      output_strides.back() = 1;\n      for (int d = output_strides.size() - 2; d >= 0; --d) {\n        output_strides[d] =\n            output_strides[d + 1] * shape_vec(reduction.group_by_dims[d + 1]);\n      }\n    }\n\n    auto CoordinatesToFlatIndex = [](ArraySlice<int64> coords,\n                                     ArraySlice<int64> strides) -> int64 {\n      if (strides.empty()) {  // Reduce all.\n        return 0;\n      }\n      CHECK_EQ(coords.size(), strides.size());\n      int64_t idx = 0;\n      for (int i = 0; i < coords.size(); ++i) {\n        idx += coords[i] * strides[i];\n      }\n      return idx;\n    };\n\n    // Each group maps one-on-one onto a value in the reduced tensor.\n    // g.group() provides the coordinates of a particular reduced value.\n    sp.Reorder<T>(reduction.reorder_dims);\n    for (const auto &g : sp.group(reduction.group_by_dims)) {\n      Op::template Run<T>(ctx, reduced_val, g.template values<T>());\n      const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);\n      out_flat(idx) = reduced_val();\n      VLOG(2) << \"coords: \" << absl::StrJoin(g.group(), \",\")\n              << \"; idx: \" << idx << \"; group \" << Op::Name() << \": \"\n              << reduced_val();\n    }\n  }\n\n private:\n  // True if the number of dimensions should be maintained.\n  bool keep_dims_;\n};\n\n#define REGISTER_KERNELS(T)                                              \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"SparseReduceSum\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceOp<T, SumOp>)\nTF_CALL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\n#define REGISTER_KERNELS(T)                                              \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"SparseReduceMax\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceOp<T, MaxOp>)\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\ntemplate <typename T, typename Op>\nclass SparseReduceSparseOp : public OpKernel {\n public:\n  explicit SparseReduceSparseOp(OpKernelConstruction *ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"keep_dims\", &keep_dims_));\n  }\n\n  void Compute(OpKernelContext *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"reduction_axes\", &reduction_axes_t));\n\n    OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));\n\n    SparseTensor sp;\n    OP_REQUIRES_OK(ctx, SparseTensor::Create(tensor::DeepCopy(*indices_t),\n                                         tensor::DeepCopy(*values_t),\n                    TensorShape(shape_t->vec<int64>()), &sp));\n    ReduceDetails reduction = SparseTensorReduceHelper(\n        sp, reduction_axes_t->flat<int32>(), keep_dims_);\n\n    sp.Reorder<T>(reduction.reorder_dims);\n    // Count nnzs in the output SparseTensor.\n    int64_t nnz = 0;\n    auto iter = sp.group(reduction.group_by_dims);\n    for (auto it = iter.begin(); it != iter.end(); ++it) {\n      nnz++;\n    }\n\n    Tensor *out_indices_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(\n                       0, TensorShape({nnz, reduction.reduced_shape.dims()}),\n                       &out_indices_t));\n    typename TTypes<int64>::Matrix out_indices_mat =\n        out_indices_t->matrix<int64>();\n    // For keep_dims. We don't explicitly set dim fields for reduced dims below.\n    out_indices_mat.setZero();\n\n    Tensor *out_values_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, TensorShape({nnz}), &out_values_t));\n    auto out_flat = out_values_t->flat<T>();\n\n    Tensor tmp_reduced_val;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                           TensorShape({}), &tmp_reduced_val));\n    auto reduced_val = tmp_reduced_val.scalar<T>();\n    int64_t i = 0;\n    for (const auto &g : sp.group(reduction.group_by_dims)) {\n      Op::template Run<T>(ctx, reduced_val, g.template values<T>());\n      std::vector<int64> group = g.group();\n      for (int64_t j = 0; j < group.size(); j++) {\n        if (keep_dims_) {\n          out_indices_mat(i, reduction.group_by_dims[j]) = group[j];\n        } else {\n          out_indices_mat(i, j) = group[j];\n        }\n      }\n      out_flat(i) = reduced_val();\n      i++;\n      VLOG(2) << \"coords: \" << absl::StrJoin(g.group(), \",\")\n              << \"; group \" << Op::Name() << \": \"\n              << reduced_val();\n    }\n\n    Tensor *out_shape_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\n                            2, TensorShape({reduction.reduced_shape.dims()}),\n                            &out_shape_t));\n    auto out_shape_flat = out_shape_t->flat<int64>();\n    auto out_dim_sizes = reduction.reduced_shape.dim_sizes();\n    if (!out_dim_sizes.empty()) {\n      std::copy(out_dim_sizes.begin(), out_dim_sizes.end(), &out_shape_flat(0));\n    }\n  }\n\n private:\n  // True if the number of dimensions should be maintained.\n  bool keep_dims_;\n};\n\n#define REGISTER_KERNELS(T)                                                    \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"SparseReduceSumSparse\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceSparseOp<T, SumOp>)\nTF_CALL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\n#define REGISTER_KERNELS(T)                                                    \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"SparseReduceMaxSparse\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceSparseOp<T, MaxOp>)\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\n}  // namespace tensorflow"