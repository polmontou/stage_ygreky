"# Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for ShardedVariable.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\n\nfrom absl.testing import parameterized\n\nfrom tensorflow.python.client import session as session_lib\nfrom tensorflow.python.compat import v2_compat\nfrom tensorflow.python.distribute import sharded_variable\nfrom tensorflow.python.eager import def_function\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import tensor_shape\nfrom tensorflow.python.framework import tensor_spec\nfrom tensorflow.python.module import module\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import embedding_ops\nfrom tensorflow.python.ops import variables as variables_lib\nfrom tensorflow.python.platform import test\nfrom tensorflow.python.saved_model import load\nfrom tensorflow.python.saved_model import loader\nfrom tensorflow.python.saved_model import save\nfrom tensorflow.python.saved_model import signature_constants\nfrom tensorflow.python.saved_model import tag_constants\nfrom tensorflow.python.training.tracking import tracking\nfrom tensorflow.python.training.tracking import util\nfrom tensorflow.python.util import nest\n\n\ndef _load_and_run(\n    model_dir,\n    inputs,\n    signature_key=signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY):\n  \"\"\"Load a SavedModel into a TF 1.x-style graph and run `signature_key`.\"\"\"\n  graph = ops.Graph()\n  with graph.as_default(), session_lib.Session() as session:\n    meta_graph_def = loader.load(session, [tag_constants.SERVING], model_dir)\n    signature = meta_graph_def.signature_def[signature_key]\n    feed_dict = {}\n    for arg_name in inputs.keys():\n      input_tensor = session.graph.get_tensor_by_name(\n          signature.inputs[arg_name].name)\n      feed_dict[input_tensor] = inputs[arg_name]\n    output_dict = {}\n    for output_name, output_tensor_info in signature.outputs.items():\n      output_dict[output_name] = session.graph.get_tensor_by_name(\n          output_tensor_info.name)\n    return session.run(output_dict, feed_dict=feed_dict)\n\n\nclass PartitionerTest(test.TestCase):\n\n  def test_fixed_shards_partitioner(self):\n    partitioner = sharded_variable.FixedShardsPartitioner(num_shards=2)\n    got = partitioner(tensor_shape.TensorShape([10, 3]), dtypes.float32)\n    self.assertAllEqual(got, [2, 1])\n\n  def test_min_size_partitioner(self):\n    partitioner = sharded_variable.MinSizePartitioner(\n        min_shard_bytes=4, max_shards=2)\n    got = partitioner(tensor_shape.TensorShape([6, 1]), dtypes.float32)\n    self.assertAllEqual(got, [2, 1])\n\n    partitioner = sharded_variable.MinSizePartitioner(\n        min_shard_bytes=4, max_shards=10)\n    got = partitioner(tensor_shape.TensorShape([6, 1]), dtypes.float32)\n    self.assertAllEqual(got, [6, 1])\n\n  def test_max_size_partitioner(self):\n    partitioner = sharded_variable.MaxSizePartitioner(max_shard_bytes=4)\n    got = partitioner(tensor_shape.TensorShape([6, 1]), dtypes.float32)\n    self.assertAllEqual(got, [6, 1])\n\n    partitioner = sharded_variable.MaxSizePartitioner(\n        max_shard_bytes=4, max_shards=2)\n    got = partitioner(tensor_shape.TensorShape([6, 1]), dtypes.float32)\n    self.assertAllEqual(got, [2, 1])\n\n    partitioner = sharded_variable.MaxSizePartitioner(max_shard_bytes=1024)\n    got = partitioner(tensor_shape.TensorShape([6, 1]), dtypes.float32)\n    self.assertAllEqual(got, [1, 1])\n\n\nclass ShardedVariableTest(test.TestCase, parameterized.TestCase):\n\n  def test_sharded_variable_simple(self):\n    v0 = variables_lib.Variable([0])\n    v1 = variables_lib.Variable([1])\n    s = sharded_variable.ShardedVariable([v0, v1], name='s')\n    self.assertEqual(s.variables[0], v0)\n    self.assertEqual(s.variables[1], v1)\n    self.assertEqual(s.shape.as_list(), [2])\n    self.assertEqual(s.dtype, v0.dtype)\n    self.assertEqual(s.name, 's')\n\n  def test_assign(self):\n    v0 = variables_lib.Variable([[0, 0]])\n    v1 = variables_lib.Variable([[1, 1], [2, 2]])\n    v2 = variables_lib.Variable([[3, 3]])\n    s = sharded_variable.ShardedVariable([v0, v1, v2])\n    ret = s.assign([[4, 4], [5, 5], [6, 6], [7, 7]])\n    self.assertAllEqual(self.evaluate(s.variables[0]), [[4, 4]])\n    self.assertAllEqual(self.evaluate(s.variables[1]), [[5, 5], [6, 6]])\n    self.assertAllEqual(self.evaluate(s.variables[2]), [[7, 7]])\n    self.assertIs(ret, s)\n\n  def test_assign_add(self):\n    v0 = variables_lib.Variable([[0, 0]])\n    v1 = variables_lib.Variable([[1, 1], [2, 2]])\n    v2 = variables_lib.Variable([[3, 3]])\n    s = sharded_variable.ShardedVariable([v0, v1, v2])\n    ret = s.assign_add([[1, 1], [1, 1], [2, 2], [2, 2]])\n    self.assertAllEqual(self.evaluate(s.variables[0]), [[1, 1]])\n    self.assertAllEqual(self.evaluate(s.variables[1]), [[2, 2], [4, 4]])\n    self.assertAllEqual(self.evaluate(s.variables[2]), [[5, 5]])\n    self.assertIs(ret, s)\n\n  def test_assign_sub(self):\n    v0 = variables_lib.Variable([[0, 0]])\n    v1 = variables_lib.Variable([[1, 1], [2, 2]])\n    v2 = variables_lib.Variable([[3, 3]])\n    s = sharded_variable.ShardedVariable([v0, v1, v2])\n    ret = s.assign_sub([[0, 0], [1, 1], [1, 1], [3, 3]])\n    self.assertAllEqual(self.evaluate(s.variables[0]), [[0, 0]])\n    self.assertAllEqual(self.evaluate(s.variables[1]), [[0, 0], [1, 1]])\n    self.assertAllEqual(self.evaluate(s.variables[2]), [[0, 0]])\n    self.assertIs(ret, s)\n\n  def test_scatter_add_uneven_partition(self):\n    v = variables_lib.Variable(array_ops.zeros((32, 1)))\n    sparse_delta = ops.IndexedSlices(\n        values=constant_op.constant([[0.], [1.], [2.], [3.], [4.], [5.]]),\n        indices=constant_op.constant([0, 10, 11, 12, 30, 31]))\n\n    v0 = variables_lib.Variable(array_ops.zeros((11, 1)))\n    v1 = variables_lib.Variable(array_ops.zeros((11, 1)))\n    v2 = variables_lib.Variable(array_ops.zeros((10, 1)))\n    sv = sharded_variable.ShardedVariable([v0, v1, v2])\n\n    v.scatter_add(sparse_delta)\n    sv.scatter_add(sparse_delta)\n    self.assertAllEqual(v, ops.convert_to_tensor(sv))\n\n    @def_function.function\n    def func():\n      v.scatter_add(sparse_delta)\n      sv.scatter_add(sparse_delta)\n\n    func()\n    self.assertAllEqual(v, ops.convert_to_tensor(sv))\n\n  @parameterized.parameters('scatter_add', 'scatter_div', 'scatter_max',\n                            'scatter_min', 'scatter_mul', 'scatter_sub',\n                            'scatter_update')\n  def test_scatter_ops_even_partition(self, op):\n    v = variables_lib.Variable(array_ops.zeros((30, 1)))\n    sparse_delta = ops.IndexedSlices(\n        values=constant_op.constant([[0.], [1.], [2.], [3.], [4.]]),\n        indices=constant_op.constant([0, 10, 12, 21, 22]))\n\n    v0 = variables_lib.Variable(array_ops.zeros((10, 1)))\n    v1 = variables_lib.Variable(array_ops.zeros((10, 1)))\n    v2 = variables_lib.Variable(array_ops.zeros((10, 1)))\n    sv = sharded_variable.ShardedVariable([v0, v1, v2])\n\n    getattr(v, op)(sparse_delta, name='scatter_v')\n    getattr(sv, op)(sparse_delta, name='scatter_sv')\n    self.assertAllEqual(v, ops.convert_to_tensor(sv))\n\n    @def_function.function\n    def func():\n      getattr(v, op)(sparse_delta, name='scatter_v')\n      getattr(sv, op)(sparse_delta, name='scatter_sv')\n\n    func()\n    self.assertAllEqual(v, ops.convert_to_tensor(sv))\n\n  def test_batch_scatter_update(self):\n    v = variables_lib.Variable(array_ops.zeros((32, 1)))\n    sparse_delta = ops.IndexedSlices(\n        values=constant_op.constant([[0.], [1.], [2.], [3.], [4.], [5.]]),\n        indices=constant_op.constant([10, 11, 12, 13, 14, 15]))\n\n    v0 = variables_lib.Variable(array_ops.zeros((11, 1)))\n    v1 = variables_lib.Variable(array_ops.zeros((11, 1)))\n    v2 = variables_lib.Variable(array_ops.zeros((10, 1)))\n    sv = sharded_variable.ShardedVariable([v0, v1, v2])\n\n    v.batch_scatter_update(sparse_delta)\n    sv.batch_scatter_update(sparse_delta)\n    self.assertAllEqual(v, ops.convert_to_tensor(sv))\n\n    @def_function.function\n    def func():\n      v.batch_scatter_update(sparse_delta)\n      sv.batch_scatter_update(sparse_delta)\n\n    func()\n    self.assertAllEqual(v, ops.convert_to_tensor(sv))\n\n  def test_sparse_read(self):\n    v = variables_lib.Variable(array_ops.zeros((30, 1)))\n    indices = constant_op.constant([0, 10, 12, 21, 22])\n\n    v0 = variables_lib.Variable(array_ops.zeros((10, 1)))\n    v1 = variables_lib.Variable(array_ops.zeros((10, 1)))\n    v2 = variables_lib.Variable(array_ops.zeros((10, 1)))\n    sv = sharded_variable.ShardedVariable([v0, v1, v2])\n\n    self.assertAllEqual(v.sparse_read(indices), sv.sparse_read(indices))\n\n    @def_function.function\n    def func():\n      return v.sparse_read(indices), sv.sparse_read(indices)\n\n    got, expect = func()\n    self.assertAllEqual(got, expect)\n\n  def test_control_dep_on_assign(self):\n    v0 = variables_lib.Variable([[0, 0]])\n    v1 = variables_lib.Variable([[1, 1], [2, 2]])\n    v2 = variables_lib.Variable([[3, 3]])\n    s = sharded_variable.ShardedVariable([v0, v1, v2])\n\n    @def_function.function\n    def func():\n      ret = s.assign([[4, 4], [5, 5], [6, 6], [7, 7]])\n      with ops.control_dependencies([ret]):\n        a = array_ops.ones((1, 1))\n      with ops.control_dependencies([control_flow_ops.group(ret)]):\n        b = array_ops.ones((1, 1))\n      return a, b\n\n    func()\n\n  def test_convert_to_tensor(self):\n    v0 = variables_lib.Variable([[0, 0]])\n    v1 = variables_lib.Variable([[1, 1], [2, 2]])\n    v2 = variables_lib.Variable([[3, 3]])\n    s = sharded_variable.ShardedVariable([v0, v1, v2])\n    t = ops.convert_to_tensor(s)\n    self.assertAllEqual(t, [[0, 0], [1, 1], [2, 2], [3, 3]])\n\n  def test_save_restore(self):\n    fname = os.path.join(self.get_temp_dir(), 'checkpoint')\n    variables = [\n        variables_lib.Variable([0]),\n        variables_lib.Variable([1]),\n        variables_lib.Variable([2]),\n        variables_lib.Variable([3])\n    ]\n    s = sharded_variable.ShardedVariable(variables, name='s')\n\n    cp = util.Checkpoint(s=s)\n    self.assertEqual(self.evaluate(cp.s.variables[0]), [0])\n    cp.write(fname)\n\n    self.evaluate(cp.s.variables[0].assign([4]))\n    self.assertEqual(self.evaluate(cp.s.variables[0]), [4])\n\n    cp.restore(fname)\n    # Tests that the original weights are restored.\n    self.assertEqual(self.evaluate(cp.s.variables[0]), [0])\n\n  def test_save_restore_different_partitions(self):\n    fname = os.path.join(self.get_temp_dir(), 'checkpoint')\n    variables = [\n        variables_lib.Variable([0]),\n        variables_lib.Variable([1]),\n        variables_lib.Variable([2]),\n        variables_lib.Variable([3])\n    ]\n    s = sharded_variable.ShardedVariable(variables, name='s')\n\n    cp = util.Checkpoint(s=s)\n    cp.write(fname)\n\n    variables2 = [variables_lib.Variable([0, 0, 0, 0])]\n    s2 = sharded_variable.ShardedVariable(variables2, name='s')\n\n    # Restore from 4 partitions into 1.\n    cp2 = util.Checkpoint(s=s2)\n    cp2.restore(fname)\n    self.assertAllEqual(self.evaluate(cp2.s.variables[0]), [0, 1, 2, 3])\n\n    self.evaluate(cp2.s.variables[0].assign([5, 10, 15, 20]))\n    cp2.write(fname)\n\n    # Restore 1 partition into 4.\n    cp.restore(fname)\n    self.assertEqual(self.evaluate(cp.s.variables[0]), [5])\n    self.assertEqual(self.evaluate(cp.s.variables[1]), [10])\n    self.assertEqual(self.evaluate(cp.s.variables[2]), [15])\n    self.assertEqual(self.evaluate(cp.s.variables[3]), [20])\n\n  def test_save_restore_4_to_2_partitions(self):\n    fname = os.path.join(self.get_temp_dir(), 'checkpoint')\n    variables = [\n        variables_lib.Variable([0]),\n        variables_lib.Variable([1]),\n        variables_lib.Variable([2]),\n        variables_lib.Variable([3])\n    ]\n    s = sharded_variable.ShardedVariable(variables, name='s')\n    cp = util.Checkpoint(s=s)\n    cp.write(fname)\n\n    variables2 = [\n        variables_lib.Variable([0, 0]),\n        variables_lib.Variable([0, 0])\n    ]\n    s2 = sharded_variable.ShardedVariable(variables2, name='s')\n    cp2 = util.Checkpoint(s=s2)\n    cp2.restore(fname)\n    # Assert that weights from the 4 partitions were loaded here.\n    self.assertLen(cp2.s.variables, 2)\n    self.assertAllEqual(self.evaluate(cp2.s.variables[0]), [0, 1])\n    self.assertAllEqual(self.evaluate(cp2.s.variables[1]), [2, 3])\n\n  def test_delayed_restore(self):\n    fname = os.path.join(self.get_temp_dir(), 'checkpoint')\n    model = tracking.AutoTrackable()\n    variables = [\n        variables_lib.Variable([0]),\n        variables_lib.Variable([1]),\n        variables_lib.Variable([2]),\n        variables_lib.Variable([3])\n    ]\n    model.s = sharded_variable.ShardedVariable(variables)\n    cp = util.Checkpoint(model=model)\n    cp.write(fname)\n\n    model2 = tracking.AutoTrackable()\n    cp2 = util.Checkpoint(model=model2)\n    cp2.restore(fname)\n    variables2 = [\n        variables_lib.Variable([0]),\n        variables_lib.Variable([0]),\n        variables_lib.Variable([0]),\n        variables_lib.Variable([0])\n    ]\n    model2.s = sharded_variable.ShardedVariable(variables2)\n    self.assertAllEqual(self.evaluate(model2.s.variables[0]), [0])\n    self.assertAllEqual(self.evaluate(model2.s.variables[1]), [1])\n    self.assertAllEqual(self.evaluate(model2.s.variables[2]), [2])\n    self.assertAllEqual(self.evaluate(model2.s.variables[3]), [3])\n\n  def test_delayed_restore_4_to_2_partitions(self):\n    fname = os.path.join(self.get_temp_dir(), 'checkpoint')\n    model = tracking.AutoTrackable()\n    variables = [\n        variables_lib.Variable([0]),\n        variables_lib.Variable([1]),\n        variables_lib.Variable([2]),\n        variables_lib.Variable([3])\n    ]\n    model.s = sharded_variable.ShardedVariable(variables)\n    cp = util.Checkpoint(model=model)\n    cp.write(fname)\n\n    model2 = tracking.AutoTrackable()\n    cp2 = util.Checkpoint(model=model2)\n    cp2.restore(fname)\n    variables2 = [\n        variables_lib.Variable([0, 0]),\n        variables_lib.Variable([0, 0])\n    ]\n    model2.s = sharded_variable.ShardedVariable(variables2)\n    self.assertAllEqual(self.evaluate(model2.s.variables[0]), [0, 1])\n    self.assertAllEqual(self.evaluate(model2.s.variables[1]), [2, 3])\n\n  def test_save_graph_def(self):\n    root = tracking.AutoTrackable()\n    v1 = variables_lib.Variable([3.])\n    v2 = variables_lib.Variable([2.])\n    root.v = sharded_variable.ShardedVariable([v1, v2])\n    root.train = def_function.function(\n        lambda x: embedding_ops.embedding_lookup_v2(root.v.variables, x))\n    # TODO(b/144057383): Remove the necessity of root.serve once saving context\n    # is made to tf.function cache.\n    root.serve = def_function.function(\n        lambda x: embedding_ops.embedding_lookup_v2(root.v.variables[0], x),\n        input_signature=[tensor_spec.TensorSpec([2], dtypes.int32, name='x')])\n\n    # Trace and use root.train\n    self.assertAllEqual([3., 2.], root.train([0, 1]).numpy())\n\n    save_dir = os.path.join(self.get_temp_dir(), 'saved_model')\n    save.save(root, save_dir, root.serve)\n    self.assertAllEqual([3., 2.],\n                        _load_and_run(save_dir, {'x': [0, 1]})['output_0'])\n\n    # Continue using root.train for training\n    self.assertAllEqual([3., 2.], root.train([0, 1]).numpy())\n\n  def test_load_raises_error(self):\n    root = tracking.AutoTrackable()\n    v1 = variables_lib.Variable([3.])\n    v2 = variables_lib.Variable([2.])\n    root.v = sharded_variable.ShardedVariable([v1, v2])\n\n    save_dir = os.path.join(self.get_temp_dir(), 'saved_model')\n    save.save(root, save_dir)\n\n    with self.assertRaisesRegex(\n        ValueError, 'Loading a saved_model containing ShardedVariable'):\n      load.load(save_dir)\n\n  def test_validation_errors(self):\n    with self.assertRaisesRegex(ValueError, 'Expected a list of '):\n      sharded_variable.ShardedVariable(\n          [variables_lib.Variable([0]), 'not-a-variable'])\n\n    with self.assertRaisesRegex(ValueError, 'must have the same dtype'):\n      sharded_variable.ShardedVariable([\n          variables_lib.Variable([0], dtype='int64'),\n          variables_lib.Variable([1], dtype='int32')\n      ])\n\n    with self.assertRaisesRegex(ValueError, 'the same shapes except'):\n      sharded_variable.ShardedVariable([\n          variables_lib.Variable(array_ops.ones((5, 10))),\n          variables_lib.Variable(array_ops.ones((5, 20)))\n      ])\n\n    with self.assertRaisesRegex(ValueError, '`SaveSliceInfo` should not'):\n      v = variables_lib.Variable([0])\n      v._set_save_slice_info(\n          variables_lib.Variable.SaveSliceInfo(\n              full_name='s', full_shape=[2], var_offset=[0], var_shape=[1]))\n      sharded_variable.ShardedVariable([v])\n\n  def test_as_function_input(self):\n    variables1 = [\n        variables_lib.Variable([1]),\n        variables_lib.Variable([1]),\n    ]\n    s = sharded_variable.ShardedVariable(variables1)\n    variables2 = [\n        variables_lib.Variable([2]),\n        variables_lib.Variable([2]),\n    ]\n    s2 = sharded_variable.ShardedVariable(variables2)\n\n    trace_count = [0]\n\n    @def_function.function\n    def func(sharded_var):\n      trace_count[0] = trace_count[0] + 1\n      sharded_var.assign([0, 0])\n\n    func(s)\n    self.assertAllEqual(ops.convert_to_tensor(s), [0, 0])\n    self.assertEqual(trace_count[0], 1)\n    func(s2)\n    self.assertAllEqual(ops.convert_to_tensor(s2), [0, 0])\n    self.assertEqual(trace_count[0], 1)\n\n  def test_flatten(self):\n    variables = [\n        variables_lib.Variable([0]),\n        variables_lib.Variable([1]),\n    ]\n    s = sharded_variable.ShardedVariable(variables)\n\n    got = nest.flatten(s)\n    self.assertIs(s, got[0])\n\n    got = nest.flatten(s, expand_composites=True)\n    self.assertAllEqual(variables, got)\n\n  def test_tf_module(self):\n\n    class Model(module.Module):\n\n      def __init__(self):\n        super().__init__()\n        variables = [\n            variables_lib.Variable([0]),\n            variables_lib.Variable([1]),\n        ]\n        self.w = sharded_variable.ShardedVariable(variables)\n\n    model = Model()\n\n    self.assertLen(model.variables, 2)\n    self.assertEqual(model.variables[0], [0])\n    self.assertEqual(model.variables[1], [1])\n    self.assertAllEqual(model.variables, model.trainable_variables)\n\n    self.assertLen(model._checkpoint_dependencies, 1)\n    self.assertIs(model._checkpoint_dependencies[0].ref, model.w)\n\n  def test_embedding_lookup(self):\n    v = [\n        variables_lib.Variable([[1., 2.], [3., 4.]]),\n        variables_lib.Variable([[5., 6.], [7., 8.]]),\n        variables_lib.Variable([[9., 10.]])\n    ]\n    sv = sharded_variable.ShardedVariable(v)\n\n    @def_function.function\n    def lookup():\n      ids = constant_op.constant([0, 3, 4])\n      return embedding_ops.embedding_lookup_v2(sv, ids)\n\n    @def_function.function\n    def sparse_lookup():\n      sp_ids = sparse_tensor.SparseTensor(\n          indices=[[0, 0], [0, 1], [1, 0], [2, 2]],\n          values=[0, 3, 4, 1],\n          dense_shape=[3, 3])\n      return embedding_ops.embedding_lookup_sparse_v2(sv, sp_ids, None)\n\n    @def_function.function\n    def safe_sparse_lookup():\n      sp_ids = sparse_tensor.SparseTensor(\n          indices=[[0, 0], [0, 1], [1, 0], [2, 2]],\n          values=[0, -1, 4, 1],\n          dense_shape=[3, 3])\n      sp_weights = sparse_tensor.SparseTensor(\n          indices=[[0, 0], [0, 1], [1, 0], [2, 2]],\n          values=[1., 1., -1., 1.],\n          dense_shape=[3, 3])\n      return embedding_ops.safe_embedding_lookup_sparse_v2(\n          sv, sp_ids, sp_weights)\n\n    # TODO(chenkai): Add safe_sparse_lookup to the list. Currently\n    # ShardedVariable is converted to a tensor in safe_sparse_lookup.\n    for func in [lookup, sparse_lookup]:\n      num_gather_ops = 0\n      for op in func.get_concrete_function().graph.get_operations():\n        if op.type == 'ResourceGather':\n          num_gather_ops += 1\n      self.assertEqual(\n          num_gather_ops, len(v), 'Number of ResourceGather op does not match'\n          ' expected, possibly due to ShardedVariable accidentally being'\n          ' converted to tensor in embedding_lookup ops.')\n\n    self.assertAllEqual(lookup(), [[1., 2.], [7., 8.], [9., 10.]])\n    self.assertAllClose(sparse_lookup(), [[4., 5.], [9., 10.], [3., 4.]])\n    self.assertAllClose(safe_sparse_lookup(), [[1., 2.], [0., 0.], [3., 4.]])\n\n  def test_slicing(self):\n    v = [\n        variables_lib.Variable([[1, 2], [3, 4], [5, 6]]),\n        variables_lib.Variable([[7, 8], [9, 10], [11, 12]]),\n        variables_lib.Variable([[13, 14], [15, 16]])\n    ]\n    sv = sharded_variable.ShardedVariable(v)\n    empty = v[0][0:0]\n\n    # Test cases: positive step\n    self.assertAllEqual(sv[:], array_ops.concat(v, axis=0))\n    self.assertAllEqual(sv[:2], [[1, 2], [3, 4]])\n    self.assertAllEqual(sv[-8:2], [[1, 2], [3, 4]])\n    self.assertAllEqual(sv[-10:2], [[1, 2], [3, 4]])\n    self.assertAllEqual(sv[5:], [[11, 12], [13, 14], [15, 16]])\n    self.assertAllEqual(sv[5:-1], [[11, 12], [13, 14]])\n    self.assertAllEqual(sv[::3], [[1, 2], [7, 8], [13, 14]])\n    self.assertAllEqual(sv[::5], [[1, 2], [11, 12]])\n    self.assertAllEqual(sv[1::6], [[3, 4], [15, 16]])\n    self.assertAllEqual(sv[1:5:6], [[3, 4]])\n    self.assertAllEqual(sv[1::7], [[3, 4]])\n    self.assertAllEqual(sv[2:7], [[5, 6], [7, 8], [9, 10], [11, 12], [13, 14]])\n    self.assertAllEqual(sv[2:7:2], [[5, 6], [9, 10], [13, 14]])\n    self.assertAllEqual(sv[2:7:3], [[5, 6], [11, 12]])\n\n    # Test cases: negative step\n    self.assertAllEqual(\n        sv[::-1], array_ops.reverse(array_ops.concat(v, axis=0), axis=[0]))\n    self.assertAllEqual(sv[2::-1], [[5, 6], [3, 4], [1, 2]])\n    self.assertAllEqual(sv[2:-8:-1], [[5, 6], [3, 4]])\n    self.assertAllEqual(sv[2:-10:-1], [[5, 6], [3, 4], [1, 2]])\n    self.assertAllEqual(sv[4::-1], [[9, 10], [7, 8], [5, 6], [3, 4], [1, 2]])\n    self.assertAllEqual(sv[-1:-3:-1], [[15, 16], [13, 14]])\n    self.assertAllEqual(sv[::-5], [[15, 16], [5, 6]])\n    self.assertAllEqual(sv[6::-6], [[13, 14], [1, 2]])\n    self.assertAllEqual(sv[6:5:-6], [[13, 14]])\n    self.assertAllEqual(sv[6::-7], [[13, 14]])\n    self.assertAllEqual(sv[7:1:-1],\n                        [[15, 16], [13, 14], [11, 12], [9, 10], [7, 8], [5, 6]])\n    self.assertAllEqual(sv[7:1:-2], [[15, 16], [11, 12], [7, 8]])\n    self.assertAllEqual(sv[7:1:-4], [[15, 16], [7, 8]])\n\n    # Test cases: empty slice\n    self.assertAllEqual(sv[0:0], empty)\n    self.assertAllEqual(sv[5:3], empty)\n    self.assertAllEqual(sv[3:5:-1], empty)\n    self.assertAllEqual(sv[-1:0], empty)\n    self.assertAllEqual(sv[2:-1:-1], empty)\n\n    # Test cases: slicing other dimensions\n    self.assertAllEqual(sv[:, 0], [1, 3, 5, 7, 9, 11, 13, 15])\n    self.assertAllEqual(sv[:, 0:1], [[1], [3], [5], [7], [9], [11], [13], [15]])\n\n    # Test cases: normal indexing\n    self.assertAllEqual(sv[2], [5, 6])\n    self.assertAllEqual(sv[6], [13, 14])\n    self.assertAllEqual(sv[2, 1], 6)\n    self.assertAllEqual(sv[-2], [13, 14])\n    with self.assertRaisesRegex(IndexError, 'out of bounds'):\n      _ = sv[100]\n    with self.assertRaisesRegex(IndexError, 'out of bounds'):\n      _ = sv[-100]\n\n    # Test cases: Ellipsis\n    self.assertAllEqual(sv[...], array_ops.concat(v, axis=0))\n    self.assertAllEqual(sv[..., 0], [1, 3, 5, 7, 9, 11, 13, 15])\n    self.assertAllEqual(sv[0:1, ...], [[1, 2]])\n\n    # Test cases: newaxis\n    self.assertAllEqual(\n        sv[array_ops.newaxis, ...],\n        array_ops.expand_dims_v2(array_ops.concat(v, axis=0), axis=0))\n\n    # Test cases: boolean masks\n    self.assertAllEqual(sv[ops.convert_to_tensor(sv) > 10],\n                        [11, 12, 13, 14, 15, 16])\n\n    # Test cases: tensor input\n    with self.assertRaisesRegex(TypeError, 'not allowed'):\n      _ = sv[constant_op.constant(1)::]\n    with self.assertRaisesRegex(TypeError, 'not allowed'):\n      _ = sv[:constant_op.constant(1):]\n    with self.assertRaisesRegex(TypeError, 'not allowed'):\n      _ = sv[constant_op.constant(1)]\n\n    # Test cases: inside tf.function\n    @def_function.function\n    def func():\n      a = sv[:, 0]\n      return a\n\n    self.assertAllEqual(func(), [1, 3, 5, 7, 9, 11, 13, 15])\n\n  def test_operator_overload(self):\n    v1 = [\n        variables_lib.Variable([1.]),\n        variables_lib.Variable([2.]),\n    ]\n    sv1 = sharded_variable.ShardedVariable(v1)\n\n    v2 = [\n        variables_lib.Variable([1.]),\n        variables_lib.Variable([2.]),\n    ]\n    sv2 = sharded_variable.ShardedVariable(v2)\n\n    equal = sv1 == sv2\n    self.assertAllEqual(equal, [True, True])\n    self.assertAllEqual(sv1 + sv2, [2.0, 4.0])\n\n\nif __name__ == '__main__':\n  v2_compat.enable_v2_behavior()\n  test.main()"