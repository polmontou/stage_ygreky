"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/io_ops.cc.\n\n#include <string>\n#include <vector>\n\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/kernels/save_restore_tensor.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/io/path.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/saved_tensor_slice_util.h\"\n#include \"tensorflow/core/util/tensor_bundle/tensor_bundle.h\"\n#include \"tensorflow/core/util/tensor_slice_reader.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\n// Shared validations of the inputs to the SaveV2 and RestoreV2 ops.\nvoid ValidateInputs(bool is_save_op, OpKernelContext* context,\n                    const Tensor& prefix, const Tensor& tensor_names,\n                    const Tensor& shape_and_slices) {\n  const int kFixedInputs = 3;  // Prefix, tensor names, shape_and_slices.\n  const int num_tensors = static_cast<int>(tensor_names.NumElements());\n  OP_REQUIRES(\n      context, prefix.NumElements() == 1,\n      errors::InvalidArgument(\"Input prefix should have a single element, got \",\n                              prefix.NumElements(), \" instead.\"));\n  OP_REQUIRES(context,\n              TensorShapeUtils::IsVector(tensor_names.shape()) &&\n                  TensorShapeUtils::IsVector(shape_and_slices.shape()),\n              errors::InvalidArgument(\n                  \"Input tensor_names and shape_and_slices \"\n                  \"should be an 1-D tensors, got \",\n                  tensor_names.shape().DebugString(), \" and \",\n                  shape_and_slices.shape().DebugString(), \" instead.\"));\n  OP_REQUIRES(context,\n              tensor_names.NumElements() == shape_and_slices.NumElements(),\n              errors::InvalidArgument(\"tensor_names and shape_and_slices \"\n                                      \"have different number of elements: \",\n                                      tensor_names.NumElements(), \" vs. \",\n                                      shape_and_slices.NumElements()));\n  OP_REQUIRES(context,\n              FastBoundsCheck(tensor_names.NumElements() + kFixedInputs,\n                              std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Too many inputs to the op\"));\n  OP_REQUIRES(\n      context, shape_and_slices.NumElements() == num_tensors,\n      errors::InvalidArgument(\"Expected \", num_tensors,\n                              \" elements in shapes_and_slices, but got \",\n                              context->input(2).NumElements()));\n  if (is_save_op) {\n    OP_REQUIRES(context, context->num_inputs() == num_tensors + kFixedInputs,\n                errors::InvalidArgument(\n                    \"Got \", num_tensors, \" tensor names but \",\n                    context->num_inputs() - kFixedInputs, \" tensors.\"));\n    OP_REQUIRES(context, context->num_inputs() == num_tensors + kFixedInputs,\n                errors::InvalidArgument(\n                    \"Expected a total of \", num_tensors + kFixedInputs,\n                    \" inputs as input #1 (which is a string \"\n                    \"tensor of saved names) contains \",\n                    num_tensors, \" names, but received \", context->num_inputs(),\n                    \" inputs\"));\n  }\n}\n\n}  // namespace\n\n// Saves a list of named tensors using the tensor bundle library.\nclass SaveV2 : public OpKernel {\n public:\n  explicit SaveV2(OpKernelConstruction* context) : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& prefix = context->input(0);\n    const Tensor& tensor_names = context->input(1);\n    const Tensor& shape_and_slices = context->input(2);\n    ValidateInputs(true /* is save op */, context, prefix, tensor_names,\n                   shape_and_slices);\n\n    const int kFixedInputs = 3;  // Prefix, tensor names, shape_and_slices.\n    const int num_tensors = static_cast<int>(tensor_names.NumElements());\n    const string& prefix_string = prefix.scalar<tstring>()();\n    const auto& tensor_names_flat = tensor_names.flat<tstring>();\n    const auto& shape_and_slices_flat = shape_and_slices.flat<tstring>();\n\n    BundleWriter writer(Env::Default(), prefix_string);\n    OP_REQUIRES_OK(context, writer.status());\n    VLOG(1) << \"BundleWriter, prefix_string: \" << prefix_string;\n\n    for (int i = 0; i < num_tensors; ++i) {\n      const string& tensor_name = tensor_names_flat(i);\n      const Tensor& tensor = context->input(i + kFixedInputs);\n      VLOG(2) << \"Starting save of \" << tensor_name;\n\n      if (!shape_and_slices_flat(i).empty()) {\n        const string& shape_spec = shape_and_slices_flat(i);\n        TensorShape shape;\n        TensorSlice slice(tensor.dims());\n        TensorShape slice_shape;\n\n        OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                    shape_spec, &shape, &slice, &slice_shape));\n        OP_REQUIRES(context, slice_shape.IsSameSize(tensor.shape()),\n                    errors::InvalidArgument(\"Slice in shape_and_slice \"\n                                            \"specification does not match the \"\n                                            \"shape of the tensor to  save: \",\n                                            shape_spec, \", tensor: \",\n                                            tensor.shape().DebugString()));\n\n        OP_REQUIRES_OK(context,\n                       writer.AddSlice(tensor_name, shape, slice, tensor));\n      } else {\n        OP_REQUIRES_OK(context, writer.Add(tensor_name, tensor));\n      }\n\n      if (VLOG_IS_ON(5)) {\n        if (tensor.dtype() == DT_FLOAT) {\n          const float* t_data = tensor.flat<float>().data();\n          float min = std::numeric_limits<float>::infinity();\n          float max = -std::numeric_limits<float>::infinity();\n          double avg = 0.0;\n          for (int i = 0; i < tensor.NumElements(); ++i) {\n            if (t_data[i] < min) min = t_data[i];\n            if (t_data[i] > max) max = t_data[i];\n            avg += t_data[i];\n          }\n          VLOG(5) << \" min \" << min << \" max \" << max << \" avg \"\n                  << avg / tensor.NumElements() << \" total elts \"\n                  << tensor.NumElements();\n        }\n      }\n\n      VLOG(2) << \"Done save of \" << tensor_name;\n    }\n    OP_REQUIRES_OK(context, writer.Finish());\n    VLOG(1) << \"Done BundleWriter, prefix_string: \" << prefix_string;\n  }\n};\nREGISTER_KERNEL_BUILDER(Name(\"SaveV2\").Device(DEVICE_CPU), SaveV2);\n\n// Restores a list of named tensors from a tensor bundle (V2 checkpoint format).\nclass RestoreV2 : public OpKernel {\n public:\n  explicit RestoreV2(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"dtypes\", &dtypes_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& prefix = context->input(0);\n    const Tensor& tensor_names = context->input(1);\n    const Tensor& shape_and_slices = context->input(2);\n    OP_REQUIRES(context, tensor_names.NumElements() == dtypes_.size(),\n                errors::InvalidArgument(\"Got \", tensor_names.NumElements(),\n                                        \" tensor names, but \", dtypes_.size(),\n                                        \" expected dtypes.\"));\n    ValidateInputs(false /* not save op */, context, prefix, tensor_names,\n                   shape_and_slices);\n\n    const string& prefix_string = prefix.scalar<tstring>()();\n\n    // Intention: we plan to use the RestoreV2 op as a backward-compatible\n    // reader as we upgrade to the V2 format.  This allows transparent upgrade.\n    // We here attempt to read a V1 checkpoint, if \"prefix_string\" does not\n    // refer to a V2 checkpoint.\n    Env* env = Env::Default();\n    std::vector<string> paths;\n    if (!env->GetMatchingPaths(MetaFilename(prefix_string), &paths).ok() ||\n        paths.empty()) {\n      // Cannot find V2's metadata file, so \"prefix_string\" does not point to a\n      // V2 checkpoint.  Invokes the V1 read path instead.\n      for (size_t i = 0; i < tensor_names.NumElements(); ++i) {\n        RestoreTensor(context, &checkpoint::OpenTableTensorSliceReader,\n                      /* preferred_shard */ -1, /* restore_slice */ true,\n                      /* restore_index */ i);\n        if (!context->status().ok()) {\n          return;\n        }\n      }\n      return;\n    }\n    // If found, invokes the V2 reader.\n    OP_REQUIRES_OK(context, RestoreTensorsV2(context, prefix, tensor_names,\n                                             shape_and_slices, dtypes_));\n  }\n\n private:\n  // Expected dtypes of the to-restore tensors.\n  std::vector<DataType> dtypes_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"RestoreV2\").Device(DEVICE_CPU), RestoreV2);\n\n// The final step in saving sharded V2 checkpoints: merges metadata files.\nclass MergeV2Checkpoints : public OpKernel {\n public:\n  explicit MergeV2Checkpoints(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"delete_old_dirs\", &delete_old_dirs_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& checkpoint_prefixes = context->input(0);\n    const Tensor& destination_prefix = context->input(1);\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsVector(checkpoint_prefixes.shape()),\n                errors::InvalidArgument(\n                    \"Input checkpoint_prefixes should be an 1-D tensor, got \",\n                    checkpoint_prefixes.shape().DebugString(), \" instead.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(destination_prefix.shape()),\n                errors::InvalidArgument(\n                    \"Input destination_prefix should be a scalar tensor, got \",\n                    destination_prefix.shape().DebugString(), \" instead.\"));\n\n    const gtl::ArraySlice<tstring> input_prefixes =\n        gtl::ArraySlice<tstring>(checkpoint_prefixes.flat<tstring>());\n    Env* env = Env::Default();\n    const string& merged_prefix = destination_prefix.scalar<tstring>()();\n    OP_REQUIRES_OK(\n        context, tensorflow::MergeBundles(env, input_prefixes, merged_prefix));\n\n    if (delete_old_dirs_) {\n      const string merged_dir(io::Dirname(merged_prefix));\n      for (const string& input_prefix : input_prefixes) {\n        const string dirname(io::Dirname(input_prefix));\n        if (dirname == merged_dir) continue;\n        Status status = env->DeleteDir(dirname);\n        // For sharded save, only the first delete will go through and all\n        // others will hit NotFound.  Use vlog to be less verbose.\n        if (!status.ok()) VLOG(1) << status;\n      }\n    }\n  }\n\n private:\n  // On merge, whether or not to delete the input (temporary) directories.\n  bool delete_old_dirs_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"MergeV2Checkpoints\").Device(DEVICE_CPU),\n                        MergeV2Checkpoints);\n\n}  // namespace tensorflow"