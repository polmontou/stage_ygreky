"/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <memory>\n#include <string>\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/kernels/boosted_trees/resources.h\"\n#include \"tensorflow/core/lib/core/refcount.h\"\n\nnamespace tensorflow {\n\nREGISTER_RESOURCE_HANDLE_KERNEL(BoostedTreesEnsembleResource);\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"IsBoostedTreesEnsembleInitialized\").Device(DEVICE_CPU),\n    IsResourceInitialized<BoostedTreesEnsembleResource>);\n\n// Creates a tree ensemble resource.\nclass BoostedTreesCreateEnsembleOp : public OpKernel {\n public:\n  explicit BoostedTreesCreateEnsembleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    // Get the stamp token.\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n\n    // Get the tree ensemble proto.\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n\n    // Only create one, if one does not exist already. Report status for all\n    // other exceptions.\n    auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"BoostedTreesCreateEnsemble\").Device(DEVICE_CPU),\n                        BoostedTreesCreateEnsembleOp);\n\n// Op for retrieving some model states (needed for training).\nclass BoostedTreesGetEnsembleStatesOp : public OpKernel {\n public:\n  explicit BoostedTreesGetEnsembleStatesOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    // Looks up the resource.\n    core::RefCountPtr<BoostedTreesEnsembleResource> tree_ensemble_resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &tree_ensemble_resource));\n    tf_shared_lock l(*tree_ensemble_resource->get_mutex());\n\n    // Sets the outputs.\n    const int num_trees = tree_ensemble_resource->num_trees();\n    const int num_finalized_trees =\n        (num_trees <= 0 ||\n         tree_ensemble_resource->IsTreeFinalized(num_trees - 1))\n            ? num_trees\n            : num_trees - 1;\n    const int num_attempted_layers =\n        tree_ensemble_resource->GetNumLayersAttempted();\n\n    // growing_metadata\n    Tensor* output_stamp_token_t = nullptr;\n    Tensor* output_num_trees_t = nullptr;\n    Tensor* output_num_finalized_trees_t = nullptr;\n    Tensor* output_num_attempted_layers_t = nullptr;\n    Tensor* output_last_layer_nodes_range_t = nullptr;\n\n    OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape(),\n                                                     &output_stamp_token_t));\n    OP_REQUIRES_OK(context, context->allocate_output(1, TensorShape(),\n                                                     &output_num_trees_t));\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, TensorShape(),\n                                            &output_num_finalized_trees_t));\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(3, TensorShape(),\n                                            &output_num_attempted_layers_t));\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                4, {2}, &output_last_layer_nodes_range_t));\n\n    output_stamp_token_t->scalar<int64>()() = tree_ensemble_resource->stamp();\n    output_num_trees_t->scalar<int32>()() = num_trees;\n    output_num_finalized_trees_t->scalar<int32>()() = num_finalized_trees;\n    output_num_attempted_layers_t->scalar<int32>()() = num_attempted_layers;\n\n    int32_t range_start;\n    int32_t range_end;\n    tree_ensemble_resource->GetLastLayerNodesRange(&range_start, &range_end);\n\n    output_last_layer_nodes_range_t->vec<int32>()(0) = range_start;\n    // For a completely empty ensemble, this will be 0. To make it a valid range\n    // we add this max cond.\n    output_last_layer_nodes_range_t->vec<int32>()(1) = std::max(1, range_end);\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesGetEnsembleStates\").Device(DEVICE_CPU),\n    BoostedTreesGetEnsembleStatesOp);\n\n// Op for serializing a model.\nclass BoostedTreesSerializeEnsembleOp : public OpKernel {\n public:\n  explicit BoostedTreesSerializeEnsembleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> tree_ensemble_resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &tree_ensemble_resource));\n    tf_shared_lock l(*tree_ensemble_resource->get_mutex());\n    Tensor* output_stamp_token_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape(),\n                                                     &output_stamp_token_t));\n    output_stamp_token_t->scalar<int64>()() = tree_ensemble_resource->stamp();\n    Tensor* output_proto_t = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, TensorShape(), &output_proto_t));\n    output_proto_t->scalar<tstring>()() =\n        tree_ensemble_resource->SerializeAsString();\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesSerializeEnsemble\").Device(DEVICE_CPU),\n    BoostedTreesSerializeEnsembleOp);\n\n// Op for deserializing a tree ensemble variable from a checkpoint.\nclass BoostedTreesDeserializeEnsembleOp : public OpKernel {\n public:\n  explicit BoostedTreesDeserializeEnsembleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> tree_ensemble_resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &tree_ensemble_resource));\n    mutex_lock l(*tree_ensemble_resource->get_mutex());\n\n    // Get the stamp token.\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n\n    // Get the tree ensemble proto.\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    // Deallocate all the previous objects on the resource.\n    tree_ensemble_resource->Reset();\n    OP_REQUIRES(\n        context,\n        tree_ensemble_resource->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token),\n        errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"BoostedTreesDeserializeEnsemble\").Device(DEVICE_CPU),\n    BoostedTreesDeserializeEnsembleOp);\n\n}  // namespace tensorflow"