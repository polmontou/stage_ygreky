"diff --git a/tensorflow/core/kernels/boosted_trees/stats_ops.cc b/tensorflow/core/kernels/boosted_trees/stats_ops.cc\nindex 2636909855a..60c1d191f52 100644\n--- a/tensorflow/core/kernels/boosted_trees/stats_ops.cc\n+++ b/tensorflow/core/kernels/boosted_trees/stats_ops.cc\n@@ -14,6 +14,7 @@ limitations under the License.\n ==============================================================================*/\n \n #include <limits>\n+#include <string>\n #include <vector>\n \n #include \"third_party/eigen3/Eigen/Core\"\n@@ -22,6 +23,7 @@ limitations under the License.\n #include \"tensorflow/core/framework/tensor_shape.h\"\n #include \"tensorflow/core/kernels/boosted_trees/boosted_trees.pb.h\"\n #include \"tensorflow/core/kernels/boosted_trees/tree_helper.h\"\n+#include \"tensorflow/core/platform/errors.h\"\n #include \"tensorflow/core/platform/logging.h\"\n \n namespace tensorflow {\n@@ -254,12 +256,18 @@ class BoostedTreesCalculateBestFeatureSplitOp : public OpKernel {\n     // node_id_range\n     const Tensor* node_id_range_t;\n     OP_REQUIRES_OK(context, context->input(\"node_id_range\", &node_id_range_t));\n+    OP_REQUIRES(\n+        context, node_id_range_t->NumElements() == 2,\n+        errors::InvalidArgument(\"node_id_range argument must have shape [2]\"));\n     const auto node_id_range = node_id_range_t->vec<int32>();\n     const int32_t node_id_first = node_id_range(0);  // inclusive\n     const int32_t node_id_last = node_id_range(1);   // exclusive\n \n     const Tensor* stats_summary_t;\n     OP_REQUIRES_OK(context, context->input(\"stats_summary\", &stats_summary_t));\n+    OP_REQUIRES(\n+        context, stats_summary_t->shape().dims() == 4,\n+        errors::InvalidArgument(\"stats_summary argument must have rank 4\"));\n     TTypes<float, 4>::ConstTensor stats_summary =\n         stats_summary_t->tensor<float, 4>();\n     const int32_t feature_dims = stats_summary_t->dim_size(1);\n@@ -272,6 +280,8 @@ class BoostedTreesCalculateBestFeatureSplitOp : public OpKernel {\n \n     const Tensor* l1_t;\n     OP_REQUIRES_OK(context, context->input(\"l1\", &l1_t));\n+    OP_REQUIRES(context, l1_t->NumElements() == 1,\n+                errors::InvalidArgument(\"l1 argument must be a scalar\"));\n     const auto l1 = l1_t->scalar<float>()();\n     DCHECK_GE(l1, 0);\n     if (logits_dim_ > 1) {\n@@ -281,17 +291,25 @@ class BoostedTreesCalculateBestFeatureSplitOp : public OpKernel {\n \n     const Tensor* l2_t;\n     OP_REQUIRES_OK(context, context->input(\"l2\", &l2_t));\n+    OP_REQUIRES(context, l2_t->NumElements() == 1,\n+                errors::InvalidArgument(\"l2 argument must be a scalar\"));\n     const auto l2 = l2_t->scalar<float>()();\n     DCHECK_GE(l2, 0);\n \n     const Tensor* tree_complexity_t;\n     OP_REQUIRES_OK(context,\n                    context->input(\"tree_complexity\", &tree_complexity_t));\n+    OP_REQUIRES(\n+        context, tree_complexity_t->NumElements() == 1,\n+        errors::InvalidArgument(\"tree_complexity argument must be a scalar\"));\n     const auto tree_complexity = tree_complexity_t->scalar<float>()();\n \n     const Tensor* min_node_weight_t;\n     OP_REQUIRES_OK(context,\n                    context->input(\"min_node_weight\", &min_node_weight_t));\n+    OP_REQUIRES(\n+        context, min_node_weight_t->NumElements() == 1,\n+        errors::InvalidArgument(\"min_node_weight argument must be a scalar\"));\n     const auto min_node_weight = min_node_weight_t->scalar<float>()();\n \n     std::vector<int32> output_node_ids;\n@@ -300,7 +318,7 @@ class BoostedTreesCalculateBestFeatureSplitOp : public OpKernel {\n     std::vector<int32> output_thresholds;\n     std::vector<Eigen::VectorXf> output_left_node_contribs;\n     std::vector<Eigen::VectorXf> output_right_node_contribs;\n-    std::vector<string> output_split_types;\n+    std::vector<std::string> output_split_types;\n \n     // TODO(tanzheny) parallelize the computation.\n     // Iterate each node and find the best gain per node."