"diff --git a/tensorflow/core/kernels/ragged_tensor_from_variant_op.cc b/tensorflow/core/kernels/ragged_tensor_from_variant_op.cc\nindex d9993bb6d39..c481d90638e 100644\n--- a/tensorflow/core/kernels/ragged_tensor_from_variant_op.cc\n+++ b/tensorflow/core/kernels/ragged_tensor_from_variant_op.cc\n@@ -174,7 +174,23 @@ Status NestedStackRaggedTensors(\n   auto output_values_flat =\n       output_ragged->mutable_values()->flat_outer_dims<VALUE_TYPE, 2>();\n   int values_index = 0;\n+\n+  TensorShape expected_value_shape = component_values_shape;\n+  expected_value_shape.RemoveDim(0);\n+\n   for (int i = 0; i < ragged_components.size(); i++) {\n+    // Check that the flat_values tensor shape is compatible.\n+    TensorShape value_shape = ragged_components[i].values().shape();\n+    value_shape.RemoveDim(0);\n+    if (value_shape != expected_value_shape) {\n+      return errors::InvalidArgument(\n+          \"All flat_values must have compatible shapes.  Shape at index 0: \",\n+          expected_value_shape, \".  Shape at index \", i, \": \", value_shape,\n+          \".  If you are using tf.map_fn, then you may need to specify an \"\n+          \"explicit fn_output_signature with appropriate ragged_rank, and/or \"\n+          \"convert output tensors to RaggedTensors.\");\n+    }\n+\n     auto component_values_flat =\n         ragged_components[i].values().flat_outer_dims<VALUE_TYPE, 2>();\n     int num_inner_elements = ragged_components[i].values().NumElements();"