"diff --git a/tensorflow/python/ops/ragged/ragged_map_fn_op_test.py b/tensorflow/python/ops/ragged/ragged_map_fn_op_test.py\nindex bead4923a0a..ace724ac871 100644\n--- a/tensorflow/python/ops/ragged/ragged_map_fn_op_test.py\n+++ b/tensorflow/python/ops/ragged/ragged_map_fn_op_test.py\n@@ -21,9 +21,11 @@ from absl.testing import parameterized\n import numpy as np\n \n from tensorflow.python.framework import dtypes\n+from tensorflow.python.framework import errors\n from tensorflow.python.framework import sparse_tensor\n from tensorflow.python.framework import test_util\n from tensorflow.python.ops import array_ops\n+from tensorflow.python.ops import map_fn as map_fn_lib\n from tensorflow.python.ops import math_ops as mo\n from tensorflow.python.ops import string_ops\n from tensorflow.python.ops.ragged import ragged_factory_ops\n@@ -309,6 +311,27 @@ class RaggedMapOpTest(test_util.TensorFlowTestCase,\n     )\n     self.assertAllEqual(id_t2, [[0, 5], [0, 4]])\n \n+  def testRaggedMapWithIncorrectFnOutputSignature(self):\n+    x = ragged_factory_ops.constant([[1, 2, 3, 4], [1]])\n+    with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                'All flat_values must have compatible shapes'):\n+      y = map_fn_lib.map_fn(lambda r: map_fn_lib.map_fn(lambda y: r, r), x)\n+      self.evaluate(y)\n+\n+  def testNestedRaggedMapWithFnOutputSignature(self):\n+    ragged1d = ragged_tensor.RaggedTensorSpec([None], dtypes.int32)\n+    ragged2d = ragged_tensor.RaggedTensorSpec([None, None], dtypes.int32)\n+\n+    x = ragged_factory_ops.constant([[1, 2, 3, 4], [1]])\n+    # pylint: disable=g-long-lambda\n+    y = map_fn_lib.map_fn(\n+        lambda r: map_fn_lib.map_fn(\n+            lambda y: r, r, fn_output_signature=ragged1d),\n+        x,\n+        fn_output_signature=ragged2d)\n+    expected = [[[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]], [[1]]]\n+    self.assertAllEqual(y, expected)\n+\n \n if __name__ == '__main__':\n   googletest.main()"