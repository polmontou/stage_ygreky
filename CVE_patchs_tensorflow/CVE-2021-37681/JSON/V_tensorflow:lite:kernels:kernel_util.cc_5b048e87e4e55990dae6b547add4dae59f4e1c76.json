"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n\n#include <algorithm>\n#include <complex>\n#include <limits>\n#include <memory>\n#ifndef TF_LITE_STATIC_MEMORY\n#include <string>\n#endif  // TF_LITE_STATIC_MEMORY\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/cppmath.h\"\n#include \"tensorflow/lite/kernels/internal/quantization_util.h\"\n\n#if defined(__APPLE__)\n#include \"TargetConditionals.h\"\n#endif\n\nnamespace tflite {\n\nnamespace {\n\n// Assumes tensor_index is a valid index (in bounds)\ninline TfLiteTensor* GetTensorAtIndex(const TfLiteContext* context,\n                                      int tensor_index) {\n  if (context->tensors != nullptr) {\n    return &context->tensors[tensor_index];\n  } else {\n    return context->GetTensor(context, tensor_index);\n  }\n}\n\n// Validate in a single place to reduce binary size\ninline TfLiteStatus ValidateTensorIndexingSafe(const TfLiteContext* context,\n                                               int index, int max_size,\n                                               const int* tensor_indices,\n                                               int* tensor_index) {\n  if (index < 0 || index >= max_size) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Invalid tensor index %d (not in [0, %d))\\n\", index,\n                       max_size);\n    return kTfLiteError;\n  }\n  if (tensor_indices[index] == kTfLiteOptionalTensor) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Tensor at index %d was optional but was expected\\n\",\n                       index);\n    return kTfLiteError;\n  }\n\n  *tensor_index = tensor_indices[index];\n  return kTfLiteOk;\n}\n\n// Same as above but returns -1 for invalid inputs instead of status + logging\n// error.\ninline int ValidateTensorIndexing(const TfLiteContext* context, int index,\n                                  int max_size, const int* tensor_indices) {\n  if (index >= 0 && index < max_size) {\n    const int tensor_index = tensor_indices[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      return tensor_index;\n    }\n  }\n  return -1;\n}\n\ninline TfLiteTensor* GetMutableInput(const TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->inputs->size, node->inputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\ninline TfLiteStatus GetMutableInputSafe(const TfLiteContext* context,\n                                        const TfLiteNode* node, int index,\n                                        const TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->inputs->size,\n                                          node->inputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n\n}  // anonymous namespace.\n\nconst TfLiteTensor* GetInput(const TfLiteContext* context,\n                             const TfLiteNode* node, int index) {\n  return GetMutableInput(context, node, index);\n}\n\nTfLiteStatus GetInputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                          int index, const TfLiteTensor** tensor) {\n  return GetMutableInputSafe(context, node, index, tensor);\n}\n\nTfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                               int index) {\n  TfLiteTensor* tensor = GetMutableInput(context, node, index);\n  return tensor->is_variable ? tensor : nullptr;\n}\n\nTfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->outputs->size, node->outputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\nTfLiteStatus GetOutputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                           int index, TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->outputs->size,\n                                          node->outputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n\nconst TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  return GetInput(context, node, index);\n}\n\n#ifndef TF_LITE_STATIC_MEMORY\nTfLiteTensor* GetTemporary(TfLiteContext* context, const TfLiteNode* node,\n                           int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->temporaries->size, node->temporaries->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\nTfLiteStatus GetTemporarySafe(const TfLiteContext* context,\n                              const TfLiteNode* node, int index,\n                              TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->temporaries->size,\n                                 node->temporaries->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n\nconst TfLiteTensor* GetIntermediates(TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->intermediates->size, node->intermediates->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}\n\nTfLiteStatus GetIntermediatesSafe(const TfLiteContext* context,\n                                  const TfLiteNode* node, int index,\n                                  TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->intermediates->size,\n                                 node->intermediates->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}\n#endif  // TF_LITE_STATIC_MEMORY\n\n// Per-axis\nTfLiteStatus PopulateConvolutionQuantizationParams(\n    TfLiteContext* context, const TfLiteTensor* input,\n    const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* output,\n    const TfLiteFusedActivation& activation, int32_t* multiplier, int* shift,\n    int32_t* output_activation_min, int32_t* output_activation_max,\n    int32_t* per_channel_multiplier, int32_t* per_channel_shift) {\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n  return PopulateConvolutionQuantizationParams(\n      context, input, filter, bias, output, activation, multiplier, shift,\n      output_activation_min, output_activation_max, per_channel_multiplier,\n      per_channel_shift, affine_quantization->scale->size);\n}\n\n// Per-axis & per-tensor\nTfLiteStatus PopulateConvolutionQuantizationParams(\n    TfLiteContext* context, const TfLiteTensor* input,\n    const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* output,\n    const TfLiteFusedActivation& activation, int32_t* multiplier, int* shift,\n    int32_t* output_activation_min, int32_t* output_activation_max,\n    int32_t* per_channel_multiplier, int32_t* per_channel_shift,\n    int num_channels) {\n  TF_LITE_ENSURE_EQ(context, input->quantization.type,\n                    kTfLiteAffineQuantization);\n  TF_LITE_ENSURE_EQ(context, filter->quantization.type,\n                    kTfLiteAffineQuantization);\n  // TODO(jianlijianli): Enable bias type check and bias scale == input scale\n  // * filter scale for each channel in affine quantization once bias\n  // quantization is properly populated.\n  // TF_LITE_ENSURE_EQ(context, bias->quantization.type,\n  // kTfLiteAffineQuantization);\n\n  // Check data type.\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n  TF_LITE_ENSURE(context, affine_quantization);\n  TF_LITE_ENSURE(context, affine_quantization->scale);\n  const bool is_per_channel = affine_quantization->scale->size > 1;\n  if (is_per_channel) {\n    //  Currently only Int8/Int16 is supported for per channel quantization.\n    TF_LITE_ENSURE(context,\n                   input->type == kTfLiteInt8 || input->type == kTfLiteInt16);\n    TF_LITE_ENSURE_EQ(context, filter->type, kTfLiteInt8);\n    TF_LITE_ENSURE_EQ(context, affine_quantization->scale->size, num_channels);\n    TF_LITE_ENSURE_EQ(\n        context, num_channels,\n        filter->dims->data[affine_quantization->quantized_dimension]);\n  }\n\n  // Populate multiplier and shift using affine quantization.\n  const float input_scale = input->params.scale;\n  const float output_scale = output->params.scale;\n  const float* filter_scales = affine_quantization->scale->data;\n  for (int i = 0; i < num_channels; ++i) {\n    // If per-tensor quantization parameter is specified, broadcast it along the\n    // quantization dimension (channels_out).\n    const float scale = is_per_channel ? filter_scales[i] : filter_scales[0];\n    const double filter_scale = static_cast<double>(scale);\n    const double effective_output_scale = static_cast<double>(input_scale) *\n                                          filter_scale /\n                                          static_cast<double>(output_scale);\n    int32_t significand;\n    int channel_shift;\n    QuantizeMultiplier(effective_output_scale, &significand, &channel_shift);\n    per_channel_multiplier[i] = significand;\n    per_channel_shift[i] = channel_shift;\n  }\n\n  // Populate scalar quantization parameters.\n  // This check on legacy quantization parameters is kept only for backward\n  // compatibility.\n  if (input->type == kTfLiteUInt8) {\n    // Check bias scale == input scale * filter scale.\n    double real_multiplier = 0.0;\n    TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(\n        context, input, filter, bias, output, &real_multiplier));\n    int exponent;\n\n    // Populate quantization parameters with multiplier and shift.\n    QuantizeMultiplier(real_multiplier, multiplier, &exponent);\n    *shift = -exponent;\n  }\n  if (input->type == kTfLiteInt8 || input->type == kTfLiteUInt8 ||\n      input->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, activation, output, output_activation_min,\n        output_activation_max));\n  }\n  return kTfLiteOk;\n}\n\nTfLiteStatus GetQuantizedConvolutionMultipler(TfLiteContext* context,\n                                              const TfLiteTensor* input,\n                                              const TfLiteTensor* filter,\n                                              const TfLiteTensor* bias,\n                                              TfLiteTensor* output,\n                                              double* multiplier) {\n  const double input_product_scale = static_cast<double>(input->params.scale) *\n                                     static_cast<double>(filter->params.scale);\n  // The following conditions must be guaranteed by the training pipeline.\n  if (bias) {\n    const double bias_scale = static_cast<double>(bias->params.scale);\n    // Here we're making sure the input_product_scale & bias_scale are about the\n    // same. Since we have:\n    // (output - output_zp) * output_scale =\n    // input_product_scale * input_product + bias * bias_scale ---- (0)\n    //\n    // (0) equals:\n    // (input_product + bias) * input_product_scale ----- (1)\n    //           +\n    // bias * (bias_scale - input_product_scale)   ------ (2)\n    //\n    // For the real kernel computation, we're doing (1), so we really need to\n    // make sure (2) has minimum impact on the output, so:\n    // bias * (bias_scale - input_product_scale) / output_scale should be\n    // a small number for an integer.\n    // Since normally bias should be within a small range.\n    // We should expect (bias_scale - input_product_scale) / output_scale to\n    // be a small number like 0.02.\n    const double scale_diff = std::abs(input_product_scale - bias_scale);\n    const double output_scale = static_cast<double>(output->params.scale);\n\n    TF_LITE_ENSURE(context, scale_diff / output_scale <= 0.02);\n  }\n  return GetQuantizedConvolutionMultipler(context, input, filter, output,\n                                          multiplier);\n}\n\nTfLiteStatus GetQuantizedConvolutionMultipler(TfLiteContext* context,\n                                              const TfLiteTensor* input,\n                                              const TfLiteTensor* filter,\n                                              TfLiteTensor* output,\n                                              double* multiplier) {\n  const double input_product_scale =\n      static_cast<double>(input->params.scale * filter->params.scale);\n  TF_LITE_ENSURE(context, input_product_scale >= 0);\n  *multiplier = input_product_scale / static_cast<double>(output->params.scale);\n\n  return kTfLiteOk;\n}\n\nnamespace {\n\ninline TfLiteStatus Quantize(TfLiteContext* context, float scale,\n                             int32_t zero_point, float f, int32_t& q) {\n  const float tmp = TfLiteRound(f / scale);\n  const bool no_integer_overflow_from_quantization =\n      (tmp >= static_cast<float>(std::numeric_limits<int32_t>::min()) &&\n       tmp <= static_cast<float>(std::numeric_limits<int32_t>::max()));\n  TF_LITE_ENSURE(context, no_integer_overflow_from_quantization);\n  q = zero_point + static_cast<int32_t>(tmp);\n  return kTfLiteOk;\n}\n\nTfLiteStatus CalculateActivationRangeQuantizedImpl(\n    TfLiteContext* context, TfLiteFusedActivation activation, int32_t qmin,\n    int32_t qmax, TfLiteTensor* output, int32_t* act_min, int32_t* act_max) {\n  const auto scale = output->params.scale;\n  const auto zero_point = output->params.zero_point;\n\n  int32_t tmp_q;\n  if (activation == kTfLiteActRelu) {\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 0.0, tmp_q));\n    *act_min = std::max(qmin, tmp_q);\n    *act_max = qmax;\n  } else if (activation == kTfLiteActRelu6) {\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 0.0, tmp_q));\n    *act_min = std::max(qmin, tmp_q);\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 6.0, tmp_q));\n    *act_max = std::min(qmax, tmp_q);\n  } else if (activation == kTfLiteActReluN1To1) {\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, -1.0, tmp_q));\n    *act_min = std::max(qmin, tmp_q);\n    TF_LITE_ENSURE_OK(context,\n                      Quantize(context, scale, zero_point, 1.0, tmp_q));\n    *act_max = std::min(qmax, tmp_q);\n  } else {\n    *act_min = qmin;\n    *act_max = qmax;\n  }\n  return kTfLiteOk;\n}\n}  // namespace\n\nTfLiteStatus CalculateActivationRangeQuantized(TfLiteContext* context,\n                                               TfLiteFusedActivation activation,\n                                               TfLiteTensor* output,\n                                               int32_t* act_min,\n                                               int32_t* act_max) {\n  int32_t qmin = 0;\n  int32_t qmax = 0;\n  if (output->type == kTfLiteUInt8) {\n    qmin = std::numeric_limits<uint8_t>::min();\n    qmax = std::numeric_limits<uint8_t>::max();\n  } else if (output->type == kTfLiteInt8) {\n    qmin = std::numeric_limits<int8_t>::min();\n    qmax = std::numeric_limits<int8_t>::max();\n  } else if (output->type == kTfLiteInt16) {\n    qmin = std::numeric_limits<int16_t>::min();\n    qmax = std::numeric_limits<int16_t>::max();\n  } else {\n    TF_LITE_ENSURE(context, false);\n  }\n\n  return CalculateActivationRangeQuantizedImpl(context, activation, qmin, qmax,\n                                               output, act_min, act_max);\n}\n\nbool HaveSameShapes(const TfLiteTensor* input1, const TfLiteTensor* input2) {\n  return TfLiteIntArrayEqual(input1->dims, input2->dims);\n}\n\n#ifndef TF_LITE_STATIC_MEMORY\n\n// TODO(b/172067338): Having this function be part of TF_LITE_STATIC_MEMORY\n// build results in a 6KB size increase, even though the function is unsused for\n// that build. What appears to be happening is that while the linker drops the\n// unsused function, the string library that gets pulled in is not dropped,\n// resulting in the increased binary size.\nstd::string GetShapeDebugString(const TfLiteIntArray* shape) {\n  std::string str;\n  for (int d = 0; d < shape->size; ++d) {\n    if (str.empty())\n      str = \"[\" + std::to_string(shape->data[d]);\n    else\n      str += \", \" + std::to_string(shape->data[d]);\n  }\n  str += \"]\";\n  return str;\n}\n\nTfLiteStatus CalculateShapeForBroadcast(TfLiteContext* context,\n                                        const TfLiteTensor* input1,\n                                        const TfLiteTensor* input2,\n                                        TfLiteIntArray** output_shape) {\n  const int dims1 = NumDimensions(input1);\n  const int dims2 = NumDimensions(input2);\n  const int out_dims = std::max(dims1, dims2);\n\n  std::unique_ptr<TfLiteIntArray, void (*)(TfLiteIntArray*)> shape(\n      TfLiteIntArrayCreate(out_dims), TfLiteIntArrayFree);\n  for (int i = 0; i < out_dims; ++i) {\n    const int d1 = i >= dims1 ? 1 : SizeOfDimension(input1, dims1 - i - 1);\n    const int d2 = i >= dims2 ? 1 : SizeOfDimension(input2, dims2 - i - 1);\n    if (!(d1 == d2 || d1 == 1 || d2 == 1)) {\n      context->ReportError(context,\n                           \"Given shapes, %s and %s, are not broadcastable.\",\n                           GetShapeDebugString(input1->dims).c_str(),\n                           GetShapeDebugString(input2->dims).c_str());\n      return kTfLiteError;\n    }\n\n    if (d1 == 0 || d2 == 0) {\n      shape->data[out_dims - i - 1] = 0;\n    } else {\n      shape->data[out_dims - i - 1] = std::max(d1, d2);\n    }\n  }\n  *output_shape = shape.release();\n  return kTfLiteOk;\n}\n\nTfLiteStatus CalculateShapeForBroadcast(TfLiteContext* context,\n                                        const TfLiteTensor* input1,\n                                        const TfLiteTensor* input2,\n                                        const TfLiteTensor* input3,\n                                        TfLiteIntArray** output_shape) {\n  const int dims1 = NumDimensions(input1);\n  const int dims2 = NumDimensions(input2);\n  const int dims3 = NumDimensions(input3);\n  const int out_dims = std::max(std::max(dims1, dims2), dims3);\n  std::unique_ptr<TfLiteIntArray, void (*)(TfLiteIntArray*)> shape(\n      TfLiteIntArrayCreate(out_dims), TfLiteIntArrayFree);\n  for (int i = 0; i < out_dims; ++i) {\n    const int d1 = i >= dims1 ? 1 : SizeOfDimension(input1, dims1 - i - 1);\n    const int d2 = i >= dims2 ? 1 : SizeOfDimension(input2, dims2 - i - 1);\n    const int d3 = i >= dims3 ? 1 : SizeOfDimension(input3, dims3 - i - 1);\n    const int min_value = std::min(std::min(d1, d2), d3);\n    int max_value = std::max(std::max(d1, d2), d3);\n    // If one dimention is 0, others must be 0 or 1.\n    if (min_value == 0) max_value = 0;\n    if (!(d1 == 1 || d1 == max_value) || !(d2 == 1 || d2 == max_value) ||\n        !(d3 == 1 || d3 == max_value)) {\n      context->ReportError(\n          context, \"Given shapes, %s, %s and %s, are not broadcastable.\",\n          GetShapeDebugString(input1->dims).c_str(),\n          GetShapeDebugString(input2->dims).c_str(),\n          GetShapeDebugString(input3->dims).c_str());\n      return kTfLiteError;\n    }\n    shape->data[out_dims - i - 1] = max_value;\n  }\n  *output_shape = shape.release();\n  return kTfLiteOk;\n}\n#endif  // TF_LITE_STATIC_MEMORY\n\n// Size of string is not constant, return 0 in such case.\nint TfLiteTypeGetSize(TfLiteType type) {\n  switch (type) {\n    case kTfLiteUInt8:\n      static_assert(sizeof(uint8_t) == 1, \"\");\n      return 1;\n    case kTfLiteInt8:\n      static_assert(sizeof(int8_t) == 1, \"\");\n      return 1;\n    case kTfLiteBool:\n      return sizeof(bool);\n    case kTfLiteInt16:\n      static_assert(sizeof(int16_t) == 2, \"\");\n      return 2;\n    case kTfLiteFloat16:\n      static_assert(sizeof(int16_t) == 2, \"\");\n      return 2;\n    case kTfLiteFloat32:\n      static_assert(sizeof(float) == 4, \"\");\n      return 4;\n    case kTfLiteInt32:\n      static_assert(sizeof(int32_t) == 4, \"\");\n      return 4;\n    case kTfLiteUInt32:\n      static_assert(sizeof(uint32_t) == 4, \"\");\n      return 4;\n    case kTfLiteInt64:\n      static_assert(sizeof(int64_t) == 8, \"\");\n      return 8;\n    case kTfLiteUInt64:\n      static_assert(sizeof(uint64_t) == 8, \"\");\n      return 8;\n    case kTfLiteFloat64:\n      static_assert(sizeof(double) == 8, \"\");\n      return 8;\n    case kTfLiteComplex64:\n      static_assert(sizeof(std::complex<float>) == 8, \"\");\n      return 8;\n    case kTfLiteComplex128:\n      static_assert(sizeof(std::complex<double>) == 16, \"\");\n      return 16;\n    default:\n      return 0;\n  }\n}\n\nbool IsMobilePlatform() {\n#if defined(ANDROID) || defined(__ANDROID__)\n  return true;\n#elif defined(__APPLE__)\n#if TARGET_IPHONE_SIMULATOR || TARGET_OS_IPHONE\n  return true;\n#endif\n#endif\n  return false;\n}\n\n}  // namespace tflite"