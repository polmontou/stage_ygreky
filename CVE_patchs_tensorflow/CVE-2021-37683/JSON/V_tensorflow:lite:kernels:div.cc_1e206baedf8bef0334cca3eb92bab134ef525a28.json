"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include <stddef.h>\n#include <stdint.h>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/compatibility.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/cpu_check.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/neon_check.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/kernels/internal/quantization_util.h\"\n#include \"tensorflow/lite/kernels/internal/reference/process_broadcast_shapes.h\"\n#include \"tensorflow/lite/kernels/internal/reference/reference_ops.h\"\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/types.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\nnamespace div {\n\n// This file has three implementation of Div.\nenum KernelType {\n  kReference,\n  kGenericOptimized,  // Neon-free\n  kNeonOptimized,\n};\n\nconstexpr int kInputTensor1 = 0;\nconstexpr int kInputTensor2 = 1;\nconstexpr int kOutputTensor = 0;\n\nstruct OpData {\n  bool requires_broadcast;\n\n  // Parameters used in the quantized paths where the output is 8bit\n  int32 output_activation_min;\n  int32 output_activation_max;\n\n  // Parameters used in all quantized paths\n  int32_t output_multiplier;\n  int output_shift;\n};\n\nvoid* Init(TfLiteContext* context, const char* buffer, size_t length) {\n  auto* data = new OpData;\n  data->requires_broadcast = false;\n  return data;\n}\n\nvoid Free(TfLiteContext* context, void* buffer) {\n  delete reinterpret_cast<OpData*>(buffer);\n}\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  output->type = input2->type;\n\n  data->requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (data->requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {\n    output_size = TfLiteIntArrayCopy(input1->dims);\n  }\n\n  if (output->type == kTfLiteUInt8) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n    const double real_multiplier =\n        input1->params.scale / (input2->params.scale * output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->output_multiplier,\n                       &data->output_shift);\n  }\n\n  return context->ResizeTensor(context, output, output_size);\n}\n\ntemplate <KernelType kernel_type>\nvoid EvalDiv(TfLiteContext* context, TfLiteNode* node, TfLiteDivParams* params,\n             const OpData* data, const TfLiteTensor* input1,\n             const TfLiteTensor* input2, TfLiteTensor* output) {\n#define TF_LITE_DIV(type, opname, data_type)                             \\\n  tflite::ArithmeticParams op_params;                                    \\\n  data_type output_activation_min, output_activation_max;                \\\n  CalculateActivationRange(params->activation, &output_activation_min,   \\\n                           &output_activation_max);                      \\\n  SetActivationParams(output_activation_min, output_activation_max,      \\\n                      &op_params);                                       \\\n  type::opname(op_params, GetTensorShape(input1),                        \\\n               GetTensorData<data_type>(input1), GetTensorShape(input2), \\\n               GetTensorData<data_type>(input2), GetTensorShape(output), \\\n               GetTensorData<data_type>(output))\n  if (output->type == kTfLiteInt32) {\n    if (kernel_type == kReference) {\n      if (data->requires_broadcast) {\n        TF_LITE_DIV(reference_ops, BroadcastDivSlow, int32_t);\n      } else {\n        TF_LITE_DIV(reference_ops, Div, int32_t);\n      }\n    } else {\n      if (data->requires_broadcast) {\n        TF_LITE_DIV(optimized_ops, BroadcastDivSlow, int32_t);\n      } else {\n        TF_LITE_DIV(optimized_ops, Div, int32_t);\n      }\n    }\n  } else if (output->type == kTfLiteFloat32) {\n    if (kernel_type == kReference) {\n      if (data->requires_broadcast) {\n        TF_LITE_DIV(reference_ops, BroadcastDivSlow, float);\n      } else {\n        TF_LITE_DIV(reference_ops, Div, float);\n      }\n    } else {\n      if (data->requires_broadcast) {\n        TF_LITE_DIV(optimized_ops, BroadcastDivSlow, float);\n      } else {\n        TF_LITE_DIV(optimized_ops, Div, float);\n      }\n    }\n  }\n#undef TF_LITE_DIV\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           TfLiteDivParams* params, const OpData* data,\n                           const TfLiteTensor* input1,\n                           const TfLiteTensor* input2, TfLiteTensor* output) {\n  if (input1->type == kTfLiteUInt8 && input2->type == kTfLiteUInt8 &&\n      output->type == kTfLiteUInt8) {\n    tflite::ArithmeticParams op_params;\n    SetActivationParams(data->output_activation_min,\n                        data->output_activation_max, &op_params);\n    op_params.input1_offset = -input1->params.zero_point;\n    op_params.input2_offset = -input2->params.zero_point;\n    op_params.output_offset = output->params.zero_point;\n    op_params.output_multiplier = data->output_multiplier;\n    op_params.output_shift = data->output_shift;\n    bool need_broadcast = optimized_ops::ProcessBroadcastShapes(\n        GetTensorShape(input1), GetTensorShape(input2), &op_params);\n#define TF_LITE_DIV(type, opname, dtype)                             \\\n  type::opname(op_params, GetTensorShape(input1),                    \\\n               GetTensorData<dtype>(input1), GetTensorShape(input2), \\\n               GetTensorData<dtype>(input2), GetTensorShape(output), \\\n               GetTensorData<dtype>(output))\n    if (kernel_type == kReference) {\n      if (need_broadcast) {\n        TF_LITE_DIV(reference_ops, BroadcastDivSlow, uint8_t);\n      } else {\n        TF_LITE_DIV(reference_ops, Div, uint8_t);\n      }\n    } else {\n      if (need_broadcast) {\n        TF_LITE_DIV(optimized_ops, BroadcastDivSlow, uint8_t);\n      } else {\n        TF_LITE_DIV(optimized_ops, Div, uint8_t);\n      }\n    }\n#undef TF_LITE_DIV\n  } else {\n    context->ReportError(\n        context, \"Unsupported combination of input and output types in Div.\");\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}\n\ntemplate <KernelType kernel_type>\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}\n\n}  // namespace div\n\nTfLiteRegistration* Register_DIV_REF() {\n  static TfLiteRegistration r = {div::Init, div::Free, div::Prepare,\n                                 div::Eval<div::kReference>};\n  return &r;\n}\n\nTfLiteRegistration* Register_DIV_GENERIC_OPT() {\n  static TfLiteRegistration r = {div::Init, div::Free, div::Prepare,\n                                 div::Eval<div::kGenericOptimized>};\n  return &r;\n}\n\nTfLiteRegistration* Register_DIV_NEON_OPT() {\n  static TfLiteRegistration r = {div::Init, div::Free, div::Prepare,\n                                 div::Eval<div::kNeonOptimized>};\n  return &r;\n}\n\nTfLiteRegistration* Register_DIV() {\n#ifdef USE_NEON\n  return Register_DIV_NEON_OPT();\n#else\n  return Register_DIV_GENERIC_OPT();\n#endif\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite"