"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/core/common_runtime/shape_refiner.h\"\n\n#include <deque>\n#include <memory>\n#include <unordered_set>\n#include <vector>\n\n#include \"tensorflow/core/common_runtime/eval_const_tensor.h\"\n#include \"tensorflow/core/common_runtime/function_utils.h\"\n#include \"tensorflow/core/common_runtime/graph_constructor.h\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/node_def.pb.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor.pb.h\"\n#include \"tensorflow/core/framework/versions.pb.h\"\n#include \"tensorflow/core/graph/algorithm.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n\nnamespace tensorflow {\n\nusing shape_inference::DimensionHandle;\nusing shape_inference::InferenceContext;\nusing shape_inference::ShapeAndType;\nusing shape_inference::ShapeHandle;\n\nShapeRefiner::ShapeRefiner(int graph_def_version,\n                           const OpRegistryInterface* ops)\n    : graph_def_version_(graph_def_version),\n      ops_registry_(ops),\n      graph_runner_(Env::Default()) {}\n\nShapeRefiner::ShapeRefiner(const VersionDef& versions,\n                           const OpRegistryInterface* ops)\n    : ShapeRefiner(versions.producer(), ops) {}\n\nShapeRefiner::~ShapeRefiner() {\n  // The lifetime of the tensors are bound to the GraphRunner, so the tensors\n  // should be deleted before it.\n  const_tensor_map_.clear();\n}\n\nnamespace {\n\nconstexpr char kArgOp[] = \"_Arg\";\nconstexpr char kRetvalOp[] = \"_Retval\";\n\n}  // namespace\n\n// Runs shape inference for the given node using the given ShapeRefiner.\n// The node must be a sub-node of a function node and the outer_context is\n// the inference context of that function node in the outer graph.\nStatus ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n\n  if (StringPiece(node->type_string()) == kArgOp) {\n    // Handle special node: function input.\n    // Shapes for these nodes are provided in the outer inference\n    // context.\n\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n\n    // TODO(b/134547156): TEMPORARY WORKAROUND. If input shape handle is not set\n    // in outer context, set _Arg node output shape to unknown.\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    // Handle special node: function output.\n    // Shapes inferred for these nodes go into the outer inference\n    // context.\n\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n\n    // outer_context outlives node_context, therefore we need to create\n    // a new shape handle owned by outer_context instead.\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n\n    auto* resource = node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      outer_context->set_output_handle_shapes_and_types(index, *resource);\n    }\n  }\n\n  return Status::OK();\n}\n\n// TODO(cwhipkey): When an inference context inside function has\n// requested_input_tensor(i) or requested_input_tensor_as_partial_shape(i)\n// set when input(i) is an _Arg op, then this request should propagate to\n// context, and vice versa.\n//\n// NOTE: Recursive user-defined functions are not supported.\n// Maybe we won't support recursive functions at all in TF, because of\n// other maintainability issues.\nStatus ShapeRefiner::InferShapesForFunction(\n    const FunctionDef* function_def, AttrSlice attributes,\n    ExtendedInferenceContext* outer_context) {\n  const Graph* graph;\n  auto it = functions_.find(function_def);\n  if (it != functions_.end()) {\n    graph = it->second.get();\n  } else {\n    InstantiationResult result;\n    TF_RETURN_IF_ERROR(InstantiateFunction(\n        *function_def, attributes,\n        [this](const string& op, const OpDef** sig) {\n          return this->function_library_->LookUpOpDef(op, sig);\n        },\n        &result));\n\n    Graph* new_graph = new Graph(function_library_);\n    GraphConstructorOptions options;\n    options.allow_internal_ops = true;\n    TF_RETURN_IF_ERROR(\n        ConvertNodeDefsToGraph(options, result.nodes, new_graph));\n    functions_[function_def].reset(new_graph);\n    graph = new_graph;\n  }\n\n  std::unordered_set<const Node*> function_nodes;\n  Status inference_status = Status::OK();\n  {\n    auto node_shape_inference_lambda = [this, &outer_context, &function_nodes,\n                                        &inference_status](const Node* node) {\n      if (!inference_status.ok()) return;\n      inference_status =\n          InferShapesForFunctionSubNode(node, outer_context->get_context());\n      function_nodes.insert(node);\n    };\n\n    // Calls inference lambda for each node after visiting all predecessors.\n    // Ensures that we are adding nodes to ShapeRefiner in the topological\n    // order.\n    ReverseDFS(*graph, {}, node_shape_inference_lambda);\n  }\n\n  // Delete the contexts created for the functions nodes to save memory.\n  for (const Node* node : function_nodes) {\n    node_to_context_.erase(node);\n  }\n\n  return inference_status;\n}\n\nStatus ShapeRefiner::AddNode(const Node* node) {\n  return AddNodeInternal(node, /*outer_context=*/nullptr);\n}\n\nStatus ShapeRefiner::AddNodeInternal(\n    const Node* node, shape_inference::InferenceContext* outer_context) {\n  // Create the inference context for this node with the existing input shapes.\n  std::unique_ptr<InferenceContext> ic(new InferenceContext(\n      graph_def_version_, node->def(), node->op_def(),\n      std::vector<ShapeHandle>(node->num_inputs()), {}, {}, {}));\n  TF_RETURN_IF_ERROR(ic->construction_status());\n\n  // For each 'input' of this node, fetch the corresponding shape\n  // from 'input's InferenceContext, and store into this node's\n  // InferenceContext.\n  for (const Edge* e : node->in_edges()) {\n    if (e->IsControlEdge()) continue;\n\n    if (e->dst_input() < 0) {\n      return tensorflow::errors::Internal(\n          \"Index \", e->dst_input(), \" is negative but not a control edge.\");\n    }\n\n    const Node* input = e->src();\n    auto it = node_to_context_.find(input);\n    if (it == node_to_context_.end()) {\n      // v1 control flow adds loops to the graph; we have to break them\n      // somewhere, so we'll ignore this input and leave its shape undefined.\n      ic->SetInput(e->dst_input(), ic->UnknownShape());\n      continue;\n    }\n\n    InferenceContext* input_ic = it->second->get_context();\n    ic->SetInput(e->dst_input(), input_ic->output(e->src_output()));\n\n    const auto* in_v =\n        input_ic->output_handle_shapes_and_types(e->src_output());\n    if (in_v != nullptr) {\n      DataType input_type = e->src()->output_type(e->src_output());\n      DCHECK(input_type == DT_RESOURCE || input_type == DT_VARIANT);\n      ic->set_input_handle_shapes_and_types(e->dst_input(),\n                                            std::vector<ShapeAndType>(*in_v));\n    }\n  }\n\n  // Get the shape function for this node\n  const OpRegistrationData* op_reg_data;\n  TF_RETURN_IF_ERROR(ops_registry_->LookUp(node->type_string(), &op_reg_data));\n  if (op_reg_data->shape_inference_fn == nullptr &&\n      require_shape_inference_fns_) {\n    return errors::InvalidArgument(\n        \"No shape inference function exists for op '\", node->type_string(),\n        \"', did you forget to define it?\");\n  }\n\n  std::unique_ptr<ExtendedInferenceContext> ec(\n      new ExtendedInferenceContext(std::move(ic), node));\n\n  // Run the shape inference function, and return if there was an error.\n  TF_RETURN_IF_ERROR(RunShapeFn(node, op_reg_data, ec.get(), outer_context));\n\n  // Store the resulting context object in the map.\n  node_to_context_[node].swap(ec);\n\n  return Status::OK();\n}\n\nStatus ShapeRefiner::SetShape(const Node* node, int output_port,\n                              ShapeHandle shape) {\n  auto c = GetContext(node);\n  if (c == nullptr) {\n    return errors::Internal(\"Could not find context for \", node->name());\n  }\n\n  if (output_port < 0 || output_port >= node->num_outputs()) {\n    return errors::InvalidArgument(\n        \"output_port '\", output_port, \"' is out of range, \", \"node '\",\n        node->name(), \"' has \", node->num_outputs(), \" outputs\");\n  }\n  // Note: it's possible, if the node's been updated, that the shape inference\n  // context doesn't have the right number of outputs.\n  if (node->num_outputs() > c->num_outputs()) {\n    TF_RETURN_IF_ERROR(c->ExpandOutputs(node->num_outputs()));\n  }\n\n  // Check compatibility, and merge the shapes.\n  ShapeHandle existing_shape = c->output(output_port);\n  TF_RETURN_IF_ERROR(c->Merge(existing_shape, shape, &shape));\n  c->set_output(output_port, shape);\n\n  // TODO(vrv): Do we need to propagate the new shape through all\n  // consumers that change their outputs?  At the moment, python\n  // does not do this, but this seems like a nice feature.\n\n  // TODO(vrv): We might need to keep track of the fact that the\n  // existing shape is invalidated, in case we need to propagate\n  // this information to remote workers.\n  return Status::OK();\n}\n\nStatus ShapeRefiner::UpdateNode(const Node* node, bool relax, bool* refined) {\n  auto it = node_to_context_.find(node);\n  if (it == node_to_context_.end()) {\n    *refined = true;\n    return AddNode(node);\n  }\n  ExtendedInferenceContext* node_ext_context = it->second.get();\n  InferenceContext* node_context = node_ext_context->get_context();\n\n  // Give up if the context wasn't successfully built by the AddNode() method.\n  TF_RETURN_IF_ERROR(node_context->construction_status());\n\n  // Check if the shapes of the nodes in the fan-in of this node have changed,\n  // and if they have update the node input shapes.\n  for (const Edge* e : node->in_edges()) {\n    if (e->IsControlEdge()) continue;\n\n    int dst_input = e->dst_input();\n    int src_output = e->src_output();\n\n    Node* input = e->src();\n    auto iter = node_to_context_.find(input);\n    if (iter == node_to_context_.end()) {\n      return errors::FailedPrecondition(\n          \"Input \", dst_input, \" ('\", input->name(), \"') for '\", node->name(),\n          \"' was not previously added to ShapeRefiner.\");\n    }\n\n    InferenceContext* c = iter->second->get_context();\n    DCHECK_GE(dst_input, 0);\n    ShapeHandle existing_input = node_context->input(dst_input);\n    if (!relax) {\n      if (node_context->MergeInput(dst_input, c->output(src_output))) {\n        if (!SameDefinedShape(node_context, node_context->input(dst_input),\n                              existing_input)) {\n          *refined = true;\n        }\n      }\n    } else {\n      if (node_context->RelaxInput(dst_input, c->output(src_output))) {\n        if (!SameDefinedShape(node_context, node_context->input(dst_input),\n                              existing_input)) {\n          *refined = true;\n        }\n      }\n    }\n    if (node_context->requested_input_tensor_as_partial_shape(dst_input)) {\n      // The input value may have changed. Since we have no way to know if\n      // that's indeed the case, err on the safe side.\n      *refined = true;\n    }\n\n    // Also propagate handle shape and dtype of edges which are carrying\n    // resource handles.\n    if (e->src()->output_type(src_output) == DT_RESOURCE) {\n      auto* outputs = c->output_handle_shapes_and_types(src_output);\n      if (!outputs) continue;\n\n      if (!relax &&\n          node_context->MergeInputHandleShapesAndTypes(dst_input, *outputs)) {\n        *refined = true;\n      } else if (relax) {\n        std::vector<ShapeAndType> existing_inputs;\n        const std::vector<ShapeAndType>* inputs =\n            node_context->input_handle_shapes_and_types(dst_input);\n        if (inputs) {\n          existing_inputs = *inputs;\n        }\n        if (node_context->RelaxInputHandleShapesAndMergeTypes(dst_input,\n                                                              *outputs)) {\n          if (IsUpdatedShapesOrTypes(\n                  node_context, existing_inputs,\n                  *node_context->input_handle_shapes_and_types(dst_input))) {\n            *refined = true;\n          }\n        }\n      }\n    }\n  }\n\n  if (!*refined) {\n    // No input shape has changed, we're done\n    return Status::OK();\n  }\n\n  // Get and run the shape function for this node to update the shapes of the\n  // outputs.\n  const OpRegistrationData* op_reg_data;\n  TF_RETURN_IF_ERROR(ops_registry_->LookUp(node->type_string(), &op_reg_data));\n  if (op_reg_data->shape_inference_fn == nullptr &&\n      require_shape_inference_fns_) {\n    return errors::InvalidArgument(\n        \"No shape inference function exists for op '\", node->type_string(),\n        \"', did you forget to define it?\");\n  }\n\n  if (!op_reg_data->shape_inference_fn) {\n    // There is nothing more we can infer\n    return Status::OK();\n  }\n\n  return RunShapeFn(node, op_reg_data, node_ext_context);\n}\n\nStatus ShapeRefiner::EvaluateConstantTensorForEdge(\n    const Node* node, int dst_idx, bool* evaluated, Tensor* result,\n    InferenceContext* outer_context) {\n  *evaluated = false;\n  const Edge* input_edge;\n  TF_RETURN_IF_ERROR(node->input_edge(dst_idx, &input_edge));\n  OutputTensor tensor(input_edge->src(), input_edge->src_output());\n  return EvaluateConstantTensor(\n      tensor, *this, *ops_registry_, graph_def_version_, evaluated, result,\n      &graph_runner_, &const_tensor_map_, kMaxTensorSize,\n      disable_constant_propagation_, outer_context);\n}\n\nStatus ShapeRefiner::EvaluateConstantIntScalarEdge(\n    const Node* node, int dst_idx, bool* evaluated, int64* result,\n    shape_inference::InferenceContext* outer_context) {\n  Tensor scalar;\n  TF_RETURN_IF_ERROR(EvaluateConstantTensorForEdge(node, dst_idx, evaluated,\n                                                   &scalar, outer_context));\n  if (*evaluated) {\n    if (scalar.NumElements() != 1) {\n      return errors::InvalidArgument(\n          \"EvaluateConstantIntScalarEdge called on non-scalar edge: \",\n          scalar.NumElements());\n    }\n    if (scalar.dtype() == DT_INT32) {\n      *result = scalar.scalar<int32>()();\n    } else {\n      if (scalar.dtype() != DT_INT64) {\n        return errors::InvalidArgument(\n            \"EvaluateConstantIntScalarEdge called on non-integer edge: \",\n            scalar.dtype());\n      }\n      *result = scalar.scalar<int64>()();\n    }\n  }\n  return Status::OK();\n}\n\nStatus ShapeRefiner::ConstantPartialShape(\n    InferenceContext* target_context, const Node* node, int dst_idx,\n    ShapeHandle* result, shape_inference::InferenceContext* outer_context) {\n  const Edge* input_edge;\n  TF_RETURN_IF_ERROR(node->input_edge(dst_idx, &input_edge));\n\n  InferenceContext* src_context = GetContext(input_edge->src());\n  if (src_context == nullptr) return errors::Internal(\"Missing src context\");\n  ShapeHandle src_shape = src_context->output(input_edge->src_output());\n\n  if (src_context->Value(src_context->Rank(src_shape)) == 0) {\n    Tensor t;\n    bool evaluated = false;\n    TF_RETURN_IF_ERROR(EvaluateConstantTensorForEdge(node, dst_idx, &evaluated,\n                                                     &t, outer_context));\n    if (!evaluated) {\n      return errors::InvalidArgument(\n          \"Received a shape scalar with unknown static value.  A static value \"\n          \"of '-1' is required to represent an unknown shape.\");\n    }\n    if (t.dims() == 0) {\n      if (t.dtype() == DT_INT32 && t.scalar<int32>()() == -1) {\n        *result = target_context->UnknownShape();\n        return Status::OK();\n      } else if (t.dtype() == DT_INT64 && t.scalar<int64>()() == -1) {\n        *result = target_context->UnknownShape();\n        return Status::OK();\n      }\n    }\n    return errors::InvalidArgument(\n        \"Received an invalid shape scalar with a static value that is not \"\n        \"'-1': \",\n        t.DebugString());\n  }\n\n  TF_RETURN_IF_ERROR(src_context->WithRank(src_shape, 1, &src_shape));\n\n  const string& src_op = input_edge->src()->type_string();\n  if (src_context->Value(src_context->Dim(src_shape, 0)) == 0) {\n    // Source tensor is a vector of length 0, so the shape it\n    // represents is as scalar.\n    *result = target_context->Scalar();\n  } else if (src_op == \"Cast\") {\n    // First try to evaluate the current tensor, as it might be a valid cast of\n    // a float.\n    Tensor t;\n    bool evaluated = false;\n    if (EvaluateConstantTensorForEdge(node, dst_idx, &evaluated, &t,\n                                      outer_context)\n            .ok()) {\n      if (evaluated &&\n          target_context->MakeShapeFromTensor(&t, src_shape, result).ok()) {\n        return Status::OK();\n      }\n    }\n\n    // Then try to infer partial shape from the input to the cast tensor.\n    ShapeHandle pre_cast_shape;\n    if (!ConstantPartialShape(target_context, input_edge->src(), 0,\n                              &pre_cast_shape, outer_context)\n             .ok()) {\n      TF_RETURN_IF_ERROR(\n          target_context->MakeShapeFromTensor(nullptr, src_shape, result));\n    }\n    if (!target_context->RankKnown(pre_cast_shape)) {\n      // Failed to evaluate. Treat the output as completely unknown.\n      *result = target_context->UnknownShape();\n      return Status::OK();\n    }\n    auto* dest_type = input_edge->src()->attrs().Find(\"DstT\");\n    if (dest_type == nullptr || dest_type->value_case() != AttrValue::kType ||\n        (dest_type->type() != DT_INT32 && dest_type->type() != DT_INT64)) {\n      // Casting to a weird type. Do not attempt to infer across it.\n      *result = target_context->MakeShape(std::vector<DimensionHandle>(\n          target_context->Rank(pre_cast_shape), target_context->UnknownDim()));\n      return Status::OK();\n    }\n    *result = pre_cast_shape;\n  } else if (src_op == \"Shape\") {\n    *result = src_context->input(0);\n  } else if (src_op == \"ShapeN\") {\n    *result = src_context->input(input_edge->src_output());\n  } else if (src_op == \"Pack\") {\n    std::vector<DimensionHandle> dims;\n    // Pack is concatenating its input scalars to form the shape tensor vector.\n    for (int i = 0; i < src_context->num_inputs(); ++i) {\n      int64 size;\n      bool evaluated;\n      TF_RETURN_IF_ERROR(EvaluateConstantIntScalarEdge(\n          input_edge->src(), i, &evaluated, &size, outer_context));\n      if (evaluated) {\n        dims.push_back(size < 0 ? target_context->UnknownDim()\n                                : target_context->MakeDim(size));\n      } else {\n        dims.push_back(target_context->UnknownDim());\n      }\n    }\n    *result = target_context->MakeShape(dims);\n  } else if (src_op == \"Concat\" || src_op == \"ConcatV2\") {\n    *result = target_context->Scalar();\n    // For Concat, input 0 is concat dim; for V2 it is the last input.\n    const int concat_dim =\n        src_op == \"Concat\" ? 0 : src_context->num_inputs() - 1;\n    // Concat is concatenating its input shape vectors.\n    for (int i = 0; i < src_context->num_inputs(); ++i) {\n      // Concat dim is ignored (and will always be a scalar).\n      if (i == concat_dim) continue;\n      ShapeHandle sub_result;\n      TF_RETURN_IF_ERROR(ConstantPartialShape(target_context, input_edge->src(),\n                                              i, &sub_result, outer_context));\n      if (!target_context->RankKnown(sub_result)) {\n        // Failed to evaluate. Treat the output as completely unknown.\n        // TODO(cwhipkey): we could rely on all inputs being the same rank, so\n        // figure that rank out and append the right number of unknown dims.\n        *result = target_context->UnknownShape();\n        return Status::OK();\n      }\n      TF_RETURN_IF_ERROR(\n          target_context->Concatenate(*result, sub_result, result));\n    }\n  } else if (src_op == \"StridedSlice\") {\n    TF_RETURN_IF_ERROR(PartialStridedSliceShape(input_edge->src(), src_context,\n                                                result, outer_context));\n  } else if (src_op == \"VariableShape\") {\n    auto* handle_data = src_context->input_handle_shapes_and_types(0);\n    if (handle_data != nullptr && !handle_data->empty()) {\n      *result = handle_data->at(0).shape;\n    } else {\n      *result = target_context->UnknownShape();\n    }\n  } else {\n    Tensor t;\n    bool evaluated = false;\n    TF_RETURN_IF_ERROR(EvaluateConstantTensorForEdge(node, dst_idx, &evaluated,\n                                                     &t, outer_context));\n    TF_RETURN_IF_ERROR(target_context->MakeShapeFromTensor(\n        evaluated ? &t : nullptr, src_shape, result));\n  }\n  return Status::OK();\n}\n\nStatus ShapeRefiner::PartialStridedSliceShape(\n    Node* slice_node, InferenceContext* ctx, ShapeHandle* result,\n    shape_inference::InferenceContext* outer_context) {\n  // Only attempt to evaluate if begin/end/strides all are scalars.\n  for (int i = 1; i <= 3; ++i) {\n    ShapeHandle input_shape = ctx->input(i);\n    if (ctx->Value(ctx->Dim(input_shape, 0)) != 1) {\n      *result = ctx->UnknownShape();\n      return Status::OK();\n    }\n  }\n\n  int begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask;\n  TF_RETURN_IF_ERROR(\n      GetNodeAttr(slice_node->attrs(), \"begin_mask\", &begin_mask));\n  TF_RETURN_IF_ERROR(GetNodeAttr(slice_node->attrs(), \"end_mask\", &end_mask));\n  TF_RETURN_IF_ERROR(\n      GetNodeAttr(slice_node->attrs(), \"ellipsis_mask\", &ellipsis_mask));\n  TF_RETURN_IF_ERROR(\n      GetNodeAttr(slice_node->attrs(), \"new_axis_mask\", &new_axis_mask));\n  TF_RETURN_IF_ERROR(\n      GetNodeAttr(slice_node->attrs(), \"shrink_axis_mask\", &shrink_axis_mask));\n\n  // Only attempt to evaluate if there are no special masks set (note that we\n  // can handle begin/end_mask == 1).\n  if (!(begin_mask == 0 || begin_mask == 1) ||\n      !(end_mask == 0 || end_mask == 1) || ellipsis_mask != 0 ||\n      new_axis_mask != 0 || shrink_axis_mask != 0) {\n    *result = ctx->UnknownShape();\n    return Status::OK();\n  }\n\n  bool evaluated;\n  int64 begin;\n  if (begin_mask == 1) {\n    begin = 0;\n  } else {\n    TF_RETURN_IF_ERROR(EvaluateConstantIntScalarEdge(slice_node, 1, &evaluated,\n                                                     &begin, outer_context));\n    if (!evaluated) {\n      *result = ctx->UnknownShape();\n      return Status::OK();\n    }\n  }\n\n  int64 end;\n  if (end_mask == 1) {\n    end = std::numeric_limits<int64>::max();\n  } else {\n    TF_RETURN_IF_ERROR(EvaluateConstantIntScalarEdge(slice_node, 2, &evaluated,\n                                                     &end, outer_context));\n    if (!evaluated) {\n      *result = ctx->UnknownShape();\n      return Status::OK();\n    }\n  }\n\n  int64 stride;\n  TF_RETURN_IF_ERROR(EvaluateConstantIntScalarEdge(slice_node, 3, &evaluated,\n                                                   &stride, outer_context));\n  if (!evaluated) {\n    *result = ctx->UnknownShape();\n    return Status::OK();\n  }\n\n  // Apply stride to input interpreted as a partial shape.\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(\n      ConstantPartialShape(ctx, slice_node, 0, &input, outer_context));\n  TF_RETURN_IF_ERROR(ctx->Subshape(input, begin, end, stride, result));\n  return Status::OK();\n}\n\nStatus ShapeRefiner::RunShapeFn(const Node* node,\n                                const OpRegistrationData* op_reg_data,\n                                ExtendedInferenceContext* ec,\n                                InferenceContext* outer_context) {\n  // This will be filled in with real data in a second pass.\n  std::vector<const Tensor*> input_tensors(node->num_inputs(), nullptr);\n  std::vector<Tensor> real_tensors(node->num_inputs());\n  std::vector<bool> attempted_materialization(node->num_inputs());\n  std::vector<bool> attempted_tensor_as_shape_conversion(node->num_inputs());\n  std::vector<ShapeHandle> input_tensors_as_shapes;\n\n  auto* c = ec->get_context();\n\n  c->set_input_tensors(input_tensors);\n  c->set_input_tensors_as_shapes(input_tensors_as_shapes);\n\n  // Run the shape inference function, and return if there was an error.\n  // Capture as lambda, because we might need to re-run inference later on.\n  auto run_inference_lambda = [&]() {\n    if (function_library_ && IsFunctionCall(*function_library_, *node)) {\n      bool disable_shape_inference;\n      if (!GetNodeAttr(AttrSlice(node->def()), \"_disable_call_shape_inference\",\n                       &disable_shape_inference)\n               .ok() ||\n          !disable_shape_inference) {\n        // Special inference logic for user-defined functions.\n        NameAttrList function;\n        TF_RETURN_IF_ERROR(\n            NameAndAttrsFromFunctionCall(node->def(), &function));\n        const FunctionDef* function_def =\n            function_library_->Find(function.name());\n        if (function_def != nullptr) {\n          // The constant Tensor map we have for the outside context is not\n          // valid inside the function. We need to push a new clean map while\n          // performing inference on the function body.\n          auto const_tensor_map_copy = const_tensor_map_;\n          const_tensor_map_.clear();\n          Status function_inference_status = InferShapesForFunction(\n              function_def, AttrSlice(&function.attr()), ec);\n          const_tensor_map_ = const_tensor_map_copy;\n          return function_inference_status;\n        }\n      }\n    }\n\n    if (op_reg_data->shape_inference_fn) {\n      TF_RETURN_IF_ERROR(c->Run(op_reg_data->shape_inference_fn));\n    } else {\n      TF_RETURN_IF_ERROR(c->Run(shape_inference::UnknownShape));\n    }\n    return Status::OK();\n  };\n  TF_RETURN_IF_ERROR(run_inference_lambda());\n\n  // We must run the shape function repeatedly, in case users write\n  // shape functions where they only conditionally call input_tensor()\n  // based on the values of another input tensor.\n  bool rerun_shape_fn;\n  do {\n    // If the result of running shape inference would have benefitted\n    // from knowing the values of input tensors, try to materialize\n    // the results of those tensors, and then run the shape inference\n    // function again using those known tensors.\n    rerun_shape_fn = false;\n\n    // NOTE: It is possible to batch the extraction and\n    // materialization of inputs, instead of materializing one input\n    // at a time like we do below.  If input-at-a-time computation\n    // becomes a bottleneck, we could separate ExtractConstantSubgraph\n    // into two functions: one that returns true if an input is\n    // derivable from constants, and another function that extracts\n    // the subgraph for multiple target nodes and executes the whole\n    // subgraph once.\n\n    for (int i = 0; i < c->num_inputs(); ++i) {\n      if (!c->requested_input_tensor(i)) {\n        continue;\n      }\n      // Check if we have not already filled in the requested input,\n      // and if not, try to materialize the tensors.\n      if (!attempted_materialization[i]) {\n        attempted_materialization[i] = true;\n\n        Tensor result;\n        bool evaluated = false;\n        TF_RETURN_IF_ERROR(EvaluateConstantTensorForEdge(\n            node, i, &evaluated, &result, outer_context));\n        if (evaluated) {\n          real_tensors[i] = result;\n          input_tensors[i] = &real_tensors[i];\n          // We have more concrete information about a shape,\n          // so re-run shape inference.\n          rerun_shape_fn = true;\n        }\n      }\n      if (c->requested_input_tensor_as_partial_shape(i) &&\n          !attempted_tensor_as_shape_conversion[i]) {\n        attempted_tensor_as_shape_conversion[i] = true;\n        if (i >= input_tensors_as_shapes.size()) {\n          input_tensors_as_shapes.resize(i + 1);\n        }\n        ShapeHandle s;\n        TF_RETURN_IF_ERROR(ConstantPartialShape(c, node, i, &s, outer_context));\n        input_tensors_as_shapes[i] = s;\n        rerun_shape_fn = true;\n      }\n    }\n\n    if (rerun_shape_fn) {\n      // We have more information about the shapes on this pass,\n      // so re-run shape inference.\n      c->set_input_tensors(input_tensors);\n      c->set_input_tensors_as_shapes(input_tensors_as_shapes);\n      TF_RETURN_IF_ERROR(run_inference_lambda());\n    }\n  } while (rerun_shape_fn);\n\n  return Status::OK();\n}\n\nbool ShapeRefiner::SameDefinedShape(InferenceContext* c, ShapeHandle s0,\n                                    ShapeHandle s1) {\n  if (s0.SameHandle(s1)) {\n    return true;\n  }\n  if (c->Rank(s0) != c->Rank(s1)) {\n    return false;\n  }\n  if (!c->RankKnown(s0) && !c->RankKnown(s1)) {\n    return false;\n  }\n  for (int i = 0; i < c->Rank(s0); ++i) {\n    if (!c->Dim(s0, i).SameHandle(c->Dim(s1, i))) {\n      int64 val0 = c->Value(c->Dim(s0, i));\n      int64 val1 = c->Value(c->Dim(s1, i));\n      if (val0 < 0 || val1 < 0 || val0 != val1) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nbool ShapeRefiner::IsUpdatedShapesOrTypes(\n    InferenceContext* c, const std::vector<ShapeAndType>& existing,\n    const std::vector<ShapeAndType>& updated) {\n  if (existing.size() != updated.size()) {\n    return true;\n  }\n  for (int i = 0; i < existing.size(); i++) {\n    if (!SameDefinedShape(c, existing[i].shape, updated[i].shape) ||\n        existing[i].dtype != updated[i].dtype) {\n      return true;\n    }\n  }\n  return false;\n}\n\n}  // namespace tensorflow"