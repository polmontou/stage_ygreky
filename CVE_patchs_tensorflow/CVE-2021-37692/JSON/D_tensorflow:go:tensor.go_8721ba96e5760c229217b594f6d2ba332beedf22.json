"diff --git a/tensorflow/go/tensor.go b/tensorflow/go/tensor.go\nindex cfb389d472d..0983e0411f0 100644\n--- a/tensorflow/go/tensor.go\n+++ b/tensorflow/go/tensor.go\n@@ -98,9 +98,9 @@ func NewTensor(value interface{}) (*Tensor, error) {\n \n \traw := tensorData(t.c)\n \n-\truntime.SetFinalizer(t, func(t *Tensor) {\n+\tdefer runtime.SetFinalizer(t, func(t *Tensor) {\n \t\tif dataType == String {\n-\t\t\tt.clearTStrings(raw, nflattened)\n+\t\t\tt.clearTStrings(raw, int64(nbytes/C.sizeof_TF_TString))\n \t\t}\n \n \t\tt.finalize()\n@@ -111,7 +111,7 @@ func NewTensor(value interface{}) (*Tensor, error) {\n \tif isAllArray(val.Type()) {\n \t\t// We have arrays all the way down, or just primitive types. We can\n \t\t// just copy the memory in as it is all contiguous.\n-\t\tif err := copyPtr(buf, unpackEFace(value).data, int(val.Type().Size())); err != nil {\n+\t\tif _, err := copyPtr(buf, unpackEFace(value).data, int(val.Type().Size())); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t} else {\n@@ -119,7 +119,10 @@ func NewTensor(value interface{}) (*Tensor, error) {\n \t\t// not be contiguous with the others or in the order we might\n \t\t// expect, so we need to work our way down to each slice of\n \t\t// primitives and copy them individually\n-\t\tif err := encodeTensorWithSlices(buf, val, shape); err != nil {\n+\t\tif n, err := encodeTensorWithSlices(buf, val, shape); err != nil {\n+\t\t\t// Set nbytes to count of bytes written for deferred call to\n+\t\t\t// runtime.SetFinalizer\n+\t\t\tnbytes = uintptr(n)\n \t\t\treturn nil, err\n \t\t}\n \t}\n@@ -486,13 +489,13 @@ func sizeVarUint(v uint64) int {\n \n // encodeTensorWithSlices writes v to the specified buffer using the format specified in\n // c_api.h. Use stringEncoder for String tensors.\n-func encodeTensorWithSlices(w *bytes.Buffer, v reflect.Value, shape []int64) error {\n+func encodeTensorWithSlices(w *bytes.Buffer, v reflect.Value, shape []int64) (int, error) {\n \t// If current dimension is a slice, verify that it has the expected size\n \t// Go's type system makes that guarantee for arrays.\n \tif v.Kind() == reflect.Slice {\n \t\texpected := int(shape[0])\n \t\tif v.Len() != expected {\n-\t\t\treturn fmt.Errorf(\"mismatched slice lengths: %d and %d\", v.Len(), expected)\n+\t\t\treturn 0, fmt.Errorf(\"mismatched slice lengths: %d and %d\", v.Len(), expected)\n \t\t}\n \t} else if v.Kind() == reflect.String {\n \t\ts := v.Interface().(string)\n@@ -501,7 +504,7 @@ func encodeTensorWithSlices(w *bytes.Buffer, v reflect.Value, shape []int64) err\n \t\tptr := unsafe.Pointer(&tstr)\n \t\treturn copyPtr(w, ptr, C.sizeof_TF_TString)\n \t} else if v.Kind() != reflect.Array {\n-\t\treturn fmt.Errorf(\"unsupported type %v\", v.Type())\n+\t\treturn 0, fmt.Errorf(\"unsupported type %v\", v.Type())\n \t}\n \n \t// Once we have just a single dimension we can just copy the data\n@@ -514,15 +517,17 @@ func encodeTensorWithSlices(w *bytes.Buffer, v reflect.Value, shape []int64) err\n \t\treturn copyPtr(w, ptr, v.Len()*int(elt.Type().Size()))\n \t}\n \n+\tn := 0\n \tsubShape := shape[1:]\n \tfor i := 0; i < v.Len(); i++ {\n-\t\terr := encodeTensorWithSlices(w, v.Index(i), subShape)\n+\t\tj, err := encodeTensorWithSlices(w, v.Index(i), subShape)\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn n + j, err\n \t\t}\n+\t\tn += j\n \t}\n \n-\treturn nil\n+\treturn n, nil\n }\n \n // It isn't safe to use reflect.SliceHeader as it uses a uintptr for Data and\n@@ -536,15 +541,14 @@ type sliceHeader struct {\n // copyPtr copies the backing data for a slice or array directly into w. Note\n // we don't need to worry about byte ordering because we want the natural byte\n // order for the machine we're running on.\n-func copyPtr(w *bytes.Buffer, ptr unsafe.Pointer, l int) error {\n+func copyPtr(w *bytes.Buffer, ptr unsafe.Pointer, l int) (int, error) {\n \t// Convert our slice header into a []byte so we can call w.Write\n \tb := *(*[]byte)(unsafe.Pointer(&sliceHeader{\n \t\tData: ptr,\n \t\tLen:  l,\n \t\tCap:  l,\n \t}))\n-\t_, err := w.Write(b)\n-\treturn err\n+\treturn w.Write(b)\n }\n \n func bug(format string, args ...interface{}) error {"