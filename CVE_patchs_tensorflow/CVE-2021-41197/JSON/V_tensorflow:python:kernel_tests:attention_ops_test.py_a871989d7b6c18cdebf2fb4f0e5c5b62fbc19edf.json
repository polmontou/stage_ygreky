"# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for image.extract_glimpse().\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_image_ops\nfrom tensorflow.python.ops import image_ops\nfrom tensorflow.python.platform import test\n\n\nclass ExtractGlimpseTest(test.TestCase):\n\n  def _VerifyValues(self, tensor_in_sizes, glimpse_sizes, offsets,\n                    expected_rows, expected_cols):\n    \"\"\"Verifies the output values of the glimpse extraction kernel.\n\n    Args:\n      tensor_in_sizes: Input tensor dimensions in [input_rows, input_cols].\n      glimpse_sizes: Dimensions of the glimpse in [glimpse_rows, glimpse_cols].\n      offsets: Relative location of the center of the glimpse in the input\n        image expressed as [row_offset, col_offset].\n      expected_rows: A list containing the expected row numbers (None for\n         out of bound entries that are expected to be replaced by uniform\n         random entries in [0,1) ).\n      expected_cols: Same as expected_rows, but for column numbers.\n    \"\"\"\n\n    rows = tensor_in_sizes[0]\n    cols = tensor_in_sizes[1]\n    # Row Tensor with entries by row.\n    # [[ 1 1 1 ... ]\n    #  [ 2 2 2 ... ]\n    #  [ 3 3 3 ... ]\n    #  [ ...\n    # ]\n    t_rows = array_ops.tile(\n        [[1.0 * r] for r in range(1, rows + 1)], [1, cols], name='tile_rows')\n\n    # Shuffle to switch to a convention of (batch_size, height, width, depth).\n    t_rows_4d = array_ops.transpose(\n        array_ops.expand_dims(array_ops.expand_dims(t_rows, 0), 3),\n        [0, 2, 1, 3])\n\n    # Column Tensor with entries by column.\n    # [[ 1 2 3 4 ... ]\n    #  [ 1 2 3 4 ... ]\n    #  [ 1 2 3 4 ... ]\n    #  [ ...         ]\n    # ]\n    t_cols = array_ops.tile(\n        [[1.0 * r for r in range(1, cols + 1)]], [rows, 1], name='tile_cols')\n\n    # Shuffle to switch to a convention of (batch_size, height, width, depth).\n    t_cols_4d = array_ops.transpose(\n        array_ops.expand_dims(array_ops.expand_dims(t_cols, 0), 3),\n        [0, 2, 1, 3])\n\n    # extract_glimpses from Row and Column Tensor, respectively.\n    # Switch order for glimpse_sizes and offsets to switch from (row, col)\n    # convention to tensorflows (height, width) convention.\n    t1 = constant_op.constant([glimpse_sizes[1], glimpse_sizes[0]], shape=[2])\n    t2 = constant_op.constant([offsets[1], offsets[0]], shape=[1, 2])\n    glimpse_rows = (array_ops.transpose(\n        image_ops.extract_glimpse(t_rows_4d, t1, t2), [0, 2, 1, 3]))\n    glimpse_cols = (array_ops.transpose(\n        image_ops.extract_glimpse(t_cols_4d, t1, t2), [0, 2, 1, 3]))\n\n    # Evaluate the TensorFlow Graph.\n    with self.cached_session() as sess:\n      value_rows, value_cols = self.evaluate([glimpse_rows, glimpse_cols])\n\n    # Check dimensions of returned glimpse.\n    self.assertEqual(value_rows.shape[1], glimpse_sizes[0])\n    self.assertEqual(value_rows.shape[2], glimpse_sizes[1])\n    self.assertEqual(value_cols.shape[1], glimpse_sizes[0])\n    self.assertEqual(value_cols.shape[2], glimpse_sizes[1])\n\n    # Check entries.\n    min_random_val = 0\n    max_random_val = max(rows, cols)\n    for i in range(glimpse_sizes[0]):\n      for j in range(glimpse_sizes[1]):\n        if expected_rows[i] is None or expected_cols[j] is None:\n          self.assertGreaterEqual(value_rows[0][i][j][0], min_random_val)\n          self.assertLessEqual(value_rows[0][i][j][0], max_random_val)\n          self.assertGreaterEqual(value_cols[0][i][j][0], min_random_val)\n          self.assertLessEqual(value_cols[0][i][j][0], max_random_val)\n        else:\n          self.assertEqual(value_rows[0][i][j][0], expected_rows[i])\n          self.assertEqual(value_cols[0][i][j][0], expected_cols[j])\n\n  def testCenterGlimpse(self):\n    self._VerifyValues(\n        tensor_in_sizes=[41, 61],\n        glimpse_sizes=[3, 5],\n        offsets=[0.0, 0.0],\n        expected_rows=[20, 21, 22],\n        expected_cols=[29, 30, 31, 32, 33])\n\n  def testEmptyTensor(self):\n    empty_image = np.zeros((0, 4, 3, 0))\n    offsets = np.zeros((0, 2))\n    with self.cached_session():\n      result = image_ops.extract_glimpse(empty_image, [1, 1], offsets)\n      self.assertAllEqual(\n          np.zeros((0, 1, 1, 0), dtype=np.float32), self.evaluate(result))\n\n  def testLargeCenterGlimpse(self):\n    self._VerifyValues(\n        tensor_in_sizes=[41, 61],\n        glimpse_sizes=[41, 61],\n        offsets=[0.0, 0.0],\n        expected_rows=list(range(1, 42)),\n        expected_cols=list(range(1, 62)))\n\n  def testTooLargeCenterGlimpse(self):\n    self._VerifyValues(\n        tensor_in_sizes=[41, 61],\n        glimpse_sizes=[43, 63],\n        offsets=[0.0, 0.0],\n        expected_rows=[None] + list(range(1, 42)) + [None],\n        expected_cols=[None] + list(range(1, 62)) + [None])\n\n  def testGlimpseFullOverlap(self):\n    self._VerifyValues(\n        tensor_in_sizes=[41, 61],\n        glimpse_sizes=[3, 5],\n        offsets=[0.1, 0.3],\n        expected_rows=[22, 23, 24],\n        expected_cols=[38, 39, 40, 41, 42])\n\n  def testGlimpseFullOverlap2(self):\n    self._VerifyValues(\n        tensor_in_sizes=[41, 61],\n        glimpse_sizes=[11, 3],\n        offsets=[-0.7, -0.7],\n        expected_rows=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n        expected_cols=[8, 9, 10])\n\n  def testGlimpseBeforeLeftMargin(self):\n    self._VerifyValues(\n        tensor_in_sizes=[41, 61],\n        glimpse_sizes=[11, 5],\n        offsets=[-0.7, -0.9],\n        expected_rows=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n        expected_cols=[1, 2, 3, 4, 5])\n\n  def testGlimpseLowerRightCorner(self):\n    self._VerifyValues(\n        tensor_in_sizes=[41, 61],\n        glimpse_sizes=[7, 5],\n        offsets=[1.0, 1.0],\n        expected_rows=[38, 39, 40, 41, None, None, None],\n        expected_cols=[59, 60, 61, None, None])\n\n  def testGlimpseNoOverlap(self):\n    self._VerifyValues(\n        tensor_in_sizes=[20, 30],\n        glimpse_sizes=[3, 3],\n        offsets=[-2.0, 2.0],\n        expected_rows=[None, None, None],\n        expected_cols=[None, None, None])\n\n  def testGlimpseOnLeftMargin(self):\n    self._VerifyValues(\n        tensor_in_sizes=[41, 61],\n        glimpse_sizes=[11, 7],\n        offsets=[-0.7, -1.0],\n        expected_rows=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n        expected_cols=[None, None, None, 1, 2, 3, 4])\n\n  def testGlimpseUpperMargin(self):\n    self._VerifyValues(\n        tensor_in_sizes=[41, 61],\n        glimpse_sizes=[7, 5],\n        offsets=[-1, 0.9],\n        expected_rows=[None, None, None, 1, 2, 3, 4],\n        expected_cols=[56, 57, 58, 59, 60])\n\n  def testGlimpseNoiseZeroV1Compatible(self):\n    # Note: The old versions of extract_glimpse was incorrect in implementation.\n    # This test is for compatibility so that graph save in old versions behave\n    # the same. Notice the API uses gen_image_ops.extract_glimpse() on purpose.\n    #\n    # Image:\n    # [  0.   1.   2.   3.   4.]\n    # [  5.   6.   7.   8.   9.]\n    # [ 10.  11.  12.  13.  14.]\n    # [ 15.  16.  17.  18.  19.]\n    # [ 20.  21.  22.  23.  24.]\n    img = constant_op.constant(\n        np.arange(25).reshape((1, 5, 5, 1)), dtype=dtypes.float32)\n    with self.test_session():\n      # Result 1:\n      # [ 0.  0.  0.]\n      # [ 0.  0.  0.]\n      # [ 0.  0.  0.]\n      result1 = gen_image_ops.extract_glimpse(\n          img, [3, 3], [[-2, 2]],\n          centered=False,\n          normalized=False,\n          noise='zero',\n          uniform_noise=False)\n      self.assertAllEqual(\n          np.asarray([[0, 0, 0], [0, 0, 0], [0, 0, 0]]),\n          self.evaluate(result1)[0, :, :, 0])\n\n      # Result 2:\n      # [  0.   0.   0.   0.   0.   0.   0.]\n      # [  0.   0.   1.   2.   3.   4.   0.]\n      # [  0.   5.   6.   7.   8.   9.   0.]\n      # [  0.  10.  11.  12.  13.  14.   0.]\n      # [  0.  15.  16.  17.  18.  19.   0.]\n      # [  0.  20.  21.  22.  23.  24.   0.]\n      # [  0.   0.   0.   0.   0.   0.   0.]\n      result2 = gen_image_ops.extract_glimpse(\n          img, [7, 7], [[0, 0]],\n          normalized=False,\n          noise='zero',\n          uniform_noise=False)\n      self.assertAllEqual(\n          np.asarray([[0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 2, 3, 4, 0],\n                      [0, 5, 6, 7, 8, 9, 0], [0, 10, 11, 12, 13, 14, 0],\n                      [0, 15, 16, 17, 18, 19, 0], [0, 20, 21, 22, 23, 24, 0],\n                      [0, 0, 0, 0, 0, 0, 0]]),\n          self.evaluate(result2)[0, :, :, 0])\n\n\n  def testGlimpseNoiseZero(self):\n    # Image:\n    # [  0.   1.   2.   3.   4.]\n    # [  5.   6.   7.   8.   9.]\n    # [ 10.  11.  12.  13.  14.]\n    # [ 15.  16.  17.  18.  19.]\n    # [ 20.  21.  22.  23.  24.]\n    img = constant_op.constant(\n        np.arange(25).reshape((1, 5, 5, 1)), dtype=dtypes.float32)\n    with self.test_session():\n      # Result 1:\n      # [ 0.  0.  0.]\n      # [ 0.  0.  0.]\n      # [ 0.  0.  0.]\n      result1 = image_ops.extract_glimpse_v2(\n          img, [3, 3], [[-2, -2]],\n          centered=False,\n          normalized=False,\n          noise='zero')\n      self.assertAllEqual(\n          np.asarray([[0, 0, 0], [0, 0, 0], [0, 0, 0]]),\n          self.evaluate(result1)[0, :, :, 0])\n\n      # Result 2:\n      # [ 12.  13.  14.   0.   0.   0.   0.]\n      # [ 17.  18.  19.   0.   0.   0.   0.]\n      # [ 22.  23.  24.   0.   0.   0.   0.]\n      # [  0.   0.   0.   0.   0.   0.   0.]\n      # [  0.   0.   0.   0.   0.   0.   0.]\n      # [  0.   0.   0.   0.   0.   0.   0.]\n      # [  0.   0.   0.   0.   0.   0.   0.]\n      result2 = image_ops.extract_glimpse_v2(\n          img, [7, 7], [[0, 0]], normalized=False, noise='zero')\n      self.assertAllEqual(\n          np.asarray([[12, 13, 14, 0, 0, 0, 0], [17, 18, 19, 0, 0, 0, 0],\n                      [22, 23, 24, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0],\n                      [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0],\n                      [0, 0, 0, 0, 0, 0, 0]]),\n          self.evaluate(result2)[0, :, :, 0])\n\n  def testGlimpseNonNormalizedNonCentered(self):\n    img = constant_op.constant(\n        np.arange(25).reshape((1, 5, 5, 1)), dtype=dtypes.float32)\n    with self.test_session():\n      result1 = image_ops.extract_glimpse_v2(\n          img, [3, 3], [[0, 0]], centered=False, normalized=False)\n      result2 = image_ops.extract_glimpse_v2(\n          img, [3, 3], [[1, 0]], centered=False, normalized=False)\n      self.assertAllEqual(\n          np.asarray([[0, 1, 2], [5, 6, 7], [10, 11, 12]]),\n          self.evaluate(result1)[0, :, :, 0])\n      self.assertAllEqual(\n          np.asarray([[5, 6, 7], [10, 11, 12], [15, 16, 17]]),\n          self.evaluate(result2)[0, :, :, 0])\n\n\nif __name__ == '__main__':\n  test.main()"