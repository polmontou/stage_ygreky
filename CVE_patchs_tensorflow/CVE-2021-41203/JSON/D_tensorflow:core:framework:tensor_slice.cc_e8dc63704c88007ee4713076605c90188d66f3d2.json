"diff --git a/tensorflow/core/framework/tensor_slice.cc b/tensorflow/core/framework/tensor_slice.cc\nindex bde1c09e7fc..0b391435906 100644\n--- a/tensorflow/core/framework/tensor_slice.cc\n+++ b/tensorflow/core/framework/tensor_slice.cc\n@@ -14,7 +14,10 @@ limitations under the License.\n ==============================================================================*/\n \n #include \"tensorflow/core/framework/tensor_slice.h\"\n+\n+#include <limits>\n #include <vector>\n+\n #include \"tensorflow/core/lib/core/errors.h\"\n #include \"tensorflow/core/lib/strings/numbers.h\"\n #include \"tensorflow/core/lib/strings/str_util.h\"\n@@ -44,6 +47,34 @@ TensorSlice::TensorSlice(\n   }\n }\n \n+Status TensorSlice::BuildTensorSlice(const TensorSliceProto& proto,\n+                                     TensorSlice* output) {\n+  output->Clear();\n+  output->starts_.reserve(proto.extent_size());\n+  output->lengths_.reserve(proto.extent_size());\n+  for (const auto& e : proto.extent()) {\n+    int64_t l = GetExtentLength(e);\n+    if (e.start() != 0 || l != kFullExtent) {\n+      if (e.start() < 0 || l <= 0) {\n+        return errors::InvalidArgument(\n+            \"Expected non-negative start and positive length but got start = \",\n+            e.start(), \", length = \", l, \": extent = \", e.ShortDebugString());\n+      }\n+      // Calculating the extent end must not cause signed integer overflow.\n+      if (static_cast<uint64_t>(e.start()) + static_cast<uint64_t>(e.length()) >\n+          std::numeric_limits<int64_t>::max()) {\n+        return errors::InvalidArgument(\n+            \"Extent end exceeds the maximum possible size: extent = \",\n+            e.ShortDebugString());\n+      }\n+    }\n+    output->starts_.push_back(e.start());\n+    output->lengths_.push_back(l);\n+  }\n+\n+  return Status::OK();\n+}\n+\n Status TensorSlice::Parse(const string& str, TensorSlice* slice) {\n   std::vector<string> items = str_util::Split(str, ':', str_util::SkipEmpty());\n   slice->starts_.reserve(items.size());"