"diff --git a/tensorflow/core/util/tensor_slice_reader_test.cc b/tensorflow/core/util/tensor_slice_reader_test.cc\nindex e6e65fc2e6c..9bd3063d4eb 100644\n--- a/tensorflow/core/util/tensor_slice_reader_test.cc\n+++ b/tensorflow/core/util/tensor_slice_reader_test.cc\n@@ -13,15 +13,19 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n-#include <utility>\n-\n #include \"tensorflow/core/util/tensor_slice_reader.h\"\n \n+#include <utility>\n+#include <vector>\n+\n #include \"tensorflow/core/framework/types.h\"\n #include \"tensorflow/core/framework/versions.pb.h\"\n #include \"tensorflow/core/lib/core/status_test_util.h\"\n #include \"tensorflow/core/lib/core/stringpiece.h\"\n+#include \"tensorflow/core/lib/io/iterator.h\"\n #include \"tensorflow/core/lib/io/path.h\"\n+#include \"tensorflow/core/lib/io/table.h\"\n+#include \"tensorflow/core/lib/io/table_builder.h\"\n #include \"tensorflow/core/lib/strings/str_util.h\"\n #include \"tensorflow/core/lib/strings/strcat.h\"\n #include \"tensorflow/core/platform/env.h\"\n@@ -30,6 +34,7 @@ limitations under the License.\n #include \"tensorflow/core/platform/test.h\"\n #include \"tensorflow/core/platform/types.h\"\n #include \"tensorflow/core/public/version.h\"\n+#include \"tensorflow/core/util/saved_tensor_slice.pb.h\"\n #include \"tensorflow/core/util/saved_tensor_slice_util.h\"\n #include \"tensorflow/core/util/tensor_slice_reader_cache.h\"\n #include \"tensorflow/core/util/tensor_slice_writer.h\"\n@@ -309,6 +314,102 @@ TEST_SIMPLE_INT(int16, int32)\n TEST_SIMPLE_INT(int8, int32)\n TEST_SIMPLE_INT(uint8, int32)\n \n+// Modifies the SavedTensorSlices messages in a checkpoint to allow creating\n+// malformed or unsupported checkpoints.\n+void MutateSavedTensorSlices(\n+    const std::string& fname,\n+    const std::function<std::string(SavedTensorSlices)>& mutator) {\n+  table::Options options;\n+  options.compression = table::kNoCompression;\n+\n+  // Read all entres from the table.\n+  std::vector<std::pair<std::string, std::string>> entries;\n+  {\n+    std::unique_ptr<RandomAccessFile> file;\n+    TF_CHECK_OK(Env::Default()->NewRandomAccessFile(fname, &file));\n+    uint64 file_size;\n+    TF_CHECK_OK(Env::Default()->GetFileSize(fname, &file_size));\n+    table::Table* t;\n+    TF_CHECK_OK(table::Table::Open(options, file.get(), file_size, &t));\n+    std::unique_ptr<table::Table> table(t);\n+    std::unique_ptr<table::Iterator> it(table->NewIterator());\n+    for (it->Seek(\"\"); it->Valid(); it->Next()) {\n+      entries.emplace_back(it->key(), it->value());\n+    }\n+    TF_CHECK_OK(it->status());\n+  }\n+\n+  // Rewrite the table, mutating each value.\n+  {\n+    std::unique_ptr<WritableFile> file;\n+    TF_CHECK_OK(Env::Default()->NewWritableFile(fname, &file));\n+    table::TableBuilder builder(options, file.get());\n+    for (const auto& entry : entries) {\n+      SavedTensorSlices sts;\n+      CHECK(sts.ParseFromString(entry.second));\n+      builder.Add(entry.first, mutator(std::move(sts)));\n+    }\n+    TF_CHECK_OK(builder.Finish());\n+    TF_CHECK_OK(file->Close());\n+  }\n+}\n+\n+TEST(TensorSliceReaderTest, MissingTensorType) {\n+  const string fname = io::JoinPath(testing::TmpDir(), \"invalid_checkpoint\");\n+  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n+  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+  TensorShape shape({4, 5});\n+  TensorSlice slice = TensorSlice::ParseOrDie(\"0,2:-\");\n+  TF_CHECK_OK(writer.Add(\"test\", shape, slice, data));\n+  TF_CHECK_OK(writer.Finish());\n+\n+  MutateSavedTensorSlices(fname, [](SavedTensorSlices sts) {\n+    if (sts.has_meta()) {\n+      for (auto& tensor : *sts.mutable_meta()->mutable_tensor()) {\n+        tensor.clear_type();\n+      }\n+    }\n+    return sts.SerializeAsString();\n+  });\n+\n+  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n+  TF_CHECK_OK(reader.status());\n+\n+  // The tensor should be present, but loading it should fail due to the\n+  // unset (invalid) type.\n+  EXPECT_TRUE(reader.HasTensor(\"test\", nullptr, nullptr));\n+  std::unique_ptr<Tensor> tensor;\n+  EXPECT_FALSE(reader.GetTensor(\"test\", &tensor).ok());\n+}\n+\n+TEST(TensorSliceReaderTest, UnsupportedTensorType) {\n+  const string fname = io::JoinPath(testing::TmpDir(), \"int32_ref_checkpoint\");\n+  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n+  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+  TensorShape shape({4, 5});\n+  TensorSlice slice = TensorSlice::ParseOrDie(\"0,2:-\");\n+  TF_CHECK_OK(writer.Add(\"test\", shape, slice, data));\n+  TF_CHECK_OK(writer.Finish());\n+\n+  MutateSavedTensorSlices(fname, [](SavedTensorSlices sts) {\n+    if (sts.has_meta()) {\n+      for (auto& tensor : *sts.mutable_meta()->mutable_tensor()) {\n+        tensor.set_type(DT_INT32_REF);\n+      }\n+    }\n+    return sts.SerializeAsString();\n+  });\n+\n+  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n+  TF_CHECK_OK(reader.status());\n+\n+  // The tensor should be present, but loading it should fail due to the\n+  // unsupported type.\n+  EXPECT_TRUE(reader.HasTensor(\"test\", nullptr, nullptr));\n+  std::unique_ptr<Tensor> tensor;\n+  EXPECT_FALSE(reader.GetTensor(\"test\", &tensor).ok());\n+}\n+\n void CachedTensorSliceReaderTesterHelper(\n     const TensorSliceWriter::CreateBuilderFunction& create_function,\n     const TensorSliceReader::OpenTableFunction& open_function) {"