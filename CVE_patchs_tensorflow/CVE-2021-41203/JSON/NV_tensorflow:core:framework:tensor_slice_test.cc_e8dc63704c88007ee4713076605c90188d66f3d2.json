"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/tensor_slice.h\"\n\n#include <limits>\n\n#include \"tensorflow/core/lib/core/status_test_util.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/protobuf.h\"\n#include \"tensorflow/core/platform/test.h\"\n#include \"tensorflow/core/protobuf/error_codes.pb.h\"\n\nnamespace tensorflow {\nnamespace {\n\n// Basic tests\nTEST(TensorSliceTest, Basic) {\n  {\n    // Repeatedly setting FullSlice should work.\n    TensorSlice s(3);\n    EXPECT_EQ(\"-:-:-\", s.DebugString());\n    EXPECT_TRUE(s.IsFull());\n\n    s.SetFullSlice(4);\n    EXPECT_EQ(\"-:-:-:-\", s.DebugString());\n    EXPECT_TRUE(s.IsFull());\n  }\n}\n\n// Testing for serialization and parsing for the string format of slices.\nTEST(TensorSliceTest, Serialization) {\n  // Serialization\n  {\n    TensorSlice s({{0, -1}, {0, 10}, {14, 1}, {0, -1}});\n    EXPECT_EQ(\"-:0,10:14,1:-\", s.DebugString());\n    EXPECT_TRUE(!s.IsFull());\n  }\n\n  {\n    TensorSliceProto proto;\n    // Define ptxt outside ASSERT_TRUE call to work around bug in some\n    // versions of gcc that breaks when you use raw string literals\n    // inside macro expansions.\n    //   See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55971\n    const char* ptxt = R\"pb(\n      extent {}\n      extent { start: 0 length: 10 }\n      extent { start: 14 length: 1 }\n      extent {}\n    )pb\";\n    ASSERT_TRUE(protobuf::TextFormat::ParseFromString(ptxt, &proto));\n    TensorSlice s(proto);\n    EXPECT_EQ(\"-:0,10:14,1:-\", s.DebugString());\n    EXPECT_TRUE(!s.IsFull());\n  }\n\n  // Parsing\n  {\n    TensorSlice s = TensorSlice::ParseOrDie(\"-:-:1,3:4,5\");\n    TensorSliceProto proto;\n    s.AsProto(&proto);\n    EXPECT_EQ(\n        \"extent { } \"\n        \"extent { } \"\n        \"extent { start: 1 length: 3 } \"\n        \"extent { start: 4 length: 5 }\",\n        proto.ShortDebugString());\n    EXPECT_TRUE(!s.IsFull());\n  }\n\n  // Failed parsing\n  {\n    TensorSlice slice;\n    Status s = TensorSlice::Parse(\"-:-:1,3:4:5\", &slice);\n    EXPECT_EQ(s.code(), error::INVALID_ARGUMENT);\n    EXPECT_TRUE(\n        absl::StrContains(s.error_message(),\n                          \"Expected a pair of numbers or '-' but got '4': \"\n                          \"string = -:-:1,3:4:5\"));\n  }\n  {\n    TensorSlice slice;\n    Status s = TensorSlice::Parse(\"-:-1,3\", &slice);\n    EXPECT_EQ(s.code(), error::INVALID_ARGUMENT);\n    EXPECT_TRUE(absl::StrContains(\n        s.error_message(),\n        \"Expected non-negative start and positive length but got \"\n        \"start = -1, length = 3: string = -:-1,3\"));\n  }\n\n  // int64 parsing\n  {\n    TensorSlice s =\n        TensorSlice::ParseOrDie(\"9223372036854775807,9223372036854775807\");\n    TensorSliceProto proto;\n    s.AsProto(&proto);\n    EXPECT_EQ(\n        \"extent { start: 9223372036854775807 length: 9223372036854775807 }\",\n        proto.ShortDebugString());\n    EXPECT_TRUE(!s.IsFull());\n  }\n\n  // int64 parsing failure\n  {\n    TensorSlice slice;\n    Status s =\n        TensorSlice::Parse(\"19223372036854775808,19223372036854775808\", &slice);\n    EXPECT_EQ(s.code(), error::INVALID_ARGUMENT);\n    EXPECT_TRUE(absl::StrContains(\n        s.error_message(),\n        \"Expected a pair of numbers or '-' but got \"\n        \"'19223372036854775808,19223372036854775808': string = \"\n        \"19223372036854775808,19223372036854775808\"));\n  }\n}\n\n// Testing `BuildTensorSlice` with valid and invalid input protos.\nTEST(TensorSliceTest, BuildTensorSlice) {\n  TensorSliceProto proto;\n  TensorSlice({{0, -1}, {0, 10}, {14, 1}}).AsProto(&proto);\n  TensorSlice s;\n\n  // Successful building.\n  {\n    TF_ASSERT_OK(TensorSlice::BuildTensorSlice(proto, &s));\n    EXPECT_EQ(\"-:0,10:14,1\", s.DebugString());\n  }\n\n  // Failed building due to negative extent start.\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(0)->set_start(-1);\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n\n  // Failed building due to negative extent length.\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->set_length(-1);\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n\n  // Failed building due to missing extent length.\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->clear_length();\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n\n  // Failed building due to extent end overflowing.\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->set_length(\n        std::numeric_limits<int64_t>::max());\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n}\n\n// Testing the slice intersection\nTEST(TensorSliceTest, Intersection) {\n  // \"EVERYTHING\" intersects with everything\n  {\n    TensorSlice a = TensorSlice::ParseOrDie(\"-:-\");\n    TensorSlice b = TensorSlice::ParseOrDie(\"1,2:3,4\");\n    TensorSlice c;\n    EXPECT_TRUE(a.Intersect(b, &c));\n    EXPECT_EQ(\"1,2:3,4\", c.DebugString());\n  }\n\n  {\n    TensorSlice a = TensorSlice::ParseOrDie(\"-:-\");\n    TensorSlice b = TensorSlice::ParseOrDie(\"1,2:3,4\");\n    TensorSlice c;\n    EXPECT_TRUE(b.Intersect(a, &c));\n    EXPECT_EQ(\"1,2:3,4\", c.DebugString());\n  }\n\n  // Overlap at all dimensions\n  {\n    TensorSlice a = TensorSlice::ParseOrDie(\"1,5:2,6:3,7:5,10\");\n    TensorSlice b = TensorSlice::ParseOrDie(\"1,2:3,4:9,10:12,1\");\n    TensorSlice c;\n    EXPECT_TRUE(a.Intersect(b, &c));\n    EXPECT_EQ(\"1,2:3,4:9,1:12,1\", c.DebugString());\n  }\n\n  // A mixture of everything and non-trivial slices\n  {\n    TensorSlice a = TensorSlice::ParseOrDie(\"-:1,1\");\n    TensorSlice b = TensorSlice::ParseOrDie(\"-:0,2\");\n    TensorSlice c;\n    EXPECT_TRUE(a.Intersect(b, &c));\n    EXPECT_EQ(\"-:1,1\", c.DebugString());\n  }\n\n  // No overlap on dimension 3: \"3,1\" and \"4,5\" don't intersect\n  {\n    TensorSlice a = TensorSlice::ParseOrDie(\"1,2:3,1:5,6\");\n    TensorSlice b = TensorSlice::ParseOrDie(\"1,3:4,5:1,6\");\n    TensorSlice c;\n    EXPECT_FALSE(a.Intersect(b, &c));\n    EXPECT_EQ(\"\", c.DebugString());\n  }\n  // No intersection when there are different dimensions\n  {\n    TensorSlice a = TensorSlice::ParseOrDie(\"1,2:3,1:-\");\n    TensorSlice b = TensorSlice::ParseOrDie(\"-:-\");\n    TensorSlice c;\n    EXPECT_FALSE(a.Intersect(b, &c));\n    EXPECT_EQ(\"\", c.DebugString());\n  }\n}\n\n// Testing applying a slice to a tensor shape\nTEST(TensorSliceTest, SliceTensorShape) {\n  // A proper application\n  {\n    TensorSlice a = TensorSlice::ParseOrDie(\"1,1:-:4,1:2,6\");\n    TensorShape x({2, 4, 5, 8});\n    TensorShape y;\n    TF_EXPECT_OK(a.SliceTensorShape(x, &y));\n    EXPECT_EQ(\"[1,4,1,6]\", y.DebugString());\n  }\n\n  // An invalid application -- dimension 2 is out of bounds\n  {\n    TensorSlice a = TensorSlice::ParseOrDie(\"1,1:1,4:-:-\");\n    TensorShape x({2, 4, 5, 8});\n    TensorShape y;\n    Status s = a.SliceTensorShape(x, &y);\n    EXPECT_EQ(s.code(), error::INTERNAL);\n    EXPECT_TRUE(absl::StrContains(s.error_message(),\n                                  \"Extent in dimension 1 out of bounds: \"\n                                  \"shape = [2,4,5,8], slice = 1,1:1,4:-:-\"));\n    EXPECT_EQ(\"[]\", y.DebugString());\n  }\n}\n\n// Testing the computation of relative slices.\nTEST(TensorSliceTest, ComputeRelative) {\n  // Easy case: base is \"everything\"\n  {\n    TensorSlice base = TensorSlice::ParseOrDie(\"-:-:-:-\");\n    TensorSlice sub = TensorSlice::ParseOrDie(\"-:1,2:-:3,4\");\n    TensorSlice relative;\n    base.ComputeRelative(sub, &relative);\n    EXPECT_EQ(\"-:1,2:-:3,4\", relative.DebugString());\n  }\n\n  // A slightly more complicated case\n  {\n    TensorSlice base = TensorSlice::ParseOrDie(\"1,2:3,4:-:5,1\");\n    TensorSlice sub = TensorSlice::ParseOrDie(\"1,1:4,2:3,3:5,1\");\n    TensorSlice relative;\n    base.ComputeRelative(sub, &relative);\n    EXPECT_EQ(\"0,1:1,2:3,3:0,1\", relative.DebugString());\n  }\n}\n\nTEST(TensorSliceTest, ExtentLength) {\n  TensorSliceProto proto;\n  // Define ptxt outside ASSERT_TRUE call to work around bug in some\n  // versions of gcc that breaks when you use raw string literals\n  // inside macro expansions.\n  //   See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55971\n  const char* ptxt = R\"pb(\n    extent {}\n    extent { start: 0 length: 10 }\n    extent { start: 14 length: 1 }\n    extent {}\n  )pb\";\n  ASSERT_TRUE(protobuf::TextFormat::ParseFromString(ptxt, &proto));\n  EXPECT_FALSE(TensorSlice::HasExtentLength(proto.extent(0)));\n  EXPECT_TRUE(TensorSlice::HasExtentLength(proto.extent(1)));\n  EXPECT_TRUE(TensorSlice::HasExtentLength(proto.extent(2)));\n  EXPECT_FALSE(TensorSlice::HasExtentLength(proto.extent(3)));\n  EXPECT_EQ(-1, TensorSlice::GetExtentLength(proto.extent(0)));\n  EXPECT_EQ(10, TensorSlice::GetExtentLength(proto.extent(1)));\n  EXPECT_EQ(1, TensorSlice::GetExtentLength(proto.extent(2)));\n  EXPECT_EQ(-1, TensorSlice::GetExtentLength(proto.extent(3)));\n}\n\nTEST(TensorSliceTest, Deserialization) {\n  // Serialization of\n  //     extent { length: 5 }\n  //     extent { start: 0 length: 10 }\n  //     extent { start: 14 length: 1 }\n  //     extent { start: 1 }\n  //     extent { }\n  // in proto2 and proto3:\n  const char pb2[] =\n      \"\\x0A\\x02\\x10\\x05\\x0A\\x04\\x08\\x00\"\n      \"\\x10\\x0A\\x0A\\x04\\x08\\x0E\\x10\\x01\\x0A\\x02\\x08\\x01\\x0A\\x00\";\n  const char pb3[] =\n      \"\\x0A\\x02\\x10\\x05\\x0A\\x02\"\n      \"\\x10\\x0A\\x0A\\x04\\x08\\x0E\\x10\\x01\\x0A\\x02\\x08\\x01\\x0A\\x00\";\n  // (The difference is that in the proto3 version, \"start: 0\" isn't included\n  // since 0 is start's default value.)\n\n  TensorSliceProto proto2;\n  ASSERT_TRUE(proto2.ParseFromArray(pb2, sizeof(pb2) - 1));\n  TensorSlice ts2(proto2);\n\n  TensorSliceProto proto3;\n  ASSERT_TRUE(proto3.ParseFromArray(pb3, sizeof(pb3) - 1));\n  TensorSlice ts3(proto3);\n\n  // Both serializations should be interpreted the same.\n  EXPECT_EQ(\"0,5:0,10:14,1:1,-1:-\", ts2.DebugString());\n  EXPECT_EQ(\"0,5:0,10:14,1:1,-1:-\", ts3.DebugString());\n}\n\nTEST(TensorSliceTest, UpdateToCover) {\n  // [2:4, :, 3:]\n  TensorSlice s({{2, 2}, {0, -1}, {3, 7}});\n  // [:, 1:4, 2:4]\n  TensorSlice other({{0, -1}, {1, 3}, {2, 2}});\n\n  s.UpdateToCover(other);\n  // [:, :, 2:]\n  EXPECT_EQ(\"-:-:2,8\", s.DebugString());\n}\n\nTEST(TensorSliceTest, IsFull) {\n  TensorSlice slice(3);\n  EXPECT_TRUE(slice.IsFull());\n\n  TensorSlice slice2({{0, -1}});\n  EXPECT_TRUE(slice2.IsFull());\n\n  TensorSlice slice3({{0, -1}, {0, -1}, {14, 1}});\n  EXPECT_TRUE(!slice3.IsFull());\n}\n\nTEST(TensorSliceTest, Equality) {\n  {  // Dims are different.\n    TensorSlice slice1(3);\n    TensorSlice slice2(2);\n    EXPECT_TRUE(slice1 != slice2);\n    EXPECT_TRUE(slice2 != slice1);\n  }\n  {  // Both are 3-dim full slices.\n    TensorSlice slice1(3);\n    TensorSlice slice2({{0, -1}, {0, -1}, {0, -1}});\n    EXPECT_TRUE(slice1 == slice2);\n    EXPECT_TRUE(slice2 == slice1);\n  }\n  {  // Differs in one dimension.\n    TensorSlice slice1(3);\n    TensorSlice slice2({{0, -1}, {0, 1}, {0, -1}});\n    EXPECT_TRUE(slice1 != slice2);\n    EXPECT_TRUE(slice2 != slice1);\n  }\n}\n\n}  // namespace\n}  // namespace tensorflow"