"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/util/tensor_slice_reader.h\"\n\n#include <utility>\n#include <vector>\n\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/framework/versions.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/io/iterator.h\"\n#include \"tensorflow/core/lib/io/table.h\"\n#include \"tensorflow/core/lib/io/table_options.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/protobuf.h\"\n#include \"tensorflow/core/public/version.h\"\n#include \"tensorflow/core/util/saved_tensor_slice_util.h\"\n#include \"tensorflow/core/util/tensor_slice_util.h\"\n\nnamespace tensorflow {\n\nnamespace checkpoint {\n\nTensorSliceReader::Table::~Table() {}\n\nnamespace {\nclass TensorSliceReaderTable : public TensorSliceReader::Table {\n public:\n  // Takes ownership of 'f'.\n  explicit TensorSliceReaderTable(RandomAccessFile* f, table::Table* t)\n      : file_(f), table_(t) {}\n\n  ~TensorSliceReaderTable() override {\n    delete table_;\n    delete file_;\n  }\n\n  bool Get(const string& key, string* value) override {\n    std::unique_ptr<table::Iterator> iter(table_->NewIterator());\n    iter->Seek(key);\n    if (iter->Valid() && iter->key() == key) {\n      StringPiece v = iter->value();\n      value->assign(v.data(), v.size());\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n private:\n  RandomAccessFile* file_;  // Owns.\n  table::Table* table_;\n};\n}  // namespace\n\nStatus OpenTableTensorSliceReader(const string& fname,\n                                  TensorSliceReader::Table** result) {\n  *result = nullptr;\n  Env* env = Env::Default();\n  std::unique_ptr<RandomAccessFile> f;\n  Status s = env->NewRandomAccessFile(fname, &f);\n  if (s.ok()) {\n    uint64 file_size;\n    s = env->GetFileSize(fname, &file_size);\n    if (s.ok()) {\n      table::Options options;\n      table::Table* table;\n      s = table::Table::Open(options, f.get(), file_size, &table);\n      if (s.ok()) {\n        *result = new TensorSliceReaderTable(f.release(), table);\n        return Status::OK();\n      } else {\n        s = Status(s.code(),\n                   strings::StrCat(s.error_message(),\n                                   \": perhaps your file is in a different \"\n                                   \"file format and you need to use a \"\n                                   \"different restore operator?\"));\n      }\n    }\n  }\n  LOG(WARNING) << \"Could not open \" << fname << \": \" << s;\n  return s;\n}\n\nTensorSliceReader::TensorSliceReader(const string& filepattern)\n    : TensorSliceReader(filepattern, OpenTableTensorSliceReader,\n                        kLoadAllShards) {}\n\nTensorSliceReader::TensorSliceReader(const string& filepattern,\n                                     OpenTableFunction open_function)\n    : TensorSliceReader(filepattern, std::move(open_function), kLoadAllShards) {\n}\n\nTensorSliceReader::TensorSliceReader(const string& filepattern,\n                                     OpenTableFunction open_function,\n                                     int preferred_shard)\n    : filepattern_(filepattern), open_function_(std::move(open_function)) {\n  VLOG(1) << \"TensorSliceReader for \" << filepattern;\n  Status s = Env::Default()->GetMatchingPaths(filepattern, &fnames_);\n  if (!s.ok()) {\n    status_ = errors::InvalidArgument(\n        \"Unsuccessful TensorSliceReader constructor: \"\n        \"Failed to get matching files on \",\n        filepattern, \": \", s.ToString());\n    return;\n  }\n  if (fnames_.empty()) {\n    status_ = errors::NotFound(\n        \"Unsuccessful TensorSliceReader constructor: \"\n        \"Failed to find any matching files for \",\n        filepattern);\n    return;\n  }\n  sss_.resize(fnames_.size());\n  for (size_t shard = 0; shard < fnames_.size(); ++shard) {\n    fname_to_index_.insert(std::make_pair(fnames_[shard], shard));\n  }\n  if (preferred_shard == kLoadAllShards || fnames_.size() == 1 ||\n      static_cast<size_t>(preferred_shard) >= fnames_.size()) {\n    LoadAllShards();\n  } else {\n    VLOG(1) << \"Loading shard \" << preferred_shard << \" for \" << filepattern_;\n    LoadShard(preferred_shard);\n  }\n}\n\nvoid TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  // Already loaded, or invalid.\n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape(ssm.shape());\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}\n\nvoid TensorSliceReader::LoadAllShards() const {\n  VLOG(1) << \"Loading all shards for \" << filepattern_;\n  for (size_t i = 0; i < fnames_.size() && status_.ok(); ++i) {\n    LoadShard(i);\n  }\n  all_shards_loaded_ = true;\n}\n\nconst TensorSliceSet* TensorSliceReader::FindTensorSlice(\n    const string& name, const TensorSlice& slice,\n    std::vector<std::pair<TensorSlice, string>>* details) const {\n  const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n  if (tss && !tss->QueryMeta(slice, details)) {\n    return nullptr;\n  }\n  return tss;\n}\n\nTensorSliceReader::~TensorSliceReader() {\n  for (auto& temp : tensors_) {\n    delete temp.second;\n  }\n  tensors_.clear();\n}\n\nbool TensorSliceReader::HasTensor(const string& name, TensorShape* shape,\n                                  DataType* type) const {\n  mutex_lock l(mu_);\n  const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n  if (!tss && !all_shards_loaded_) {\n    VLOG(1) << \"Did not find tensor in preferred shard, loading all shards: \"\n            << name;\n    LoadAllShards();\n    tss = gtl::FindPtrOrNull(tensors_, name);\n  }\n  if (tss) {\n    if (shape) {\n      *shape = tss->shape();\n    }\n    if (type) {\n      *type = tss->type();\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nStatus TensorSliceReader::GetTensor(\n    const string& name, std::unique_ptr<tensorflow::Tensor>* out_tensor) const {\n  DataType type;\n  TensorShape shape;\n  TensorSlice slice;\n  {\n    mutex_lock l(mu_);\n    const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n    if (tss == nullptr) {\n      return errors::NotFound(name, \" not found in checkpoint file\");\n    }\n\n    if (tss->Slices().size() > 1) {\n      // TODO(sherrym): Support multi-slice checkpoints.\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor);\n  Status s = tensorflow::Tensor::BuildTensor(type, shape, t.get());\n  if (!s.ok()) return s;\n  bool success = false;\n\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n\n  switch (type) {\n    READER_COPY(DT_FLOAT);\n    READER_COPY(DT_DOUBLE);\n    READER_COPY(DT_INT32);\n    READER_COPY(DT_UINT8);\n    READER_COPY(DT_INT16);\n    READER_COPY(DT_INT8);\n    READER_COPY(DT_INT64);\n    READER_COPY(DT_STRING);\n    default:\n      return errors::Unimplemented(\"Data type not supported\");\n  }\n#undef READER_COPY\n\n  if (!success) {\n    return errors::NotFound(name, \" not found in checkpoint file\");\n  }\n  std::swap(*out_tensor, t);\n\n  return Status::OK();\n}\n\nTensorSliceReader::VarToShapeMap TensorSliceReader::GetVariableToShapeMap()\n    const {\n  VarToShapeMap name_to_shape;\n  if (status().ok()) {\n    for (auto& e : Tensors()) {\n      name_to_shape[e.first] = e.second->shape();\n    }\n  }\n  return name_to_shape;\n}\n\nTensorSliceReader::VarToDataTypeMap\nTensorSliceReader::GetVariableToDataTypeMap() const {\n  VarToDataTypeMap name_to_dtype;\n  if (status().ok()) {\n    for (auto& e : Tensors()) {\n      name_to_dtype[e.first] = e.second->type();\n    }\n  }\n  return name_to_dtype;\n}\n\nconst string TensorSliceReader::DebugString() const {\n  string shape_str;\n  if (status().ok()) {\n    for (const auto& e : Tensors()) {\n      strings::StrAppend(&shape_str, e.first, \" (\",\n                         DataType_Name(e.second->type()), \") \",\n                         e.second->shape().DebugString());\n      // Indicates if a tensor has more than 1 slice (i.e., it's partitioned).\n      const int num_slices = e.second->Slices().size();\n      if (num_slices > 1) {\n        strings::StrAppend(&shape_str, \", \", num_slices, \" slices\");\n      }\n      strings::StrAppend(&shape_str, \"\\n\");\n    }\n  }\n  return shape_str;\n}\n\n}  // namespace checkpoint\n\n}  // namespace tensorflow"