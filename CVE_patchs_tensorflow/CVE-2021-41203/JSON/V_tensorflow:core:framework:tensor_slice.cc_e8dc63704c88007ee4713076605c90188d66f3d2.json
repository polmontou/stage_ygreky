"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/tensor_slice.h\"\n#include <vector>\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/strings/numbers.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/platform/logging.h\"\n\nnamespace tensorflow {\n\nTensorSlice::TensorSlice(int dim) { SetFullSlice(dim); }\n\nTensorSlice::TensorSlice(const TensorSliceProto& proto) {\n  starts_.reserve(proto.extent_size());\n  lengths_.reserve(proto.extent_size());\n  for (const auto& e : proto.extent()) {\n    starts_.push_back(e.start());\n    lengths_.push_back(GetExtentLength(e));\n  }\n}\n\nTensorSlice::TensorSlice(\n    std::initializer_list<std::pair<int64_t, int64_t>> extents) {\n  starts_.reserve(extents.size());\n  lengths_.reserve(extents.size());\n  for (const auto& e : extents) {\n    starts_.push_back(e.first);\n    lengths_.push_back(e.second);\n  }\n}\n\nStatus TensorSlice::Parse(const string& str, TensorSlice* slice) {\n  std::vector<string> items = str_util::Split(str, ':', str_util::SkipEmpty());\n  slice->starts_.reserve(items.size());\n  slice->lengths_.reserve(items.size());\n  for (const string& x : items) {\n    int64_t s, l;\n    if (x == \"-\") {\n      // \"everything\"\n      s = 0;\n      l = kFullExtent;\n    } else {\n      std::vector<string> sl = str_util::Split(x, ',', str_util::SkipEmpty());\n      if (sl.size() != 2 || !strings::safe_strto64(sl[0], &s) ||\n          !strings::safe_strto64(sl[1], &l)) {\n        return errors::InvalidArgument(\n            \"Expected a pair of numbers or '-' \"\n            \"but got '\",\n            x, \"': string = \", str);\n      }\n      if (s < 0 || l <= 0) {\n        return errors::InvalidArgument(\n            \"Expected non-negative start and \"\n            \"positive length but got start = \",\n            s, \", length = \", l, \": string = \", str);\n      }\n    }\n    slice->starts_.push_back(s);\n    slice->lengths_.push_back(l);\n  }\n\n  return Status::OK();\n}\n\nvoid TensorSlice::Clear() {\n  starts_.clear();\n  lengths_.clear();\n}\n\nbool TensorSlice::IsFull() const {\n  for (int d = 0; d < dims(); ++d) {\n    if (!IsFullAt(d)) return false;\n  }\n  return true;\n}\n\nvoid TensorSlice::SetFullSlice(int dim) {\n  Clear();\n  starts_.reserve(dim);\n  lengths_.reserve(dim);\n  for (int d = 0; d < dim; ++d) {\n    starts_.push_back(0);\n    lengths_.push_back(kFullExtent);\n  }\n}\n\nvoid TensorSlice::Extend(int dim) {\n  int old_dim = dims();\n  DCHECK_LE(old_dim, dim);\n  starts_.resize(dim);\n  lengths_.resize(dim);\n  for (int d = old_dim; d < dim; ++d) {\n    starts_[d] = 0;\n    lengths_[d] = kFullExtent;\n  }\n}\n\nvoid TensorSlice::AsProto(TensorSliceProto* proto) const {\n  for (int d = 0; d < dims(); ++d) {\n    TensorSliceProto::Extent* e = proto->add_extent();\n    // We only need to record the explicit slice for non-full slices\n    if (!IsFullAt(d)) {\n      e->set_start(starts_[d]);\n      e->set_length(lengths_[d]);\n    }\n  }\n}\n\nstring TensorSlice::DebugString() const {\n  string buffer;\n  bool first = true;\n  for (int d = 0; d < dims(); ++d) {\n    if (!first) {\n      buffer.append(\":\");\n    }\n    if (IsFullAt(d)) {\n      buffer.append(\"-\");\n    } else {\n      strings::StrAppend(&buffer, starts_[d], \",\", lengths_[d]);\n    }\n    first = false;\n  }\n  return buffer;\n}\n\nbool TensorSlice::Intersect(const TensorSlice& other,\n                            TensorSlice* result) const {\n  // First, if two slices have different ranks, they obviously don't overlap\n  // -- in fact they are not compatible.\n  if (dims() != other.dims()) {\n    return false;\n  }\n\n  // Setting the result to the right dimension\n  if (result) {\n    result->SetFullSlice(dims());\n  }\n  // The two slices overlap if they overlap in all dimensions.\n  for (int d = 0; d < dims(); ++d) {\n    if (IsFullAt(d)) {\n      if (result) {\n        result->set_start(d, other.start(d));\n        result->set_length(d, other.length(d));\n      }\n    } else if (other.IsFullAt(d)) {\n      if (result) {\n        result->set_start(d, start(d));\n        result->set_length(d, length(d));\n      }\n    } else {\n      // If we have an intersection here, it should have a start that is the\n      // max of the two starts and an end that is the min of the two ends.\n      int64_t s = std::max(start(d), other.start(d));\n      int64_t l = std::min(end(d), other.end(d)) - s;\n      if (l > 0) {\n        // We have a real intersection\n        if (result) {\n          result->set_start(d, s);\n          result->set_length(d, l);\n        }\n      } else {\n        // We don't have an intersection for this dimension -- thus we don't\n        // have any intersection at all.\n        if (result) {\n          result->Clear();\n        }\n        return false;\n      }\n    }\n  }\n  // If we are here, we know there is overlap in every dimension.\n  return true;\n}\n\nbool TensorSlice::operator==(const TensorSlice& other) const {\n  return dims() == other.dims() && starts_ == other.starts_ &&\n         lengths_ == other.lengths_;\n}\n\nvoid TensorSlice::ComputeRelative(const TensorSlice& sub,\n                                  TensorSlice* relative) const {\n  DCHECK_EQ(dims(), sub.dims());\n  relative->SetFullSlice(dims());\n  for (int d = 0; d < dims(); ++d) {\n    if (IsFullAt(d)) {\n      relative->set_start(d, sub.start(d));\n      relative->set_length(d, sub.length(d));\n    } else {\n      // Otherwise the relative start is the difference between the start of\n      // sub and the start of base\n      relative->set_start(d, sub.start(d) - start(d));\n      relative->set_length(d, sub.length(d));\n    }\n  }\n}\n\nvoid TensorSlice::UpdateToCover(const TensorSlice& other) {\n  DCHECK_EQ(dims(), other.dims());\n  for (int d = 0; d < dims(); ++d) {\n    if (!IsFullAt(d)) {\n      if (other.IsFullAt(d)) {\n        starts_[d] = 0;\n        lengths_[d] = kFullExtent;\n      } else {\n        const auto new_end = std::max(end(d), other.end(d));\n        set_start(d, std::min(start(d), other.start(d)));\n        set_length(d, new_end - start(d));\n      }\n    }\n  }\n}\n\n// static\nbool TensorSlice::HasExtentLength(const TensorSliceProto::Extent& extent) {\n  return extent.has_length_case() == TensorSliceProto::Extent::kLength;\n}\n\n// static\nint64_t TensorSlice::GetExtentLength(const TensorSliceProto::Extent& extent) {\n  if (!HasExtentLength(extent)) return -1;\n  return extent.length();\n}\n\nStatus TensorSlice::SliceTensorShape(const TensorShape& shape,\n                                     TensorShape* result_shape) const {\n  result_shape->Clear();\n  // Mismatching ranks: we can't apply the slice at all.\n  if (shape.dims() != dims()) {\n    return errors::Internal(\"Mismatching ranks: shape = \", shape.DebugString(),\n                            \", slice = \", DebugString());\n  }\n  for (int d = 0; d < dims(); ++d) {\n    if (IsFullAt(d)) {\n      result_shape->AddDim(shape.dim_size(d));\n    } else {\n      // Check if the extent applies to the dimension\n      if (end(d) <= shape.dim_size(d)) {\n        // Yes: the end is within the range of the dim -- we adjust the result\n        // shape so that its size along this dimension is the length of the\n        // slice.\n        result_shape->AddDim(length(d));\n      } else {\n        // The extent doesn't apply to the dimension\n        result_shape->Clear();\n        return errors::Internal(\"Extent in dimension \", d,\n                                \" out of bounds: shape = \", shape.DebugString(),\n                                \", slice = \", DebugString());\n      }\n    }\n  }\n  // If we are here, we have successfully applied the shape.\n  return Status::OK();\n}\n\nconst int64_t TensorSlice::kFullExtent = -1;\n\n}  // namespace tensorflow"