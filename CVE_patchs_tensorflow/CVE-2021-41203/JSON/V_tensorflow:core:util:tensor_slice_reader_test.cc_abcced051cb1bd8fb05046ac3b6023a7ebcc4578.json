"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <utility>\n\n#include \"tensorflow/core/util/tensor_slice_reader.h\"\n\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/versions.pb.h\"\n#include \"tensorflow/core/lib/core/status_test_util.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/io/path.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/protobuf.h\"\n#include \"tensorflow/core/platform/test.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/public/version.h\"\n#include \"tensorflow/core/util/saved_tensor_slice_util.h\"\n#include \"tensorflow/core/util/tensor_slice_reader_cache.h\"\n#include \"tensorflow/core/util/tensor_slice_writer.h\"\n\nnamespace tensorflow {\n\nnamespace checkpoint {\n\nnamespace {\n\n// A simple test where we write a few tensor slices with a number of tensor\n// slice writers and then read them back from a tensor slice reader.\n//\n// We have a 2-d tensor of shape 4 X 5 that looks like this:\n//\n//   0   1   2   3   4\n//   5   6   7   8   9\n//  10  11  12  13  14\n//  15  16  17  18  19\n//\n// We assume this is a row-major matrix.\n\nvoid SimpleFloatHelper(\n    const TensorSliceWriter::CreateBuilderFunction& create_function,\n    TensorSliceReader::OpenTableFunction open_function) {\n  const string fname_base = io::JoinPath(testing::TmpDir(), \"float_checkpoint\");\n\n  TensorShape shape({4, 5});\n\n  // File #0 contains a slice that is the top two rows:\n  //\n  //   0   1   2   3   4\n  //   5   6   7   8   9\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  {\n    const string fname = strings::StrCat(fname_base, \"_0\");\n    TensorSliceWriter writer(fname, create_function);\n    const float data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    TensorSlice slice = TensorSlice::ParseOrDie(\"0,2:-\");\n    TF_CHECK_OK(writer.Add(\"test\", shape, slice, data));\n    TF_CHECK_OK(writer.Finish());\n  }\n\n  // File #1 contains two slices:\n  //\n  // slice #0 is the bottom left corner\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //  10  11  12   .   .\n  //  15  16  17   .   .\n  //\n  // slice #1 is the bottom right corner\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //   .   .   .  18  19\n  {\n    const string fname = strings::StrCat(fname_base, \"_1\");\n    TensorSliceWriter writer(fname, create_function);\n    // slice #0\n    {\n      const float data[] = {10, 11, 12, 15, 16, 17};\n      TensorSlice slice = TensorSlice::ParseOrDie(\"2,2:0,3\");\n      TF_CHECK_OK(writer.Add(\"test\", shape, slice, data));\n    }\n    // slice #1\n    {\n      const float data[] = {18, 19};\n      TensorSlice slice = TensorSlice::ParseOrDie(\"3,1:3,2\");\n      TF_CHECK_OK(writer.Add(\"test\", shape, slice, data));\n    }\n    TF_CHECK_OK(writer.Finish());\n  }\n\n  // Notice that we leave a hole in the tensor\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //   .   .   . (13) (14)\n  //   .   .   .   .   .\n\n  // Now we need to read the tensor slices\n  const string filepattern = strings::StrCat(fname_base, \"_*\");\n  TensorSliceReader reader(filepattern, std::move(open_function));\n  TF_EXPECT_OK(reader.status());\n  EXPECT_EQ(2, reader.num_files());\n\n  // We query some of the tensors\n  {\n    TensorShape shape;\n    DataType type;\n    EXPECT_TRUE(reader.HasTensor(\"test\", &shape, &type));\n    EXPECT_EQ(\"[4,5]\", shape.DebugString());\n    EXPECT_EQ(DT_FLOAT, type);\n    EXPECT_FALSE(reader.HasTensor(\"don't exist\", nullptr, nullptr));\n  }\n\n  // Now we query some slices\n  //\n  // Slice #1 is an exact match\n  //   0   1   2   3   4\n  //   5   6   7   8   9\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  {\n    TensorSlice s = TensorSlice::ParseOrDie(\"0,2:-\");\n    float expected[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    float results[10];\n    EXPECT_TRUE(reader.CopySliceData(\"test\", s, results));\n    for (int i = 0; i < 10; ++i) {\n      EXPECT_EQ(expected[i], results[i]);\n    }\n  }\n\n  // Slice #2 is a subset match\n  //   .   .   .   .   .\n  //   5   6   7   8   9\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  {\n    TensorSlice s = TensorSlice::ParseOrDie(\"1,1:-\");\n    float expected[] = {5, 6, 7, 8, 9};\n    float results[5];\n    EXPECT_TRUE(reader.CopySliceData(\"test\", s, results));\n    for (int i = 0; i < 5; ++i) {\n      EXPECT_EQ(expected[i], results[i]);\n    }\n  }\n\n  // Slice #4 includes the hole and so there is no match\n  //   .   .   .   .   .\n  //   .   .   7   8   9\n  //   .   .  12  13  14\n  //   .   .   .   .   .\n  {\n    TensorSlice s = TensorSlice::ParseOrDie(\"1,2:2,3\");\n    float results[6];\n    EXPECT_FALSE(reader.CopySliceData(\"test\", s, results));\n  }\n}\n\nTEST(TensorSliceReaderTest, SimpleFloat) {\n  SimpleFloatHelper(CreateTableTensorSliceBuilder, OpenTableTensorSliceReader);\n}\n\ntemplate <typename T, typename U>\nvoid SimpleIntXHelper(\n    const TensorSliceWriter::CreateBuilderFunction& create_function,\n    TensorSliceReader::OpenTableFunction open_function,\n    const string& checkpoint_file) {\n  const string fname_base = io::JoinPath(testing::TmpDir(), checkpoint_file);\n\n  TensorShape shape({4, 5});\n\n  // File #0 contains a slice that is the top two rows:\n  //\n  //   0   1   2   3   4\n  //   5   6   7   8   9\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  {\n    const string fname = strings::StrCat(fname_base, \"_0\");\n    TensorSliceWriter writer(fname, create_function);\n    const T data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    TensorSlice slice = TensorSlice::ParseOrDie(\"0,2:-\");\n    TF_CHECK_OK(writer.Add(\"test\", shape, slice, data));\n    TF_CHECK_OK(writer.Finish());\n  }\n\n  // File #1 contains two slices:\n  //\n  // slice #0 is the bottom left corner\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //  10  11  12   .   .\n  //  15  16  17   .   .\n  //\n  // slice #1 is the bottom right corner\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //   .   .   .  18  19\n  {\n    const string fname = strings::StrCat(fname_base, \"_1\");\n    TensorSliceWriter writer(fname, create_function);\n    // slice #0\n    {\n      const T data[] = {10, 11, 12, 15, 16, 17};\n      TensorSlice slice = TensorSlice::ParseOrDie(\"2,2:0,3\");\n      TF_CHECK_OK(writer.Add(\"test\", shape, slice, data));\n    }\n    // slice #1\n    {\n      const T data[] = {18, 19};\n      TensorSlice slice = TensorSlice::ParseOrDie(\"3,1:3,2\");\n      TF_CHECK_OK(writer.Add(\"test\", shape, slice, data));\n    }\n    TF_CHECK_OK(writer.Finish());\n  }\n\n  // Notice that we leave a hole in the tensor\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //   .   .   . (13) (14)\n  //   .   .   .   .   .\n\n  // Now we need to read the tensor slices\n  const string filepattern = strings::StrCat(fname_base, \"_*\");\n  TensorSliceReader reader(filepattern, std::move(open_function));\n  TF_EXPECT_OK(reader.status());\n  EXPECT_EQ(2, reader.num_files());\n\n  // We query some of the tensors\n  {\n    TensorShape shape;\n    DataType type;\n    EXPECT_TRUE(reader.HasTensor(\"test\", &shape, &type));\n    EXPECT_EQ(\"[4,5]\", shape.DebugString());\n    EXPECT_EQ(DataTypeToEnum<T>::v(), type);\n    EXPECT_FALSE(reader.HasTensor(\"don't exist\", nullptr, nullptr));\n  }\n\n  // Now we query some slices\n  //\n  // Slice #1 is an exact match\n  //   0   1   2   3   4\n  //   5   6   7   8   9\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  {\n    TensorSlice s = TensorSlice::ParseOrDie(\"0,2:-\");\n    T expected[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    U results[10];\n    EXPECT_TRUE(reader.CopySliceData(\"test\", s, results));\n    for (int i = 0; i < 10; ++i) {\n      EXPECT_EQ(expected[i], results[i]);\n    }\n  }\n\n  // Slice #2 is a subset match\n  //   .   .   .   .   .\n  //   5   6   7   8   9\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  {\n    TensorSlice s = TensorSlice::ParseOrDie(\"1,1:-\");\n    T expected[] = {5, 6, 7, 8, 9};\n    U results[5];\n    EXPECT_TRUE(reader.CopySliceData(\"test\", s, results));\n    for (int i = 0; i < 5; ++i) {\n      EXPECT_EQ(expected[i], results[i]);\n    }\n  }\n\n  // Slice #4 includes the hole and so there is no match\n  //   .   .   .   .   .\n  //   .   .   7   8   9\n  //   .   .  12  13  14\n  //   .   .   .   .   .\n  {\n    TensorSlice s = TensorSlice::ParseOrDie(\"1,2:2,3\");\n    U results[6];\n    EXPECT_FALSE(reader.CopySliceData(\"test\", s, results));\n  }\n}\n\n#define TEST_SIMPLE_INT(TYPE, SAVED_TYPE)                             \\\n  TEST(TensorSliceReaderTest, Simple##TYPE) {                         \\\n    SimpleIntXHelper<TYPE, SAVED_TYPE>(CreateTableTensorSliceBuilder, \\\n                                       OpenTableTensorSliceReader,    \\\n                                       #TYPE \"_checkpoint\");          \\\n  }\n\nTEST_SIMPLE_INT(int32, int32)\nTEST_SIMPLE_INT(int64_t, int64_t)\nTEST_SIMPLE_INT(int16, int32)\nTEST_SIMPLE_INT(int8, int32)\nTEST_SIMPLE_INT(uint8, int32)\n\nvoid CachedTensorSliceReaderTesterHelper(\n    const TensorSliceWriter::CreateBuilderFunction& create_function,\n    const TensorSliceReader::OpenTableFunction& open_function) {\n  const string fname_base = io::JoinPath(testing::TmpDir(), \"float_checkpoint\");\n\n  TensorShape shape({4, 5});\n\n  // File #0 contains a slice that is the top two rows:\n  //\n  //   0   1   2   3   4\n  //   5   6   7   8   9\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  {\n    const string fname = strings::StrCat(fname_base, \"_0\");\n    TensorSliceWriter writer(fname, create_function);\n    const float data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    TensorSlice slice = TensorSlice::ParseOrDie(\"0,2:-\");\n    TF_CHECK_OK(writer.Add(\"test\", shape, slice, data));\n    TF_CHECK_OK(writer.Finish());\n  }\n\n  // File #1 contains two slices:\n  //\n  // slice #0 is the bottom left corner\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //  10  11  12   .   .\n  //  15  16  17   .   .\n  //\n  // slice #1 is the bottom right corner\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //   .   .   .  18  19\n  {\n    const string fname = strings::StrCat(fname_base, \"_1\");\n    TensorSliceWriter writer(fname, create_function);\n    // slice #0\n    {\n      const float data[] = {10, 11, 12, 15, 16, 17};\n      TensorSlice slice = TensorSlice::ParseOrDie(\"2,2:0,3\");\n      TF_CHECK_OK(writer.Add(\"test\", shape, slice, data));\n    }\n    // slice #1\n    {\n      const float data[] = {18, 19};\n      TensorSlice slice = TensorSlice::ParseOrDie(\"3,1:3,2\");\n      TF_CHECK_OK(writer.Add(\"test\", shape, slice, data));\n    }\n    TF_CHECK_OK(writer.Finish());\n  }\n\n  // Notice that we leave a hole in the tensor\n  //   .   .   .   .   .\n  //   .   .   .   .   .\n  //   .   .   . (13) (14)\n  //   .   .   .   .   .\n\n  // Now we need to read the tensor slices\n  TensorSliceReaderCache cache;\n  const string filepattern = strings::StrCat(fname_base, \"_*\");\n  const TensorSliceReader* reader = cache.GetReader(\n      filepattern, open_function, TensorSliceReader::kLoadAllShards);\n  EXPECT_TRUE(reader != nullptr);\n  EXPECT_EQ(2, reader->num_files());\n\n  // We query some of the tensors\n  {\n    TensorShape shape;\n    DataType type;\n    EXPECT_TRUE(reader->HasTensor(\"test\", &shape, &type));\n    EXPECT_EQ(\"[4,5]\", shape.DebugString());\n    EXPECT_EQ(DT_FLOAT, type);\n    EXPECT_FALSE(reader->HasTensor(\"don't exist\", nullptr, nullptr));\n  }\n\n  // Make sure the reader is cached.\n  const TensorSliceReader* reader2 = cache.GetReader(\n      filepattern, open_function, TensorSliceReader::kLoadAllShards);\n  EXPECT_EQ(reader, reader2);\n\n  reader = cache.GetReader(\"file_does_not_exist\", open_function,\n                           TensorSliceReader::kLoadAllShards);\n  EXPECT_TRUE(reader == nullptr);\n}\n\nTEST(CachedTensorSliceReaderTest, SimpleFloat) {\n  CachedTensorSliceReaderTesterHelper(CreateTableTensorSliceBuilder,\n                                      OpenTableTensorSliceReader);\n}\n\nstatic void VersionTest(const VersionDef& versions, const string& error) {\n  const string path = io::JoinPath(testing::TmpDir(), \"checkpoint\");\n\n  {\n    // Prepare an empty checkpoint with some version information\n    SavedTensorSlices sts;\n    *sts.mutable_meta()->mutable_versions() = versions;\n    string contents;\n    EXPECT_TRUE(sts.SerializeToString(&contents));\n\n    // Write it to disk\n    TensorSliceWriter::Builder* builder;\n    TF_ASSERT_OK(CreateTableTensorSliceBuilder(path, &builder));\n    builder->Add(kSavedTensorSlicesKey, contents);\n    int64_t file_size;\n    TF_EXPECT_OK(builder->Finish(&file_size));\n    delete builder;\n  }\n\n  // Read it back in and verify that we get the expected error\n  TensorSliceReader reader(path, OpenTableTensorSliceReader);\n  EXPECT_TRUE(reader.status().code() == error::INVALID_ARGUMENT &&\n              absl::StartsWith(reader.status().error_message(), error))\n      << \"Expected error starting with '\" << errors::InvalidArgument(error)\n      << \"', got '\" << reader.status() << \"'\";\n}\n\nTEST(CheckpointVersionTest, MinConsumer) {\n  VersionDef versions;\n  versions.set_producer(TF_CHECKPOINT_VERSION + 1);\n  versions.set_min_consumer(TF_CHECKPOINT_VERSION + 1);\n  VersionTest(\n      versions,\n      strings::StrCat(\"Checkpoint min consumer version \",\n                      TF_CHECKPOINT_VERSION + 1, \" above current version \",\n                      TF_CHECKPOINT_VERSION, \" for TensorFlow\"));\n}\n\nTEST(CheckpointVersionTest, MinProducer) {\n  VersionDef versions;\n  versions.set_producer(TF_CHECKPOINT_VERSION_MIN_PRODUCER - 1);\n  VersionTest(versions, strings::StrCat(\"Checkpoint producer version \",\n                                        TF_CHECKPOINT_VERSION_MIN_PRODUCER - 1,\n                                        \" below min producer \",\n                                        TF_CHECKPOINT_VERSION_MIN_PRODUCER,\n                                        \" supported by TensorFlow\"));\n}\n\nTEST(CheckpointVersionTest, BadConsumer) {\n  VersionDef versions;\n  versions.set_producer(TF_CHECKPOINT_VERSION + 1);\n  versions.add_bad_consumers(TF_CHECKPOINT_VERSION);\n  VersionTest(\n      versions,\n      strings::StrCat(\n          \"Checkpoint disallows consumer version \", TF_CHECKPOINT_VERSION,\n          \".  Please upgrade TensorFlow: this version is likely buggy.\"));\n}\n\n}  // namespace\n\n}  // namespace checkpoint\n\n}  // namespace tensorflow"