"diff --git a/tensorflow/core/kernels/pooling_ops_common.h b/tensorflow/core/kernels/pooling_ops_common.h\nindex 1a41a5adca5..8890e24a32a 100644\n--- a/tensorflow/core/kernels/pooling_ops_common.h\n+++ b/tensorflow/core/kernels/pooling_ops_common.h\n@@ -189,6 +189,9 @@ class MaxPoolingOp : public OpKernel {\n   void SpatialMaxPool(OpKernelContext* context, Tensor* output,\n                       const Tensor& tensor_in, const PoolParameters& params,\n                       const Padding& padding) {\n+    if (output->NumElements() == 0) {\n+      return;\n+    }\n     // On GPU, use Eigen's Spatial Max Pooling.  On CPU, use an\n     // EigenMatrix version that is currently faster than Eigen's\n     // Spatial MaxPooling implementation.\n@@ -443,6 +446,9 @@ class MaxPoolingV2Op : public OpKernel {\n   void SpatialMaxPool(OpKernelContext* context, Tensor* output,\n                       const Tensor& tensor_in, const PoolParameters& params,\n                       const Padding& padding) {\n+    if (output->NumElements() == 0) {\n+      return;\n+    }\n     // On GPU, use Eigen's Spatial Max Pooling.  On CPU, use an\n     // EigenMatrix version that is currently faster than Eigen's\n     // Spatial MaxPooling implementation.\n@@ -561,6 +567,9 @@ template <typename Device, typename T>\n void SpatialAvgPool(OpKernelContext* context, Tensor* output,\n                     const Tensor& input, const PoolParameters& params,\n                     const Padding& padding) {\n+  if (output->NumElements() == 0) {\n+    return;\n+  }\n   typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n       ConstEigenMatrixMap;\n   typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>"