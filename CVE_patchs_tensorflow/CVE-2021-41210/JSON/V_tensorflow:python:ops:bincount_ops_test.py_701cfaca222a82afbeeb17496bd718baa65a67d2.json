"# Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# maxlengthations under the License.\n# ==============================================================================\n\"\"\"Tests for bincount ops.\"\"\"\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import bincount_ops\nfrom tensorflow.python.ops import gen_count_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.ops.ragged import ragged_factory_ops\nfrom tensorflow.python.ops.ragged import ragged_tensor\nfrom tensorflow.python.platform import test\n\n\nclass TestSparseCount(test.TestCase, parameterized.TestCase):\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\": \"_no_maxlength\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 6]\n      }, {\n          \"testcase_name\": \"_maxlength\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [1, 1, 1, 1, 2],\n          \"expected_shape\": [2, 7]\n      }, {\n          \"testcase_name\": \"_minlength\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 9]\n      }, {\n          \"testcase_name\": \"_minlength_larger_values\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 8]\n      }, {\n          \"testcase_name\": \"_no_maxlength_binary\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 6],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_maxlength_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 7],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_minlength_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 9],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_minlength_larger_values_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 8],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_no_maxlength_weights\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [2, 1, 0.5, 9, 3],\n          \"expected_shape\": [2, 6],\n          \"weights\": [[0.5, 1, 2], [3, 4, 5]]\n      }, {\n          \"testcase_name\": \"_maxlength_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [2, 1, 0.5, 3, 9],\n          \"expected_shape\": [2, 7],\n          \"weights\": [[0.5, 1, 2, 11], [7, 3, 4, 5]]\n      }, {\n          \"testcase_name\": \"_minlength_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],\n          \"expected_shape\": [2, 9],\n          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]\n      }, {\n          \"testcase_name\": \"_minlength_larger_values_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],\n          \"expected_shape\": [2, 8],\n          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]\n      }, {\n          \"testcase_name\": \"_1d\",\n          \"x\": np.array([3, 2, 1, 1], dtype=np.int32),\n          \"expected_indices\": [[1], [2], [3]],\n          \"expected_values\": [2, 1, 1],\n          \"expected_shape\": [4]\n      }, {\n          \"testcase_name\": \"_all_axes\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[1], [2], [3], [4], [5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\": None\n      })\n  def test_dense_input(self,\n                       x,\n                       expected_indices,\n                       expected_values,\n                       expected_shape,\n                       minlength=None,\n                       maxlength=None,\n                       binary_output=False,\n                       weights=None,\n                       axis=-1):\n    y = bincount_ops.sparse_bincount(\n        x,\n        weights=weights,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\":\n              \"_no_maxlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [3, 6],\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n      },\n      {\n          \"testcase_name\":\n              \"_no_maxlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1],\n          \"expected_shape\": [3, 6],\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_no_maxlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 7, 10],\n          \"expected_shape\": [3, 6],\n          \"weights\":\n              np.array([[6, 0, 2, 0], [0, 0, 0, 0], [10, 0, 3.5, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 7, 10],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [0, 0, 14, 0], [10, 0, 3.5, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 14, 6.5, 10],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 14, 6.5, 10],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),\n      },\n      {\n          \"testcase_name\": \"_1d\",\n          \"x\": np.array([3, 0, 1, 1], dtype=np.int32),\n          \"expected_indices\": [[1], [3]],\n          \"expected_values\": [2, 1],\n          \"expected_shape\": [4],\n      },\n      {\n          \"testcase_name\":\n              \"_all_axes\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[1], [3], [4], [5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\":\n              None,\n      },\n  )\n  def test_sparse_input(self,\n                        x,\n                        expected_indices,\n                        expected_values,\n                        expected_shape,\n                        maxlength=None,\n                        minlength=None,\n                        binary_output=False,\n                        weights=None,\n                        axis=-1):\n    x_sparse = sparse_ops.from_dense(x)\n    w_sparse = sparse_ops.from_dense(weights) if weights is not None else None\n    y = bincount_ops.sparse_bincount(\n        x_sparse,\n        weights=w_sparse,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\": \"_no_maxlength\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 6],\n      },\n      {\n          \"testcase_name\": \"_maxlength\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 7],\n      },\n      {\n          \"testcase_name\": \"_minlength\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 9],\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 8],\n      },\n      {\n          \"testcase_name\": \"_no_maxlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 6],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_maxlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 7],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_minlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 9],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"binary_output\": True,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 8],\n      },\n      {\n          \"testcase_name\": \"_no_maxlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],\n          \"expected_shape\": [5, 6],\n          \"weights\": [[], [], [6, 0.5, 2], [], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_maxlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],\n          \"expected_shape\": [5, 7],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_minlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],\n          \"expected_shape\": [5, 9],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],\n          \"expected_shape\": [5, 8],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_1d\",\n          \"x\": [3, 0, 1, 1],\n          \"expected_indices\": [[0], [1], [3]],\n          \"expected_values\": [1, 2, 1],\n          \"expected_shape\": [4],\n      },\n      {\n          \"testcase_name\": \"_all_axes\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[0], [1], [3], [4], [5]],\n          \"expected_values\": [2, 1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\": None,\n      },\n  )\n  def test_ragged_input(self,\n                        x,\n                        expected_indices,\n                        expected_values,\n                        expected_shape,\n                        maxlength=None,\n                        minlength=None,\n                        binary_output=False,\n                        weights=None,\n                        axis=-1):\n    x_ragged = ragged_factory_ops.constant(x)\n    w = ragged_factory_ops.constant(weights) if weights is not None else None\n    y = bincount_ops.sparse_bincount(\n        x_ragged,\n        weights=w,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n\nclass TestDenseBincount(test.TestCase, parameterized.TestCase):\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_count(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n\n    np_out = np.bincount(inp_vals, minlength=size)\n    self.assertAllEqual(\n        np_out, self.evaluate(bincount_ops.bincount(sparse_inp, axis=0)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_count_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n    weight_vals = np.random.random((n_elems,))\n    sparse_weights = sparse_tensor.SparseTensor(inp_indices, weight_vals,\n                                                [num_rows, 1])\n\n    np_out = np.bincount(inp_vals, minlength=size, weights=weight_vals)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(\n            sparse_inp, sparse_weights, axis=0)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_binary(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 10\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n\n    np_out = np.ones((size,))\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(sparse_inp, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_col_reduce_count(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,\n                                              inp_sparse.values - 1,\n                                              inp_sparse.dense_shape)\n    self.assertAllEqual(\n        np_out, self.evaluate(bincount_ops.bincount(arr=inp_sparse, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_col_reduce_binary(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate([\n            np.where(np.bincount(inp[j, :], minlength=size) > 0, 1, 0)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,\n                                              inp_sparse.values - 1,\n                                              inp_sparse.dense_shape)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            bincount_ops.bincount(arr=inp_sparse, axis=-1, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n                                    dtype)\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 2, 1]]\n    # pyformat: enable\n    self.assertAllEqual(expected_output,\n                        self.evaluate(bincount_ops.bincount(arr=x, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_binary(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 1, 1]]\n    # pyformat: enable\n    self.assertAllEqual(\n        expected_output,\n        self.evaluate(\n            bincount_ops.bincount(arr=x, axis=-1, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_with_weights(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    weights = ragged_factory_ops.constant([[], [], [.1, .2, .3], [],\n                                           [.2, .5, .6, .3]])\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [.2, .3, 0, .1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [.5, 0, 0, 0, .9, .2]]\n    # pyformat: enable\n    self.assertAllClose(\n        expected_output,\n        self.evaluate(bincount_ops.bincount(arr=x, weights=weights, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_np(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(arr=x, minlength=size, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_np_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_weight = np.random.random((num_rows, num_cols))\n    np_out = np.reshape(\n        np.concatenate([\n            np.bincount(inp[j, :], weights=np_weight[j, :], minlength=size)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    weights = ragged_tensor.RaggedTensor.from_tensor(np_weight)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            bincount_ops.bincount(\n                arr=x, weights=weights, minlength=size, axis=-1)))\n\n\nclass TestSparseCountFailureModes(test.TestCase):\n\n  def test_dense_input_sparse_weights_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_dense_input_ragged_weights_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_dense_input_wrong_shape_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = np.array([[3, 2], [5, 4], [4, 3]])\n    # Note: Eager mode and graph mode throw different errors here. Graph mode\n    # will fail with a ValueError from the shape checking logic, while Eager\n    # will fail with an InvalidArgumentError from the kernel itself.\n    if context.executing_eagerly():\n      with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                  \"must have the same shape\"):\n        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n    else:\n      with self.assertRaisesRegex(ValueError, \"both shapes must be equal\"):\n        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_dense_weights_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_ragged_weights_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_wrong_indices_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 1, 0, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same indices\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_too_many_indices_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 1, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesIncompatibleShapesError():\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_wrong_shape_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4], [0, 0, 0, 0]],\n                 dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same dense shape\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_dense_weights_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_sparse_weights_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_different_shape_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same row splits\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n\n@test_util.run_all_in_graph_and_eager_modes\n@test_util.disable_tfrt\nclass RawOpsTest(test.TestCase, parameterized.TestCase):\n\n  def testSparseCountSparseOutputBadIndicesShape(self):\n    indices = [[[0], [0]], [[0], [1]], [[1], [0]], [[1], [2]]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4, 6]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Input indices must be a 2-dimensional tensor\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testSparseCountSparseOutputBadWeightsShape(self):\n    indices = [[0, 0], [0, 1], [1, 0], [1, 2]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Weights and values must have the same shape\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testSparseCountSparseOutputBadNumberOfValues(self):\n    indices = [[0, 0], [0, 1], [1, 0]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4, 6]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        \"Number of values must match first dimension of indices\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutput(self):\n    splits = [0, 4, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    output_indices, output_values, output_shape = self.evaluate(\n        gen_count_ops.RaggedCountSparseOutput(\n            splits=splits, values=values, weights=weights, binary_output=False))\n    self.assertAllEqual([[0, 1], [0, 2], [1, 2], [1, 5], [1, 10]],\n                        output_indices)\n    self.assertAllEqual([7, 3, 5, 7, 6], output_values)\n    self.assertAllEqual([2, 11], output_shape)\n\n  def testRaggedCountSparseOutputBadWeightsShape(self):\n    splits = [0, 4, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Weights and values must have the same shape\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputEmptySplits(self):\n    splits = []\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        \"Must provide at least 2 elements for the splits argument\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputBadSplitsStart(self):\n    splits = [1, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Splits must start with 0\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputBadSplitsEnd(self):\n    splits = [0, 5]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Splits must end with the number of values\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n\nif __name__ == \"__main__\":\n  test.main()"