"# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n# pylint: disable=unidiomatic-typecheck\n\"\"\"Defun decorator for defining graph-mode functions.\"\"\"\n\nimport collections\nimport functools\nimport itertools\nimport pprint\nimport threading\nimport types as types_lib\nimport weakref\n\nimport numpy as np\nimport six\nfrom six.moves import map\n\nfrom tensorflow.core.framework import attr_value_pb2\nfrom tensorflow.core.framework import function_pb2\nfrom tensorflow.python import pywrap_tfe\nfrom tensorflow.python.client import pywrap_tf_session\nfrom tensorflow.python.eager import backprop\nfrom tensorflow.python.eager import backprop_util\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.eager import execute\nfrom tensorflow.python.eager import forwardprop_util\nfrom tensorflow.python.eager import function_trace_type\nfrom tensorflow.python.eager import monitoring\nfrom tensorflow.python.eager import tape\nfrom tensorflow.python.eager.graph_only_ops import graph_placeholder\nfrom tensorflow.python.framework import c_api_util\nfrom tensorflow.python.framework import composite_tensor\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import device as pydev\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import error_interpolation\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import func_graph as func_graph_module\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import tensor_shape\nfrom tensorflow.python.framework import tensor_spec\nfrom tensorflow.python.framework import type_spec\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import default_gradient\nfrom tensorflow.python.ops import functional_ops\nfrom tensorflow.python.ops import gradients_util\nfrom tensorflow.python.ops import handle_data_util\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.platform import tf_logging as logging\nfrom tensorflow.python.profiler import trace\nfrom tensorflow.python.saved_model import save_context\nfrom tensorflow.python.types import core\nfrom tensorflow.python.util import _pywrap_utils\nfrom tensorflow.python.util import compat\nfrom tensorflow.python.util import function_utils\nfrom tensorflow.python.util import lazy_loader\nfrom tensorflow.python.util import memory\nfrom tensorflow.python.util import nest\nfrom tensorflow.python.util import object_identity\nfrom tensorflow.python.util import tf_decorator\nfrom tensorflow.python.util import tf_inspect\nfrom tensorflow.python.util.tf_export import tf_export\n\n# Loaded lazily due to a circular dependency (roughly\n# tf.function->autograph->->dataset->tf.function).\n# TODO(b/133251390): Use a regular import.\nag_ctx = lazy_loader.LazyLoader(\n    \"ag_ctx\", globals(),\n    \"tensorflow.python.autograph.core.ag_ctx\")\nnp_arrays = lazy_loader.LazyLoader(\n    \"np_arrays\", globals(),\n    \"tensorflow.python.ops.numpy_ops.np_arrays\")\n\n\nFORWARD_FUNCTION_ATTRIBUTE_NAME = \"forward_function_name\"\nBACKWARD_FUNCTION_ATTRIBUTE_NAME = \"backward_function_name\"\nIMPLEMENTS_ATTRIBUTE_NAME = \"_implements\"\nSHARED_RENDEZVOUS_ATTRIBUTE_NAME = \"shared_rendezvous\"\n# A temporary flag. Turning this on will allow tf.function to aggressively avoid\n# retracing ResourceVariable inputs. This feature will change tf.function's\n# Variable tracing behavior, hence we want to limit the potential blockers that\n# are not detected by Global TAP.\n# TODO(jiaweix): remove this flag and related args (b/198782192)\nENCODE_VARIABLES_BY_RESOURCE_ID = True\n# TODO(b/201533914): Remove this flag and related args\nUSE_FULL_TRACE_TYPE = False\n\n_graph_building_time_counter = monitoring.Counter(\n    \"/tensorflow/core/tf_function/graph_building_time_usecs\",\n    \"Time for tf.function to build a graph (us).\")\n\n\nCacheKey = collections.namedtuple(\"CacheKey\", [\n    \"input_signature\",\n    \"parent_graph\",\n    \"device_functions\",\n    \"colocation_stack\",\n    \"in_cross_replica_context\",\n    \"variable_policy\",\n    \"xla_context_id\",\n])\n\n\ndef _type_spec_for(x):\n  \"\"\"Returns a TypeSpec for `x`, or `None` if `x` doesn't have a TensorSpec.\"\"\"\n  if isinstance(x, ops.Tensor):\n    return tensor_spec.TensorSpec.from_tensor(x)\n  elif isinstance(x, type_spec.TypeSpec):\n    return x\n  elif isinstance(x, composite_tensor.CompositeTensor):\n    return x._type_spec  # pylint: disable=protected-access\n  else:\n    return None\n\n\ndef _is_type_subset(a, b):\n  \"\"\"Returns true if TypeSpec `b` is a subset of type `a` (or if a is None.)\"\"\"\n  if a is None:\n    return True\n  else:\n    return a.most_specific_compatible_type(b) == a\n\n\ndef _shape_relaxed_type_for_composite_tensor(x):\n  \"\"\"Returns a shape-relaxed TypeSpec for x (if composite) or x (if not).\"\"\"\n  if isinstance(x, composite_tensor.CompositeTensor):\n    # pylint: disable=protected-access\n    return x._type_spec._with_tensor_ranks_only()\n  else:\n    return x\n\n\ndef common_shape(x, y):\n  \"\"\"Find a `TensorShape` that is compatible with both `x` and `y`.\"\"\"\n  if x is None != y is None:\n    raise RuntimeError(\n        \"Cannot find a common shape when LHS shape is None but RHS shape \"\n        f\"is not (or vice versa): {x} vs. {y}.\")\n  if x is None:\n    return None  # The associated input was not a Tensor, no shape generated.\n  if not isinstance(x, tensor_shape.TensorShape):\n    raise TypeError(f\"`x` must be a TensorShape, got type {type(x)}.\")\n  if not isinstance(y, tensor_shape.TensorShape):\n    raise TypeError(f\"`y` must be a TensorShape, got type {type(y)}.\")\n  if x.rank != y.rank or x.rank is None:\n    return tensor_shape.TensorShape(None)\n  dims = []\n  for dim_x, dim_y in zip(x.dims, y.dims):\n    if (dim_x != dim_y\n        or tensor_shape.dimension_value(dim_x) is None\n        or tensor_shape.dimension_value(dim_y) is None):\n      dims.append(None)\n    else:\n      dims.append(tensor_shape.dimension_value(dim_x))\n  return tensor_shape.TensorShape(dims)\n\n\ndef is_same_structure(structure1,\n                      structure2,\n                      check_values=False):\n  \"\"\"Check two structures for equality, optionally of types and of values.\"\"\"\n  try:\n    nest.assert_same_structure(structure1, structure2, expand_composites=True)\n  except (ValueError, TypeError):\n    return False\n  if check_values:\n    flattened1 = nest.flatten(structure1, expand_composites=True)\n    flattened2 = nest.flatten(structure2, expand_composites=True)\n    # First check the types to avoid AttributeErrors.\n    if any(type(f1) != type(f2) for f1, f2 in zip(flattened1, flattened2)):\n      return False\n    return flattened1 == flattened2\n  return True\n\n\ndef _parse_func_attrs(attributes):\n  \"\"\"Convert the keyword arguments into function_def attributes.\n\n  Currently only support primitive types: bool, int, float and string.\n\n  Args:\n    attributes: the dictionary of attributes.\n  Returns:\n    A dict of attributes where the key is the name of attribute and the value\n      is the AttrValue proto.\n  Raises:\n    ValueError: If the kwargs contains unallowlisted name or unsupported value\n      types.\n  \"\"\"\n  attrs = {}\n  for key, value in attributes.items():\n    if isinstance(value, attr_value_pb2.AttrValue):\n      attrs[key] = value\n    # bool type check has to happen before int since bool is a subclass of int.\n    elif isinstance(value, bool):\n      attrs[key] = attr_value_pb2.AttrValue(b=value)\n    elif isinstance(value, int):\n      attrs[key] = attr_value_pb2.AttrValue(i=value)\n    elif isinstance(value, float):\n      attrs[key] = attr_value_pb2.AttrValue(f=value)\n    elif isinstance(value, (str, bytes, six.text_type)):\n      attrs[key] = attr_value_pb2.AttrValue(s=compat.as_bytes(value))\n    else:\n      raise ValueError(f\"Attribute {key} must be bool, int, float, string, or \"\n                       f\"AttrValue. Got {type(value)}.\")\n  return attrs\n\n\nclass _InterpolateFunctionError(object):\n  \"\"\"Context Manager that interpolates the exception from 'top_level_func'.\"\"\"\n\n  __slots__ = [\"_func\"]\n\n  def __init__(self, top_level_func):\n    self._func = top_level_func\n\n  def __enter__(self):\n    pass\n\n  def __exit__(self, typ, exc, tb):\n    if not exc or not isinstance(exc, errors.OpError):\n      return False\n    message = compat.as_text(exc.message)\n    _, tags = error_interpolation.parse_message(message)\n    g = None\n    func_stack = []\n    for t in tags:\n      if t.type == \"function_node\":\n        # TODO(mdan): Tests should cover this.\n        if t.name == compat.as_str(self._func.name):\n          g = self._func.graph\n        elif g:\n          next_func = g._get_function(t.name)  # pylint: disable=protected-access\n          if next_func is not None and isinstance(next_func,\n                                                  _EagerDefinedFunction):\n            g = next_func.graph\n        if g:\n          func_stack.append(g.name)\n        else:\n          func_stack.append(\"<unknown>\")\n    if g:\n      message = error_interpolation.interpolate(message, g)\n      if len(func_stack) >= 2:\n        message += \"\\n\\nFunction call stack:\\n\"\n        message += \" -> \".join(func_stack)\n        message += \"\\n\"\n      exc._message = message  # pylint: disable=protected-access\n    return False\n\n\n_function_callbacks = set()\n\n\ndef add_function_callback(function_callback):\n  \"\"\"Add a callback function for Function creation.\n\n  The callback function has the signature:\n\n    `def function_callback(function, name, graph, inputs, outputs):`\n\n  where:\n  - `function`: _EagerDefinedFunction being created before finalizing the graph.\n      Do not modify the function directly but instead modify the graph.\n  - `name`: name of the function.\n  - `graph`: Graph of the function.\n  - `inputs`: `tuple` of tensors used as inputs to the function.\n  - `outputs`: `tuple` of tensors used as outputs from the function.\n\n  The callback is at the top of the `_EagerDefinedFunction` construction, giving\n  callback an opportunity to make the last edits to the graph. Do not make\n  changes to `graph, inputs`, and `outputs` manually, but, instead, set the\n  `graph` as the default then define ops.\n\n  Repeated registration of the same callback function is idempotent.\n  After a callback is added, it can be removed with the\n  `remove_function_callback()` method.\n\n  Args:\n    function_callback: The callback to add.\n  \"\"\"\n  _function_callbacks.add(function_callback)\n\n\ndef remove_function_callback(function_callback):\n  \"\"\"Remove an already-added function callback.\n\n  See the doc string of `add_function_callback()` for more information.\n\n  Args:\n    function_callback: The callback to remove.\n  \"\"\"\n  _function_callbacks.remove(function_callback)\n\n\ndef clear_function_callbacks():\n  \"\"\"Clear all function callbacks, if any have been regisered.\"\"\"\n  _function_callbacks.clear()\n\n\n_FORWARD_PREFIX = \"__forward_\"\n_BACKWARD_PREFIX = \"__backward_\"\n_INFERENCE_PREFIX = \"__inference_\"\n\n\ndef _forward_name(n):\n  \"\"\"The name of a generated forward defun named n.\"\"\"\n  return \"%s%s_%s\" % (_FORWARD_PREFIX, n, ops.uid())\n\n\ndef _backward_name(n):\n  \"\"\"The name of a generated backward defun named n.\"\"\"\n  return \"%s%s_%s\" % (_BACKWARD_PREFIX, n, ops.uid())\n\n\ndef _inference_name(n):\n  \"\"\"The name of a forward-but-no-gradient defun named n.\"\"\"\n  return \"%s%s_%s\" % (_INFERENCE_PREFIX, n, ops.uid())\n\n\ndef _enclosing_xla_context():\n  \"\"\"Returns the XLAControlFlowContext, which exists inside a tpu.rewrite().\"\"\"\n  graph = ops.get_default_graph()\n  while graph is not None:\n    # pylint: disable=protected-access\n    context_ = graph._get_control_flow_context()\n    # pylint: enable=protected-access\n    while context_ is not None:\n      if isinstance(context_, control_flow_ops.XLAControlFlowContext):\n        return context_\n      context_ = context_.outer_context\n    # This may be a FuncGraph due to defuns or v2 control flow. We need to\n    # find the original graph with the XLAControlFlowContext.\n    graph = getattr(graph, \"outer_graph\", None)\n  return None\n\n\nclass _EagerDefinedFunctionDeleter(object):\n  \"\"\"Unregister function from eager context.\"\"\"\n\n  __slots__ = [\"name\"]\n\n  def __init__(self, name):\n    self.name = name\n\n  def __del__(self):\n    try:\n      context.remove_function(self.name)\n    except TypeError:\n      # Suppress some exceptions, mainly for the case when we're running on\n      # module deletion. Things that can go wrong include the context module\n      # already being unloaded, self._handle._handle_data no longer being\n      # valid, and so on. Printing warnings in these cases is silly\n      # (exceptions raised from __del__ are printed as warnings to stderr).\n      pass  # 'NoneType' object is not callable when the handle has been\n      # partially unloaded.\n    except AttributeError:\n      pass  # 'NoneType' object has no attribute 'eager_mode' when context has\n      # been unloaded. Will catch other module unloads as well.\n\n\nclass FunctionAlreadyGarbageCollectedError(Exception):\n\n  def __init__(self, function_name):\n    super(FunctionAlreadyGarbageCollectedError, self).__init__(\n        \"{} has already been garbage collected and cannot be called.\".format(\n            function_name))\n\n\n# TODO(apassos) get rid of this by splitting framework.function._DefinedFunction\n# so it doesn't have the definition-generating logic and is just a container for\n# an already-defined function.\nclass _EagerDefinedFunction(object):\n  \"\"\"Callable with the interface of `framework.function._DefinedFunction`.\n\n  `_EagerDefinedFunction` encapsulates a function definition and its properties,\n  and it provides a method for calling the encapsulated function. Some Ops\n  take functions as attributes, which have type `func`; an instance of this\n  class may be provided as the value of these `func` attributes.\n  \"\"\"\n\n  def __init__(self, name, graph, inputs, outputs, attrs):\n    \"\"\"Initializes an eager defined function.\n\n    Args:\n      name: str, the name for the created function.\n      graph: Graph, the graph containing the operations in the function\n      inputs: the tensors in the graph to be used as inputs to the function\n      outputs: the tensors in the graph which will be outputs from the function\n      attrs: dict mapping names of attributes to their AttrValue values\n    \"\"\"\n    for function_callback in _function_callbacks:\n      function_callback(self, name, graph, tuple(inputs), tuple(outputs))\n\n    input_ops = set(arg.op for arg in inputs)\n    operations = [op for op in graph.get_operations() if op not in input_ops]\n\n    graph_output_names = graph._output_names  # pylint: disable=protected-access\n    if (graph_output_names is not None and\n        all(ops.tensor_id(t) in graph_output_names for t in outputs)):\n      output_names = [\n          compat.as_bytes(graph_output_names[ops.tensor_id(t)]) for t in outputs\n      ]\n      if len(set(output_names)) != len(output_names):\n        # There are duplicate names for some reason, probably an invalid\n        # signature. Revert to auto-naming.\n        output_names = []\n    else:\n      output_names = []\n    fn = pywrap_tf_session.TF_GraphToFunction_wrapper(\n        graph._c_graph,  # pylint: disable=protected-access\n        compat.as_str(name),\n        False,\n        [o._c_op for o in operations],  # pylint: disable=protected-access\n        [t._as_tf_output() for t in inputs],  # pylint: disable=protected-access\n        [t._as_tf_output() for t in outputs],  # pylint: disable=protected-access\n        output_names,\n        [o._c_op for o in graph.control_outputs],  # pylint: disable=protected-access\n        [],  # control_output_names\n        None,\n        compat.as_str(\"\"))\n\n    for name, attr_value in attrs.items():\n      serialized = attr_value.SerializeToString()\n      # TODO(iga): this creates and deletes a new TF_Status for every attr.\n      # It might be worth creating a convenient way to re-use status.\n      pywrap_tf_session.TF_FunctionSetAttrValueProto(fn, compat.as_str(name),\n                                                     serialized)\n\n    # TODO(apassos) avoid creating a FunctionDef (specially to grab the\n    # signature, but also in general it's nice not to depend on it.\n    with c_api_util.tf_buffer() as buffer_:\n      pywrap_tf_session.TF_FunctionToFunctionDef(fn, buffer_)\n      proto_data = pywrap_tf_session.TF_GetBuffer(buffer_)\n    function_def = function_pb2.FunctionDef()\n    function_def.ParseFromString(compat.as_bytes(proto_data))\n    self._name = compat.as_bytes(function_def.signature.name)\n    with ops.init_scope():\n      if context.executing_eagerly():\n        context.ensure_initialized()\n        context.add_function(fn)\n        self._function_deleter = _EagerDefinedFunctionDeleter(self.name)\n        self._registered_on_context = True\n    self.definition = function_def\n    self.signature = function_def.signature\n    self._num_outputs = len(self.signature.output_arg)\n    self._output_types = [o.type for o in self.signature.output_arg]\n    self._output_shapes = [o.shape for o in outputs]\n    self._control_captures = graph.control_captures\n    # Shallow copy outputs since ConcreteFunction may mutate it.\n    self._func_graph_outputs = list(outputs)\n    self.grad_func_name = None\n    self.python_grad_func = None\n    self._c_func = c_api_util.ScopedTFFunction(fn)\n    self._grad_func = None\n    self.graph = graph\n    self._stateful_ops = tuple(op for op in operations if op._is_stateful)  # pylint: disable=protected-access\n\n  def add_to_graph(self, g=None):\n    \"\"\"Add the function to the current context or a graph, if supplied.\n\n    Args:\n      g: the graph to add the function to. If not supplied, the function will\n        be added to the current context.\n    \"\"\"\n    # pylint: disable=protected-access\n    if not g and context.executing_eagerly():\n      ctx = context.context()\n      if not ctx.has_function(self.name):\n        ctx.add_function_def(self.definition)\n    else:\n      if not g._is_function(self.name):\n        g._add_function(self)\n      for f in self.graph._functions.values():\n        if not g._is_function(f.name):\n          g._add_function(f)\n    # pylint: enable=protected-access\n\n  @property\n  def name(self):\n    return self._name\n\n  @property\n  def stateful_ops(self):\n    return self._stateful_ops\n\n  def call(self, ctx, args, cancellation_manager=None):\n    \"\"\"Calls this function with `args` as inputs.\n\n    `ConcreteFunction` execution respects device annotations only if the\n    function won't be compiled with xla.\n\n    Args:\n      ctx: a Context object\n      args: a list of arguments to supply this function with.\n      cancellation_manager: a `CancellationManager` object that can be used to\n        cancel function execution.\n\n    Returns:\n      The outputs of the function call.\n\n    Raises:\n      ValueError: if the number of arguments is incorrect.\n      FunctionAlreadyGarbageCollectedError: if the function is no longer\n        available to be called because it has been garbage collected.\n    \"\"\"\n    if len(args) != len(self.signature.input_arg):\n      raise ValueError(\n          f\"Signature specifies {len(list(self.signature.input_arg))} \"\n          f\"arguments, got: {len(args)}.\")\n\n    # If the `ScopedTFFunction` (accessed via `_c_func`) has already been\n    # cleaned up as a part of garbage collection, this `_EagerDefinedFunction`\n    # should also be garbage and is likely being called as part of a `__del__`\n    # elsewhere. In that case, there's nothing we can do, so we raise an\n    # exception for the caller to handle.\n    if self._c_func.has_been_garbage_collected:\n      raise FunctionAlreadyGarbageCollectedError(self.name)\n\n    function_call_options = ctx.function_call_options\n    if function_call_options.config_proto_serialized is None:\n      config = function_utils.get_disabled_rewriter_config()\n    else:\n      config = function_call_options.config_proto_serialized\n    executor_type = function_call_options.executor_type or \"\"\n\n    executing_eagerly = ctx.executing_eagerly()\n    attrs = (\"executor_type\", executor_type, \"config_proto\", config)\n    if executing_eagerly:\n      with _InterpolateFunctionError(self):\n        if cancellation_manager is None:\n          outputs = execute.execute(\n              str(self.signature.name),\n              num_outputs=self._num_outputs,\n              inputs=args,\n              attrs=attrs,\n              ctx=ctx)\n        else:\n          outputs = execute.execute_with_cancellation(\n              str(self.signature.name),\n              num_outputs=self._num_outputs,\n              inputs=args,\n              attrs=attrs,\n              ctx=ctx,\n              cancellation_manager=cancellation_manager)\n      # Replace empty list with None\n      outputs = outputs or None\n    else:\n      # TODO(akshayka): Either remove this if the FunctionLibraryRuntime\n      # creates `PartitionedCallOp` kernels by default, or remove the previous\n      # branch if a TPU kernel is registered for `PartitionedCall`.\n      with _InterpolateFunctionError(self):\n        with ops.control_dependencies(self._control_captures):\n          # The caller must use record_operation to record this operation in the\n          # eager case, so we enforce the same requirement for the non-eager\n          # case by explicitly pausing recording. We don't have a gradient\n          # registered for PartitionedCall, so recording this operation confuses\n          # forwardprop code (GradientTape manages to ignore it).\n          with tape.stop_recording():\n            outputs = functional_ops.partitioned_call(\n                args=args,\n                f=self,\n                tout=self._output_types,\n                executing_eagerly=executing_eagerly,\n                config=config,\n                executor_type=executor_type)\n\n    for i, func_graph_output in enumerate(self._func_graph_outputs):\n      handle_data_util.copy_handle_data(func_graph_output, outputs[i])\n    if executing_eagerly:\n      return outputs\n    else:\n      # TODO(b/128924522): This additional set_shape should not be\n      # necessary. ShapeRefiner likely needs to inspect handle_data. Remove this\n      # once that's done.\n      for i, shape in enumerate(self._output_shapes):\n        outputs[i].set_shape(shape)\n      return outputs\n\n\ndef _create_forward_backward_with_graph(attrs, forward_graph, backwards_graph):\n  \"\"\"Creates forward and backward functions from the function graphs.\"\"\"\n  forward_function_name = _forward_name(forward_graph.name)\n  common_attributes = dict(attrs)\n  # NB: forward and backward function need to drop \"_implements\".\n  # attribute, because their signature contains all the intermediate tensors\n  # that they compute. Thus they don't have a stable signature which can\n  # be directly optimized downstream.\n  # See for more details:\n  # https://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.md#appendix-future-support-for-optimizing-gradient-functions\n  common_attributes.pop(IMPLEMENTS_ATTRIBUTE_NAME, None)\n  backward_function_attr = _parse_func_attrs(\n      {FORWARD_FUNCTION_ATTRIBUTE_NAME: forward_function_name})\n  backward_function_attr.update(common_attributes)\n  backward_function = ConcreteFunction(\n      backwards_graph, attrs=backward_function_attr)\n  forward_function_attr = _parse_func_attrs({\n      BACKWARD_FUNCTION_ATTRIBUTE_NAME:\n      backward_function.name})\n  forward_function_attr.update(common_attributes)\n  forward_function = _EagerDefinedFunction(\n      forward_function_name, forward_graph, forward_graph.inputs,\n      forward_graph.outputs, forward_function_attr)\n  return forward_function, backward_function\n\n\nclass _DelayedRewriteGradientFunctions(object):\n  \"\"\"Caches forward/backward functions with a delayed forward rewrite.\"\"\"\n\n  def __init__(self, func_graph, attrs, func_graph_deleter):\n    \"\"\"Construct an inference function and initialize caches.\"\"\"\n    # A map from the number of forward function outputs with accepted gradients\n    # to forward and backward functions, used to cache non-tape backward\n    # function generation.\n    self._cached_function_pairs = {}\n    self._func_graph = func_graph\n    self._inference_function = _EagerDefinedFunction(\n        _inference_name(self._func_graph.name), self._func_graph,\n        self._func_graph.inputs, self._func_graph.outputs, attrs)\n    self._attrs = attrs\n    self._gradient_name = None\n    # Note that the FuncGraph is mutated later, so we need to inspect it now to\n    # figure out the user-specified outputs of the inference function.\n    self._num_inference_outputs = len(self._func_graph.outputs)\n    self._func_graph_deleter = func_graph_deleter\n\n  def forward_backward(self, num_doutputs=None):\n    \"\"\"A possibly-cached pair of forward and backward functions.\"\"\"\n    if num_doutputs is None:\n      num_doutputs = self._num_inference_outputs\n    forward_backward = self._cached_function_pairs.get(num_doutputs)\n    if forward_backward is not None:\n      return forward_backward\n    forward, backward = self._construct_forward_backward(num_doutputs)\n    self._cached_function_pairs[num_doutputs] = (forward, backward)\n    return forward, backward\n\n  def _construct_forward_backward(self, num_doutputs):\n    \"\"\"Constructs a pair of forward and backward functions.\n\n    Args:\n      num_doutputs: The constructed backprop function will take output gradients\n        for the first `num_doutputs` outputs of the forward function. Defaults\n        to the number of outputs for the inference function, but when\n        higher-order gradients are computed this will increase to include side\n        outputs.\n\n    Returns:\n      A pair of (forward_function, backward_function):\n        forward_function: A re-generated inference function (an\n          _EagerDefinedFunction) to account for new side outputs, if any extra\n          were required when building the backward pass.\n        backward_function: A ConcreteFunction that Takes `num_doutputs`\n          arguments and returns gradients with respect to inputs of the forward\n          function.\n    \"\"\"\n    trainable_outputs = [\n        output for output in self._func_graph.outputs[:num_doutputs]\n        if backprop_util.IsTrainable(output)]\n\n    signature = []\n    for t in trainable_outputs:\n      signature.append(\n          tensor_spec.TensorSpec(*default_gradient.shape_and_dtype(t)))\n\n    def _backprop_function(*grad_ys):\n      with ops.device(None):\n        return gradients_util._GradientsHelper(  # pylint: disable=protected-access\n            trainable_outputs,\n            self._func_graph.inputs,\n            grad_ys=grad_ys,\n            src_graph=self._func_graph)\n\n    with self._func_graph.as_default():\n      backwards_graph = func_graph_module.FuncGraph(\n          _backward_name(self._func_graph.name))\n      func_graph_module.func_graph_from_py_func(\n          name=backwards_graph.name,\n          python_func=_backprop_function,\n          args=[], kwargs={},\n          signature=signature,\n          func_graph=backwards_graph)\n      backwards_graph_captures = backwards_graph.external_captures\n      captures_from_forward = [\n          c for c in backwards_graph_captures if\n          not isinstance(c, ops.EagerTensor) and c.graph is self._func_graph]\n\n      existing_outputs = object_identity.ObjectIdentitySet(\n          self._func_graph.outputs)\n      for capture in captures_from_forward:\n        if capture not in existing_outputs:\n          existing_outputs.add(capture)\n          self._func_graph.outputs.append(capture)\n\n      forward_function, backward_function = _create_forward_backward_with_graph(\n          self._attrs, self._func_graph, backwards_graph)\n      return forward_function, backward_function\n\n  def _rewrite_forward_and_call_backward(self, op, *doutputs):\n    \"\"\"Add outputs to the forward call and feed them to the grad function.\"\"\"\n    forward_function, backwards_function = self.forward_backward(len(doutputs))\n    if not backwards_function.outputs:\n      return backwards_function.structured_outputs\n    forward_function.add_to_graph(op.graph)\n\n    # pylint: disable=protected-access\n    # Rewrite an inference call op to be a forward call op\n    op._set_func_attr(\"f\", forward_function.name)\n    op._set_type_list_attr(\"Tout\", forward_function._output_types)\n    op._add_outputs(\n        forward_function._output_types[len(op.outputs):],\n        forward_function._output_shapes[len(op.outputs):])\n    for i in range(len(op.outputs)):\n      func_graph_output = forward_function._func_graph_outputs[i]\n      handle_data_util.copy_handle_data(func_graph_output, op.outputs[i])\n    # pylint: enable=protected-access\n\n    capture_mapping = dict(\n        zip((ops.tensor_id(t) for t in self._func_graph.outputs), op.outputs))\n    remapped_captures = [\n        capture_mapping.get(ops.tensor_id(capture), capture)\n        for capture in backwards_function.captured_inputs\n    ]\n\n    # Replace Nones with zeros since we're calling a graph function which\n    # expects numeric inputs.\n    cleaned_doutputs = []\n    for doutput, placeholder in zip(doutputs, self._func_graph.outputs):\n      if backprop_util.IsTrainable(placeholder):\n        if isinstance(doutput, ops.IndexedSlices):\n          # Gradient passed to a backward ConcreteFunction must be tf.Tensor,\n          # so we convert tf.IndexedSlices to tf.Tensor.\n          cleaned_doutputs.append(ops.convert_to_tensor(doutput))\n        elif doutput is not None:\n          cleaned_doutputs.append(doutput)\n        else:\n          cleaned_doutputs.append(default_gradient.zeros_like(placeholder))\n\n    # Compute the gradients using the side outputs\n    return backwards_function._call_flat(  # pylint: disable=protected-access\n        cleaned_doutputs, remapped_captures)\n\n  def get_gradient_function(self):\n    \"\"\"Returns gradient function.\n\n    The gradient rewrites an inference call op to a forward call op, but does\n    not modify a pre-existing forward call op. It then computes the gradient\n    from the output's gradients and the side outputs of the forward op.\n    \"\"\"\n    return self._rewrite_forward_and_call_backward\n\n  def forward(self, inference_args=None, input_tangents=None):\n    \"\"\"A forward function with only user-specified outputs.\n\n    The call operation for the returned inference function can be rewritten into\n    a forward function. This only happens if the backward function (from the\n    `backward` method) ends up being used to compute gradients.\n\n    This approach avoids constructing unnecessary graphs, but it only works if\n    we are calling this function when not executing eagerly.\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function. Unused, but taken for compatibility with\n        _TapeGradientFunctions.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`. Unused; if required, tape functions must be used\n        instead.\n\n    Returns:\n      An _EagerDefinedFunction.\n    \"\"\"\n    del inference_args  # unused\n    if input_tangents:\n      # This class does not support special-cased forwardprop. The arguments are\n      # here for compatibility with _TapeGradientFunctions.\n      raise errors.InternalError(\"unexpectedly got forwardprop information in \"\n                                 \"a class that does not support forwardprop.\")\n    return self._inference_function\n\n  def _backward(self, outputs):\n    \"\"\"Fetch a backward function for `outputs` from the forward function.\"\"\"\n    def _backward_function(*args):\n      call_op = outputs[0].op\n      return self._rewrite_forward_and_call_backward(call_op, *args)\n    return _backward_function, outputs\n\n  def record(self, flat_outputs, inference_args, input_tangents):\n    \"\"\"Record the function call operation.\n\n    _DelayedRewriteGradientFunctions supports only first-order backprop tape\n    gradients (and then only when graph building). It does not work with\n    higher-order tape gradients or forward autodiff, but does work with\n    higher-order symbolic gradients (tf.gradients).\n\n    Args:\n      flat_outputs: The result of running `forward`.\n      inference_args: A flat list of Tensors with inference inputs to the\n        operation.\n      input_tangents: A flat list of Tensors with input tangents consumed by the\n        operation.\n    \"\"\"\n    backward_function, to_record = self._backward(flat_outputs)\n    tape.record_operation(self._inference_function.signature.name,\n                          to_record, inference_args + input_tangents,\n                          backward_function)\n\n\n# Contains information about a forward function wrapped to compute jvps.\n_ForwardWrapper = collections.namedtuple(\n    \"_ForwardWrapper\", (\n        # The wrapper Graph.\n        \"graph\",\n        # A flat list of non-tangent Tensor outputs from the wrapped forward\n        # function.\n        \"outputs\",\n        # Indices for output tangents, same format as\n        # forwardprop_util.pack_tangents.\n        \"output_indices\",\n        # A flat list of tangents for `outputs`.\n        \"output_tangents\"))\n\n\nclass _TapeGradientFunctions(object):\n  \"\"\"Caches forward and backward functions compatible with eager gradients.\n\n  In contrast to the delayed-rewrite approach in\n  `_DelayedRewriteGradientFunctions` which only works with delayed execution,\n  the forward function generated by this class has a fixed set of outputs which\n  may be preserved by a tape in order to compute gradients later.\n\n  This class is abstract; its child classes differ in how many side outputs of\n  the forward function their backward function accepts gradients for, which\n  determines whether higher-order tape gradients are possible.\n  \"\"\"\n\n  def __init__(self, func_graph, attrs, func_graph_deleter,\n               forwardprop_input_indices, delayed_rewrite_functions,\n               need_gradients_for_jvps):\n    self._func_graph = func_graph\n    self._forward_graph = None\n    self._attrs = attrs\n    self._forward = None\n    self._backward = None\n    self._num_outputs = len(func_graph.outputs)\n    self._func_graph_deleter = func_graph_deleter\n    self._forwardprop_input_indices = forwardprop_input_indices\n    self._forwardprop_output_indices = None\n    self._num_forwardprop_outputs = 0\n    self._num_inference_outputs = len(func_graph.outputs)\n    self._num_trainable_inference_outputs = len(\n        [t for t in func_graph.outputs if backprop_util.IsTrainable(t)])\n    self._delayed_rewrite_functions = delayed_rewrite_functions\n    self._need_gradients_for_jvps = need_gradients_for_jvps\n\n  def _build_functions_for_outputs(\n      self, outputs, inference_args, input_tangents):\n    \"\"\"Forward+backward functions where the backward function sees `outputs`.\"\"\"\n    # First figure out which of `outputs` are trainable. We'll accept gradients\n    # for each of these in the backward function.\n    handles_to_variables = self._func_graph.variable_captures\n    trainable_outputs = []\n    trainable_indices = []\n    for index, output in enumerate(outputs):\n\n      if backprop_util.IsTrainable(output):\n        # Swap in the Variable object for resource handles if we can so\n        # sparse gradients work.\n        output = handles_to_variables.get(id(output), output)\n        trainable_outputs.append(output)\n        trainable_indices.append(index)\n\n    backwards_graph = func_graph_module.FuncGraph(\n        _backward_name(self._func_graph.name))\n    with backwards_graph.as_default():\n      gradients_wrt_outputs = []\n      for output in trainable_outputs:\n        gradient_shape, gradient_dtype = default_gradient.shape_and_dtype(\n            output)\n        gradient_placeholder = graph_placeholder(gradient_dtype, gradient_shape)\n        handle_data_util.copy_handle_data(output, gradient_placeholder)\n        gradients_wrt_outputs.append(gradient_placeholder)\n      with ops.device(None):\n        gradients_wrt_inputs = gradients_util._GradientsHelper(  # pylint: disable=protected-access\n            trainable_outputs,\n            self._func_graph.inputs,\n            grad_ys=gradients_wrt_outputs,\n            src_graph=self._func_graph)\n\n      if input_tangents:\n        # Convert IndexedSlices to dense tensors (as we do elsewhere for\n        # function gradients). Our C++ bindings don't know how to handle them\n        # currently.\n        gradients_wrt_inputs = nest.map_structure(\n            lambda x: ops.convert_to_tensor(x) if x is not None else None,\n            gradients_wrt_inputs)\n      captures_from_forward = [\n          c for c in backwards_graph.external_captures\n          if not isinstance(c, ops.EagerTensor) and c.graph is self._func_graph\n      ]\n      existing_outputs = object_identity.ObjectIdentitySet(\n          self._func_graph.outputs)\n      for capture in captures_from_forward:\n        if capture not in existing_outputs:\n          existing_outputs.add(capture)\n          self._func_graph.outputs.append(capture)\n\n    # The ordering of `backwards_graph.inputs` is important: inputs of\n    # `backward_function` correspond to outputs (including\n    # side outputs) of `self._tape_forward_function`.\n    backwards_graph.inputs = (\n        gradients_wrt_outputs + backwards_graph.internal_captures)\n    backwards_graph.outputs.extend(\n        grad\n        for grad in nest.flatten(gradients_wrt_inputs, expand_composites=True)\n        if grad is not None)\n    backwards_graph.structured_outputs = gradients_wrt_inputs\n\n    forward_function, backward_function = _create_forward_backward_with_graph(\n        self._attrs, self._func_graph, backwards_graph)\n\n    if not input_tangents:\n      # There is no need to special-case forwardprop, so we can return the\n      # forward+backward pair we've created without further wrapping.\n      return (forward_function, self._func_graph, backward_function,\n              # No forwardprop outputs.\n              None, 0)\n    forward_wrapper = self._wrap_forward_function_with_jvps(\n        forward_function, backward_function, inference_args, input_tangents)\n    (wrapped_backwards_graph,\n     forward_wrapper) = self._wrap_backward_function_with_jvp_backprop(\n         backward_function, gradients_wrt_outputs, forward_wrapper)\n    # Now that we've added new captures, we need to make sure forward outputs\n    # are in the same order the backward function expects them to be in:\n    # [inference outputs] + [jvps] + [side outputs] + [captures].\n    forward_wrapper = self._shuffle_forward_outputs(forward_wrapper)\n    (wrapped_forward_function,\n     wrapped_backward_function) = _create_forward_backward_with_graph(\n         self._attrs, forward_wrapper.graph, wrapped_backwards_graph)\n    if (len(inference_args) + len(input_tangents)\n        != len(forward_wrapper.graph.inputs)):\n      raise errors.InternalError(\n          f\"The forward graph had {len(forward_wrapper.graph.inputs)} inputs, \"\n          f\"but we expected {len(inference_args) + len(input_tangents)} \"\n          f\"({len(inference_args)} inference inputs and \"\n          f\"{len(input_tangents)} input tangents).\")\n    return (wrapped_forward_function, forward_wrapper.graph,\n            wrapped_backward_function, forward_wrapper.output_indices,\n            len(forward_wrapper.output_tangents))\n\n  def _wrap_forward_function_with_jvps(\n      self, forward_function, backward_function,\n      inference_args, input_tangents):\n    \"\"\"Adds inline JVP computation to a forward function.\"\"\"\n    forward_wrapper_graph = func_graph_module.FuncGraph(\n        _forward_name(self._func_graph.name))\n    with forward_wrapper_graph.as_default():\n      # Tell forward accumulators to free up space for new JVP computations,\n      # since one may be in the process of computing a JVP (if that computation\n      # triggered this function building).\n      #\n      # We'll make symbolic versions of input JVPs, run the forward function\n      # under forward accumulators to get symbolic output JVPs, then set those\n      # as outputs of the new wrapped forward function.\n      with forwardprop_util.push_forwardprop_state():\n        forward_captures = {\n            ops.tensor_id(internal): external\n            for external, internal in self._func_graph.captures}\n        for input_index, real_input in enumerate(self._func_graph.inputs):\n          # This loop is more or less equivalent to running tf.identity on each\n          # of self._func_graph.inputs. However, doing that also captures jvps\n          # for resource handles, which confuses the jvp capturing code below\n          # (since primal inputs are interwoven with jvp inputs).\n          input_placeholder = array_ops.placeholder(\n              dtype=real_input.dtype,\n              shape=real_input.shape)\n          capture = forward_captures.get(ops.tensor_id(real_input))\n          if capture is not None:\n            forward_wrapper_graph.add_capture(capture, input_placeholder)\n            if capture.dtype == dtypes.resource:\n              handle_data_util.copy_handle_data(capture, input_placeholder)\n          else:\n            forward_wrapper_graph.inputs.append(input_placeholder)\n        for inp, arg in zip(forward_wrapper_graph.inputs, inference_args):\n          tape.record_operation(\n              \"captured_value\", [inp], [arg],\n              backward_function=lambda x: [x],\n              forward_function=lambda x: [x])\n        num_inference_inputs = len(inference_args)\n        for tape_indices in self._forwardprop_input_indices:\n          for input_index, jvp_index in tape_indices:\n            input_placeholder = forward_wrapper_graph.inputs[input_index]\n            if len(forward_wrapper_graph.inputs) != jvp_index:\n              raise errors.InternalError(\n                  f\"Expected {jvp_index} forward graph inputs, \"\n                  f\"got {len(forward_wrapper_graph.inputs)}.\")\n            gradient_shape, gradient_dtype = default_gradient.shape_and_dtype(\n                input_placeholder)\n            jvp_placeholder = graph_placeholder(gradient_dtype, gradient_shape)\n            external_jvp = input_tangents[jvp_index - num_inference_inputs]\n            forward_wrapper_graph.add_capture(external_jvp, jvp_placeholder)\n            tensor_shape.TensorShape(\n                external_jvp.shape).assert_is_compatible_with(\n                    jvp_placeholder.shape)\n            tape.record_operation(\n                \"captured_value\",\n                [jvp_placeholder],\n                [external_jvp],\n                backward_function=lambda x: [x],\n                forward_function=lambda x: [x])\n        forward_inputs = forward_wrapper_graph.inputs[:num_inference_inputs]\n        gradient_function = (\n            self._delayed_rewrite_functions._rewrite_forward_and_call_backward)  # pylint: disable=protected-access\n        with ops.get_default_graph()._override_gradient_function(  # pylint: disable=protected-access\n            {\"PartitionedCall\": gradient_function,\n             \"StatefulPartitionedCall\": gradient_function}):\n          forward_outputs = forward_function.call(context.context(),\n                                                  forward_inputs)\n          if isinstance(forward_outputs, ops.Operation):\n            # _wrapped_backward_function expects a list, but if the function has\n            # no outputs its call() returns an Operation. We need to undo that\n            # so we don't cause problems later.\n            forward_outputs = []\n        py_backward, _ = self._wrap_backward_function(\n            self._func_graph, backward_function, forward_outputs)\n      # We will never request backward tape gradients for this operation\n      # directly since we're wrapping the call; forwardprop will call the\n      # backward function (and nested forward accumulators may build\n      # higher-order gradients), but any watching GradientTapes should ignore\n      # it.\n      #\n      # TODO(allenl): It might be better to explicitly stop backward recording\n      # so we don't use the second-order tape cases unnecessarily.\n      tape.record_operation_forwardprop_only(\n          forward_function.signature.name,\n          forward_outputs, forward_inputs, py_backward, None)\n      output_indices, output_tangents = (\n          pywrap_tfe.TFE_Py_PackJVPs(forward_outputs))\n      output_tangents = [forward_wrapper_graph.capture(t)\n                         for t in output_tangents]\n    return _ForwardWrapper(\n        graph=forward_wrapper_graph, outputs=forward_outputs,\n        output_indices=output_indices, output_tangents=output_tangents)\n\n  def _wrap_backward_function_with_jvp_backprop(\n      self, backward_function, gradients_wrt_outputs, forward_wrapper):\n    \"\"\"Wraps `backward_function` to include gradients for JVPs.\"\"\"\n    wrapped_backwards_graph = func_graph_module.FuncGraph(\n        _backward_name(self._func_graph.name))\n    with wrapped_backwards_graph.as_default():\n      py_backward, recorded_outputs = self._wrap_backward_function(\n          self._func_graph, backward_function, forward_wrapper.outputs)\n      trainable_index = 0\n      forward_doutputs = []\n      doutput_args = []\n      for output in recorded_outputs:\n        if backprop_util.IsTrainable(output):\n          doutput = gradients_wrt_outputs[trainable_index]\n          doutput_placeholder = graph_placeholder(doutput.dtype, doutput.shape)\n          doutput_args.append(doutput_placeholder)\n          forward_doutputs.append(doutput_placeholder)\n          trainable_index += 1\n        else:\n          doutput_args.append(None)\n\n      dinputs = py_backward(*doutput_args)\n      existing_outputs = object_identity.ObjectIdentitySet(\n          forward_wrapper.outputs + forward_wrapper.output_tangents)\n      num_processed_output_tangents = 0\n      gradients_wrt_output_tangents = []\n      tangent_doutputs = []\n      output_tangents = forward_wrapper.output_tangents\n      output_indices = forward_wrapper.output_indices\n      if self._need_gradients_for_jvps:\n        # TODO(allenl): Consider using a throwaway graph to avoid extra gradient\n        # evaluations; gradients for jvps may have common subgraphs.\n        while num_processed_output_tangents != len(output_tangents):\n          for output in output_tangents[num_processed_output_tangents:]:\n            gradient_shape, gradient_dtype = default_gradient.shape_and_dtype(\n                output)\n            placeholder = graph_placeholder(gradient_dtype, gradient_shape)\n            gradients_wrt_output_tangents.append(placeholder)\n            tangent_doutputs.append(placeholder)\n          num_processed_output_tangents = len(output_tangents)\n          with ops.device(None):\n            gradients_wrt_inputs = gradients_util._GradientsHelper(  # pylint: disable=protected-access\n                output_tangents,\n                forward_wrapper.graph.inputs,\n                grad_ys=gradients_wrt_output_tangents,\n                src_graph=forward_wrapper.graph)\n          dinputs = [\n              backprop.aggregate_indexed_slices_gradients((existing, new))\n              for existing, new in zip(dinputs, gradients_wrt_inputs)\n              if existing is not None or new is not None]\n          dinputs.extend(gradients_wrt_inputs[len(dinputs):])\n          captures_from_forward = [\n              c for c in wrapped_backwards_graph.external_captures\n              if (not isinstance(c, ops.EagerTensor)\n                  and c.graph is forward_wrapper.graph)]\n          for capture in captures_from_forward:\n            if capture not in existing_outputs:\n              existing_outputs.add(capture)\n              forward_wrapper.outputs.append(capture)\n          output_indices, output_tangents = (\n              forwardprop_util.pack_tangents(forward_wrapper.outputs))\n          output_tangents = [forward_wrapper.graph.capture(t)\n                             for t in output_tangents]\n          for t in output_tangents:\n            existing_outputs.add(t)\n    wrapped_backwards_graph.inputs = (\n        forward_doutputs[:self._num_trainable_inference_outputs]\n        + tangent_doutputs\n        + forward_doutputs[self._num_trainable_inference_outputs:]\n        + wrapped_backwards_graph.internal_captures)\n    wrapped_backwards_graph.structured_outputs = dinputs\n    wrapped_backwards_graph.outputs = [t for t in dinputs if t is not None]\n    return (wrapped_backwards_graph,\n            forward_wrapper._replace(output_indices=output_indices,\n                                     output_tangents=output_tangents))\n\n  def _shuffle_forward_outputs(self, forward_wrapper):\n    \"\"\"Reorders function outputs so captures are last.\"\"\"\n    def _index_map(original):\n      if original < self._num_inference_outputs:\n        return original\n      if original >= len(forward_wrapper.outputs):\n        return (original - len(forward_wrapper.outputs)\n                + self._num_inference_outputs)\n      return original + len(forward_wrapper.output_tangents)\n    output_indices = nest.map_structure(\n        _index_map, forward_wrapper.output_indices)\n    forward_wrapper.graph.outputs = (\n        forward_wrapper.outputs[:self._num_inference_outputs]\n        + forward_wrapper.output_tangents\n        + forward_wrapper.outputs[self._num_inference_outputs:])\n    return forward_wrapper._replace(output_indices=output_indices)\n\n  def forward(self, inference_args, input_tangents):\n    \"\"\"Construct or fetch a forward function with side-outputs.\n\n    When graph building without a tape active, symbolic gradients rely on\n    regenerating the backward function for higher-order gradients (to account\n    for new side outputs of the rewritten forward function call). Thus there is\n    no fixed backward function for this case. However, when a tape is active\n    (eager or graph building), we generate fixed backward and forward functions\n    at forward function call time.\n\n    This difference between the tape and non-tape cases is to avoid building\n    unneeded backward functions while graph building (where we may or may not\n    eventually need gradients).\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n\n    Returns:\n      A forward _EagerDefinedFunction.\n    \"\"\"\n    if self._forward is None:\n      (self._forward, self._forward_graph, self._backward,\n       self._forwardprop_output_indices, self._num_forwardprop_outputs) = (\n           self._forward_and_backward_functions(inference_args, input_tangents))\n    return self._forward\n\n  def _wrap_backward_function(self, forward_graph, backward, outputs):\n    \"\"\"Create a backward function given `outputs` from the forward function.\"\"\"\n    capture_mapping = dict(\n        zip((ops.tensor_id(t) for t in forward_graph.outputs), outputs))\n    captured_inputs = backward.captured_inputs\n    remapped_captures = [\n        capture_mapping.get(ops.tensor_id(capture), capture)\n        for capture in captured_inputs\n    ]\n    if any(t.graph is forward_graph for t in remapped_captures\n           if not isinstance(t, ops.EagerTensor)):\n      incorrect_mapping = [t for t in remapped_captures\n                           if (not isinstance(t, ops.EagerTensor) and\n                               t.graph is not forward_graph)]\n      raise errors.InternalError(\"Failed to map all backward graph captures to \"\n                                 \"the forward graph. Incorrectly mapped: \"\n                                 f\"{incorrect_mapping}.\")\n    # We may need to use zeros_like to get a zero for variant Tensors with\n    # unconnected gradients. We do that in advance so we don't have to hold on\n    # to the outputs themselves, which may not be needed otherwise.\n    variant_zeros_like = {}\n    backward_function_inputs = (len(backward.inputs) - len(captured_inputs))\n    recorded_outputs = []\n    trainable_recorded_outputs = 0\n    skip_positions = []\n    if self._num_forwardprop_outputs and not self._need_gradients_for_jvps:\n      relevant_outputs = (\n          outputs[:self._num_inference_outputs]\n          + outputs[self._num_inference_outputs\n                    + self._num_forwardprop_outputs:])\n    else:\n      relevant_outputs = outputs\n    for output_index, output in enumerate(relevant_outputs):\n      if trainable_recorded_outputs < backward_function_inputs:\n        recorded_outputs.append(output)\n      if backprop_util.IsTrainable(output):\n        trainable_recorded_outputs += 1\n      else:\n        skip_positions.append(output_index)\n      if output.dtype == dtypes.variant:\n        variant_zeros_like[output_index] = default_gradient.zeros_like(output)\n\n    def _backward_function_wrapper(*args):\n      \"\"\"Process output gradients and call the backward function.\"\"\"\n      if not backward.outputs:\n        return backward.structured_outputs\n\n      processed_args = []\n      input_index = 0\n      for output_index, arg in enumerate(args):\n        # Convert IndexedSlices to dense tensors. The IndexedSlices optimization\n        # is only really effective when doing tf.gather(variable) as the\n        # adjoint functions for most operations are unlikely to preserve the\n        # sparsity in IndexedSlices.\n        if isinstance(arg, ops.IndexedSlices):\n          arg = ops.convert_to_tensor(arg)\n        if output_index in skip_positions:\n          continue\n        if arg is None:\n          # We're calling a (non-polymorphic) ConcreteFunction, so we need to\n          # have a Tensor value for each Tensor we thought would be trainable\n          # based on its dtype, even if it ended up being unconnected.\n          input_placeholder = backward.inputs[\n              input_index]\n          if input_placeholder.dtype == dtypes.variant:\n            arg = variant_zeros_like[output_index]\n          else:\n            arg = array_ops.zeros(\n                *default_gradient.shape_and_dtype(input_placeholder))\n        processed_args.append(arg)\n        input_index += 1\n        if input_index >= backward_function_inputs:\n          break\n      return backward._call_flat(  # pylint: disable=protected-access\n          processed_args, remapped_captures)\n\n    return _backward_function_wrapper, recorded_outputs\n\n  def record(self, flat_outputs, inference_args, input_tangents):\n    \"\"\"Record the function call operation.\n\n    For backprop, indicates the backward function to use and which new Tensors\n    must be watched. For forwardprop from eager, the function call itself will\n    have produced tangents which need to be recorded.\n\n    Args:\n      flat_outputs: The result of running `forward`.\n      inference_args: A flat list of Tensors with inference inputs to the\n        operation.\n      input_tangents: A flat list of Tensors with input tangents consumed by the\n        operation.\n    \"\"\"\n    backward_function, to_record = self._wrap_backward_function(\n        self._forward_graph, self._backward, flat_outputs)\n    if self._forwardprop_output_indices:\n      tape.record_operation_backprop_only(\n          self._forward.signature.name,\n          to_record, inference_args,\n          backward_function)\n      tape.record_operation_forwardprop_only(\n          self._forward.signature.name,\n          flat_outputs, inference_args + input_tangents,\n          backward_function,\n          self._forwardprop_output_indices)\n    else:\n      tape.record_operation(self._forward.signature.name,\n                            to_record, inference_args + input_tangents,\n                            backward_function)\n\n\nclass _FirstOrderTapeGradientFunctions(_TapeGradientFunctions):\n  \"\"\"Caches tape-friendly functions for first-order gradients.\"\"\"\n\n  def __init__(self, func_graph, attrs, func_graph_deleter,\n               forwardprop_input_indices, delayed_rewrite_functions,\n               need_gradients_for_jvps):\n    super(_FirstOrderTapeGradientFunctions, self).__init__(\n        func_graph, attrs, func_graph_deleter, forwardprop_input_indices,\n        delayed_rewrite_functions, need_gradients_for_jvps)\n    self._func_graph_deleter = func_graph_deleter\n    self._forwardprop_input_indices = forwardprop_input_indices\n\n  def _forward_and_backward_functions(self, inference_args, input_tangents):\n    \"\"\"Shortcut for when only first-order gradients are required.\n\n    The returned backward function does not accept gradients with respect to\n    side output of forward_function. This is fine as long as the user can't\n    possibly request second order tape gradients, as when they've used a single\n    non-persistent GradientTape. Since we don't need the backward function to\n    take gradients with respect to side outputs, we can skip some potentially\n    slow graph building.\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n\n    Returns:\n      A tuple of (forward_function, backward_function):\n        forward_function: Takes the same inputs as the inference function, but\n          returns side outputs used by backward_function in addition to the\n          inference function's outputs.\n        backward_function: Takes side outputs from forward_function and\n          gradients with respect to the \"real\" outputs of forward_function and\n          returns gradients with respect to the inputs.\n    \"\"\"\n    outputs = self._func_graph.outputs[:self._num_inference_outputs]\n    return self._build_functions_for_outputs(\n        outputs, inference_args, input_tangents)\n\n\nclass _HigherOrderTapeGradientFunctions(_TapeGradientFunctions):\n  \"\"\"Caches tape-friendly functions for higher-order gradients.\"\"\"\n\n  # TODO(b/136189779): Cond/while under a tape may need similar logic. Consider\n  # generalizing if so.\n  def _forward_and_backward_functions(self, inference_args, input_tangents):\n    \"\"\"Forward and backward functions suitable for higher-order gradients.\n\n    Unlike in `_FirstOrderTapeGradientFunctions`, the backward function built by\n    this method accepts gradients for all of the outputs of the returned forward\n    function, including side outputs.\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n\n    Returns:\n      A tuple of (forward_function, backward_function):\n        forward_function: Takes the same inputs as the inference function, but\n          returns side outputs used by backward_function in addition to the\n          inference function's outputs.\n        backward_function: Takes side outputs from forward_function and\n          gradients with respect to all of its outputs, real and side. Returns\n          gradients with respect to the inputs.\n    \"\"\"\n    outputs = []\n    iteration_count = 0\n    # First we need to figure out how many side outputs from the forward pass\n    # will be required. We do this in a temporary graph to avoid actually\n    # running multiple copies of the backward pass (one per _GradientsHelper\n    # call).\n    #\n    # While computing gradients, the backward function captures Tensors from\n    # the forward function. We add these as side outputs of the original\n    # function. However, we then need to accept output gradients with respect\n    # to these side outputs for higher order gradients to work. Thus we loop\n    # until the number of outputs of the function stabilizes. Note that this\n    # is only required for tape gradients, where we need to declare in advance\n    # all of the forward op's outputs: symbolic gradients with tf.gradients\n    # instead rely on regenerating backward functions when higher-order\n    # gradients are requested.\n    while (len(outputs) < len(self._func_graph.outputs)\n           # It's possible for gradient generation to add new ops to the forward\n           # pass. If all of the new outputs are non-trainable, there's no\n           # reason to continue.\n           and any(backprop_util.IsTrainable(output)\n                   for output in self._func_graph.outputs[len(outputs):])):\n      iteration_count += 1\n      if iteration_count >= 20 and iteration_count % 5 == 0:\n        new_op_with_trainable_output = None\n        num_new_trainable_outputs = 0\n        for output in self._func_graph.outputs[len(outputs):]:\n          if backprop_util.IsTrainable(output):\n            num_new_trainable_outputs += 1\n            new_op_with_trainable_output = output.op\n        logging.warning(\n            (\"Determining side outputs for the function '{}' is taking longer \"\n             \"than expected ({} iterations, typically this converges in 5 or \"\n             \"so). This could indicate that a gradient registration is adding \"\n             \"new ops to the forward pass every time gradients are generated. \"\n             \"{} new trainable output(s) were added this iteration, one from \"\n             \"the following op:\\n {}\\nThis may indicate a TensorFlow bug, or \"\n             \"an issue in a tf.custom_gradient.\")\n            .format(\n                self._func_graph.name, iteration_count,\n                num_new_trainable_outputs, new_op_with_trainable_output))\n      outputs = list(self._func_graph.outputs)\n      self._build_functions_for_outputs(\n          outputs, inference_args, input_tangents)\n\n    (forward_function, forward_graph,\n     backward_function, output_indices, num_output_tangents) = (\n         self._build_functions_for_outputs(\n             outputs, inference_args, input_tangents))\n    if (len(self._func_graph.outputs) > len(outputs)\n        and any(backprop_util.IsTrainable(output)\n                for output in self._func_graph.outputs[len(outputs):])):\n      raise errors.InternalError(\n          \"Unexpectedly added new outputs to the forward function when \"\n          \"building the backward function: \"\n          f\"{self._func_graph.outputs[len(outputs):]}.\")\n    return (forward_function, forward_graph, backward_function, output_indices,\n            num_output_tangents)\n\n\nclass _ForwardBackwardCall(object):\n  \"\"\"Holds the state of a function call between execution and recording.\"\"\"\n\n  __slots__ = [\n      \"_functions\", \"_inference_args\", \"_input_tangents\", \"_tape_watching\"\n  ]\n\n  def __init__(self, functions, inference_args, input_tangents, tape_watching):\n    \"\"\"Collects information about the function call.\n\n    Args:\n      functions: An object which produces forward and backward functions, either\n        a _DelayedRewriteGradientFunctions or a _TapeGradientFunctions object.\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n      tape_watching: Boolean, with True indicating that recording is necessary.\n    \"\"\"\n    self._functions = functions\n    self._inference_args = inference_args\n    self._input_tangents = input_tangents\n    self._tape_watching = tape_watching\n\n  def forward(self):\n    \"\"\"Builds or retrieves a forward function for this call.\"\"\"\n    forward_function = self._functions.forward(\n        self._inference_args, self._input_tangents)\n    return forward_function, self._inference_args + self._input_tangents\n\n  def record(self, flat_outputs):\n    \"\"\"Given outputs from the execution of `forward`, records the operation.\"\"\"\n    if (self._tape_watching\n        and not isinstance(flat_outputs, ops.Operation)\n        and flat_outputs is not None):\n      # We only record function calls which have outputs, and then only when a\n      # tape is watching.\n      self._functions.record(\n          flat_outputs, self._inference_args, self._input_tangents)\n\n\n# Sentinel value used by with ConcreteFunction's structured signature to\n# indicate that a non-tensor parameter should use the value that was\n# specified when the concrete function was created.\n_BOUND_VALUE = object()\n\n\nclass ConcreteFunction(core.ConcreteFunction):\n  \"\"\"A `tf.types.experimental.ConcreteFunction` created from `tf.function`.\"\"\"\n\n  def __init__(self,\n               func_graph,\n               attrs=None,\n               shared_func_graph=True,\n               function_spec=None):\n    \"\"\"Initialize a `ConcreteFunction`.\n\n    Args:\n      func_graph: An instance of FuncGraph: the function body to wrap.\n      attrs: (optional) dict mapping names of attributes to their AttrValue\n        values. Attributes in `attrs` will be included in this function's\n        definition.\n     shared_func_graph: If False, the ConcreteFunction takes ownership of\n       `func_graph` and will break reference cycles when it is deleted. This\n       makes the FuncGraph inoperable.\n     function_spec: FunctionSpec for the original function.  If not specified,\n       then this ConcreteFunction may only be called using the flat signature.\n\n    Raises:\n      ValueError: If number of input_placeholders is not equal to the number\n        of function inputs.\n    \"\"\"\n    # _arg_keywords and _num_positional_args define the flat signature.  They\n    # are assigned after construction.\n    self._arg_keywords = None\n    self._num_positional_args = None\n\n    self._func_graph = func_graph\n    self._captured_inputs = self._func_graph.external_captures + self._func_graph.deferred_external_captures\n\n    # function_spec defines the structured signature.\n    self._set_function_spec(function_spec)\n\n    if attrs and IMPLEMENTS_ATTRIBUTE_NAME in attrs:\n      # The alternative is to silently drop \"implements\" tag\n      # but it seems likely it would lead to hard to catch bugs.\n      # Another alternative is to make func_body to preserve the order\n      # of arguments if variables are present. Yet another option\n      # is to automatically replace variables as arguments to functions\n      # to v.read_value() whenever \"implements\" tag is present\n      # Anytime we annotate existing function we probably want to wrap\n      # it with safe read_value for backward compatibility.\n      has_resource_vars = any(inp.dtype == dtypes.resource\n                              for inp in self.inputs)\n\n      assert not any((has_resource_vars, self._captured_inputs)), (\n          'Function {name} has \"{attr}={value}\" attribute and thus can not '\n          \"depend on any tensors outside of its signature or modify variables. \"\n          \"\\n\\nNote: variables are always captured and cause function \"\n          \"re-tracing for every variable called.\\n\"\n          \"  inputs: {inputs}\\n  captures: {captured}\\n\\n\"\n          \"To pass a variable to such function use  \"\n          \"use variable.read_value().\".format(\n              name=func_graph.name,\n              attr=IMPLEMENTS_ATTRIBUTE_NAME,\n              value=attrs[IMPLEMENTS_ATTRIBUTE_NAME],\n              inputs=self.inputs,\n              captured=self._captured_inputs))\n    self._output_shapes = tuple(\n        output.shape for output in self._func_graph.outputs)\n    self._attrs = _parse_func_attrs(attrs or {})\n\n    if shared_func_graph:\n      self._garbage_collector = None\n    else:\n      self._garbage_collector = ConcreteFunctionGarbageCollector(func_graph)\n\n    # Pairs of forward and backward functions used for computing gradients.\n    #\n    # These each get a reference to the FuncGraph deleter since they use the\n    # FuncGraph directly.\n    self._delayed_rewrite_functions = _DelayedRewriteGradientFunctions(\n        func_graph, self._attrs, self._garbage_collector)\n    self._first_order_tape_functions = {}\n    self._higher_order_tape_functions = {}\n    # Cache the inference function to avoid a (Python) function call when not\n    # building gradients.\n    self._inference_function = self._delayed_rewrite_functions.forward()\n\n  def _set_function_spec(self, function_spec):\n    \"\"\"Enables the structured signature by supplying a function_spec.\"\"\"\n    self._function_spec = None\n    self._pre_initialized_function_spec = function_spec\n\n    # Note: when ConcreteFunctions are built by recreate_function() in\n    # function_deserialization.py, they don't have a structured_input_signature\n    # yet.  In that case, _initialize_function_spec() gets called by\n    # _setup_functions_structures() in load.py.\n    if (function_spec is not None and\n        self.structured_input_signature is not None):\n      self._initialize_function_spec()\n\n  def _initialize_function_spec(self):\n    \"\"\"Updates `self._function_spec` to include varargs and bound variables.\n\n    Adds new positional arguments for any varargs (i.e., for args that are\n    in `structured_input_signature`, but not in the original fullargspec.args).\n\n    Replaces `defaults` and `kwonlydefaults` with the `_BOUND_VALUE`, for\n    all args and kwargs in `structured_input_signature`.\n\n    Sets `varkw` and `varargs` to None.\n    \"\"\"\n    if self._pre_initialized_function_spec is None:\n      return  # e.g., SavedBareConcreteFunction doesn't have function_spec yet.\n    assert not self._function_spec, \"already initialized\"\n    function_spec = self._pre_initialized_function_spec\n    args = function_spec.fullargspec.args\n    arg_specs, kwarg_specs = self.structured_input_signature\n    vararg_indices = range(len(function_spec.arg_names), len(arg_specs))\n    fullargspec = tf_inspect.FullArgSpec(\n        args=list(args) + [\"<arg{}>\".format(i + 1) for i in vararg_indices],\n        varargs=None,\n        varkw=None,\n        defaults=[_BOUND_VALUE] * len(arg_specs),\n        kwonlyargs=list(sorted(kwarg_specs)),\n        kwonlydefaults=dict((k, _BOUND_VALUE) for k in kwarg_specs),\n        annotations=function_spec.fullargspec.annotations)\n    self._function_spec = FunctionSpec(\n        fullargspec,\n        function_spec.is_method,\n        function_spec.input_signature,\n        function_spec.is_pure,\n        name=self._func_graph.name)\n\n  @property\n  def variables(self):\n    \"\"\"Sequence of variables for this function.\"\"\"\n    return tuple(self._func_graph.variables)\n\n  @property\n  def trainable_variables(self):\n    \"\"\"Sequence of trainable variables for this function.\"\"\"\n    return tuple(self._func_graph.trainable_variables)\n\n  def __call__(self, *args, **kwargs):\n    \"\"\"Executes the wrapped function.\n\n    ConcreteFunctions have two signatures:\n\n    * The signature of the original function wrapped by this ConcreteFunction.\n    * A flat signature, where each argument accepts a single Tensor.\n\n    The original function signature is generally preferred, but the flat input\n    signature is supported for backward compatibility.\n\n    ### Original Function Signature\n\n    When calling a ConcreteFunction with the signature of the original function,\n    each argument must match the type or value that was used when the\n    ConcreteFunction's graph was traced.  In particular:\n\n    * Tensor arguments (including CompositeTensors, such as RaggedTensor) must\n      have matching `TypeSpec`s.\n    * Non-Tensor arguments (such as booleans or ints) must have equal values.\n    * Nested arguments (such as lists, tuples, or dictionaries) must have the\n      same nesting structure; and each nested value must have a matching type\n      or value.\n\n    The default value for any arguments that were traced with non-Tensor values\n    is the value that was used in the trace.  Arguments that were traced with\n    tensor arguments do not have a default value (even if the original function\n    had a default value for that argument).\n\n    ### Flat Signature\n\n    When calling a ConcreteFunction with the flat signature, the arguments\n    correspond to the flattened component tensors of the arguments that were\n    used to construct the ConcreteFunction.  Parameter names are assigned based\n    on `TensorSpec.name` (when specified) or the original argument names (with\n    suffixes automatically added for nested arguments or composite tensors with\n    multiple components).\n\n    Args:\n      *args: Positional arguments to the concrete function.\n      **kwargs: Keyword arguments to the concrete function.\n\n    Returns:\n      The result of applying the TF function on the given Tensors.\n\n    Raises:\n      AssertionError: If this `ConcreteFunction` was not created through\n        `get_concrete_function`.\n      TypeError: If the arguments do not match the function's signature.\n    \"\"\"\n    return self._call_impl(args, kwargs)\n\n  def _call_impl(self, args, kwargs, cancellation_manager=None):\n    \"\"\"See `__call__` for details.\"\"\"\n    with trace.Trace(self._func_graph.name, tf_function_call=\"concrete\"):\n      # Construct the list of input tensors: check if the structured signature\n      # applies first; and if not, then use the flat signature.\n      if self._function_spec is not None:\n        try:\n          return self._call_with_structured_signature(args, kwargs,\n                                                      cancellation_manager)\n        except TypeError as structured_err:\n          try:\n            return self._call_with_flat_signature(args, kwargs,\n                                                  cancellation_manager)\n          except TypeError:\n            raise structured_err\n\n      return self._call_with_flat_signature(args, kwargs, cancellation_manager)\n\n  def _call_with_flat_signature(self, args, kwargs, cancellation_manager):\n    \"\"\"Executes the wrapped function with the flat signature.\n\n    Args:\n      args: Positional arguments to the concrete function.\n      kwargs: Keyword arguments to the concrete function.\n      cancellation_manager: A `CancellationManager` that can be used to cancel\n        function invocation.\n\n    Returns:\n      The result of applying the function on the Tensors/Variables contained in\n      `args` and `kwargs`.\n    Raises:\n      TypeError: if `args` and `kwargs` do not match the flat signature of this\n        `ConcreteFunction`.\n    \"\"\"\n    if len(args) > self._num_positional_args:\n      raise TypeError(\n          f\"{self._flat_signature_summary()} takes {self._num_positional_args} \"\n          f\"positional arguments, got {len(args)}.\")\n    args = list(args)\n    kwargs = dict(kwargs)\n    for keyword in self._arg_keywords[len(args):]:\n      try:\n        args.append(kwargs.pop(compat.as_str(keyword)))\n      except KeyError:\n        specified_keywords = (\n            list(self._arg_keywords[:len(args)]) + list(kwargs.keys()))\n        missing_required_args = sorted(\n            set(self._arg_keywords) - set(specified_keywords))\n        raise TypeError(f\"{self._flat_signature_summary()} missing required \"\n                        f\"arguments: {', '.join(missing_required_args)}.\")\n    if kwargs:\n      positional_arg_keywords = set(self._arg_keywords[:len(args)])\n      for unused_key in kwargs:\n        if unused_key in positional_arg_keywords:\n          raise TypeError(f\"{self._flat_signature_summary()} got two values \"\n                          f\"for '{unused_key}'.\")\n      raise TypeError(f\"{self._flat_signature_summary()} got unexpected \"\n                      f\"keyword arguments: {', '.join(sorted(kwargs))}.\")\n\n    for i, arg in enumerate(args):\n      if not isinstance(\n          arg, (ops.Tensor, resource_variable_ops.BaseResourceVariable)):\n        raise TypeError(f\"{self._flat_signature_summary()}: expected argument \"\n                        f\"#{i}(zero-based) to be a Tensor; \"\n                        f\"got {type(arg).__name__} ({arg}).\")\n    return self._call_flat(args, self.captured_inputs, cancellation_manager)\n\n  def _call_with_structured_signature(self, args, kwargs, cancellation_manager):\n    \"\"\"Executes the wrapped function with the structured signature.\n\n    Args:\n      args: Positional arguments to the concrete function.\n      kwargs: Keyword arguments to the concrete function.\n      cancellation_manager: A `CancellationManager` that can be used to cancel\n        function invocation.\n\n    Returns:\n      The result of applying the function on the Tensors/Variables contained in\n      `args` and `kwargs`.\n    Raises:\n      TypeError: if `args` and `kwargs` do not match the structured signature\n        of this `ConcreteFunction`.\n    \"\"\"\n    args, kwargs, _, filtered_flat_args = \\\n        self._function_spec.canonicalize_function_inputs(*args, **kwargs)\n    self._structured_signature_check_missing_args(args, kwargs)\n    self._structured_signature_check_unexpected_args(args, kwargs)\n    self._structured_signature_check_arg_types(args, kwargs)\n    return self._call_flat(\n        filtered_flat_args,\n        captured_inputs=self.captured_inputs,\n        cancellation_manager=cancellation_manager)\n\n  def _structured_signature_check_missing_args(self, args, kwargs):\n    \"\"\"Raises a TypeError if any args are missing.\"\"\"\n    arg_specs, kwarg_specs = self.structured_input_signature\n    missing_arguments = []\n    for i, (arg, spec) in enumerate(zip(args, arg_specs)):\n      if arg is _BOUND_VALUE and _contains_type_spec(spec):\n        missing_arguments.append(self._function_spec.arg_names[i])\n    for (name, arg) in kwargs.items():\n      if arg is _BOUND_VALUE and _contains_type_spec(kwarg_specs[name]):\n        missing_arguments.append(name)\n    if missing_arguments:\n      raise TypeError(f\"{self._structured_signature_summary()} missing \"\n                      \"required arguments: \"\n                      f\"{', '.join(sorted(missing_arguments))}.\")\n\n  def _structured_signature_check_unexpected_args(self, args, kwargs):\n    \"\"\"Raises a TypeError if there are any extra args.\"\"\"\n    arg_specs, kwarg_specs = self.structured_input_signature\n    if len(args) > len(arg_specs):\n      raise TypeError(\n          f\"{self._structured_signature_summary()} takes \"\n          f\"{len(self._function_spec.arg_names)} positional arguments but got \"\n          f\"{len(args)}.\")\n    if len(kwargs) > len(kwarg_specs):\n      extra_args = set(kwargs) - set(kwarg_specs)\n      raise TypeError(f\"{self._structured_signature_summary()} got unexpected \"\n                      f\"keyword arguments: {', '.join(extra_args)}.\")\n\n  def _structured_signature_check_arg_types(self, args, kwargs):\n    \"\"\"Raises a TypeError if any args have the wrong type.\"\"\"\n    # Check argument types\n    arg_specs, kwarg_specs = self.structured_input_signature\n    for i, (arg, spec) in enumerate(zip(args, arg_specs)):\n      name = self._function_spec.arg_names[i]\n      self._structured_signature_check_arg_type(arg, spec, name)\n    for (name, arg) in kwargs.items():\n      self._structured_signature_check_arg_type(arg, kwarg_specs[name], name)\n\n  def _structured_signature_check_arg_type(self, arg, spec, name):\n    \"\"\"Raise TypeError if `arg`'s type doesn't match `spec`.\"\"\"\n    if arg is _BOUND_VALUE:\n      return\n\n    # Check the overall nested structure of the argument.\n    try:\n      nest.assert_same_structure(arg, spec, expand_composites=True)\n    except (ValueError, TypeError):\n      try:\n        nest.assert_same_structure(arg, spec, expand_composites=False)\n        expected, got = spec, arg\n      except (ValueError, TypeError):\n        expected, got = _structure_summary(spec), _structure_summary(arg)\n      raise TypeError(f\"{self._structured_signature_summary()}: argument \"\n                      f\"{name} had incorrect type\\n\"\n                      f\"  expected: {expected}\\n\"\n                      f\"       got: {got}\")\n\n    # Check the type for each leaf in the nested structure.\n    arg_pieces = nest.flatten(arg, expand_composites=True)\n    spec_pieces = nest.flatten(spec, expand_composites=True)\n    for (arg_piece, spec_piece) in zip(arg_pieces, spec_pieces):\n      # TODO(mdan): Use consistent error messages.\n      if isinstance(spec_piece, tensor_spec.DenseSpec):\n        # TODO(edloper): Consider calling convert_to_tensor on non-tensor\n        # values here.  That would match the behavior of\n        # _call_concrete_function() in function_deserialization.py.  If\n        # we do, then we need to change the nest assert_same_structure and\n        # flatten calls above to use shallow variants.\n        tensor_types = (ops.Tensor, resource_variable_ops.BaseResourceVariable)\n        if not isinstance(arg_piece, tensor_types):\n          raise TypeError(f\"{self._structured_signature_summary()} expected a \"\n                          f\"Tensor in {name}, but got \"\n                          f\"{type(arg_piece).__name__} value {arg_piece}.\")\n      elif arg_piece is not _BOUND_VALUE:\n        try:\n          arg_matches_spec = bool(arg_piece == spec_piece)\n        except (ValueError, TypeError):\n          logging.vlog(1, \"Error matching value with spec\", exc_info=True)\n          arg_matches_spec = False\n        if not arg_matches_spec:\n          raise TypeError(\n              f\"ConcreteFunction {self._structured_signature_summary()} was \"\n              f\"constructed with {type(spec_piece).__name__} value \"\n              f\"{spec_piece} in {name}, but was called with \"\n              f\"{type(arg_piece).__name__} value {arg_piece}.\")\n\n  def _call_flat(self, args, captured_inputs, cancellation_manager=None):\n    \"\"\"Executes the wrapped function.\n\n    Args:\n      args: a list of Tensors or Variables. Arguments from the Python function\n        should be filtered before calling this method: objects aside from\n        Tensors, CompositeTensors, and Variables are ignored. Any\n        CompositeTensors should be expanded before calling this method.\n      captured_inputs: the captured inputs that are also part of the input args\n        to the actual execution. By default, it should be self._captured_inputs.\n      cancellation_manager: (Optional.) A `CancellationManager` that can be\n        used to cancel function invocation.\n\n    Returns:\n      The result of applying the TF function to `args`.\n\n    Raises:\n      ValueError: If `args` contains anything other than Tensors or Variables.\n    \"\"\"\n    ctx = context.context()\n    executing_eagerly = ctx.executing_eagerly()\n\n    # Copy saveable status of function's graph to current FuncGraph.\n    default_graph = ops.get_default_graph()\n    if default_graph.building_function and not self._func_graph.saveable:\n      default_graph.mark_as_unsaveable(self._func_graph.saving_errors)\n\n    if (tape.could_possibly_record() or\n        hasattr(default_graph, \"watch_variable\")):\n      for v in self._func_graph.variables:\n        resource_variable_ops.variable_accessed(v)\n\n    tensor_inputs = []\n    variables_used = set([])\n    for i, arg in enumerate(args):\n      if isinstance(arg, resource_variable_ops.BaseResourceVariable):\n        # We can pass a variable more than once, and in this case we need to\n        # pass its handle only once.\n        if id(arg.handle) in variables_used:\n          continue\n        resource_variable_ops.variable_accessed(arg)\n        tensor_inputs.append(arg.handle)\n        variables_used.add(id(arg.handle))\n      elif isinstance(arg, ops.Tensor):\n        tensor_inputs.append(arg)\n        if not executing_eagerly:\n          # If we're graph building, shape inference is on. We check for input\n          # compatibility up front to avoid hard to debug incompatibilities\n          # later.\n          graph_input_shape = tensor_shape.TensorShape(\n              self._func_graph.inputs[i].shape)\n          if not graph_input_shape.is_compatible_with(arg.shape):\n            if self._arg_keywords:\n              arg_name = \"'{}'\".format(self._arg_keywords[i])\n            else:\n              arg_name = \"with index {}\".format(i)\n            raise ValueError(\n                f\"The argument {arg_name} (value {arg}) is not compatible with \"\n                \"the shape this function was traced with. Expected shape \"\n                f\"{self._func_graph.inputs[i].shape}, but got shape \"\n                f\"{arg.shape}.\\n\\nIf you called get_concrete_function, you may \"\n                \"need to pass a tf.TensorSpec(..., shape=...) with a less \"\n                \"specific shape, having None on axes which can vary.\")\n      else:\n        raise ValueError(f\"{i:d}-th input {arg} must be a Tensor, got \"\n                         f\"{type(arg)} when calling {self._func_graph.name}.\")\n    args = tensor_inputs + captured_inputs\n    possible_gradient_type = gradients_util.PossibleTapeGradientTypes(args)\n    if (possible_gradient_type == gradients_util.POSSIBLE_GRADIENT_TYPES_NONE\n        and executing_eagerly):\n      # No tape is watching; skip to running the function.\n      return self._build_call_outputs(self._inference_function.call(\n          ctx, args, cancellation_manager=cancellation_manager))\n    forward_backward = self._select_forward_and_backward_functions(\n        args,\n        possible_gradient_type,\n        executing_eagerly)\n    forward_function, args_with_tangents = forward_backward.forward()\n    if executing_eagerly:\n      flat_outputs = forward_function.call(\n          ctx, args_with_tangents, cancellation_manager=cancellation_manager)\n    else:\n      with default_graph._override_gradient_function(  # pylint: disable=protected-access\n          {\"PartitionedCall\": self._get_gradient_function(),\n           \"StatefulPartitionedCall\": self._get_gradient_function()}):\n        flat_outputs = forward_function.call(ctx, args_with_tangents)\n    forward_backward.record(flat_outputs)\n    return self._build_call_outputs(flat_outputs)\n\n  def _experimental_with_cancellation_manager(self, cancellation_manager):\n    \"\"\"Returns a callable that invokes a cancellable version of this function.\n\n    Args:\n      cancellation_manager: A `CancellationManager` object that can be used to\n        cancel function invocation.\n\n    Returns:\n      A callable with the same signature as this concrete function.\n    \"\"\"\n\n    def cancellable_call(*args, **kwargs):\n      return self._call_impl(\n          args, kwargs, cancellation_manager=cancellation_manager)\n\n    return cancellable_call\n\n  @property\n  def name(self):\n    \"\"\"`ConcreteFunction` name.\"\"\"\n    return self._delayed_rewrite_functions.forward().name\n\n  @property\n  def graph(self):\n    \"\"\"Returns the graph from which this function was constructed.\"\"\"\n    return self._func_graph\n\n  @property\n  def inputs(self):\n    \"\"\"Returns tensors in `self.graph` corresponding to arguments.\"\"\"\n    return self._func_graph.inputs\n\n  @property\n  def structured_input_signature(self):\n    \"\"\"Returns structured signature for this concrete function.\n\n    Returns:\n      A tuple `(args, kwargs)`, where:\n\n        * `args` is a tuple that specifies the expected type or value each for\n          positional argument.\n        * `kwargs` is a dictionary that specifies the expected type or value\n          for each keyword-only argument.\n\n      The type or value for each argument is specified using one of the\n      following:\n\n        * A `tf.TypeSpec`, indicating that a Tensor or other TensorFlow-native\n          value is expected.\n        * A Python value, such as an integer, indicating that an equal value\n          is expected.\n        * A nested structure of `tf.TypeSpec`s and Python values, indicating\n          that a corresponding nested structure is expected.\n    \"\"\"\n    return self._func_graph.structured_input_signature\n\n  @property\n  def outputs(self):\n    \"\"\"Returns tensors in `self.graph` corresponding to returned tensors.\"\"\"\n    return self._func_graph.outputs\n\n  @property\n  def structured_outputs(self):\n    \"\"\"Returns outputs in `self.graph` as returned by the original function.\"\"\"\n    return self._func_graph.structured_outputs\n\n  def set_external_captures(self, captures):\n    \"\"\"Updates the function capture values.\n\n    The new values must have tensor types and shapes consistent with the\n    original captures of the concrete function, but it is allowed to change a\n    value captured with a deferred one and vice-versa.\n\n    Args:\n      captures: A list of tensors or closures. Tensors are value captures, and\n        closures are call-time (deferred captures).\n    \"\"\"\n    # TODO(wxinyi): 1. verify that the new captures' type spec is compatible\n    # with the original's. However, doing so requires MirroredVariable captures\n    # initialized. 2. replace the original/new captures/deferred\n    # captures in the wrapped graph. Doing such for a capture-to-deferred\n    # capture replacement requires more arguments than the deferred capture\n    # itself, e.g. default value, spec.\n    self._captured_inputs = captures\n\n  def replace_capture_with_deferred_capture(self,\n                                            tensor,\n                                            closure,\n                                            spec,\n                                            placeholder=None,\n                                            default_value=None):\n    \"\"\"Replaces existing capture `tensor` with a deferred capture `closure`.\n\n    This API replaces the capture `tensor` from the concrete function's captured\n    inputs list, and places the deferred capture `closure` in\n    its spot so the order of captured inputs is preserved. This is important\n    because the old `tensor` and the new `closure` will have the same internal\n    placeholder, which can be passed through the `placeholder` argument, or\n    skipped, in which case we find the placeholder from internal inputs by\n    indexing `tensor` in the external captured inputs list. Thus, it is\n    important that the new deferred capture has output spec (specified by the\n    `spec` argument) compatible with the internal placeholder (`placeholder`)\n    and the original capture (`tensor`).\n\n    For example,\n\n    ```python\n    bool_captured_tensor = tf.constant(True)\n    float_captured_tensor = tf.constant([3.], dtype=tf.float32)\n    value = tf.constant([2.], dtype=tf.float32)\n\n    @tf.function\n    def fn():\n      deferred_tensor = ops.get_default_graph().capture_call_time_value(\n          lambda: value,\n          tf.TensorSpec(shape=(1,), dtype=tf.float32))\n      if bool_captured_tensor:\n        return deferred_tensor\n      else:\n        return deferred_tensor + float_captured_tensor\n\n    concrete_fn = fn.get_concrete_function()\n    print(concrete_fn())  # tf.Tensor([2.], shape=(1,), dtype=float32)\n\n    new_bool_captured_tensor = constant_op.constant(False)\n    def bool_closure():\n      return new_bool_captured_tensor\n\n    concrete_fn.replace_capture_with_deferred_capture(\n        bool_captured_tensor,\n        bool_closure,\n        spec=tensor_spec.TensorSpec(shape=(), dtype=dtypes.bool))\n\n    print(concrete_fn())  # tf.Tensor([5.], shape=(1,), dtype=float32)\n    ```\n\n    Args:\n      tensor: Tensor already captured. This `tensor` should be listed in\n        concrete_function.captured_inputs except when it's empty such as when\n        the concrete function is restored from SavedModel.\n      closure: function which takes no arguments, to be evaluated at function\n        call time, returning a nest of tensors compatible with `spec`.\n      spec: nest of TypeSpec for the value to capture.\n      placeholder: optional. The internal placeholder corresponding to the\n        captured `tensor` and the new `closure`.\n      default_value: optional value to use in environments that cannot safely\n        evaluate closure.\n    \"\"\"\n    capture_index = None\n    for i, capture in enumerate(self._captured_inputs):\n      if id(tensor) == id(capture):\n        capture_index = i\n        break\n\n    if placeholder is None:\n      if capture_index is None:\n        raise ValueError(\n            f\"Did not find `tensor` argument {tensor} in the ConcreteFunction's\"\n            \" captured inputs list, and did not receive a placeholder argument.\"\n            \" Thus we're unable to infer the internal placeholder. \")\n\n      placeholder = self.inputs[-len(self._captured_inputs) + capture_index]\n\n    if not (spec.is_compatible_with(tensor) or\n            spec.is_compatible_with(placeholder)):\n      raise ValueError(\n          f\"Attempting to substitute closure with spec {spec} that's \"\n          f\"incompatible with the original capture {tensor} or the internal \"\n          f\"placeholder {placeholder}.\")\n\n    self._func_graph.replace_capture_with_deferred_capture(\n        tensor=tensor,\n        closure=closure,\n        spec=spec,\n        placeholder=placeholder,\n        default_value=default_value)\n\n    if capture_index is not None:\n      self._captured_inputs[capture_index] = closure\n\n  @property\n  def captured_inputs(self):\n    \"\"\"Returns external Tensors captured by this function.\n\n    self.__call__(*args) passes `args + self.captured_inputs` to the function.\n    \"\"\"\n    return nest.flatten(\n        [x() if callable(x) else x for x in self._captured_inputs],\n        expand_composites=True)\n\n  @property\n  def function_def(self):\n    \"\"\"Returns a `FunctionDef` object representing this function.\"\"\"\n    return self._delayed_rewrite_functions.forward().definition\n\n  @property\n  def output_shapes(self):\n    \"\"\"The function's output shapes.\"\"\"\n    return nest.map_structure(\n        lambda x: getattr(x, \"shape\", tensor_shape.TensorShape(None)),\n        composite_tensor.replace_composites_with_components(\n            self._func_graph.structured_outputs),\n        expand_composites=False)\n\n  @property\n  def output_dtypes(self):\n    # TODO(akshayka): Consider removing this.\n    return nest.map_structure(\n        lambda x: x.dtype if x is not None else None,\n        composite_tensor.replace_composites_with_components(\n            self._func_graph.structured_outputs),\n        expand_composites=False)\n\n  def add_to_graph(self, g=None):\n    \"\"\"Registers the function, adds it to the graph g or default graph.\n\n    Args:\n      g: If specified, registers the function with this graph. Defaults to the\n        current context (either the default graph or the eager context).\n    \"\"\"\n    # If we are not executing eagerly, adds the function to default graph if no\n    # graph is specified.\n    # In case of eager execution, function definition gets added to context\n    # during construction itself.\n\n    if not context.executing_eagerly() and not g:\n      g = ops.get_default_graph()\n    self._delayed_rewrite_functions.forward().add_to_graph(g)\n\n  def add_gradient_functions_to_graph(self, g=None):\n    \"\"\"Add forward/backward functions to graph `g` or the current context.\"\"\"\n    if not context.executing_eagerly() and not g:\n      g = ops.get_default_graph()\n    self._delayed_rewrite_functions.forward().add_to_graph(g)\n    forward_function, backward_function = (\n        self._delayed_rewrite_functions.forward_backward())\n    forward_function.add_to_graph(g)\n    backward_function.add_to_graph(g)\n\n  def _get_gradient_function(self):\n    \"\"\"Returns gradient function. It will be lazily created at first call.\"\"\"\n    return self._delayed_rewrite_functions._rewrite_forward_and_call_backward  # pylint: disable=protected-access\n\n  def _select_forward_and_backward_functions(\n      self, args, possible_gradient_type, executing_eagerly):\n    \"\"\"Selects forward and backward functions based on the calling context.\n\n    The forward function computes the \"real\" function outputs, `self._outputs`,\n    and any extra values needed by the corresponding backward function.\n\n    Args:\n      args: A flat list of Tensors with all of the inputs to the forward\n        function (including user-specified and captured inputs).\n      possible_gradient_type: One of gradients_util.POSSIBLE_GRADIENT_TYPES_*.\n      executing_eagerly: Boolean, the value of context.executing_eagerly().\n\n    Returns:\n      An object with a `forward` method returning a tuple of (forward_function :\n      _EagerDefinedFunction, augmented_arguments : List), and a corresponding\n      `record` method which takes outputs from the forward function and records\n      the operation. forward_function should be called with augmented_arguments.\n    \"\"\"\n    if executing_eagerly:\n      input_tangents = forwardprop_util.pack_tangents(args)\n    else:\n      input_tangents = forwardprop_util.TangentInfo()\n    need_gradients_for_jvps = tape.should_record_backprop(\n        input_tangents.tangents)\n    # Allows re-use of forward and backward function pairs depending on the\n    # tapes and forward accumulators watching its inputs.\n    cache_key = (need_gradients_for_jvps, input_tangents.indices)\n    if (possible_gradient_type\n        == gradients_util.POSSIBLE_GRADIENT_TYPES_FIRST_ORDER):\n      if input_tangents.indices or executing_eagerly:\n        # There is a single non-persistent tape active, so the user can only\n        # request first-order gradients from a tape. We can spend less time\n        # graph building since we know this.\n        #\n        # We may still end up computing higher-order gradients, but that'd be\n        # through `tf.gradients`, which can re-write the forward pass and so\n        # needs no preparation here.\n        functions = self._first_order_tape_functions.get(cache_key, None)\n        if functions is None:\n          functions = _FirstOrderTapeGradientFunctions(\n              self._func_graph, self._attrs, self._garbage_collector,\n              forwardprop_input_indices=input_tangents.indices,\n              delayed_rewrite_functions=self._delayed_rewrite_functions,\n              need_gradients_for_jvps=need_gradients_for_jvps)\n          self._first_order_tape_functions[cache_key] = functions\n        return _ForwardBackwardCall(\n            functions, args, input_tangents.tangents, tape_watching=True)\n      else:\n        # We can avoid computing second-order gradients in some cases by doing a\n        # delayed rewrite when graph building. Since we know we'll only compute\n        # first-order tape gradients, the delayed rewrite is safe: we won't need\n        # to tell the tape about side outputs.\n        #\n        # TODO(allenl): This case is really dirty. It would be better if we\n        # could temporarily pop all of the current tapes to avoid\n        # accidentally taking second-order gradients.\n        return _ForwardBackwardCall(\n            self._delayed_rewrite_functions, args, input_tangents.tangents,\n            tape_watching=True)\n    elif (possible_gradient_type\n          == gradients_util.POSSIBLE_GRADIENT_TYPES_HIGHER_ORDER):\n      # Either there's a persistent tape watching, or there are multiple nested\n      # tapes. Either way, the user may request higher-order gradients. We'll\n      # spend a bit more time and make sure higher-order gradients are correct.\n      functions = self._higher_order_tape_functions.get(\n          cache_key, None)\n      if functions is None:\n        functions = _HigherOrderTapeGradientFunctions(\n            self._func_graph, self._attrs, self._garbage_collector,\n            forwardprop_input_indices=input_tangents.indices,\n            delayed_rewrite_functions=self._delayed_rewrite_functions,\n            need_gradients_for_jvps=need_gradients_for_jvps)\n        self._higher_order_tape_functions[cache_key] = functions\n      return _ForwardBackwardCall(functions, args, input_tangents.tangents,\n                                  tape_watching=True)\n    # else possible_gradient_type == POSSIBLE_GRADIENT_TYPES_NONE, meaning no\n    # tape is recording.\n    return _ForwardBackwardCall(\n        self._delayed_rewrite_functions, args, input_tangents.tangents,\n        tape_watching=False)\n\n  def _build_call_outputs(self, result):\n    \"\"\"Maps the fdef output list to actual output structure.\n\n    Args:\n      result: Output lists defined by FunctionDef.\n    Returns:\n      The actual call output.\n    \"\"\"\n    # TODO(jlchu): call C++ version in function.cc when speed is improved\n    if self._func_graph.structured_outputs is None:\n      return result\n\n    # Replace outputs with results, skipping over any 'None' values.\n    outputs_list = nest.flatten(\n        self._func_graph.structured_outputs, expand_composites=True)\n    j = 0\n    for i, o in enumerate(outputs_list):\n      if o is not None:\n        handle_data_util.copy_handle_data(self.outputs[j], result[j])\n        outputs_list[i] = result[j]\n        j += 1\n    ret = nest.pack_sequence_as(self._func_graph.structured_outputs,\n                                outputs_list, expand_composites=True)\n    return ret\n\n  @property\n  def _as_name_attr_list(self):\n    \"\"\"Returns a `NameAttrList` representing this function.\"\"\"\n    ret = attr_value_pb2.NameAttrList(name=self.name)\n    for name, value in self._attrs.items():\n      ret.attr[name].CopyFrom(value)\n    return ret\n\n  def _structured_signature_summary(self, default_values=False):\n    \"\"\"Returns a string summarizing this function's structured signature.\n\n    Args:\n      default_values: If true, then include default values in the signature.\n\n    Returns:\n      A `string`.\n    \"\"\"\n    # Note: we can't just use self._funcion_spec.signature_summary(), because\n    # that would show \"_BOUND_VALUE\" as the default value for all arguments.\n    assert self._function_spec is not None\n    arg_specs, kwarg_specs = self.structured_input_signature\n    arg_names = list(self._function_spec.arg_names)\n\n    # If an explicit input_signature is provided to @tf.function, then any\n    # arguments with defaults that are not covered by that explicit signature\n    # are simply dropped from the signature.\n    # TODO(b/159639913) Look into whether dropping arguments with default values\n    # from the signature is the right thing to do.\n    arg_names = arg_names[:len(arg_specs)]\n\n    if default_values:\n      for i in range(len(arg_names)):\n        if not _contains_type_spec(arg_specs[i]):\n          arg_names[i] += \"={}\".format(arg_specs[i])\n    if kwarg_specs:\n      arg_names.append(\"*\")\n      for name, spec in kwarg_specs.items():\n        arg_names.append(name)\n        if default_values and not _contains_type_spec(spec):\n          arg_names[-1] += \"={}\".format(spec)\n    signature = f\"{self._func_graph.name}({', '.join(arg_names)})\"\n\n    return signature\n\n  def _flat_signature_summary(self):\n    \"\"\"Returns a string summarizing this function's flat signature.\"\"\"\n    assert self._arg_keywords is not None\n    assert self._num_positional_args is not None\n    arg_names = self._arg_keywords\n    if self._num_positional_args > len(arg_names):\n      arg_names.extend(\n          \"<arg{}>\".format(i + 1)\n          for i in range(len(arg_names), self._num_positional_args))\n    return f\"{self._func_graph.name}({', '.join(arg_names)})\"\n\n  def pretty_printed_signature(self, verbose=True):\n    \"\"\"Returns a string summarizing the signature of this concrete function.\"\"\"\n    if not verbose:\n      return self._structured_signature_summary(default_values=True)\n\n    def pretty_print_spec(spec):\n      \"\"\"Returns a string describing the spec for a single argument.\"\"\"\n      if isinstance(spec, tensor_spec.TensorSpec):\n        return \"{} Tensor, shape={}\".format(spec.dtype.name, spec.shape)\n      elif nest.is_sequence(spec):\n        pieces = nest.flatten(spec, expand_composites=False)\n        markers = [_Marker(\"<{}>\".format(i + 1)) for i in range(len(pieces))]\n        structure = nest.pack_sequence_as(spec, markers)\n        # Ensure dictionaries are sorted by key (for determinism)\n        result = pprint.pformat(structure, width=10000)\n        for (marker, piece) in zip(markers, pieces):\n          result += \"\\n      {}: {}\".format(marker, pretty_print_spec(piece))\n        return result\n      else:\n        return repr(spec)\n\n    lines = [self._structured_signature_summary(default_values=True)]\n    arg_specs, kwarg_specs = self.structured_input_signature\n    names = list(self._function_spec.arg_names)\n\n    # If an explicit input_signature is provided to @tf.function, then any\n    # arguments with defaults that are not covered by that explicit signature\n    # are simply dropped from the signature.\n    # TODO(b/159639913) Look into whether dropping arguments with default values\n    # from the signature is the right thing to do.\n\n    # Note: we can skip bound args, since we already displayed their bound\n    # value in the signature summary.\n    arg_details = []\n    for (name, spec) in zip(names[:len(arg_specs)], list(arg_specs)):\n      if _contains_type_spec(spec):\n        arg_details.append(\"    {}: {}\".format(name, pretty_print_spec(spec)))\n\n    if kwarg_specs:\n      for kwarg in sorted(kwarg_specs):\n        spec = kwarg_specs[kwarg]\n        if _contains_type_spec(spec):\n          arg_details.append(\"    {}: {}\".format(\n              kwarg, pretty_print_spec(spec)))\n\n    if arg_details:\n      lines.append(\"  Args:\")\n      lines.extend(arg_details)\n    lines.append(\"  Returns:\")\n\n    def spec_from_value(value):\n      # For loaded function, structured_outputs are already specs.\n      if isinstance(value, type_spec.TypeSpec):\n        return value\n      return type_spec.type_spec_from_value(value)\n\n    lines.append(\"    {}\".format(\n        pretty_print_spec(\n            nest.map_structure(spec_from_value, self.structured_outputs))))\n\n    return \"\\n\".join(lines)\n\n  def __repr__(self):\n    if self._function_spec is not None:\n      return \"<ConcreteFunction {} at 0x{:X}>\".format(\n          self.pretty_printed_signature(verbose=False), id(self))\n    elif not (self._num_positional_args is None or self._arg_keywords is None):\n      return \"<ConcreteFunction {} at 0x{:X}>\".format(\n          self._flat_signature_summary(), id(self))\n    else:\n      return object.__repr__(self)\n\n  def __str__(self):\n    if self._function_spec is not None:\n      return \"ConcreteFunction {}\".format(self.pretty_printed_signature())\n    else:\n      return self.__repr__()\n\n\n_pywrap_utils.RegisterType(\"Tensor\", ops.Tensor)\n_pywrap_utils.RegisterType(\"EagerTensor\", ops.EagerTensor)\n_pywrap_utils.RegisterType(\"IndexedSlices\", ops.IndexedSlices)\n\n\ndef _deterministic_dict_values(dictionary):\n  return tuple(dictionary[key] for key in sorted(dictionary))\n\n\nclass FunctionSpec(object):\n  \"\"\"Specification of how to bind arguments to a function.\"\"\"\n\n  @staticmethod\n  def from_function_and_signature(python_function,\n                                  input_signature,\n                                  is_pure=False,\n                                  experimental_follow_type_hints=False,\n                                  jit_compile=None):\n    \"\"\"Create a FunctionSpec instance given a python function and signature.\n\n    Args:\n      python_function: a function to inspect\n      input_signature: a signature of the function (None, if variable)\n      is_pure: if True all input arguments (including variables and constants)\n      will be converted to tensors and no variable changes allowed.\n      experimental_follow_type_hints: see `tf.function`\n      jit_compile: see `tf.function`\n\n    Returns:\n      instance of FunctionSpec\n    \"\"\"\n    fullargspec = tf_inspect.getfullargspec(python_function)\n    if (input_signature is not None and\n        set(fullargspec.kwonlyargs) - set(fullargspec.kwonlydefaults or ())):\n      nodefault_kwonlyargs = set(fullargspec.kwonlyargs)\n      if fullargspec.kwonlydefaults is not None:\n        nodefault_kwonlyargs -= set(fullargspec.kwonlydefaults)\n      raise ValueError(\"Cannot build TF function from \"\n                       f\"{python_function.__name__}: keyword-only arguments \"\n                       \"must have default values when input_signature is \"\n                       \"provided. Got keyword-only arguments without default \"\n                       f\"values: {sorted(nodefault_kwonlyargs)}.\")\n\n    # Checks if the `fullargspec` contains self or cls as its first argument.\n    is_method = tf_inspect.isanytargetmethod(python_function)\n\n    # Treat a wrapped partial function as a special case. For all arguments that\n    # were overridden with keywords in the partial:\n    #   - remove the corresponding arguments,\n    #   - remove the corresponding keywords.\n    _, unwrapped = tf_decorator.unwrap(python_function)\n    if isinstance(unwrapped, functools.partial):\n      # Also consider the Python3 case with kwonlydefaults.\n      if fullargspec.defaults or fullargspec.kwonlydefaults:\n        new_defaults = fullargspec.defaults\n        new_args = fullargspec.args\n        if fullargspec.defaults:\n          # To be able to canonicalize the function properly, we want to ignore\n          # default values that are overridden via a partial kwarg. For example:\n          #\n          #   def func(a, b, c, d=5, e=7):\n          #     return a, b, c, d, e\n          #   p_func = tf.function(functools.partial(func, 10, e=9))\n          #\n          # Here we want to drop from the defaults the parameter `e`. If we\n          # forwarded the call to the partial function with a default for `e`\n          # we would get an error for passing two values for one parameter.\n          #\n          # Note that this has a limitation: we can only override parameters at\n          # the end of the parameter list.\n          #\n          # In this case we want to end up with 3 arguments (b, c, d) and 1\n          # default value (5). We do this by constructing a mask where 0 stands\n          # for a value that was overridden by a partial kwarg. The seemingly\n          # complicated logic below does just that - for arguments (b, c, d, e)\n          # we would get a mask (1, 1, 1, 0).\n          old_args = fullargspec.args\n          old_defaults = fullargspec.defaults\n\n          no_default = object()\n          num_args_without_defaults = len(old_args) - len(old_defaults)\n          left_padding = tuple([no_default] * num_args_without_defaults)\n\n          args_with_defaults = zip(old_args, left_padding + old_defaults)\n\n          # Create a mask where 0 stands for args that had a partial kwarg\n          # defined.\n          non_keyword_defaults_mask = [\n              0 if key in unwrapped.keywords else 1 for key in old_args\n          ]\n          # Keep only arguments and defaults that were not kwargs of partial.\n          new_args_with_defaults = list(\n              itertools.compress(args_with_defaults, non_keyword_defaults_mask))\n          # Keep all args.\n          new_args = [arg for arg, _ in new_args_with_defaults]\n          # Keep only real default values.\n          new_defaults = [\n              default for _, default in new_args_with_defaults\n              if default is not no_default\n          ]\n        fullargspec = tf_inspect.FullArgSpec(\n            args=new_args,\n            varargs=fullargspec.varargs,\n            varkw=fullargspec.varkw,\n            defaults=new_defaults,\n            kwonlyargs=[],\n            kwonlydefaults={},\n            annotations=fullargspec.annotations)\n\n    # Get the function's name.  Remove functools.partial wrappers if necessary.\n    while isinstance(python_function, functools.partial):\n      python_function = python_function.func\n    name = getattr(python_function, \"__name__\", \"f\")\n\n    return FunctionSpec(\n        fullargspec,\n        is_method,\n        input_signature,\n        is_pure=is_pure,\n        jit_compile=jit_compile,\n        experimental_follow_type_hints=experimental_follow_type_hints,\n        name=name)\n\n  def __init__(self,\n               fullargspec,\n               is_method,\n               input_signature,\n               is_pure=False,\n               experimental_follow_type_hints=False,\n               name=None,\n               jit_compile=None):\n    \"\"\"Constructs a FunctionSpec describing a python function.\n\n    Args:\n      fullargspec: `tf_inspect.FullArgSpec` object describing the function.\n      is_method: True if the function is a method.\n      input_signature: a signature of the function (None, if variable)\n      is_pure: if True all input arguments (including variables and constants)\n        will be converted to tensors and no variable changes allowed.\n      experimental_follow_type_hints: see `tf.function`.\n      name: Name of the function\n      jit_compile: see `tf.function`.\n    \"\"\"\n    self._fullargspec = fullargspec\n    self._is_method = is_method\n    self._is_pure = is_pure\n    self._jit_compile = jit_compile\n    self._experimental_follow_type_hints = experimental_follow_type_hints\n\n    # TODO(edloper): Include name when serializing for SavedModel?\n    self._name = name or \"f\"\n\n    if self._is_method:\n      # Remove `self`: default arguments shouldn't be matched to it.\n      # TODO(b/127938157): Should this error out if there is no arg to\n      # be removed?\n      args = fullargspec.args[1:]\n    else:\n      args = fullargspec.args\n\n    # A cache mapping from argument name to index, for canonicalizing\n    # arguments that are called in a keyword-like fashion.\n    self._args_to_indices = {arg: i for i, arg in enumerate(args)}\n    self._arg_names = args\n\n    # A cache mapping from arg index to default value, for canonicalization.\n    default_values = fullargspec.defaults\n    offset = len(args) - len(default_values or [])\n    self._arg_indices_to_default_values = {\n        offset + index: default\n        for index, default in enumerate(default_values or [])\n    }\n    self._arg_indices_no_default_values = set(range(len(args))) - set(\n        self._arg_indices_to_default_values)\n    if input_signature is None:\n      self._input_signature = None\n    else:\n      self._input_signature = tuple(input_signature)\n      self._flat_input_signature = tuple(nest.flatten(input_signature,\n                                                      expand_composites=True))\n\n  @property\n  def fullargspec(self):\n    return self._fullargspec\n\n  @property\n  def is_method(self):\n    return self._is_method\n\n  @property\n  def args_to_indices(self):\n    return self._args_to_indices\n\n  @property\n  def kwargs_to_include(self):\n    return self._kwargs_to_include\n\n  @property\n  def input_signature(self):\n    return self._input_signature\n\n  @property\n  def flat_input_signature(self):\n    return self._flat_input_signature\n\n  @property\n  def is_pure(self):\n    return self._is_pure\n\n  @property\n  def jit_compile(self):\n    return self._jit_compile\n\n  @property\n  def arg_names(self):\n    return self._arg_names\n\n  @property\n  def vararg_name(self):\n    return self._fullargspec.varargs\n\n  @property\n  def varkw_name(self):\n    return self._fullargspec.varkw\n\n  def signature_summary(self, default_values=False):\n    \"\"\"Returns a string summarizing this function's signature.\n\n    Args:\n      default_values: If true, then include default values in the signature.\n\n    Returns:\n      A `string`.\n    \"\"\"\n    args = list(self._arg_names)\n    if default_values:\n      for (i, default) in self._arg_indices_to_default_values.items():\n        args[i] += \"={}\".format(default)\n    if self._fullargspec.kwonlyargs:\n      args.append(\"*\")\n      for arg_name in self._fullargspec.kwonlyargs:\n        args.append(arg_name)\n        if default_values and arg_name in self._fullargspec.kwonlydefaults:\n          args[-1] += \"={}\".format(self._fullargspec.kwonlydefaults[arg_name])\n    return f\"{self._name}({', '.join(args)})\"\n\n  def _to_tensor_or_tensor_spec(self, x):\n    return (x if isinstance(x, (ops.Tensor, tensor_spec.TensorSpec))\n            else ops.convert_to_tensor(x))\n\n  def _convert_variables_to_tensors(self, args, kwargs):\n    args = [self._to_tensor_or_tensor_spec(x) for x in args]\n    kwargs = {kw: self._to_tensor_or_tensor_spec(x)\n              for kw, x in kwargs.items()}\n    return tuple(args), kwargs\n\n  def _convert_annotated_args_to_tensors(self, args, kwargs):\n    \"\"\"Attempts to autobox arguments annotated as tf.Tensor.\"\"\"\n    if self.input_signature is not None:\n      return\n\n    args = list(args)\n    for i, arg in enumerate(args):\n      # See\n      # https://docs.python.org/3/library/inspect.html#inspect.getfullargspec\n      if i < len(self._fullargspec.args):\n        annotation_key = self._fullargspec.args[i]\n      else:\n        annotation_key = self._fullargspec.varargs\n      arg_annotation = self._fullargspec.annotations.get(annotation_key, None)\n\n      # TODO(rahulkamat): Change to TensorLike (here ans below)\n      if arg_annotation == ops.Tensor:\n        args[i] = self._to_tensor_or_tensor_spec(arg)\n\n    for kw, v in kwargs.items():\n      if kw in self._fullargspec.kwonlyargs or kw in self._fullargspec.args:\n        annotation_key = kw\n      else:\n        annotation_key = self._fullargspec.varkw\n      kwarg_annotation = self._fullargspec.annotations.get(annotation_key, None)\n      if kwarg_annotation == ops.Tensor:\n        kwargs[kw] = self._to_tensor_or_tensor_spec(v)\n    return tuple(args), kwargs\n\n  def _validate_inputs(self, flat_inputs):\n    \"\"\"Raises an error if inputs contain illegal values.\"\"\"\n    for inp in flat_inputs:\n      # TODO(b/183107079): Allow these once they're handled properly.\n      if isinstance(inp, weakref.ref):\n        raise ValueError(\n            f\"weakref input {inp} not supported for function {self._name}\")\n\n  def canonicalize_function_inputs(self, *args, **kwargs):\n    \"\"\"Canonicalizes `args` and `kwargs`.\n\n    Canonicalize the inputs to the Python function using a `FunctionSpec`\n    instance. In particular, we parse the varargs and kwargs that the\n    original function was called with into a tuple corresponding to the\n    Python function's positional (named) arguments and a dictionary\n    corresponding to its kwargs.  Missing default arguments are added.\n\n    If this `FunctionSpec` has an input signature, then it is used to convert\n    arguments to tensors; otherwise, any inputs containing numpy arrays are\n    converted to tensors.\n\n    Additionally, any inputs containing numpy arrays are converted to Tensors.\n\n    Args:\n      *args: The varargs this object was called with.\n      **kwargs: The keyword args this function was called with.\n\n    Returns:\n      A canonicalized ordering of the inputs, as well as full and filtered\n      (Tensors and Variables only) versions of their concatenated flattened\n      representations, represented by a tuple in the form (args, kwargs,\n      flat_args, filtered_flat_args). Here: `args` is a full list of bound\n      arguments, and `kwargs` contains only true keyword arguments, as opposed\n      to named arguments called in a keyword-like fashion.\n\n    Raises:\n      ValueError: If a keyword in `kwargs` cannot be matched with a positional\n        argument when an input signature is specified, or when the inputs\n        do not conform to the input signature.\n    \"\"\"\n    if self._is_pure:\n      args, kwargs = self._convert_variables_to_tensors(args, kwargs)\n    if self._experimental_follow_type_hints:\n      args, kwargs = self._convert_annotated_args_to_tensors(args, kwargs)\n    # Pre-calculate to reduce overhead\n    arglen = len(args)\n    if self._input_signature is not None:\n      if arglen > len(self._input_signature):\n        raise TypeError(f\"{self.signature_summary()} specifies \"\n                        f\"{len(self._input_signature)} positional arguments, \"\n                        f\"but got {arglen}.\")\n      for arg in six.iterkeys(kwargs):\n        index = self._args_to_indices.get(arg, None)\n        if index is None:\n          raise TypeError(f\"{self.signature_summary()} got unexpected keyword \"\n                          f\"argument `{arg}`.\")\n        if index >= len(self._input_signature):\n          raise TypeError(\n              f\"{self.signature_summary()} got keyword argument `{arg}` that \"\n              \"was not included in input_signature.\")\n\n    if not kwargs:\n      inputs = args\n      if self._arg_indices_to_default_values:\n        try:\n          inputs += tuple(self._arg_indices_to_default_values[i]\n                          for i in range(arglen, len(self._arg_names)))\n        except KeyError:\n          missing_args = [\n              self._arg_names[i]\n              for i in range(arglen, len(self._arg_names))\n              if i not in self._arg_indices_to_default_values\n          ]\n          raise TypeError(f\"{self.signature_summary()} missing required \"\n                          f\"arguments: {', '.join(missing_args)}.\")\n\n      if self._fullargspec.kwonlydefaults:\n        kwargs.update(self._fullargspec.kwonlydefaults)\n    else:\n      # Maps from index of arg to its corresponding value, according to `args`\n      # and `kwargs`; seeded with the default values for the named args that\n      # aren't in `args`.\n      arg_indices_to_values = {\n          index: default for index, default in six.iteritems(\n              self._arg_indices_to_default_values) if index >= arglen\n      }\n      consumed_args = []\n      missing_arg_indices = self._arg_indices_no_default_values - set(\n          range(arglen))\n      for arg, value in six.iteritems(kwargs):\n        index = self._args_to_indices.get(arg, None)\n        if index is not None:\n          if index < arglen:\n            raise TypeError(f\"{self.signature_summary()} got two values for \"\n                            f\"{arg!r}.\")\n          arg_indices_to_values[index] = value\n          # These arguments in 'kwargs' might also belong to\n          # positional arguments\n          missing_arg_indices.discard(index)\n          consumed_args.append(arg)\n      for arg in consumed_args:\n        # After this loop, `kwargs` will only contain keyword_only arguments,\n        # and all positional_or_keyword arguments have been moved to `inputs`.\n        kwargs.pop(arg)\n      inputs = args + _deterministic_dict_values(arg_indices_to_values)\n      # Exclude positional args with values\n      if missing_arg_indices:\n        missing_args = [self._arg_names[i] for i in sorted(missing_arg_indices)]\n        if len(missing_args) == 1:\n          raise TypeError(f\"{self.signature_summary()} missing 1 required \"\n                          f\"argument: {missing_args[0]}.\")\n        else:\n          raise TypeError(f\"{self.signature_summary()} missing required \"\n                          f\"arguments: {', '.join(missing_args)}.\")\n\n      if kwargs and self._input_signature is not None:\n        raise TypeError(\"Keyword arguments are not supported when \"\n                        \"input_signature is provided. Signature: \"\n                        f\"{self.signature_summary()}. Keyword arguments: \"\n                        f\"{kwargs}.\")\n\n      if self._fullargspec.kwonlydefaults:\n        for (kwarg, default) in self._fullargspec.kwonlydefaults.items():\n          kwargs.setdefault(kwarg, default)\n\n    if self._input_signature is None:\n      inputs, flat_inputs, filtered_flat_inputs = _convert_numpy_inputs(inputs)\n      kwargs, flat_kwargs, filtered_flat_kwargs = _convert_numpy_inputs(kwargs)\n      flat_inputs += flat_kwargs\n      filtered_flat_inputs += filtered_flat_kwargs\n    else:\n      inputs, flat_inputs, filtered_flat_inputs = _convert_inputs_to_signature(\n          inputs, self._input_signature, self._flat_input_signature)\n\n    self._validate_inputs(flat_inputs)\n\n    return inputs, kwargs, flat_inputs, filtered_flat_inputs\n\n\ndef _convert_numpy_inputs(inputs):\n  \"\"\"Convert numpy array inputs to tensors.\"\"\"\n  # We assume that any CompositeTensors have already converted their components\n  # from numpy arrays to Tensors, so we don't need to expand composites here for\n  # the numpy array conversion. Instead, we do so because the flattened inputs\n  # are eventually passed to ConcreteFunction()._call_flat, which requires\n  # expanded composites.\n  flat_inputs = nest.flatten(inputs, expand_composites=True)\n\n  # Check for NumPy arrays in arguments and convert them to Tensors.\n  # TODO(nareshmodi): Skip ndarray conversion to tensor altogether, perhaps\n  # finding a way to store them directly in the cache key (currently not\n  # possible since ndarrays are not hashable).\n  need_packing = False\n  filtered_flat_inputs = []\n  for index, value in enumerate(flat_inputs):\n    if isinstance(value,\n                  (ops.Tensor, resource_variable_ops.BaseResourceVariable)):\n      filtered_flat_inputs.append(value)\n    elif hasattr(value, \"__array__\") and not (\n        hasattr(value, \"_should_act_as_resource_variable\") or\n        isinstance(value, (np.str_, type, composite_tensor.CompositeTensor))):\n      # This case is equivalent to _is_ndarray(value) == True\n      a = value.__array__()\n      if not isinstance(a, np.ndarray):\n        raise TypeError(f\"The output of __array__ must be an np.ndarray, \"\n                        f\"got {type(a)} from {value}.\")\n      flat_inputs[index] = constant_op.constant(a)\n      filtered_flat_inputs.append(flat_inputs[index])\n      need_packing = True\n  if need_packing:\n    return (nest.pack_sequence_as(\n        structure=inputs, flat_sequence=flat_inputs,\n        expand_composites=True), flat_inputs, filtered_flat_inputs)\n  else:\n    return inputs, flat_inputs, filtered_flat_inputs\n\n\ndef _convert_inputs_to_signature(inputs, input_signature, flat_input_signature):\n  \"\"\"Convert inputs to pass into a function with an explicit signature.\"\"\"\n\n  def format_error_message(inputs, input_signature):\n    return (\"  inputs: (\\n\" + \"    \" + \",\\n    \".join(str(i) for i in inputs) +\n            \")\\n\" + \"  input_signature: (\\n\" + \"    \" +\n            \",\\n    \".join(str(i) for i in input_signature) + \")\")\n\n  try:\n    flatten_inputs = nest.flatten_up_to(\n        input_signature,\n        inputs[:len(input_signature)],\n        expand_composites=True,\n        check_types=False)  # lists are convert to tuples for `tf.data`.\n  except ValueError:\n    raise ValueError(\"Structure of Python function inputs does not match \"\n                     \"input_signature:\\n\"\n                     f\"{format_error_message(inputs, input_signature)}.\")\n\n  need_packing = False\n  for index, (value, spec) in enumerate(zip(flatten_inputs,\n                                            flat_input_signature)):\n    if (isinstance(spec, tensor_spec.TensorSpec) and\n        not _pywrap_utils.IsTensor(value)):\n      try:\n        flatten_inputs[index] = ops.convert_to_tensor(\n            value, dtype_hint=spec.dtype)\n        need_packing = True\n      except ValueError:\n        raise ValueError(\"When input_signature is provided, all inputs to \"\n                         \"the Python function must be convertible to \"\n                         \"tensors:\\n\"\n                         f\"{format_error_message(inputs, input_signature)}.\")\n\n  if any(not spec.is_compatible_with(other) for spec, other in zip(\n      flat_input_signature,\n      flatten_inputs)):\n    raise ValueError(\"Python inputs incompatible with input_signature:\\n\"\n                     f\"{format_error_message(inputs, input_signature)}.\")\n\n  if need_packing:\n    inputs = nest.pack_sequence_as(\n        structure=input_signature,\n        flat_sequence=flatten_inputs,\n        expand_composites=True)\n\n  flat_inputs = nest.flatten(inputs, expand_composites=True)\n\n  return (inputs, flat_inputs, [\n      t for t in flat_inputs\n      if isinstance(t, (ops.Tensor, resource_variable_ops.BaseResourceVariable))\n  ])\n\n\nclass FunctionCache(object):\n  \"\"\"A lightweight container for cached functions.\n  \"\"\"\n\n  __slots__ = [\n      \"missed\", \"primary\", \"arg_relaxed_specs\", \"arg_relaxed\",\n      \"_garbage_collectors\"\n  ]\n\n  def __init__(self):\n    # The set of functions that have been missed; entries are CacheKey with\n    # input_signature `None` (e.g. a \"call context key\")\n    self.missed = set()\n    # The primary cache, mapping a fully shaped CacheKey to a function.\n    self.primary = collections.OrderedDict()\n    # A cache key lookup, mapping a CacheKey generated without shape info to a\n    # flat list of `TypeSpec`s with relaxed shapes (one for each flattened\n    # argument). Arguments that are not Tensors or `CompositeTensor`s contain a\n    # `None` for the corresponding relaxed spec.\n    self.arg_relaxed_specs = collections.OrderedDict()\n    # The secondary cache, mapping a CacheKey generated without shape info to a\n    # function.\n    self.arg_relaxed = collections.OrderedDict()\n    # All OrderedDicts require manual garbage collection.\n    self._garbage_collectors = [\n        _FunctionGarbageCollector(self.primary),\n        _FunctionGarbageCollector(self.arg_relaxed),\n        _FunctionGarbageCollector(self.arg_relaxed_specs)]\n\n  def all_values(self):\n    \"\"\"A list of all `ConcreteFunction` instances held by this cache.\"\"\"\n    # We need to simultaneously make sure our returned concrete functions are\n    # unique *and* make sure they are returned in a deterministic order for\n    # serialization.\n    #\n    # TODO(b/174215821): It's likely that we ultimately would just prefer to\n    # choose the most specific concrete function shape given a set of\n    # arguments. If and when that is implemented, this logic can be revisited.\n    primary_functions = set(self.primary.values())\n    return list(self.primary.values()) + [\n        v for v in self.arg_relaxed.values() if v not in primary_functions]\n\n\n# TODO(mdan): Refactor this and clarify relationship with def_function.Function.\n# Right now, def_function.Function is the higher level implementation.\nclass Function(object):\n  \"\"\"Wrapper class for the graph functions defined for a Python function.\n\n  See the documentation for `defun` for more information on the semantics of\n  defined functions.\n\n  `Function` class is thread-compatible meaning that minimal usage of defuns\n  (defining and calling) is thread-safe, but if users call other methods or\n  invoke the base `python_function` themselves, external synchronization is\n  necessary.\n  In addition, Function is not reentrant, so recursive functions need to call\n  the wrapped function, not the wrapper.\n  \"\"\"\n\n  def __init__(self,\n               python_function,\n               name,\n               input_signature=None,\n               attributes=None,\n               autograph=True,\n               autograph_options=None,\n               experimental_relax_shapes=False,\n               capture_by_value=None,\n               jit_compile=None,\n               experimental_follow_type_hints=False):\n    \"\"\"Initializes a `Function`.\n\n    Args:\n      python_function: the function to be wrapped.\n      name: the name given to it.\n      input_signature: a possibly nested sequence of `TensorSpec` objects\n        specifying the input signature of this function. If `None`, a separate\n        function is instantiated for each inferred input signature.\n      attributes: dict, extra keyword arguments that will be added as attribute\n        of the function.\n      autograph: whether to use autograph to compile\n        `python_function`. See https://www.tensorflow.org/guide/autograph for\n        more information.\n      autograph_options: Experimental knobs to control behavior\n        `when autograph=True`. See https://www.tensorflow.org/guide/autograph\n        for more information.\n      experimental_relax_shapes: When true, argument shapes may be relaxed to\n        avoid unnecessary retracing.\n      capture_by_value: Experimental. Whether to capture resource variables by\n        value or reference. If None, will inherit from a parent context or\n        default to False.\n      jit_compile: Force-compile the function with XLA, cf.\n        def_function.Function doc on jit_compile.\n      experimental_follow_type_hints: See the documentation for `tf.function`.\n\n    Raises:\n      ValueError: if `input_signature` is not None and the `python_function`'s\n        argspec has keyword arguments.\n    \"\"\"\n    self._python_function = python_function\n    pure_function = attributes and IMPLEMENTS_ATTRIBUTE_NAME in attributes\n    self._function_spec = FunctionSpec.from_function_and_signature(\n        python_function,\n        input_signature,\n        is_pure=pure_function,\n        experimental_follow_type_hints=experimental_follow_type_hints)\n    self._name = name\n    self._autograph = autograph\n    self._autograph_options = autograph_options\n    self._experimental_relax_shapes = experimental_relax_shapes\n    self._function_cache = FunctionCache()\n    self._function_attributes = attributes or {}\n    self._capture_by_value = capture_by_value\n    self.tracing_count = 0\n    if self.input_signature is not None:\n      self._hashable_input_signature = hash(self.flat_input_signature)\n\n    self._lock = threading.RLock()\n    # _descriptor_cache is a of instance of a class to an instance-specific\n    # `Function`, used to make sure defun-decorated methods create different\n    # functions for each instance.\n    self._descriptor_cache = weakref.WeakKeyDictionary()\n    self._jit_compile = jit_compile\n    self._experimental_follow_type_hints = experimental_follow_type_hints\n\n  def __call__(self, *args, **kwargs):\n    \"\"\"Calls a graph function specialized to the inputs.\"\"\"\n    with self._lock:\n      (graph_function,\n       filtered_flat_args) = self._maybe_define_function(args, kwargs)\n    return graph_function._call_flat(\n        filtered_flat_args, captured_inputs=graph_function.captured_inputs)  # pylint: disable=protected-access\n\n  @property\n  def python_function(self):\n    \"\"\"Returns the wrapped Python function.\"\"\"\n    return self._python_function  # pylint: disable=protected-access\n\n  @property\n  def function_spec(self):\n    return self._function_spec\n\n  @property\n  def input_signature(self):\n    \"\"\"Returns the input signature.\"\"\"\n    return self._function_spec.input_signature\n\n  @property\n  def flat_input_signature(self):\n    \"\"\"Returns the flattened input signature.\"\"\"\n    return self._function_spec.flat_input_signature\n\n  def _get_concrete_function_internal_garbage_collected(self, *args, **kwargs):\n    \"\"\"Returns a concrete function which cleans up its graph function.\"\"\"\n    if self.input_signature:\n      args, kwargs = None, None\n    with self._lock:\n      graph_function, _ = self._maybe_define_function(args, kwargs)\n    return graph_function\n\n  def _get_concrete_function_internal(self, *args, **kwargs):\n    \"\"\"Bypasses error checking when getting a graph function.\"\"\"\n    graph_function = self._get_concrete_function_internal_garbage_collected(\n        *args, **kwargs)\n    # We're returning this concrete function to someone, and they may keep a\n    # reference to the FuncGraph without keeping a reference to the\n    # ConcreteFunction object. So we won't clean up the reference cycles\n    # manually and instead will leave them to Python's garbage collector.\n    graph_function._garbage_collector.release()  # pylint: disable=protected-access\n    return graph_function\n\n  def _get_concrete_function_garbage_collected(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` specialized to inputs and execution context.\n\n    Unlike `get_concrete_function(...)`, the graph will be deleted when the\n    returned function is deleted.  It's useful to avoid creating a reference\n    cycle when you know for sure that the graph will be no longer used without\n    the returned function.\n\n    Args:\n      *args: inputs to specialize on.\n      **kwargs: inputs to specialize on.\n    \"\"\"\n    if self.input_signature:\n      if kwargs:\n        raise ValueError(\"Cannot define a TensorFlow function from a Python \"\n                         \"function with keyword arguments when \"\n                         \"input_signature is provided, got keyword arguments \"\n                         f\"({kwargs}) with input_signature \"\n                         f\"({self.input_signature}).\")\n      if args:\n        # If args are provided, they must match the input signature.\n        if not is_same_structure(self.input_signature, args):\n          raise ValueError(\"Structure of Python function inputs does not match \"\n                           f\"input_signature: inputs ({args}), \"\n                           f\"input_signature ({self.input_signature}).\")\n        flat_inputs = nest.flatten(args, expand_composites=True)\n        if any(not isinstance(arg, (ops.Tensor, tensor_spec.DenseSpec,\n                                    resource_variable_ops.BaseResourceVariable))\n               for arg in flat_inputs):\n          raise ValueError(\"When input_signature is provided, all inputs to \"\n                           \"the Python function must be Tensors, Variables, \"\n                           \"tf.TensorSpec or tf.VariableSpec objects.\")\n        if any(not spec.is_compatible_with(other)\n               for spec, other in zip(self.flat_input_signature, flat_inputs)):\n          raise ValueError(\"Python inputs incompatible with input_signature: \"\n                           f\"inputs ({args}), input_signature \"\n                           f\"({self.input_signature}).\")\n      args, kwargs = None, None\n    with self._lock:\n      graph_function, _ = self._maybe_define_function(args, kwargs)\n      seen_names = set()\n      captured = object_identity.ObjectIdentitySet(\n          graph_function.graph.internal_captures)\n      # pylint: disable=protected-access\n      graph_function._arg_keywords = []\n      prefix_counts = {}\n      # pylint: enable=protected-access\n      num_positional = 0\n      for arg in graph_function.graph.inputs:\n        if arg in captured:\n          break\n        num_positional += 1\n        user_arg_name = compat.as_str(arg.op.get_attr(\"_user_specified_name\"))\n        proposal = user_arg_name\n        while proposal in seen_names:\n          index = prefix_counts.get(user_arg_name, 1)\n          proposal = \"{}_{}\".format(user_arg_name, index)\n          prefix_counts[user_arg_name] = index + 1\n        seen_names.add(proposal)\n        graph_function._arg_keywords.append(proposal)  # pylint: disable=protected-access\n      # Anything can be a positional argument, in the same order as .inputs\n      graph_function._num_positional_args = num_positional  # pylint: disable=protected-access\n      return graph_function\n\n  def get_concrete_function(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` specialized to inputs and execution context.\n\n    Args:\n      *args: inputs to specialize on. Can be concrete values (e.g. 1)\n         or `tf.Tensor` or `tf.TensorSpec`.\n      **kwargs: keyword inputs to specialize on. Concrete values (e.g. 1)\n         or `tf.Tensor` or `tf.TensorSpec`.\n    \"\"\"\n    graph_function = self._get_concrete_function_garbage_collected(\n        *args, **kwargs)\n    graph_function._garbage_collector.release()  # pylint: disable=protected-access\n    return graph_function\n\n  def __get__(self, instance, owner):\n    \"\"\"Makes it possible to defun instance methods.\"\"\"\n    del owner\n    # `instance` here is the instance that this `Function` was accessed through\n    # e.g., for\n    #\n    #   class Foo(object):\n    #\n    #     @function.defun\n    #     def bar(self):\n    #       ...\n    #\n    #   foo = Foo()\n    #   foo.bar()  # `foo.bar` is a `Function` instance\n    #\n    # then `instance` will be `foo` (and `owner` will be `Foo`).  We create a\n    # new instance of `Function` here to allow different instances each\n    # to create variables once, thereby allowing methods to be decorated with\n    # defun. Keeps a cache to avoid retracing the function every time the\n    # descriptor is accessed.\n    if instance not in self._descriptor_cache:\n      if instance is None:\n        return self\n      # If there is no instance-specific `Function` in the cache, we construct\n      # an instance-specific `Function` that uses a weak reference to the\n      # instance (so that the instance will be correctly gc'd).\n\n      # And finally add the wrapped function to the description cache\n      self._descriptor_cache[instance] = class_method_to_instance_method(\n          self, instance)\n\n    # Return the cached `Function` for the instance\n    return self._descriptor_cache[instance]\n\n  def _cache_key(self,\n                 args,\n                 kwargs,\n                 cache_key_context,\n                 include_tensor_ranks_only=False):\n    \"\"\"Computes the cache key given inputs and execution context.\"\"\"\n    if self.input_signature is None:\n      # We always use both args and kwargs to form input even if one is empty.\n      # This reduces ambiguity, for example, when args contains a dict and\n      # kwargs is empty.\n      inputs = (args, kwargs)\n      hashable_input_signature = function_trace_type.get_arg_spec(\n          inputs, include_tensor_ranks_only, ENCODE_VARIABLES_BY_RESOURCE_ID,\n          USE_FULL_TRACE_TYPE)\n    else:\n      del args, kwargs\n      assert not include_tensor_ranks_only\n      hashable_input_signature = self._hashable_input_signature\n\n    (parent_graph, device_functions, colocation_stack, in_cross_replica_context,\n     variable_policy, xla_context_id) = cache_key_context\n\n    return CacheKey(hashable_input_signature, parent_graph, device_functions,\n                    colocation_stack, in_cross_replica_context, variable_policy,\n                    xla_context_id)\n\n  def _cache_key_context(self):\n    \"\"\"Returns execution context.\"\"\"\n    ctx = context.context()\n\n    # Don't need to open an init_scope if the _cache_key call is in eager mode\n    # already.\n    executing_eagerly = ctx.executing_eagerly()\n    parent_graph = None\n    xla_context_id = 0\n    if not executing_eagerly:\n      # We want to force function retracing for each different\n      # XLAControlFlowContext, so add `xla_context_id` to the cache key.\n      xla_context = _enclosing_xla_context()\n      if xla_context is not None and \\\n            xla_context.RequiresUniqueFunctionRetracing():\n        xla_context_id = id(xla_context)\n\n      with ops.init_scope():\n        # The graph, or whether we're executing eagerly, should be a part of the\n        # cache key so we don't improperly capture tensors such as variables.\n        executing_eagerly = ctx.executing_eagerly()\n        parent_graph = None if executing_eagerly else ops.get_default_graph()\n\n    # pylint: disable=protected-access\n    default_graph = ops.get_default_graph()\n    # TODO(b/117617952): The current distribution strategy will affect graph\n    # building (e.g. accessing different variables from different devices) and\n    # so requires retracing for each device.\n    strategy_stack = default_graph._distribution_strategy_stack\n    uses_distribution_strategy = (\n        strategy_stack and\n        strategy_stack[-1].strategy.extended._retrace_functions_for_each_device\n    )\n    if executing_eagerly:\n      colocation_stack = ()\n      if uses_distribution_strategy:\n        device_functions = (pydev.merge_device(ctx.device_name),)\n      else:\n        device_functions = ()\n    else:\n      colocation_stack = tuple(default_graph._colocation_stack.peek_objs())\n      if (uses_distribution_strategy\n          or func_graph_module.device_stack_has_callable(\n              default_graph._device_function_stack)):\n        # Putting the device in the cache key ensures that call-site device\n        # annotations are respected.\n        device_functions = tuple(default_graph._device_functions_outer_to_inner)\n      else:\n        device_functions = ()\n\n    in_cross_replica_context = False\n    try:\n      in_cross_replica_context = (strategy_stack[-1].replica_context is None)  # pylint: disable=protected-access\n    except (AttributeError, IndexError):\n      pass\n\n    if save_context.in_save_context():\n      variable_policy = (\n          save_context.get_save_options().experimental_variable_policy)\n    else:\n      variable_policy = None\n\n    return (parent_graph, device_functions, colocation_stack,\n            in_cross_replica_context, variable_policy, xla_context_id)\n\n  def _create_graph_function(self, args, kwargs, override_flat_arg_shapes=None):\n    \"\"\"Create a `ConcreteFunction` from `args` and `kwargs`.\"\"\"\n    self.tracing_count += 1\n\n    if self.input_signature is None:\n      arglen = len(args)\n    else:\n      arglen = len(self.input_signature)\n    base_arg_names = self._function_spec.arg_names[:arglen]\n    num_missing_args = arglen - len(self._function_spec.arg_names)\n    missing_arg_names = [self._function_spec.vararg_name] * num_missing_args\n    # Produce a list of missing args of the form [\"arg_0\", \"arg_1\", ...],\n    # where arg is based on the self._function_spec.vararg_name.\n    missing_arg_names = [\n        \"%s_%d\" % (arg, i) for i, arg in enumerate(missing_arg_names)\n    ]\n    arg_names = base_arg_names + missing_arg_names\n    graph_function = ConcreteFunction(\n        func_graph_module.func_graph_from_py_func(\n            self._name,\n            self._python_function,\n            args,\n            kwargs,\n            self.input_signature,\n            autograph=self._autograph,\n            autograph_options=self._autograph_options,\n            arg_names=arg_names,\n            override_flat_arg_shapes=override_flat_arg_shapes,\n            capture_by_value=self._capture_by_value),\n        self._function_attributes,\n        function_spec=self.function_spec,\n        # Tell the ConcreteFunction to clean up its graph once it goes out of\n        # scope. This is not the default behavior since it gets used in some\n        # places (like Keras) where the FuncGraph lives longer than the\n        # ConcreteFunction.\n        shared_func_graph=False)\n    return graph_function\n\n  def _define_function_with_shape_relaxation(self, args, kwargs, flat_args,\n                                             filtered_flat_args,\n                                             cache_key_context):\n    \"\"\"Define a function, relaxing arg shapes to avoid unnecessary retracing.\"\"\"\n    flat_no_comp = nest.flatten((args, kwargs), expand_composites=False)\n\n    any_composite_args = any(\n        isinstance(x, composite_tensor.CompositeTensor) for x in flat_no_comp)\n\n    # Build a cache key where TensorShapes include only rank information (and\n    # not information about the size of each dimension).\n    if not any_composite_args:\n      rank_only_cache_key = self._cache_key(\n          args, kwargs, cache_key_context, include_tensor_ranks_only=True)\n    else:\n      # For the rank-only cache key, replace any composite tensors with\n      # shape-relaxed TypeSpecs.\n      (cache_key_args, cache_key_kwargs) = nest.map_structure(\n          _shape_relaxed_type_for_composite_tensor, (args, kwargs))\n      rank_only_cache_key = self._cache_key(\n          cache_key_args,\n          cache_key_kwargs,\n          cache_key_context,\n          include_tensor_ranks_only=True)\n\n    arg_specs = [_type_spec_for(x) for x in flat_no_comp]\n    relaxed_arg_specs = self._function_cache.arg_relaxed_specs.get(\n        rank_only_cache_key, None)\n    relaxed_arg_function = self._function_cache.arg_relaxed.get(\n        rank_only_cache_key, None)\n\n    if (relaxed_arg_function is not None\n        and all(_is_type_subset(x, y) for (x, y) in\n                zip(relaxed_arg_specs, arg_specs))):\n      return relaxed_arg_function, filtered_flat_args\n\n    if relaxed_arg_specs is None:\n      relaxed_arg_specs = arg_specs\n    else:\n      if len(arg_specs) != len(relaxed_arg_specs):\n        raise RuntimeError(\"Expected arg_specs len to match relaxed_arg_specs \"\n                           f\"len: {len(arg_specs):d} vs. \"\n                           f\"{len(relaxed_arg_specs):d}.\")\n      relaxed_arg_specs = [\n          x if x is None else x.most_specific_compatible_type(y)\n          for (x, y) in zip(arg_specs, relaxed_arg_specs)]\n    self._function_cache.arg_relaxed_specs[rank_only_cache_key] = (\n        relaxed_arg_specs)\n    relaxed_arg_shapes = [\n        x if x is None else x.shape\n        for x in nest.flatten(relaxed_arg_specs, expand_composites=True)]\n\n    if any_composite_args:\n      # Rebuild composite tensors with the relaxed TypeSpecs.  For example,\n      # if a tf.data iterator is passed as an argument, then we need to relax\n      # the TensorShapes in its element_spec.\n      (relaxed_arg_specs, relaxed_kwarg_specs) = nest.pack_sequence_as(\n          (args, kwargs), relaxed_arg_specs, expand_composites=False)\n      (args, kwargs) = nest.pack_sequence_as(\n          (relaxed_arg_specs, relaxed_kwarg_specs),\n          flat_args,\n          expand_composites=True)\n\n    graph_function = self._create_graph_function(\n        args, kwargs, override_flat_arg_shapes=relaxed_arg_shapes)\n    self._function_cache.arg_relaxed[rank_only_cache_key] = graph_function\n\n    return (graph_function, [\n        t for t in nest.flatten((args, kwargs), expand_composites=True)\n        if isinstance(t, (ops.Tensor,\n                          resource_variable_ops.BaseResourceVariable))\n    ])\n\n  def _maybe_define_function(self, args, kwargs):\n    \"\"\"Gets a function for these inputs, defining it if necessary.\n\n    `args` and `kwargs` can be None if this `Function` was created with an\n    `input_signature`.\n\n    Caller must hold self._lock.\n\n    Args:\n      args: The varargs for the Python function.\n      kwargs: The keyword args for the Python function.\n\n    Returns:\n      A graph function corresponding to the input signature implied by args and\n      kwargs, as well as filtered flattened inputs (only Tensors and Variables)\n      that the object should be called with.\n\n    Raises:\n      ValueError: If inputs are incompatible with the input signature.\n      TypeError: If the function inputs include non-hashable objects\n      RuntimeError: If there's an internal bug (inconsistency) in handling\n        shape relaxation retracing.\n    \"\"\"\n    if self.input_signature is None or args is not None or kwargs is not None:\n      args, kwargs, flat_args, filtered_flat_args = \\\n          self._function_spec.canonicalize_function_inputs(*args, **kwargs)\n    else:\n      flat_args, filtered_flat_args = [None], []\n\n    cache_key_context = self._cache_key_context()\n    cache_key = self._cache_key(args, kwargs, cache_key_context)\n\n    try:\n      hash(cache_key)\n    except TypeError as e:\n      raise TypeError(\n          \"Arguments supplied to `defun`-generated functions must be \"\n          f\"hashable.  Original error: {e}.\")\n\n    graph_function = self._function_cache.primary.get(cache_key, None)\n    if graph_function is not None:\n      return graph_function, filtered_flat_args\n\n    with monitoring.MonitoredTimer(_graph_building_time_counter.get_cell()):\n      with trace.Trace(\"tf.function-graph_building\"):\n        logging.vlog(1,\n                     \"Creating new FuncGraph for Python function %r (key: %r)\",\n                     self._python_function, cache_key)\n        logging.vlog(2, \"Python function signature [args: %s] [kwargs: %s]\",\n                     args, kwargs)\n\n        # pylint: disable=protected-access\n        call_context_key = cache_key._replace(input_signature=None)\n        # pylint: disable=protected-access\n\n        ag_status = (\n            ag_ctx.Status.ENABLED\n            if self._autograph else ag_ctx.Status.DISABLED)\n        with ag_ctx.ControlStatusCtx(\n            status=ag_status, options=self._autograph_options):\n\n          # Build a function with shape relaxation retracing if:\n          # 1. shape relaxation is explicitly enabled\n          # and 2. there's no provided input signature\n          # and 3. there's been a cache miss for this calling context\n          if (self._experimental_relax_shapes and\n              self.input_signature is None and\n              call_context_key in self._function_cache.missed):\n            return self._define_function_with_shape_relaxation(\n                args, kwargs, flat_args, filtered_flat_args, cache_key_context)\n\n          self._function_cache.missed.add(call_context_key)\n          graph_function = self._create_graph_function(args, kwargs)\n          self._function_cache.primary[cache_key] = graph_function\n\n          return graph_function, filtered_flat_args\n\n\ndef register(func, *args, **kwargs):\n  \"\"\"Register a specialization of a `Function` into the graph.\n\n  This won't actually call the function with the inputs, and only put the\n  function definition into graph. Register function with different input param\n  will result into multiple version of functions registered in graph.\n\n  Args:\n    func: the `Function` instance that generated by a @defun\n    *args: input arguments for the Python function.\n    **kwargs: input keyword arguments for the Python function.\n\n  Returns:\n    a `ConcreteFunction` object specialized to inputs and execution context.\n\n  Raises:\n    ValueError: When the input function is not a defun wrapped python function.\n  \"\"\"\n  if not isinstance(func, Function):\n    raise ValueError(\"Only defun function is allowed to be registered. \"\n                     f\"Got {func} with type {type(func)}.\")\n  concrete_func = func.get_concrete_function(*args, **kwargs)\n  concrete_func.add_to_graph()\n  concrete_func.add_gradient_functions_to_graph()\n  return concrete_func\n\n\ndef validate_signature(signature):\n  if not isinstance(signature, (tuple, list)):\n    raise TypeError(\"input_signature must be either a tuple or a list, got \"\n                    f\"{type(signature)}.\")\n\n  if any(not isinstance(arg, tensor_spec.DenseSpec)\n         for arg in nest.flatten(signature, expand_composites=True)):\n    bad_args = [arg for arg in nest.flatten(signature, expand_composites=True)\n                if not isinstance(arg, tensor_spec.DenseSpec)]\n    raise TypeError(\"input_signature must be a possibly nested sequence of \"\n                    f\"TensorSpec objects, got invalid args {bad_args} with \"\n                    f\"types {list(map(type, bad_args))}.\")\n\n\ndef validate_python_function(python_function):\n  if not callable(python_function):\n    raise TypeError(f\"{python_function} is not a callable object.\")\n\n\ndef defun(func=None,\n          input_signature=None,\n          autograph=True,\n          experimental_autograph_options=None,\n          experimental_relax_shapes=False):\n  \"\"\"Compiles a Python function into a callable TensorFlow graph.\n\n  `defun` (short for \"define function\") compiles a Python function\n  composed of TensorFlow operations into a callable that executes a `tf.Graph`\n  containing those operations. The callable produced by `defun` contains only\n  the subgraph of TensorFlow operations that were executed when the Python\n  function was called with a particular input signature, defined as a list\n  of the shapes and dtypes of the Python function's Tensor-valued arguments and\n  the values of its non-Tensor Python objects.\n\n  When eager execution is enabled, the ability to create graphs from Python\n  functions makes it possible to incrementally trade off debuggability and\n  interactivity for performance.  Functions compiled with `defun` cannot be\n  inspected with `pdb`; however, executing a graph\n  generated by `defun` sometimes takes less time and memory than eagerly\n  executing the corresponding Python function, since specifying computations as\n  graphs allows for optimizations like automatic buffer reuse and\n  parallelization among ops. Note that executing a `defun`-compiled function\n  incurs a small constant overhead, so eagerly executing sufficiently small\n  Python functions might take less time than executing their corresponding\n  `defun`-generated graphs.\n\n  For a Python function to be compatible with `defun`, all of its arguments must\n  be hashable Python objects or lists thereof. The function itself may not\n  modify the list/map structure of its arguments. Additionally, it must return\n  zero or more `tf.Tensor` objects. If the Python function returns\n  a `tf.Variable`, its compiled version will return the value of that variable\n  as a `tf.Tensor`.\n\n  Executing a graph generated by `defun` respects device annotations (i.e.,\n  all `with tf.device` directives present in a Python function will also be\n  present in its corresponding graph), but it is not yet possible to execute the\n  generated graphs across multiple machines.\n\n  _Example Usage_\n\n  ```python\n  import tensorflow as tf\n\n  tf.compat.v1.enable_eager_execution()\n\n  # A simple example.\n  def f(x, y):\n    return tf.reduce_mean(tf.multiply(x ** 2, 3) + y)\n\n  g = tf.contrib.eager.defun(f)\n\n  x = tf.constant([[2.0, 3.0]])\n  y = tf.constant([[3.0, -2.0]])\n\n  # `f` and `g` will return the same value, but `g` will be executed as a\n  # TensorFlow graph.\n  assert f(x, y).numpy() == g(x, y).numpy()\n\n  # `defun` is capable of compiling Python functions that close over Python\n  # objects, including Tensors and Variables.\n  @tf.contrib.eager.defun\n  def h():\n    return f(x, y)\n\n  assert (h().numpy() == f(x, y).numpy()).all()\n\n  # `defun` automatically lifts variables out of the graphs it creates,\n  # allowing you to compile the `call` methods of `tf.keras.layers.Layer` and\n  # `tf.keras.Model` objects.\n  class MyModel(tf.keras.Model):\n\n    def __init__(self, keep_probability=0.2):\n      super(MyModel, self).__init__()\n      self.dense1 = tf.keras.layers.Dense(4, activation=tf.nn.relu)\n      self.dense2 = tf.keras.layers.Dense(5, activation=tf.nn.softmax)\n      self.keep_probability = keep_probability\n\n    @tf.contrib.eager.defun\n    def call(self, inputs, training=True):\n      x = self.dense2(self.dense1(inputs))\n      if training:\n        return tf.nn.dropout(x, self.keep_probability)\n      else:\n        return x\n\n  model = MyModel()\n  model(x, training=True)  # executes a graph, with dropout\n  model(x, training=False) # executes a graph, without dropout\n\n  # `defun`-compiled functions are differentiable.\n  optimizer = tf.compat.v1.train.GradientDescentOptimizer(learning_rate=0.01)\n  with tf.GradientTape() as tape:\n    outputs = model(x)\n  gradient = tape.gradient(outputs, model.trainable_variables)\n  optimizer.apply_gradients((grad, var) for grad, var in zip(gradient,\n                            model.trainable_variables))\n  ```\n\n  When using `defun`, there are subtleties regarding inputs, Python control\n  flow, and variable creation that one should be aware of. For concreteness, let\n  `f` be a Python function that returns zero or more `tf.Tensor` objects and\n  let `F = defun(f)`. `F` builds a graph for each unique input signature it\n  sees, Python control flow is baked into graphs, and operations related to\n  variable initialization are automatically lifted out of the graphs that `F`\n  generates and placed in the eager context if executing eagerly or into an\n  outer graph otherwise.\n\n  _Input Signatures_\n\n  By default, `F = tf.contrib.eager.defun(f)` instantiates a separate graph\n  for every unique sequence of the shapes and dtypes of Tensor arguments and\n  the values of Python objects it is invoked with. For example, calling\n  `F(tf.random.uniform([2])` will execute a different graph than\n  `F(tf.random.uniform([3])` because the two inputs have different shapes.\n  The first time that `F(*args, **kwargs)` is called with a particular sequence\n  of Tensor shapes and dtypes and Python values, it constructs a graph by\n  tracing the execution of `f(*args, **kwargs)`; this graph is bound to an\n  input signature inferred from `(*args, **kwargs)` and cached for future reuse.\n\n  NumPy arrays passed as inputs to `F` are converted to `tf.Tensor` objects\n  before being passed to `f`, and are treated as Tensors for caching. This\n  allows a function to be called multiple times with NumPy arrays having\n  different values but the same shape and dtype without re-tracing each time.\n\n  `tf.contrib.eager.defun` caches graphs for your convenience, letting you\n  define TensorFlow functions without explicitly specifying their signatures.\n  However, this policy is conservative and potentially expensive; for example,\n  when different invocations of your function have differently-shaped Tensor\n  inputs, this policy might generate more graph functions than necessary. To\n  eliminate such costs, `tf.contrib.eager.defun` allows you to supply an\n  optional `input_signature` argument specifying the shapes and dtypes of the\n  inputs. In particular, the shapes may be partially unspecified, with `None`s\n  in the unknown dimensions.  When an input signature is provided,\n  `tf.contrib.eager.defun` will only instantiate a single graph for the\n  decorated Python function. The following is an example:\n\n  ```python\n  import tensorflow as tf\n\n  # The first `TensorSpec` below describes the shape and dtype of `words`,\n  # and the second describes the shape and dtype of `another_tensor`. Note that\n  # the last dimension of the `words` `TensorSpec` is left unspecified.\n  @tf.contrib.eager.defun(input_signature=[\n    tf.contrib.eager.TensorSpec(shape=[50, 300, None], dtype=tf.float32),\n    tf.contrib.eager.TensorSpec(shape=[300, 100], dtype=tf.float32)\n  ])\n  def my_sequence_model(words, another_tensor):\n    ...\n\n  # Note how the third dimension of the first input can vary freely.\n  words = tf.random.uniform(([50, 300, 10])\n  second_input = tf.random.uniform([300, 100])\n  my_sequence_model(words, second_input)\n\n  words = tf.random.uniform(([50, 300, 20])\n  my_sequence_model(words, second_input)\n\n  # Passing an input with an incompatible shape will raise an error.\n  words = tf.random.uniform(([50, 100, 20])\n  my_sequence_model(words, second_input)  # <---- This will raise an error.\n\n  ```\n\n  Python functions that are compiled with an `input_signature` must only accept\n  Tensors as arguments and must not take unnamed keyword arguments (**kwargs).\n\n  _Tracing_\n\n  Be aware that because `F` only logs TensorFlow operations, all the other\n  Python code that `f` executes will only shape the _construction_ of the graphs\n  that `F` executes: the Python code won't be executed when the graphs\n  themselves are executed, though it will be executed every time the Python\n  function is traced (and a given Python function might be traced multiple\n  times, once for each input signature it is invoked with). For example, whereas\n  the Python function\n\n  ```python\n  import tensorflow as tf\n  import numpy as np\n\n  tf.compat.v1.enable_eager_execution()\n\n  def add_noise():\n    return tf.eye(5) + np.random.randn(5, 5)\n  ```\n\n  will return a different output everytime it is invoked, the compiled function\n  `compiled = tf.contrib.eager.defun(add_noise)` will return the same value\n  every time it is called, since a particular random offset generated by NumPy\n  will be inserted into the graph as a TensorFlow constant. The solution is to\n  replace the call to `np.random.randn` with `tf.random.normal((5, 5))`.\n\n  _Python Side-Effects_\n\n  A corollary of the previous discussion on tracing is the following: If a\n  Python function `f` has Python side-effects, then executing `f` multiple times\n  will not necessarily be semantically equivalent to executing `F =\n  tf.contrib.eager.defun(f)` multiple times; this difference is due to the fact\n  that `defun` only captures the subgraph of TensorFlow operations that is\n  constructed when `f` is called in a graph-building context.\n\n  _Python Control Flow_\n\n  The structure of many machine learning computations depend upon whether one is\n  training or validating, and it is common to nest specialized logic under `if\n  training:` blocks. By mapping each input signature to a unique graph, `defun`\n  lets users transparently compile such code, as the following code snippet\n  demonstrates:\n\n  ```python\n  import tensorflow as tf\n\n  tf.compat.v1.enable_eager_execution()\n\n  @tf.contrib.eager.defun\n  def lossy_matmul(W, x, training=True):\n    outputs = tf.matmul(W, x)\n    if training:\n      outputs = tf.nn.dropout(outputs, keep_probability=0.2)\n    return outputs\n\n  W = tf.random.normal((3, 5))\n  x = tf.random.normal((5, 1))\n\n  # Executes a graph that applies dropout.\n  lossy_outputs = lossy_matmul(W, x, training=True)\n\n  # Executes a graph that does not apply dropout.\n  exact_outputs = lossy_matmul(W, x, training=False)\n  ```\n\n  _TensorFlow Control Flow_\n\n  When `autograph` is `True`, data-dependent control flow is allowed as well.\n  Control flow statements that depend on `Tensor` values are staged into\n  corresponding TensorFlow ops. For example, the following code will work as\n  expected:\n\n  ```python\n  @tf.contrib.eager.defun\n  def dynamic_rnn_loop(cell, seq):\n    state, output = cell.zero_state()\n    for input in seq:\n      state, output = cell(input, state)\n    return output\n  ```\n\n  For more information see `tf.autograph`.\n\n  _Variables_\n\n  TensorFlow operations related to variable creation and initialization are\n  automatically lifted out of the graphs generated by `defun`. In practice, this\n  implies that variable creation and initialization only happen the first time\n  `F` is called, and that variables are reused every time thereafter. Many\n  TensorFlow APIs, like `tf.keras.layers.Layer` objects, create variables the\n  first time they are called and reuse them thereafter. Automatic variable\n  lifting makes it possible to compile these APIs without extra effort, at the\n  cost of introducing a discrepancy between the semantics of executing Python\n  functions and their corresponding compiled functions. For example:\n\n  ```python\n  import tensorflow as tf\n\n  tf.compat.v1.enable_eager_execution()\n\n  def fn():\n    x = tf.Variable(0.0)\n    x.assign_add(1.0)\n    return x.read_value()\n\n  # `fn` is a Python function, so x is created, initialized, and destroyed upon\n  # every invocation\n  assert fn().numpy() == fn().numpy() == 1.0\n\n  compiled = tf.contrib.eager.defun(fn)\n\n  # Compiling `fn` with `defun` hoists all variables outside of the generated\n  # graph, so initialization happens exactly once.\n  assert compiled().numpy() == 1.0\n  assert compiled().numpy() == 2.0\n  ```\n\n  Finally, because each input signature is bound to a unique graph, if your\n  Python function constructs `tf.Variable` objects, then each graph constructed\n  for that Python function will reference a unique set of variables. To\n  circumvent this problem, we recommend against compiling Python functions that\n  create `tf.Variable` objects. Instead, Python functions should either\n  lexically close over `tf.Variable` objects or accept them as arguments,\n  preferably encapsulated in an object-oriented container. If you must create\n  variables inside your Python function and you want each graph generated for it\n  to reference the same set of variables, add logic to your Python function that\n  ensures that variables are only created the first time it is called and are\n  reused for every subsequent invocation; note that this is precisely what\n  `tf.keras.layers.Layer` objects do, so we recommend using them to represent\n  variable-bearing computations whenever possible.\n\n  Args:\n    func: function to be compiled. If `func` is None, returns a\n      decorator that can be invoked with a single argument - `func`. The\n      end result is equivalent to providing all the arguments up front.\n      In other words, defun(input_signature=...)(func) is equivalent to\n      defun(func, input_signature=...). The former allows\n      the following use case:\n        @tf.contrib.eager.defun(input_signature=...)\n        def foo(...):\n          ...\n\n    input_signature: A possibly nested sequence of\n      `tf.contrib.eager.TensorSpec` objects specifying the shapes and dtypes of\n      the Tensors that will be supplied to this function. If `None`, a separate\n      function is instantiated for each inferred input signature.  If a\n      signature is specified, every input to `func` must be a `Tensor`, and\n      `func` cannot accept `**kwargs`.\n    autograph: Whether `func` should be compiled before\n      constructing the graph. See https://www.tensorflow.org/guide/autograph\n      for more information.\n    experimental_autograph_options: Experimental knobs (in the form of a tuple\n      of tensorflow.autograph.Feature values) to control behavior when\n      autograph=True.\n    experimental_relax_shapes: When true, argument shapes may be relaxed to\n      avoid unnecessary retracing.\n\n  Returns:\n     If `func` is not None, returns a callable that will execute the compiled\n     function (and return zero or more `tf.Tensor` objects).\n     If `func` is None, returns a decorator that, when invoked with a single\n     `func` argument, returns a callable equivalent to the case above.\n\n  Raises:\n    TypeError: If `input_signature` is neither `None` nor a sequence of\n      `tf.contrib.eager.TensorSpec` objects.\n  \"\"\"\n  return defun_with_attributes(\n      func=func,\n      input_signature=input_signature,\n      autograph=autograph,\n      experimental_autograph_options=experimental_autograph_options,\n      experimental_relax_shapes=experimental_relax_shapes)\n\n\n@tf_export(\"__internal__.function.defun_with_attributes\", v1=[])\ndef defun_with_attributes(func=None,\n                          input_signature=None,\n                          attributes=None,\n                          autograph=True,\n                          experimental_autograph_options=None,\n                          jit_compile=None,\n                          experimental_relax_shapes=False,\n                          experimental_follow_type_hints=False):\n  \"\"\"Compiles a Python function into a callable TensorFlow graph.\n\n  This function supports adding extra function attributes. See detailed\n  documentation in defun(). Currently this is not exposed in public API since we\n  don't expect user to directly use attributes, and attribute won't work by\n  itself. This assumption might change in future.\n\n  Args:\n    func: function to be compiled.\n    input_signature: same as defun()'s input_signature.\n    attributes: A dictionary of arguments which will be added to function def as\n      attributes. Currently only support primitive types as value, and only\n      allowlisted attribute name is allowed. Unallowlisted attribute name or\n      unsupported value will result into ValueError. `func_name` is also one of\n      the allowlisted argument which is a python string, and sets the name for\n      this `ConcreteFunction` in the graph.\n    autograph: same as defun()'s autograph.\n    experimental_autograph_options: same as defun()'s\n      experimental_autograph_options.\n    jit_compile: same as defun()'s jit_compile.\n    experimental_relax_shapes: same as defun()'s experimental_relax_shapes\n    experimental_follow_type_hints: see `tf.function`.\n\n  Returns:\n    Same as the return value of defun, with attributes added to the function in\n    graph.\n  \"\"\"\n  if input_signature is not None:\n    validate_signature(input_signature)\n\n  # TODO(apassos): deal with captured global state. Deal with control flow.\n  def decorated(function):\n    try:\n      if attributes:\n        name = attributes.pop(\"func_name\", function.__name__)\n      else:\n        name = function.__name__\n    except AttributeError:\n      name = \"function\"\n    return tf_decorator.make_decorator(\n        function,\n        Function(\n            function,\n            name,\n            input_signature=input_signature,\n            attributes=attributes,\n            autograph=autograph,\n            autograph_options=experimental_autograph_options,\n            jit_compile=jit_compile,\n            experimental_relax_shapes=experimental_relax_shapes,\n            experimental_follow_type_hints=experimental_follow_type_hints))\n\n  # This code path is for the `foo = tfe.defun(foo, ...)` use case\n  if func is not None:\n    return decorated(func)\n\n  # This code path is for the\n  #\n  # @tfe.defun(...)\n  # def foo(...):\n  #    ...\n  #\n  # use case, which is equivalent to `foo = tfe.defun(...)(foo)`\n  return decorated\n\n\n# When a method is bound to objects of this type, it allows AutoGraph to\n# recover a weak reference the original method's self pointer, so that it can\n# execute it consistent with class_method_to_instance_method's\n# bound_method_wrapper.\n# TODO(b/119246461): This is not pretty. Use a descriptor instead?\nclass TfMethodTarget(object):\n  \"\"\"Binding target for methods replaced by function and defun.\"\"\"\n\n  __slots__ = (\"weakrefself_target__\", \"weakrefself_func__\")\n\n  def __init__(self, target, original_python_function):\n    self.weakrefself_target__ = target\n    self.weakrefself_func__ = weakref.ref(original_python_function)\n\n  @property\n  def target(self):\n    return self.weakrefself_target__()\n\n  @property\n  def target_class(self):\n    true_self = self.weakrefself_target__()\n    if tf_inspect.isclass(true_self):\n      # Class method\n      return true_self\n    else:\n      return true_self.__class__\n\n  def call(self, args, kwargs):\n    wrapped_fn = self.weakrefself_func__()\n    if tf_inspect.ismethod(wrapped_fn):\n      wrapped_fn = six.get_unbound_function(wrapped_fn)\n    return wrapped_fn(self.weakrefself_target__(), *args, **kwargs)\n\n\ndef class_method_to_instance_method(original_function, instance):\n  \"\"\"Constructs a new `Function` with `self` bound.\"\"\"\n  weak_instance = weakref.ref(instance)\n\n  # Note: while we could bind to a weakref proxy instead, that causes the\n  # bound method to be unhashable.\n  bound_method = types_lib.MethodType(\n      original_function.python_function,\n      TfMethodTarget(weak_instance, original_function.python_function))\n\n  # original_function is expected to be of one of the two `Function` types\n  # (defined either in function.py or def_function.py).\n  assert hasattr(original_function, \"_name\")\n  assert hasattr(original_function, \"_autograph\")\n  assert hasattr(original_function, \"_function_spec\")\n  assert hasattr(original_function, \"python_function\")\n\n  weak_bound_method_wrapper = None\n  def bound_method_wrapper(*args, **kwargs):\n    \"\"\"Wraps either a dummy MethodType or a converted AutoGraph function.\"\"\"\n    # __wrapped__ allows AutoGraph to swap in a converted function.\n    strong_bound_method_wrapper = weak_bound_method_wrapper()\n    wrapped_fn = strong_bound_method_wrapper.__wrapped__\n\n    if wrapped_fn is strong_bound_method_wrapper.__original_wrapped__:\n      # If __wrapped__ was not replaced, then call original_function.\n      # TODO(mdan): For better consistency, use the wrapper's call().\n      wrapped_fn = original_function.python_function\n      if tf_inspect.ismethod(wrapped_fn):\n        wrapped_fn = six.get_unbound_function(wrapped_fn)\n      return wrapped_fn(weak_instance(), *args, **kwargs)\n\n    # If __wrapped__ was replaced, then it is always an unbound function.\n    # However, the replacer is still responsible for attaching self properly.\n    # TODO(mdan): Is it possible to do it here instead?\n    return wrapped_fn(*args, **kwargs)\n  weak_bound_method_wrapper = weakref.ref(bound_method_wrapper)\n\n  # pylint: disable=protected-access\n  # We make a dummy MethodType object to generate the correct bound method\n  # signature. The actual call is to a function with a weak reference to\n  # `instance`.\n  instance_func = type(original_function)(\n      tf_decorator.make_decorator(bound_method, bound_method_wrapper),\n      name=original_function._name,\n      autograph=original_function._autograph,\n      input_signature=original_function.input_signature,\n      experimental_relax_shapes=original_function._experimental_relax_shapes,\n      jit_compile=original_function._jit_compile)\n  # pylint: enable=protected-access\n\n  # We wrap the the bound method with tf_decorator so inspection works correctly\n  wrapped_instance_func = tf_decorator.make_decorator(bound_method,\n                                                      instance_func)\n  return wrapped_instance_func\n\n\nclass _FunctionGarbageCollector(object):\n  \"\"\"Cleans up cycles when a defun goes out of scope.\"\"\"\n\n  __slots__ = [\"_cache\"]\n\n  def __init__(self, cache):\n    self._cache = cache\n\n  def __del__(self):\n    if func_graph_module is None or memory is None:\n      return\n    try:\n      while self._cache:\n        self._cache.popitem()\n      memory.dismantle_ordered_dict(self._cache)\n    except:  # pylint: disable=bare-except\n      pass\n\n\nclass ConcreteFunctionGarbageCollector(object):\n  \"\"\"Cleans up reference cycles when a `ConcreteFunction` goes out of scope.\"\"\"\n\n  __slots__ = [\"_func_graph\"]\n\n  def __init__(self, func_graph):\n    self._func_graph = func_graph\n\n  def release(self):\n    \"\"\"Call off the FuncGraph deletion.\"\"\"\n    self._func_graph = None\n\n  def __del__(self):\n    if func_graph_module is None or memory is None or self._func_graph is None:\n      return\n    try:\n      func_graph_module.dismantle_func_graph(self._func_graph)\n    except:  # pylint: disable=bare-except\n      pass\n\n\nclass _Marker(object):\n  \"\"\"Markers used to pretty-print nested args in function signatures.\"\"\"\n\n  __slots__ = [\"_s\"]\n\n  def __init__(self, s):\n    self._s = s\n\n  def __repr__(self):\n    return str(self._s)\n\n\ndef _structure_summary(structure):\n  \"\"\"Displays a summary of the nesting structure of the given value.\"\"\"\n\n  def type_name(x):\n    if isinstance(x, type_spec.TypeSpec):\n      return x.value_type.__name__\n    else:\n      return type(x).__name__\n\n  markers = [_Marker(type_name(v)) for v in nest.flatten(structure)]\n  return str(nest.pack_sequence_as(structure, markers))\n\n\ndef _contains_type_spec(value):\n  return any(isinstance(x, type_spec.TypeSpec) for x in nest.flatten(value))"