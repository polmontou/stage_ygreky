"# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n# pylint: disable=unidiomatic-typecheck\n\"\"\"API for defining graph functions with some additional eager semantics.\n\ndef_function.function wraps the function concept in function.py (\"defun\") to\nallow initializing `tf.Variable`s with subgraphs of the function. For example:\n\n```python\nclass M(tf.Module):\n  def __init__(self):\n    self.v_opinit = None\n    self.v_arginit = None\n\n  @tf.function\n  def __call__(self, x):\n    # Variables are only created on the first call to the function. This is a\n    # common pattern in layer libraries.\n    if self.v_opinit is None:\n      # self.v_opinit will outlive the function call, but `tf.ones` is traced as\n      # part of the function body before the `tf.Variable` object is\n      # created. This subgraph is easy to lift out of the function.\n      self.v_opinit = tf.Variable(tf.ones([]))\n\n      # If arguments feed into variable initialization, it can be very tricky to\n      # disentangle from the rest of the function. We don't attempt it.\n      self.v_arginit = tf.Variable(tf.ones(tf.shape(x)) * tf.constant(2.))\n    return self.v_opinit + self.v_arginit + x\n```\n\nThese patterns with \"defun\" throw an error asking the user to put the variable's\ninitializer in a lambda. With tf.function they work with eager semantics either\nby lifting the subgraph out of the function and using it to initialize the\nvariable, or by initializing variables on the first call to the function (if\nthey weren't already initialized by something else, e.g. a checkpoint API). The\nlatter requires tf.conds, and is not well supported by TF-XLA, so we only do it\nwhen necessary.\n\nSince these patterns are relatively common in layer libraries, we expose the\nwrapper in this file as `tf.function`. The function concept in function.py is an\ninternal implementation detail.\n\nIn order to support these variable initialization patterns, tf.function defines\na variable subtype (UnliftedInitializerVariable) which collects the input\nsubgraph. This type of variable replaces the regular variable type on the first\ntf.function trace. To exclude initializers from the function body (the `tf.ones`\nops above and associated assignment operations), tf.function traces a second\ntime if it sees variables on the first call.\n\"\"\"\n\nimport functools\nimport threading\nimport types as types_lib\nimport weakref\nimport six\n\nfrom google.protobuf import text_format as _text_format\nfrom google.protobuf.message import DecodeError\nfrom tensorflow.core.framework import attr_value_pb2\nfrom tensorflow.python.distribute.parallel_device import parallel_device\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.eager import function as function_lib\nfrom tensorflow.python.eager import lift_to_graph\nfrom tensorflow.python.eager import monitoring\nfrom tensorflow.python.framework import composite_tensor\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import func_graph as func_graph_module\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import control_flow_util\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import random_ops\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.platform import tf_logging as logging\nfrom tensorflow.python.profiler import trace\nfrom tensorflow.python.training.tracking import base as trackable\nfrom tensorflow.python.types import core\nfrom tensorflow.python.util import deprecation\nfrom tensorflow.python.util import nest\nfrom tensorflow.python.util import object_identity\nfrom tensorflow.python.util import tf_decorator\nfrom tensorflow.python.util import traceback_utils\nfrom tensorflow.python.util.tf_export import tf_export\n\nFREQUENT_TRACING_WARNING_MAX_CALL_HISTORY = 10\nFREQUENT_TRACING_WARNING_THRESHOLD = 5\nFREQUENT_TRACING_WARNING_MAX_WARNING_PER_DETECTOR = 2\nALLOW_DYNAMIC_VARIABLE_CREATION = False\n\n_tf_function_counter = monitoring.Counter(\n    \"/tensorflow/core/tf_function_counter\",\n    \"Counter for the number of tf.functions created when Eager execution is \"\n    \"enabled.\",\n    # jit_compile is \"0\" or \"1\".\n    \"jit_compile\")\n\n\nclass _FrequentTracingDetector(object):\n  \"\"\"Class keeping track of how many recent calls triggered tracing.\"\"\"\n\n  __slots__ = [\"_calls_per_tracings\", \"_call_count\", \"_total_warning_count\"]\n\n  def __init__(self):\n    self._calls_per_tracings = []\n    self._total_warning_count = 0\n    self._call_count = 0\n\n  def called_with_tracing(self, function_name, omit_warning):\n    \"\"\"Updates the list of most recent calls' tracing information.\n\n    Warns the user when recent calls caused retracing too often.\n\n    Args:\n      function_name: the python function being traced.\n      omit_warning: If 'True', this call will not warn the user even if\n        retracing happens too often.\n    \"\"\"\n    self._call_count += 1\n    self._calls_per_tracings.append(1)\n\n    while self._calls_per_tracings:\n      if (self._call_count - self._calls_per_tracings[0] >\n          FREQUENT_TRACING_WARNING_MAX_CALL_HISTORY):\n        self._call_count -= self._calls_per_tracings.pop(0)\n      else:\n        break\n\n    if (omit_warning or self._total_warning_count >=\n        FREQUENT_TRACING_WARNING_MAX_WARNING_PER_DETECTOR):\n      return\n    if len(self._calls_per_tracings) >= FREQUENT_TRACING_WARNING_THRESHOLD:\n      self._total_warning_count += 1\n      logging.warning(\n          \"{} out of the last {} calls to {} triggered tf.function \"\n          \"retracing. Tracing is expensive and the excessive number of \"\n          \"tracings could be due to (1) creating @tf.function repeatedly in \"\n          \"a loop, (2) passing tensors with different shapes, (3) passing \"\n          \"Python objects instead of tensors. For (1), please define your \"\n          \"@tf.function outside of the loop. For (2), @tf.function has \"\n          \"experimental_relax_shapes=True option that relaxes argument \"\n          \"shapes that can avoid unnecessary retracing. For (3), please \"\n          \"refer to \"\n          \"https://www.tensorflow.org/guide/function#controlling_retracing\"\n          \" and https://www.tensorflow.org/api_docs/python/tf/function for \"\n          \" more details.\".format(\n              len(self._calls_per_tracings), self._call_count, function_name))\n\n  def called_without_tracing(self):\n    # We don't count tracing when users load a concrete function directly or\n    # call get_concrete_function, so the first call can be not a tracing call.\n    if not self._calls_per_tracings:\n      self._calls_per_tracings = [0]\n    self._calls_per_tracings[-1] += 1\n    self._call_count += 1\n\n\nclass _FrequentTracingDetectorManager(object):\n  \"\"\"Class for the management of all _FrequentTracingDetector objects.\"\"\"\n\n  __slots__ = [\"_detectors\", \"_lock\"]\n\n  def __init__(self):\n    self._detectors = weakref.WeakKeyDictionary()  # GUARDED_BY(self._lock)\n    self._lock = threading.Lock()\n\n  def _get_detector(self, key):\n    if key not in self._detectors:\n      self._detectors[key] = _FrequentTracingDetector()\n    return self._detectors[key]\n\n  def called_without_tracing(self, key):\n    with self._lock:\n      detector = self._get_detector(key)\n      detector.called_without_tracing()\n\n  def called_with_tracing(self, key, function_name, omit_warning):\n    with self._lock:\n      detector = self._get_detector(key)\n      detector.called_with_tracing(function_name, omit_warning)\n\n\n_frequent_tracing_detector_manager = _FrequentTracingDetectorManager()\n\n\nclass UnliftedInitializerVariable(resource_variable_ops.UninitializedVariable):\n  \"\"\"Variable which does not lift its initializer out of function context.\n\n  Instances of this variable, when created, build a graph which runs their\n  initializer inside a tf.cond(is_initialized) block.\n\n  This can only be created inside a defun called from (eventually) eager\n  mode. That is, non-function-building graphs are not supported.\n  \"\"\"\n\n  def __init__(self,\n               initial_value=None,\n               trainable=None,\n               caching_device=None,\n               name=None,\n               dtype=None,\n               constraint=None,\n               add_initializers_to=None,\n               lifted_initializer_graph=None,\n               synchronization=None,\n               aggregation=None,\n               shape=None,\n               **unused_kwargs):\n    \"\"\"Creates a variable.\n\n    Args:\n      initial_value: A `Tensor`, or Python object convertible to a `Tensor`,\n        which is the initial value for the Variable. The initial value must have\n        a shape specified unless `validate_shape` is set to False. Can also be a\n        callable with no argument that returns the initial value when called.\n        (Note that initializer functions from init_ops.py must first be bound\n         to a shape before being used here.)\n      trainable: If `True`, GradientTapes automatically watch uses of this\n        Variable.\n      caching_device: Optional device string or function describing where the\n        Variable should be cached for reading.  Defaults to the Variable's\n        device.  If not `None`, caches on another device.  Typical use is to\n        cache on the device where the Ops using the Variable reside, to\n        deduplicate copying through `Switch` and other conditional statements.\n      name: Optional name for the variable. Defaults to `'Variable'` and gets\n        uniquified automatically.\n      dtype: If set, initial_value will be converted to the given type.\n        If None, either the datatype will be kept (if initial_value is\n       a Tensor) or float32 will be used (if it is a Python object convertible\n       to a Tensor).\n      constraint: An optional projection function to be applied to the variable\n        after being updated by an `Optimizer` (e.g. used to implement norm\n        constraints or value constraints for layer weights). The function must\n        take as input the unprojected Tensor representing the value of the\n        variable and return the Tensor for the projected value\n        (which must have the same shape). Constraints are not safe to\n        use when doing asynchronous distributed training.\n      add_initializers_to: if not None and not in legacy graph mode, the\n        initializer tensor will be added to this map in addition to adding the\n        assignment to the function.\n      lifted_initializer_graph: FuncGraph to try to lift initializers to.\n      synchronization: Indicates when a distributed a variable will be\n        aggregated. Accepted values are constants defined in the class\n        `tf.VariableSynchronization`. By default the synchronization is set to\n        `AUTO` and the current `DistributionStrategy` chooses\n        when to synchronize.\n      aggregation: Indicates how a distributed variable will be aggregated.\n        Accepted values are constants defined in the class\n        `tf.VariableAggregation`.\n      shape: (optional) The shape of this variable. If None, the shape of\n        `initial_value` will be used. When setting this argument to\n        `tf.TensorShape(None)` (representing an unspecified shape), the variable\n        can be assigned with values of different shapes.\n\n    Raises:\n      ValueError: If the initial value is not specified, or does not have a\n        shape and `validate_shape` is `True`.\n      RuntimeError: If called outside of a function definition.\n    \"\"\"\n    with ops.init_scope():\n      self._in_graph_mode = not context.executing_eagerly()\n    if not ops.inside_function():\n      # If we've been init_scope()d out of the function definition nothing to do\n      # here; we can't really do the capturing or conditional logic.\n      resource_variable_ops.ResourceVariable.__init__(\n          self, initial_value=initial_value, trainable=trainable,\n          caching_device=caching_device, name=name, dtype=dtype,\n          constraint=constraint)\n      return\n    if initial_value is None:\n      raise ValueError(\"`initial_value` must be a Tensor or a Python \"\n                       \"object convertible to a Tensor. Got None.\")\n    init_from_fn = callable(initial_value)\n\n    if constraint is not None and not callable(constraint):\n      raise ValueError(f\"`constraint` with type {type(constraint)} must be a \"\n                       \"callable.\")\n\n    with ops.name_scope(name, \"Variable\", []\n                        if init_from_fn else [initial_value]) as scope_name:\n      with ops.name_scope(\"Initializer\"):\n        if init_from_fn:\n          initial_value = initial_value()\n        if isinstance(initial_value, trackable.CheckpointInitialValue):\n          self._maybe_initialize_trackable()\n          self._update_uid = initial_value.checkpoint_position.restore_uid\n          initial_value = initial_value.wrapped_value\n\n        initial_value = ops.convert_to_tensor(initial_value,\n                                              name=\"initial_value\", dtype=dtype)\n      assert initial_value is not None\n\n      # Don't use `shape or initial_value.shape` since TensorShape has\n      # overridden `__bool__`.\n      if shape is None:\n        shape = initial_value.shape\n\n    # Use the constructor for UninitializedVariable to start. Outside the name\n    # scope so we don't double up the prefix.\n    super(UnliftedInitializerVariable, self).__init__(\n        trainable=trainable,\n        caching_device=caching_device,\n        name=name,\n        shape=shape,\n        dtype=initial_value.dtype,\n        constraint=constraint,\n        synchronization=synchronization,\n        aggregation=aggregation,\n        extra_handle_data=initial_value,\n        **unused_kwargs)\n\n    with ops.name_scope(scope_name):\n      if self._in_graph_mode:\n        with ops.init_scope():\n          outer_graph = ops.get_default_graph()\n        func_graph = ops.get_default_graph()\n        function_placeholders = (\n            func_graph.inputs + func_graph.internal_captures)\n        placeholder_ops = set(\n            [tensor.op for tensor in function_placeholders])\n        lifted_initializer = lift_to_graph.lift_to_graph(\n            [initial_value], outer_graph,\n            disallowed_placeholders=placeholder_ops)[initial_value]\n        with ops.init_scope():\n          self._initial_value = lifted_initializer\n          with ops.name_scope(\"IsInitialized\"):\n            self._is_initialized_op = (\n                resource_variable_ops.var_is_initialized_op(self._handle))\n          if initial_value is not None:\n            with ops.name_scope(\"Assign\") as n, ops.colocate_with(self._handle):\n              self._initializer_op = resource_variable_ops.assign_variable_op(\n                  self._handle, lifted_initializer, name=n)\n      elif context.executing_eagerly():\n        # In this case, both current scope and init scope are eager.\n        # Assign_variable_op will be executed immediately. So we don't need to\n        # add it to \"add_initializers_to\" to lift it out.\n        with ops.name_scope(\"Assign\") as n, ops.colocate_with(self._handle):\n          resource_variable_ops.assign_variable_op(\n              self._handle, initial_value, name=n)\n      else:\n        # Init scope is eager but current scope is graph. We will lift out this\n        # variable by addint it into \"add_initializers_to\".\n        if add_initializers_to is not None:\n          add_initializers_to.append((self, initial_value))\n\n        def assign_fn():\n          with ops.name_scope(\"Assign\") as n, ops.colocate_with(self._handle):\n            resource_variable_ops.assign_variable_op(\n                self._handle,\n                initial_value,\n                name=n)\n            # Returning values to keep tf.cond happy.\n          return ops.convert_to_tensor(1)\n        def not_assign_fn():\n          return ops.convert_to_tensor(0)\n        # Note: this cond is always guaranteed to run because we're inside a\n        # defun which will insert automatic control dependencies. It will only\n        # execute assign_fn if lifting failed.\n        graph = ops.get_default_graph()\n\n        # Capture the handle ahead of time in order to avoid querying the shape\n        # of the handle which helps async execution performance\n        graph.capture(self._handle, shape=())\n        control_flow_ops.cond(\n            resource_variable_ops.var_is_initialized_op(self._handle),\n            not_assign_fn, assign_fn)\n\n\nRUN_FUNCTIONS_EAGERLY = False\n\n\n@deprecation.deprecated(\n    None,\n    \"Use `tf.config.run_functions_eagerly` instead of the experimental \"\n    \"version.\")\n@tf_export(\"config.experimental_run_functions_eagerly\")\ndef experimental_run_functions_eagerly(run_eagerly):\n  \"\"\"Enables / disables eager execution of `tf.function`s.\n\n  Calling `tf.config.experimental_run_functions_eagerly(True)` will make all\n  invocations of `tf.function` run eagerly instead of running as a traced graph\n  function.\n\n  See `tf.config.run_functions_eagerly` for an example.\n\n  Note: This flag has no effect on functions passed into tf.data transformations\n  as arguments. tf.data functions are never executed eagerly and are always\n  executed as a compiled Tensorflow Graph.\n\n  Args:\n    run_eagerly: Boolean. Whether to run functions eagerly.\n  \"\"\"\n  return run_functions_eagerly(run_eagerly)\n\n\n@tf_export(\"config.run_functions_eagerly\")\ndef run_functions_eagerly(run_eagerly):\n  \"\"\"Enables / disables eager execution of `tf.function`s.\n\n  Calling `tf.config.run_functions_eagerly(True)` will make all\n  invocations of `tf.function` run eagerly instead of running as a traced graph\n  function.\n\n  This can be useful for debugging.\n\n  >>> def my_func(a):\n  ...  print(\"Python side effect\")\n  ...  return a + a\n  >>> a_fn = tf.function(my_func)\n\n  >>> # A side effect the first time the function is traced\n  >>> a_fn(tf.constant(1))\n  Python side effect\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  >>> # No further side effect, as the traced function is called\n  >>> a_fn(tf.constant(2))\n  <tf.Tensor: shape=(), dtype=int32, numpy=4>\n\n  >>> # Now, switch to eager running\n  >>> tf.config.run_functions_eagerly(True)\n  >>> # Side effect, as the function is called directly\n  >>> a_fn(tf.constant(2))\n  Python side effect\n  <tf.Tensor: shape=(), dtype=int32, numpy=4>\n\n  >>> # Turn this back off\n  >>> tf.config.run_functions_eagerly(False)\n\n  Note: This flag has no effect on functions passed into tf.data transformations\n  as arguments. tf.data functions are never executed eagerly and are always\n  executed as a compiled Tensorflow Graph.\n\n  Args:\n    run_eagerly: Boolean. Whether to run functions eagerly.\n  \"\"\"\n  global RUN_FUNCTIONS_EAGERLY\n  RUN_FUNCTIONS_EAGERLY = bool(run_eagerly)\n\n\n@deprecation.deprecated(\n    None,\n    \"Use tf.config.functions_run_eagerly instead of the experimental version.\")\n@tf_export(\"config.experimental_functions_run_eagerly\")\ndef experimental_functions_run_eagerly():\n  \"\"\"Returns the value of the `experimental_run_functions_eagerly` setting.\"\"\"\n  return functions_run_eagerly()\n\n\n@tf_export(\"config.functions_run_eagerly\")\ndef functions_run_eagerly():\n  \"\"\"Returns the value of the `run_functions_eagerly` setting.\"\"\"\n  return RUN_FUNCTIONS_EAGERLY\n\n\ndef _evaluate_var_is_initialized(variables):\n  \"\"\"Compute booleans indicating whether each variable is initialized.\"\"\"\n  with ops.init_scope():\n    var_is_initialized = []\n    for v in variables:\n      var_is_initialized.append(\n          resource_variable_ops.var_is_initialized_op(v.handle))\n    try:\n      # Stack all the var_is_initialized values into one tensor and interpret\n      # the numpy value. This will reduce the number of RPCs between client and\n      # worker in the remote case.\n      return array_ops.stack(var_is_initialized).numpy()\n    except errors.UnimplementedError:\n      # Some devices do not support implicit copy-off to host. Fall back to\n      # variable-by-variable processing.\n      for index, v in enumerate(variables):\n        try:\n          numpy_value = var_is_initialized[index].numpy()\n        except errors.UnimplementedError:\n          # This is a variable on a parallel device; we'll extract its value on\n          # each replica and assert that they're identical.\n          components = parallel_device.unpack(var_is_initialized[index])\n          with ops.device(None):\n            components = array_ops.stack(components)\n            all_initialized = math_ops.reduce_all(components).numpy()\n            any_initialized = math_ops.reduce_any(components).numpy()\n          if all_initialized != any_initialized:\n            raise NotImplementedError(\n                f\"Some but not all components of a parallel variable {v!r} \"\n                \"were initialized between their creation in a tf.function and \"\n                \"the function's trace having completed. This is not \"\n                \"supported; consider initializing either all or none of the \"\n                \"components, or moving initialization out of the function.\")\n          numpy_value = all_initialized\n        var_is_initialized[index] = numpy_value\n  return var_is_initialized\n\n\nclass FunctionDeleter(object):\n\n  __slots__ = [\"func_graph\"]\n\n  def __init__(self, func_graph):\n    self.func_graph = func_graph\n\n  def __del__(self):\n    try:\n      func_graph_module.dismantle_func_graph(self.func_graph)\n    except:  # pylint: disable=bare-except\n      # Note: bare except here because this can be noisy at shutdown time.\n      pass\n\n\nclass OptionalXlaContext(object):\n  \"\"\"Wrapper for XLA context optionally applied under a context manager.\"\"\"\n\n  def __init__(self, is_compiled):\n    wrap = is_compiled and not control_flow_util.GraphOrParentsInXlaContext( \\\n              ops.get_default_graph())\n    self.xla_context = control_flow_ops.XLAControlFlowContext() \\\n        if wrap else None\n\n  def __enter__(self):\n    if self.xla_context:\n      self.xla_context.Enter()\n\n  def __exit__(self, t, value, traceback):\n    if self.xla_context:\n      self.xla_context.Exit()\n\n\n# TODO(mdan): Consider expose this type for instance type checking.\n@tf_export(\"__internal__.function.Function\", v1=[])\nclass Function(core.GenericFunction):\n  \"\"\"A `tf.types.experimental.GenericFunction` created by `tf.function`.\n\n  Currently, individual methods/attributes under this class are not guaranteed\n  by the TF API contract, and are subject to future changes.\n  \"\"\"\n\n  def __init__(self,\n               python_function,\n               name,\n               input_signature=None,\n               autograph=True,\n               jit_compile=None,\n               experimental_implements=None,\n               experimental_autograph_options=None,\n               experimental_relax_shapes=False,\n               experimental_follow_type_hints=None):\n    \"\"\"Initializes a `Function`.\n\n    Args:\n      python_function: the function to be wrapped.\n      name: the name given to it.\n      input_signature: See the documentation for `tf.function`.\n      autograph: See the documentation for `tf.function`.\n      jit_compile: See the documentation for `tf.function`.\n      experimental_implements: See the documentation for `tf.function`.\n      experimental_autograph_options: See the documentation for `tf.function`.\n      experimental_relax_shapes: See the documentation for `tf.function`.\n      experimental_follow_type_hints: See the documentation for `tf.function`.\n\n    Raises:\n      ValueError: if `input_signature` is not None and the `python_function`'s\n        argspec has keyword arguments.\n    \"\"\"\n    self._lock = threading.Lock()\n    self._python_function = python_function\n    self._function_spec = function_lib.FunctionSpec.from_function_and_signature(\n        python_function,\n        input_signature,\n        jit_compile=jit_compile,\n        experimental_follow_type_hints=experimental_follow_type_hints,\n    )\n    self._implements = experimental_implements\n    # If `True`, the function uses the rendezvous of the parent. This is only\n    # needed to support code where raw send/recv operations are inserted and\n    # when functions are run in graph mode where they may not be inlined.\n    self._shared_rendezvous = None\n    self._autograph = autograph\n    self._experimental_autograph_options = experimental_autograph_options\n    self._experimental_relax_shapes = experimental_relax_shapes\n    self._jit_compile = jit_compile\n    if experimental_follow_type_hints is None:\n      experimental_follow_type_hints = False\n    self._experimental_follow_type_hints = experimental_follow_type_hints\n    self._created_variables = None  # GUARDED_BY(self._lock)\n    self._stateful_fn = None  # GUARDED_BY(self._lock)\n    self._stateless_fn = None  # GUARDED_BY(self._lock)\n    self._descriptor_cache = weakref.WeakKeyDictionary()\n    self._name = name\n    self._input_signature = input_signature\n    self._key_for_call_stats = self._get_key_for_call_stats()\n    self._omit_frequent_tracing_warning = False\n    ops._tf_function_api_guage.get_cell().set(True)  # pylint: disable=protected-access\n\n  def __getstate__(self):\n    \"\"\"Custom pickling, to omit unpickleable objects.\"\"\"\n    result = self.__dict__.copy()\n    del result[\"_lock\"]\n    del result[\"_descriptor_cache\"]\n    del result[\"_key_for_call_stats\"]\n    return result\n\n  def __setstate__(self, state):\n    \"\"\"Restore from pickled state.\"\"\"\n    self.__dict__ = state\n    self._lock = threading.Lock()\n    self._descriptor_cache = weakref.WeakKeyDictionary()\n    self._key_for_call_stats = self._get_key_for_call_stats()\n\n  def _get_key_for_call_stats(self):\n    \"\"\"Returns key instance to track call stats and retracings.\n\n    The key instance a best-effort to preserve global consistency.\n    \"\"\"\n    target_function = self._python_function\n    # `__wrapped__` is a conventional Python attribute that a higher-order\n    # function keeps its original function's instance.  We also directly use\n    # this attribute for dealing with a class method.  See\n    # `bound_method_wrapper` in `function.py`.  If we don't use `__wrapped__`,\n    # all class methods will return the same `bound_method_wrapper` instance\n    # from this function.\n    while hasattr(target_function, \"__wrapped__\"):\n      target_function = target_function.__wrapped__\n\n    if hasattr(target_function, \"__func__\"):\n      target_function = target_function.__func__\n\n    if hasattr(target_function, \"__code__\"):\n      return target_function.__code__\n\n    return self._python_function\n\n  def _defun_with_scope(self, scope):\n    \"\"\"Creates a defun wrapped inside a variable creator scope.\"\"\"\n\n    weak_wrapped_fn = None\n    compile_with_xla = self._jit_compile\n\n    def wrapped_fn(*args, **kwds):\n      \"\"\"Wraps `self._python_function` in a variable creator scope.\"\"\"\n      # We register a variable creator with reduced priority. If an outer\n      # variable creator is just modifying keyword arguments to the variable\n      # constructor, this will work harmoniously. Since the `scope` registered\n      # here actually creates the variable, it taking priority would otherwise\n      # ignore the outer creator.\n      #\n      # If an outer variable creator calls the variable constructor manually,\n      # for example creating a MirroredVariable, then they won't call our\n      # creator. This means we won't be able to trace the initialization graph,\n      # and so variable initializers can't depend on function arguments. This is\n      # better than the alternative, tracing the initialization graph but giving\n      # the user a variable type they didn't want.\n      default_graph = ops.get_default_graph()\n      with default_graph._variable_creator_scope(scope, priority=50):  # pylint: disable=protected-access\n        # __wrapped__ allows AutoGraph to swap in a converted function. We give\n        # the function a weak reference to itself to avoid a reference cycle.\n        with OptionalXlaContext(compile_with_xla):\n          out = weak_wrapped_fn().__wrapped__(*args, **kwds)\n        return out\n\n    weak_wrapped_fn = weakref.ref(wrapped_fn)\n\n    return self._defun(tf_decorator.make_decorator(\n        self._python_function,\n        wrapped_fn))\n\n  def _create_implements_attribute(self):\n    \"\"\"Creates the attribute value corresponding to IMPLEMENTS_ATTRIBUTE_NAME.\"\"\"\n    attributes = {}\n    if isinstance(self._implements, str):\n      # First check if the IMPLEMENTS_ATTRIBUTE_NAME is specified as a\n      # NameAttrList. This is used when apart from the function name being\n      # implemented, a list of attributes is also being specified.\n      # The attributes are specified as key-value pairs in the NameAttrList\n      # of the corresponding AttrValue. The function name will be in the\n      # 'name' field of the NameAttrList. Else, it is just a string\n      # corresponding to the function name.\n      try:\n        implements_attr = six.ensure_text(self._implements, \"utf-8\")\n        attr_value = attr_value_pb2.AttrValue()\n        nameattrlist = attr_value_pb2.NameAttrList()\n        _text_format.Merge(implements_attr, nameattrlist)\n        attr_value.func.CopyFrom(nameattrlist)\n        attributes[function_lib.IMPLEMENTS_ATTRIBUTE_NAME] = attr_value\n      except (_text_format.ParseError, DecodeError):\n        attributes[function_lib.IMPLEMENTS_ATTRIBUTE_NAME] = self._implements\n    return attributes\n\n  def _defun(self, fn):\n    \"\"\"Returns a defun generated from the input function.\"\"\"\n    attributes = {}\n\n    if self._implements is not None:\n      attributes = self._create_implements_attribute()\n\n    share = self._shared_rendezvous\n    if share is not None:\n      attributes[function_lib.SHARED_RENDEZVOUS_ATTRIBUTE_NAME] = share\n\n    if self._jit_compile is not None:\n      attributes.update(_XlaMustCompile=bool(self._jit_compile))\n      if self._jit_compile:\n        attributes.update(_noinline=True)\n    if not attributes:\n      attributes = None\n    return function_lib.defun_with_attributes(\n        fn,\n        input_signature=self.input_signature,\n        attributes=attributes,\n        autograph=self._autograph,\n        jit_compile=self._jit_compile,\n        experimental_autograph_options=self._experimental_autograph_options,\n        experimental_follow_type_hints=self._experimental_follow_type_hints,\n        experimental_relax_shapes=self._experimental_relax_shapes)\n\n  def _initialize(self, args, kwds, add_initializers_to=None):\n    \"\"\"Initializes, on the first call.\n\n    Creates two `Function`s, one that will allow creation of variables\n    and one that won't.\n\n    Additionally runs a trace for the `Function` that allows creation\n    of variables.\n\n    Args:\n      args: Arguments to the underlying python callable.\n      kwds: Keyword arguments to the python callable.\n      add_initializers_to: Where to collect variable initializers, if not None.\n    \"\"\"\n\n    if self._input_signature is not None:\n      arglen = len(self._input_signature)\n      arg_names_len = len(self.function_spec.arg_names)\n      default_arg_len = len(self.function_spec.fullargspec.defaults or ())\n      required_arg_len = arg_names_len - default_arg_len\n      # The input signature must cover all required function arguments.\n      if arglen < required_arg_len:\n        missing_tensor_specs = self.function_spec.arg_names[\n            arglen:required_arg_len]\n        raise TypeError(\n            f\"The decorated function {self._name} has {required_arg_len} \"\n            f\"required argument(s), but tf.function was only passed an \"\n            f\"input_signature of length {arglen}. This covers {arglen} \"\n            f\"required argument(s): {self.function_spec.arg_names[:arglen]}, \"\n            f\"but TensorSpecs are still required for the remaining \"\n            f\"{len(missing_tensor_specs)} argument(s): {missing_tensor_specs}.\")\n\n    created_variables = []\n    lifted_initializer_graph = func_graph_module.FuncGraph(\"initializer\")\n\n    def variable_capturing_scope(unused_next_creator, **kwds):\n      \"\"\"Creates UnliftedInitializerVariables and saves references to them.\"\"\"\n      v = UnliftedInitializerVariable(\n          add_initializers_to=add_initializers_to,\n          lifted_initializer_graph=lifted_initializer_graph, **kwds)\n      created_variables.append(weakref.ref(v))\n      return v\n\n    self._created_variables = created_variables\n    self._stateful_fn = self._defun_with_scope(variable_capturing_scope)\n    self._stateful_fn._name = self._name  # pylint: disable=protected-access\n    # Force the definition of the function for these arguments\n    self._lifted_initializer_graph = lifted_initializer_graph\n    self._graph_deleter = FunctionDeleter(self._lifted_initializer_graph)\n    self._concrete_stateful_fn = (\n        self._stateful_fn._get_concrete_function_internal_garbage_collected(  # pylint: disable=protected-access\n            *args, **kwds))\n\n    def invalid_creator_scope(*unused_args, **unused_kwds):\n      \"\"\"Disables variable creation.\"\"\"\n      raise ValueError(\n          \"tf.function only supports singleton tf.Variables created on the \"\n          \"first call. Make sure the tf.Variable is only created once or \"\n          \"created outside tf.function. See \"\n          \"https://www.tensorflow.org/guide/function#creating_tfvariables \"\n          \"for more information.\")\n\n    self._stateless_fn = self._defun_with_scope(invalid_creator_scope)\n    self._stateless_fn._name = self._name  # pylint: disable=protected-access\n\n  def _clone(self, python_function):\n    \"\"\"Clone the function with different python function.\"\"\"\n    f = Function(\n        python_function=(self._python_function\n                         if python_function is None else python_function),\n        name=self._name,\n        input_signature=self._input_signature,\n        autograph=self._autograph,\n        jit_compile=self._jit_compile,\n        experimental_implements=self._implements,\n        experimental_autograph_options=self._experimental_autograph_options,\n        experimental_relax_shapes=self._experimental_relax_shapes,\n        experimental_follow_type_hints=self._experimental_follow_type_hints)\n\n    if self._shared_rendezvous:\n      f._shared_rendezvous = self._shared_rendezvous  # pylint: disable=protected-access\n\n    return f\n\n  def _decorate(self, decorator):\n    \"\"\"Allows the captured Python function to be decorated in place.\n\n    This method is only safe to call when the Function has not been called by a\n    user. It makes sense to use this method to push a decorator into the\n    function rather than wrapping the function in the decorator.\n\n    We use this in tf.Module to allow user annotated `tf.functions` to remain as\n    `Function` objects but still automatically enter the Module name_scope\n    when they are evaluated like all other methods.\n\n    Args:\n      decorator: A callable accepting a single argument which is the function\n        to decorate and returning a callable result.\n\n    Raises:\n      ValueError: If the function has been called a ValueError is raised.\n    \"\"\"\n    if self._stateful_fn is not None or self._stateless_fn is not None:\n      raise ValueError(\n          \"Functions cannot be decorated after they have been traced.\")\n\n    self._python_function = decorator(self._python_function)\n    self._function_spec = function_lib.FunctionSpec.from_function_and_signature(\n        self._python_function, self.input_signature)\n\n  # TODO: Remove this private method after updating all its uses\n  # A good moment to do this could be when the experimental label is removed\n  def _get_tracing_count(self):\n    return self.experimental_get_tracing_count()\n\n  def experimental_get_tracing_count(self):\n    \"\"\"Returns the number of times the function has been traced.\n\n    For more information on when a function is traced and when it is\n    traced multiple times see https://www.tensorflow.org/guide/function.\n    Example:\n\n    >>> @tf.function\n    ... def double(a):\n    ...   return a + a\n    >>> double(tf.constant(1))\n    >>> double(tf.constant(2))\n    >>> double.experimental_get_tracing_count()\n    1\n    >>> double(tf.constant(\"a\"))\n    >>> double.experimental_get_tracing_count()\n    2\n\n\n    The first time experimental_get_tracing_count is called\n    it returns 1, as the function is traced the first\n    time it is called, and the second time the same graph is used\n    since we're calling it with a parameter of the same type.\n\n    The second time experimental_get_tracing_count is called\n    it returns 2, as we called double with a\n    different argument type, and so it was traced again.\n\n    \"\"\"\n    result = self._stateless_fn.tracing_count if self._stateless_fn else 0\n    result += self._stateful_fn.tracing_count if self._stateful_fn else 0\n    return result\n\n  @property\n  def _run_functions_eagerly(self):\n    return RUN_FUNCTIONS_EAGERLY\n\n  @traceback_utils.filter_traceback\n  def __call__(self, *args, **kwds):\n    # Implements GenericFunction.__call__.\n    if self._run_functions_eagerly:\n      with trace.Trace(self._name, tf_function_call=\"eager\"):\n        return self._python_function(*args, **kwds)\n\n    # Only count the statistics the first time, before initialization took\n    # place.\n    if self._created_variables is None:\n      compiled = bool(self._jit_compile and\n                      not control_flow_util.GraphOrParentsInXlaContext(\n                          ops.get_default_graph()))\n      # For nested functions, increment the counter only when a function with\n      # jit_compile=True is called within a function with jit_compile=False. We\n      # count this special case to correctly record that both jit_compile=True\n      # and jit_compile=False is being used for parts of the outer function.\n      if ops.executing_eagerly_outside_functions() and (\n          context.executing_eagerly() or compiled):\n        # Labels must be strings in Python, so we convert 'compiled' to a string\n        _tf_function_counter.get_cell(str(int(compiled))).increase_by(1)\n\n    tracing_count = self.experimental_get_tracing_count()\n    with trace.Trace(self._name) as tm:\n      # TODO(cheshire): Do not duplicate the XLAControlFlowContext annotation.\n      compiler = \"xla\" if self._jit_compile else \"nonXla\"\n\n      with OptionalXlaContext(self._jit_compile):\n        result = self._call(*args, **kwds)\n\n      new_tracing_count = self.experimental_get_tracing_count()\n      without_tracing = (tracing_count == new_tracing_count)\n      execution_mode = \"notTraced\" if without_tracing else \"traced\"\n      tm.set_metadata(tf_function_call=execution_mode + \"-\" + compiler,\n                      tracing_count=new_tracing_count)\n\n    if context.executing_eagerly():\n      if without_tracing:\n        _frequent_tracing_detector_manager.called_without_tracing(\n            self._key_for_call_stats)\n      else:\n        _frequent_tracing_detector_manager.called_with_tracing(\n            self._key_for_call_stats, self._python_function,\n            self._omit_frequent_tracing_warning)\n\n    return result\n\n  def _call(self, *args, **kwds):\n    \"\"\"Calls the graph function.\"\"\"\n    self._lock.acquire()\n    if ALLOW_DYNAMIC_VARIABLE_CREATION:\n      condition = self._created_variables and self._stateful_fn is None\n    else:\n      condition = self._created_variables\n    if condition:\n      # Release the lock early so that multiple threads can perform the call\n      # in parallel.\n      self._lock.release()\n      # In this case we have created variables on the first call, so we run the\n      # defunned version which is guaranteed to never create variables.\n      return self._stateless_fn(*args, **kwds)  # pylint: disable=not-callable\n    elif self._stateful_fn is not None:\n      # Release the lock early so that multiple threads can perform the call\n      # in parallel.\n      self._lock.release()\n      # In this case we have not created variables on the first call. So we can\n      # run the first trace but we should fail if variables are created.\n      results = self._stateful_fn(*args, **kwds)\n      if self._created_variables and not ALLOW_DYNAMIC_VARIABLE_CREATION:\n        raise ValueError(\"Creating variables on a non-first call to a function\"\n                         \" decorated with tf.function.\")\n      return results\n\n    try:\n      # This is the first call of __call__, so we have to initialize.\n      initializers = []\n      self._initialize(args, kwds, add_initializers_to=initializers)\n    finally:\n      # At this point we know that the initialization is complete (or less\n      # interestingly an exception was raised) so we no longer need a lock.\n      self._lock.release()\n\n    if self._created_variables:\n      try:\n        # Attempt to initialize variables eagerly and without conds by lifting\n        # out initialization graphs. This is the only initialization strategy\n        # compatible with XLA at the moment.\n        self._initialize_uninitialized_variables(initializers)\n      except lift_to_graph.UnliftableError:\n        pass  # Fall through to cond-based initialization.\n      else:\n        # Lifting succeeded, so variables are initialized and we can run the\n        # stateless function.\n        return self._stateless_fn(*args, **kwds)\n    else:\n      _, _, _, filtered_flat_args = \\\n          self._stateful_fn._function_spec.canonicalize_function_inputs(  # pylint: disable=protected-access\n              *args, **kwds)\n      # If we did not create any variables the trace we have is good enough.\n      return self._concrete_stateful_fn._call_flat(\n          filtered_flat_args, self._concrete_stateful_fn.captured_inputs)  # pylint: disable=protected-access\n\n    def fn_with_cond(inner_args, inner_kwds, inner_filtered_flat_args):\n      \"\"\"Conditionally runs initialization if it's needed.\"\"\"\n      condition = True\n      for wr in self._created_variables:\n        variable = wr()\n        if variable is None:\n          raise ValueError(\n              \"A tf.Variable created inside your tf.function has been\"\n              \" garbage-collected. Your code needs to keep Python references\"\n              \" to variables created inside `tf.function`s.\\n\"\n              \"\\n\"\n              \"A common way to raise this error is to create and return a\"\n              \" variable only referenced inside your function:\\n\"\n              \"\\n\"\n              \"@tf.function\\n\"\n              \"def f():\\n\"\n              \"  v = tf.Variable(1.0)\\n\"\n              \"  return v\\n\"\n              \"\\n\"\n              \"v = f()  # Crashes with this error message!\\n\"\n              \"\\n\"\n              \"The reason this crashes is that @tf.function annotated\"\n              \" function returns a **`tf.Tensor`** with the **value** of the\"\n              \" variable when the function is called rather than the\"\n              \" variable instance itself. As such there is no code holding a\"\n              \" reference to the `v` created inside the function and Python\"\n              \" garbage collects it.\\n\"\n              \"\\n\"\n              \"The simplest way to fix this issue is to create variables\"\n              \" outside the function and capture them:\\n\"\n              \"\\n\"\n              \"v = tf.Variable(1.0)\\n\"\n              \"\\n\"\n              \"@tf.function\\n\"\n              \"def f():\\n\"\n              \"  return v\\n\"\n              \"\\n\"\n              \"f()  # <tf.Tensor: numpy=1.>\\n\"\n              \"v.assign_add(1.)\\n\"\n              \"f()  # <tf.Tensor: numpy=2.>\")\n        condition = math_ops.logical_and(\n            condition, resource_variable_ops.var_is_initialized_op(\n                variable.handle))\n      # We want to call stateless_fn if possible because it avoids recomputing\n      # potentially expensive initializers.\n      return control_flow_ops.cond(\n          condition,\n          lambda: self._stateless_fn(*inner_args, **inner_kwds),\n          functools.partial(\n              self._concrete_stateful_fn._call_flat,  # pylint: disable=protected-access\n              inner_filtered_flat_args,\n              captured_inputs=self._concrete_stateful_fn.captured_inputs))\n\n    # We've created variables and are unable to lift the initialization graphs,\n    # so we fall back to initializing with conds while running the function.\n    canon_args, canon_kwds, _, filtered_flat_args = \\\n        self._stateful_fn._function_spec.canonicalize_function_inputs(  # pylint: disable=protected-access\n            *args, **kwds)\n    return function_lib.defun(fn_with_cond)(canon_args, canon_kwds,\n                                            filtered_flat_args)\n\n  def experimental_get_compiler_ir(self, *args, **kwargs):\n    # Implements GenericFunction.experimental_get_compiler_ir\n    context.ensure_initialized()\n    if not self._jit_compile:\n      raise ValueError(\"Compiler IR can only be returned for functions marked \"\n                       \"with 'jit_compile=True'\")\n\n    concrete_fn = self.get_concrete_function(*args, **kwargs)\n    fn_name = concrete_fn.name\n\n    # pylint: disable=protected-access\n    _, _, _, filtered_flat_args = \\\n        concrete_fn._function_spec.canonicalize_function_inputs(\n            *args, **kwargs)\n\n    def compiler_ir_generator(stage=\"hlo\", device_name=None):\n      # TODO(cheshire): This is a hack to get the current \"preferred\" device,\n      # there is no current API to get it otherwise.\n      if device_name is None:\n        device_name = random_ops.random_normal([]).device\n      res_bytes = context.context().get_compiler_ir(\n          device_name=device_name,\n          stage=stage,\n          function_name=fn_name,\n          args=list(filtered_flat_args) + concrete_fn.captured_inputs)\n      if stage in (\"hlo_serialized\", \"optimized_hlo_serialized\",\n                   \"optimized_hlo_proto_serialized\"):\n        return res_bytes\n      else:\n        return res_bytes.decode(\"utf-8\")\n\n    return compiler_ir_generator\n\n  @property\n  def python_function(self):\n    \"\"\"The python function wrapped in this tf.function.\"\"\"\n    return self._python_function\n\n  @property\n  def input_signature(self):\n    return self._function_spec.input_signature\n\n  @property\n  def function_spec(self):\n    return self._function_spec\n\n  def pretty_printed_concrete_signatures(self, verbose=True):\n    joiner = \"\\n\\n\" if verbose else \"\\n\"\n    return joiner.join([\n        c.pretty_printed_signature(verbose=verbose)\n        for c in self._list_all_concrete_functions()\n    ])\n\n  def _initialize_uninitialized_variables(self, initializers):\n    \"\"\"Make and call a `ConcreteFunction` which initializes variables.\"\"\"\n\n    if not initializers:\n      return\n\n    var_is_initialized = _evaluate_var_is_initialized(\n        [v for v, _ in initializers])\n\n    # Note: using defun here avoids an infinite recursion.\n    # Most of the code in this function runs eagerly with init_scope, where\n    # autograph is not necessary.\n    @function_lib.defun(autograph=False)\n    def initialize_variables():\n      op_map = object_identity.ObjectIdentityDictionary()\n\n      inits = []\n      for (v, init), is_initialized in zip(initializers, var_is_initialized):\n        with ops.init_scope():\n          if is_initialized:\n            continue\n        inits.append(init)\n\n      if inits:\n        op_map = lift_to_graph.lift_to_graph(\n            inits, ops.get_default_graph(), op_map=op_map)\n      for (v, init), is_initialized in zip(initializers, var_is_initialized):\n        with ops.init_scope():\n          if is_initialized:\n            continue\n        v.assign(op_map[init], read_value=False)\n\n    with ops.init_scope():\n      return initialize_variables.get_concrete_function()()\n\n  def get_initialization_function(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` which initializes this function's variables.\n\n    Requires that this function hasn't been accessed yet through either calling\n    it or calling get_concrete_function. Fails if we cannot build an initializer\n    function which does not depend on the concrete values of the inputs to this\n    function.\n\n    Note that running this function will overwrite any values currently assigned\n    to variables, for example restores from a checkpoint.\n\n    Args:\n      *args: arguments to the underlying python callable.\n      **kwargs: keyword arguments to the python callable.\n\n    Returns:\n      A `ConcreteFunction` object which initializes the variables of this\n      function.\n\n    Raises:\n      RuntimeError: if called after the variables have been initialized.\n    \"\"\"\n    with self._lock:\n      if self._stateful_fn is not None:\n        raise RuntimeError(\n            \"get_initialization_function cannot be called after the function \"\n            \"has been used\")\n      # Here we trace the function, collect the initializers, and attempt to\n      # extract them and run them eagerly. Fail only if we cannot do so.\n      initializers = []\n      self._initialize(args, kwargs, add_initializers_to=initializers)\n\n    # Note: using defun here avoids an infinite recursion.\n    @function_lib.defun\n    def initialize_variables():\n      for v, init in initializers:\n        v.assign(\n            lift_to_graph.lift_to_graph([init], ops.get_default_graph())[init],\n            read_value=False)\n\n    return initialize_variables.get_concrete_function()\n\n  def _list_all_concrete_functions(self):\n    \"\"\"Returns all concrete functions.\"\"\"\n    if self.input_signature is not None:\n      self.get_concrete_function()\n    concrete_functions = []\n    # pylint: disable=protected-access\n    if self._stateful_fn:\n      concrete_functions.extend(\n          self._stateful_fn._function_cache.all_values())\n    if self._stateless_fn:\n      concrete_functions.extend(\n          self._stateless_fn._function_cache.all_values())\n    # pylint: enable=protected-access\n    return concrete_functions\n\n  def _list_all_concrete_functions_for_serialization(self):\n    \"\"\"Returns all concrete functions for serialization.\n\n    Returns:\n      A list of instances of `ConcreteFunction`.\n    \"\"\"\n    concrete_functions = self._list_all_concrete_functions()\n    seen_signatures = []\n    for concrete_function in concrete_functions:\n      signature = concrete_function.structured_input_signature\n      flattened = nest.flatten(signature)\n      if any(\n          isinstance(arg, func_graph_module.UnknownArgument)\n          for arg in flattened):\n        logging.info(\"Unsupported signature for serialization: %s.\", signature)\n        continue\n      equal_to_signature = functools.partial(\n          function_lib.is_same_structure, signature, check_values=True)\n      if not any(equal_to_signature(s) for s in seen_signatures):\n        seen_signatures.append(signature)\n\n    # Re-create concrete functions for these signatures. Re-creating ensures\n    # that if the cache key has changed, the function will be traced again.\n    concrete_functions = []\n    for args, kwargs in seen_signatures:\n      concrete_functions.append(self.get_concrete_function(*args, **kwargs))\n    return concrete_functions\n\n  def _get_concrete_function_garbage_collected(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` specialized to inputs and execution context.\n\n    Unlike `get_concrete_function(...)`, the graph will be deleted when the\n    returned function is deleted.  It's useful to avoid creating a reference\n    cycle when you know for sure that the graph will be no longer used without\n    the returned function.\n\n    Args:\n      *args: inputs to specialize on.\n      **kwargs: inputs to specialize on.\n\n    Returns:\n      A TensorFlow function which takes exactly one `tf.Tensor` per argument.\n\n    Raises:\n      ValueError: if this object has not yet been called on concrete values.\n    \"\"\"\n    with self._lock:\n      if self._stateful_fn is None:\n        initializers = []\n        self._initialize(args, kwargs, add_initializers_to=initializers)\n        self._initialize_uninitialized_variables(initializers)\n\n    if self._created_variables:\n      # In this case we have created variables on the first call, so we run the\n      # defunned version which is guaranteed to never create variables.\n      return self._stateless_fn._get_concrete_function_garbage_collected(  # pylint: disable=protected-access\n          *args, **kwargs)\n    elif self._stateful_fn is not None:\n      # In this case we have not created variables on the first call. So we can\n      # run the first trace but we should fail if variables are created.\n      concrete = self._stateful_fn._get_concrete_function_garbage_collected(  # pylint: disable=protected-access\n          *args, **kwargs)\n      if self._created_variables:\n        raise ValueError(\"Creating variables on a non-first call to a function\"\n                         \" decorated with tf.function.\")\n      return concrete\n\n  def get_concrete_function(self, *args, **kwargs):\n    # Implements GenericFunction.get_concrete_function.\n    concrete = self._get_concrete_function_garbage_collected(*args, **kwargs)\n    concrete._garbage_collector.release()  # pylint: disable=protected-access\n    return concrete\n\n  def __get__(self, instance, owner):\n    \"\"\"Makes it possible to defun instance methods.\"\"\"\n    del owner\n    # `instance` here is the instance that this `Function` was accessed through\n    # e.g., for\n    #\n    #   class Foo(object):\n    #\n    #     @function.defun\n    #     def bar(self):\n    #       ...\n    #\n    #   foo = Foo()\n    #   foo.bar()  # `foo.bar` is a `Function` instance\n    #\n    # then `instance` will be `foo` (and `owner` will be `Foo`).  For composite\n    # tensors, we can just treat `instance` as a normal parameter.  But for\n    # other types, we create a new instance of `Function` here to allow\n    # different instances each to create variables once, thereby allowing\n    # methods to be decorated with tf.function. Keeps a cache to avoid retracing\n    # the function every time the descriptor is accessed.\n    # TODO(mdan): Identify types which can just be parameters more generically.\n    #\n    # The check for instance._type_spec=None is used because certain classes\n    # (including subclasses of tf.linalg.LinearOperator) are subclasses of\n    # CompositeTensor but do not actually implement the required APIs.\n    # TODO(b/199278478): Fix those classes, then remove the check for\n    # `instance._type_spec is not None`.\n    if (isinstance(instance, composite_tensor.CompositeTensor) and\n        instance._type_spec is not None):  # pylint: disable=protected-access\n      return types_lib.MethodType(self, instance)\n    if instance not in self._descriptor_cache:\n      if instance is None:\n        return self\n      # TODO(mdan): If the CompositeTensor path works, do the same here.\n      # It's unclear whether we need the tf-decorator, or could just call\n      # MethodType(self.clone(), instance)\n      self._descriptor_cache[instance] = (\n          function_lib.class_method_to_instance_method(self, instance))\n    return self._descriptor_cache[instance]\n\n\n@tf_export(\"function\")\n@deprecation.deprecated_args(None,\n                             \"experimental_compile is deprecated, use \"\n                             \"jit_compile instead\", \"experimental_compile\")\ndef function(func=None,\n             input_signature=None,\n             autograph=True,\n             jit_compile=None,\n             experimental_implements=None,\n             experimental_autograph_options=None,\n             experimental_relax_shapes=False,\n             experimental_compile=None,\n             experimental_follow_type_hints=None) -> core.GenericFunction:\n  \"\"\"Compiles a function into a callable TensorFlow graph.\n\n  `tf.function` constructs a `tf.types.experimental.GenericFunction` that\n  executes a TensorFlow graph (`tf.Graph`) created by trace-compiling the\n  TensorFlow operations in `func`. More information on the topic can be found\n  in [Introduction to Graphs and tf.function]\n  (https://www.tensorflow.org/guide/intro_to_graphs).\n\n  See [Better Performance with tf.function]\n  (https://www.tensorflow.org/guide/function) for tips on performance and\n  known limitations.\n\n  Example usage:\n\n  >>> @tf.function\n  ... def f(x, y):\n  ...   return x ** 2 + y\n  >>> x = tf.constant([2, 3])\n  >>> y = tf.constant([3, -2])\n  >>> f(x, y)\n  <tf.Tensor: ... numpy=array([7, 7], ...)>\n\n  The trace-compilation allows non-TensorFlow operations to execute, but under\n  special conditions. In general, only TensorFlow operations are guaranteed to\n  run and create fresh results whenever the `GenericFunction` is called.\n\n  ## Features\n\n  `func` may use data-dependent control flow, including `if`, `for`, `while`\n  `break`, `continue` and `return` statements:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   if tf.reduce_sum(x) > 0:\n  ...     return x * x\n  ...   else:\n  ...     return -x // 2\n  >>> f(tf.constant(-2))\n  <tf.Tensor: ... numpy=1>\n\n  `func`'s closure may include `tf.Tensor` and `tf.Variable` objects:\n\n  >>> @tf.function\n  ... def f():\n  ...   return x ** 2 + y\n  >>> x = tf.constant([-2, -3])\n  >>> y = tf.Variable([3, -2])\n  >>> f()\n  <tf.Tensor: ... numpy=array([7, 7], ...)>\n\n  `func` may also use ops with side effects, such as `tf.print`, `tf.Variable`\n  and others:\n\n  >>> v = tf.Variable(1)\n  >>> @tf.function\n  ... def f(x):\n  ...   for i in tf.range(x):\n  ...     v.assign_add(i)\n  >>> f(3)\n  >>> v\n  <tf.Variable ... numpy=4>\n\n  Important: Any Python side-effects (appending to a list, printing with\n  `print`, etc) will only happen once, when `func` is traced. To have\n  side-effects executed into your `tf.function` they need to be written\n  as TF ops:\n\n  >>> l = []\n  >>> @tf.function\n  ... def f(x):\n  ...   for i in x:\n  ...     l.append(i + 1)    # Caution! Will only happen once when tracing\n  >>> f(tf.constant([1, 2, 3]))\n  >>> l\n  [<tf.Tensor ...>]\n\n  Instead, use TensorFlow collections like `tf.TensorArray`:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   ta = tf.TensorArray(dtype=tf.int32, size=0, dynamic_size=True)\n  ...   for i in range(len(x)):\n  ...     ta = ta.write(i, x[i] + 1)\n  ...   return ta.stack()\n  >>> f(tf.constant([1, 2, 3]))\n  <tf.Tensor: ..., numpy=array([2, 3, 4], ...)>\n\n  ## `tf.function` creates polymorphic callables\n\n  Internally, `tf.types.experimental.GenericFunction` may contain multiple\n  `tf.types.experimental.ConcreteFunction`s, each specialized to arguments with\n  different data types or shapes, since TensorFlow can perform more\n  optimizations on graphs of specific shapes, dtypes and values of constant\n  arguments. `tf.function` treats any pure Python values as opaque objects (best\n  thought of as compile-time constants), and builds a separate `tf.Graph` for\n  each set of Python arguments that it encounters.\n  For more information, see the\n  [tf.function guide](https://www.tensorflow.org/guide/function#rules_of_tracing)\n\n  Executing a `GenericFunction` will select and execute the appropriate\n  `ConcreteFunction` based on the argument types and values.\n\n  To obtain an individual `ConcreteFunction`, use the\n  `GenericFunction.get_concrete_function` method. It can be called with the\n  same arguments as `func` and returns a\n  `tf.types.experimental.ConcreteFunction`. `ConcreteFunction`s are backed by a\n  single `tf.Graph`:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   return x + 1\n  >>> isinstance(f.get_concrete_function(1).graph, tf.Graph)\n  True\n\n  `ConcreteFunction`s can be executed just like `GenericFunction`s, but their\n  input is resticted to the types to which they're specialized.\n\n  ## Retracing\n\n  `ConcreteFunctions` are built (traced) on the fly, as the `GenericFunction` is\n  called with new TensorFlow types or shapes, or with new Python values as\n  arguments. When `GenericFunction` builds a new trace, it is said that `func`\n  is retraced. Retracing is a frequent performance concern for `tf.function` as\n  it can be considerably slower than executing a graph that's already been\n  traced. It is ideal to minimize the amount of retracing in your code.\n\n  Caution: Passing python scalars or lists as arguments to `tf.function` will\n  usually retrace. To avoid this, pass numeric arguments as Tensors whenever\n  possible:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   return tf.abs(x)\n  >>> f1 = f.get_concrete_function(1)\n  >>> f2 = f.get_concrete_function(2)  # Slow - compiles new graph\n  >>> f1 is f2\n  False\n  >>> f1 = f.get_concrete_function(tf.constant(1))\n  >>> f2 = f.get_concrete_function(tf.constant(2))  # Fast - reuses f1\n  >>> f1 is f2\n  True\n\n  Python numerical arguments should only be used when they take few distinct\n  values, such as hyperparameters like the number of layers in a neural network.\n\n  ## Input signatures\n\n  For Tensor arguments, `GenericFunction`creates a new `ConcreteFunction` for\n  every unique set of input shapes and datatypes. The example below creates two\n  separate `ConcreteFunction`s, each specialized to a different shape:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   return x + 1\n  >>> vector = tf.constant([1.0, 1.0])\n  >>> matrix = tf.constant([[3.0]])\n  >>> f.get_concrete_function(vector) is f.get_concrete_function(matrix)\n  False\n\n  An \"input signature\" can be optionally provided to `tf.function` to control\n  this process. The input signature specifies the shape and type of each\n  Tensor argument to the function using a `tf.TensorSpec` object. More general\n  shapes can be used. This ensures only one `ConcreteFunction` is created, and\n  restricts the `GenericFunction` to the specified shapes and types. It is\n  an effective way to limit retracing when Tensors have dynamic shapes.\n\n  >>> @tf.function(\n  ...     input_signature=[tf.TensorSpec(shape=None, dtype=tf.float32)])\n  ... def f(x):\n  ...   return x + 1\n  >>> vector = tf.constant([1.0, 1.0])\n  >>> matrix = tf.constant([[3.0]])\n  >>> f.get_concrete_function(vector) is f.get_concrete_function(matrix)\n  True\n\n  ## Variables may only be created once\n\n  `tf.function` only allows creating new `tf.Variable` objects when it is called\n  for the first time:\n\n  >>> class MyModule(tf.Module):\n  ...   def __init__(self):\n  ...     self.v = None\n  ...\n  ...   @tf.function\n  ...   def __call__(self, x):\n  ...     if self.v is None:\n  ...       self.v = tf.Variable(tf.ones_like(x))\n  ...     return self.v * x\n\n  In general, it is recommended to create `tf.Variable`s outside of\n  `tf.function`.\n  In simple cases, persisting state across `tf.function` boundaries may be\n  implemented using a pure functional style in which state is represented by\n  `tf.Tensor`s passed as arguments and returned as return values.\n\n  Contrast the two styles below:\n\n  >>> state = tf.Variable(1)\n  >>> @tf.function\n  ... def f(x):\n  ...   state.assign_add(x)\n  >>> f(tf.constant(2))  # Non-pure functional style\n  >>> state\n  <tf.Variable ... numpy=3>\n\n  >>> state = tf.constant(1)\n  >>> @tf.function\n  ... def f(state, x):\n  ...   state += x\n  ...   return state\n  >>> state = f(state, tf.constant(2))  # Pure functional style\n  >>> state\n  <tf.Tensor: ... numpy=3>\n\n  ## Python operations execute only once per trace\n\n  `func` may contain TensorFlow operations mixed with pure Python operations.\n  However, when the function is executed, only the TensorFlow operations will\n  run. The Python operations run only once, at trace time. If TensorFlow\n  operations depend on results from Pyhton operations, those results will be\n  frozen into the graph.\n\n  >>> @tf.function\n  ... def f(a, b):\n  ...   print('this runs at trace time; a is', a, 'and b is', b)\n  ...   return b\n  >>> f(1, tf.constant(1))\n  this runs at trace time; a is 1 and b is Tensor(\"...\", shape=(), dtype=int32)\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n\n  >>> f(1, tf.constant(2))\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  >>> f(2, tf.constant(1))\n  this runs at trace time; a is 2 and b is Tensor(\"...\", shape=(), dtype=int32)\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n\n  >>> f(2, tf.constant(2))\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  ## Using type annotations to improve performance\n\n  'experimental_follow_type_hints` can be used along with type annotations to\n  reduce retracing by automatically casting any Python values to `tf.Tensor`\n  (something that is not done by default, unless you use input signatures).\n\n  >>> @tf.function(experimental_follow_type_hints=True)\n  ... def f_with_hints(x: tf.Tensor):\n  ...   print('Tracing')\n  ...   return x\n  >>> @tf.function(experimental_follow_type_hints=False)\n  ... def f_no_hints(x: tf.Tensor):\n  ...   print('Tracing')\n  ...   return x\n  >>> f_no_hints(1)\n  Tracing\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n  >>> f_no_hints(2)\n  Tracing\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n  >>> f_with_hints(1)\n  Tracing\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n  >>> f_with_hints(2)\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  Args:\n    func: the function to be compiled. If `func` is None, `tf.function` returns\n      a decorator that can be invoked with a single argument - `func`. In other\n      words, `tf.function(input_signature=...)(func)` is equivalent to\n      `tf.function(func, input_signature=...)`. The former can be used as\n      decorator.\n    input_signature: A possibly nested sequence of `tf.TensorSpec` objects\n      specifying the shapes and dtypes of the Tensors that will be supplied to\n      this function. If `None`, a separate function is instantiated for each\n      inferred input signature.  If input_signature is specified, every input to\n      `func` must be a `Tensor`, and `func` cannot accept `**kwargs`.\n    autograph: Whether autograph should be applied on `func` before tracing a\n      graph. Data-dependent control flow requires `autograph=True`. For more\n      information, see the [tf.function and AutoGraph guide](\n      https://www.tensorflow.org/guide/function#autograph_transformations).\n    jit_compile: If `True`, compiles the function using\n      [XLA](https://tensorflow.org/xla). XLA performs compiler optimizations,\n      such as fusion, and attempts to emit more efficient code. This may\n      drastically improve the performance. If set to `True`,\n      the whole function needs to be compilable by XLA, or an\n      `errors.InvalidArgumentError` is thrown.\n      If `None` (default), compiles the function with XLA when running on TPU\n      and goes through the regular function execution path when running on\n      other devices.\n      If `False`, executes the function without XLA compilation.  Set this value\n      to `False` when directly running a multi-device function on TPUs (e.g. two\n      TPU cores, one TPU core and its host CPU).\n      Not all functions are compilable, see a list of\n      [sharp corners](https://tensorflow.org/xla/known_issues).\n    experimental_implements: If provided, contains a name of a \"known\" function\n      this implements. For example \"mycompany.my_recurrent_cell\".\n      This is stored as an attribute in inference function,\n      which can then be detected when processing serialized function.\n      See [standardizing composite ops](https://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.md)  # pylint: disable=line-too-long\n      for details.  For an example of utilizing this attribute see this\n      [example](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.cc)\n      The code above automatically detects and substitutes function that\n      implements \"embedded_matmul\" and allows TFLite to substitute its own\n      implementations. For instance, a tensorflow user can use this\n       attribute to mark that their function also implements\n      `embedded_matmul` (perhaps more efficiently!)\n      by specifying it using this parameter:\n      `@tf.function(experimental_implements=\"embedded_matmul\")`\n      This can either be specified as just the string name of the function or\n      a NameAttrList corresponding to a list of key-value attributes associated\n      with the function name. The name of the function will be in the 'name'\n      field of the NameAttrList. To define a formal TF op for this function\n      implements, try the experimental [composite TF](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/tfr)\n      project.\n    experimental_autograph_options: Optional tuple of\n      `tf.autograph.experimental.Feature` values.\n    experimental_relax_shapes: When True, `tf.function` may generate fewer,\n      graphs that are less specialized on input shapes.\n    experimental_compile: Deprecated alias to 'jit_compile'.\n    experimental_follow_type_hints: When True, the function may use type\n      annotations from `func` to optimize the tracing performance. For example,\n      arguments annotated with `tf.Tensor` will automatically be converted\n      to a Tensor.\n\n  Returns:\n     If `func` is not None, returns a `tf.types.experimental.GenericFunction`.\n     If `func` is None, returns a decorator that, when invoked with a single\n     `func` argument, returns a `tf.types.experimental.GenericFunction`.\n\n  Raises:\n     `ValueError` when attempting to use `jit_compile=True`, but XLA support is\n     not available.\n  \"\"\"\n  if func is not None:\n    function_lib.validate_python_function(func)\n  if input_signature is not None:\n    function_lib.validate_signature(input_signature)\n  if experimental_follow_type_hints is None:\n    experimental_follow_type_hints = False\n\n  def decorated(inner_function):\n    try:\n      name = inner_function.__name__\n    except AttributeError:\n      name = \"function\"\n    return tf_decorator.make_decorator(\n        inner_function,\n        decorator_name=\"tf.function\",\n        decorator_func=Function(\n            inner_function,\n            name,\n            input_signature=input_signature,\n            autograph=autograph,\n            experimental_autograph_options=experimental_autograph_options,\n            experimental_relax_shapes=experimental_relax_shapes,\n\n            # TODO(b/171825496): Update once `experimental_compile` is removed\n            # entirely in favor of 'jit_compile'.\n            jit_compile=deprecation.deprecated_argument_lookup(\n                \"jit_compile\",\n                jit_compile,\n                \"experimental_compile\",\n                experimental_compile),\n            experimental_implements=experimental_implements,\n            experimental_follow_type_hints=experimental_follow_type_hints))\n\n  # This code path is for the `foo = tf.function(foo, ...)` use case\n  if func is not None:\n    return decorated(func)\n\n  # This code path is for the\n  #\n  # @tf.function(...)\n  # def foo(...):\n  #    ...\n  #\n  # use case, which is equivalent to `foo = tf.function(...)(foo)`\n  return decorated"