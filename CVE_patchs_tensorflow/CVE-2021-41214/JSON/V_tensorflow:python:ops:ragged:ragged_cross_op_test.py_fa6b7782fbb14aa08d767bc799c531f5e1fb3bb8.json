"# Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for tf.ragged.cross and tf.ragged.cross_hashed.\"\"\"\n\nfrom absl.testing import parameterized\n\nimport numpy as np\n\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.ops.ragged import ragged_array_ops\nfrom tensorflow.python.ops.ragged import ragged_factory_ops\nfrom tensorflow.python.ops.ragged import ragged_tensor\nfrom tensorflow.python.platform import googletest\n\nragged_const = ragged_factory_ops.constant_value\ndense_const = np.array\n\n\ndef sparse_const(matrix):\n  indices = []\n  values = []\n  for i, row in enumerate(matrix):\n    for j, val in enumerate(row):\n      indices.append([i, j])\n      values.append(val)\n  shape = [len(matrix), max(len(row) for row in matrix)] if matrix else [0, 0]\n  if not values:\n    indices = np.zeros([0, 2], dtype=np.int64)\n    values = np.zeros([0], dtype=np.int64)\n  return sparse_tensor.SparseTensorValue(indices, values, shape)\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass RaggedCrossOpTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  @parameterized.named_parameters([\n      dict(\n          testcase_name='NoInputs',\n          inputs=[],\n          expected=ragged_const([], ragged_rank=1, dtype=dtypes.int32)),\n      dict(\n          testcase_name='OneInput_RaggedStr',\n          inputs=[ragged_const([['a', 'b'], [], ['c']])],\n          expected=ragged_const([[b'a', b'b'], [], [b'c']])),\n      dict(\n          testcase_name='OneInput_RaggedInt',\n          inputs=[ragged_const([[1, 2, 3], [4, 5]])],\n          expected=ragged_const([[b'1', b'2', b'3'], [b'4', b'5']])),\n      dict(\n          testcase_name='OneInput_DenseInt',\n          inputs=[dense_const([[1, 2, 3], [4, 5, 6]])],\n          expected=ragged_const([[b'1', b'2', b'3'], [b'4', b'5', b'6']])),\n      dict(\n          testcase_name='OneInput_SparseStr',\n          inputs=[sparse_const([['a', 'b'], [], ['c']])],\n          expected=ragged_const([[b'a', b'b'], [], [b'c']])),\n      dict(\n          testcase_name='TwoInputs_RaggedStr_RaggedStr',\n          inputs=[\n              ragged_const([['a', 'b'], [], ['c']]),\n              ragged_const([['d', 'e'], ['f'], ['g']])\n          ],\n          expected=ragged_const([[b'a_X_d', b'a_X_e', b'b_X_d', b'b_X_e'], [],\n                                 [b'c_X_g']])),\n      dict(\n          testcase_name='TwoInputs_RaggedInt_RaggedInt',\n          inputs=[\n              ragged_const([[1, 2], [], [3]]),\n              ragged_const([[4, 5, 6], [], [7]])\n          ],\n          expected=ragged_const(\n              [[b'1_X_4', b'1_X_5', b'1_X_6', b'2_X_4', b'2_X_5', b'2_X_6'], [],\n               [b'3_X_7']])),\n      dict(\n          testcase_name='TwoInputs_RaggedStr_RaggedInt',\n          inputs=[\n              ragged_const([['a', 'b'], [], ['c']]),\n              ragged_const([['1', '2'], ['3'], ['4']])\n          ],\n          expected=ragged_const([[b'a_X_1', b'a_X_2', b'b_X_1', b'b_X_2'], [],\n                                 [b'c_X_4']])),\n      dict(\n          testcase_name='TwoInputs_SparseStr_SparseStr',\n          inputs=[\n              sparse_const([['a', 'b'], [], ['c']]),\n              sparse_const([['d', 'e'], ['f'], ['g']])\n          ],\n          expected=ragged_const([[b'a_X_d', b'a_X_e', b'b_X_d', b'b_X_e'], [],\n                                 [b'c_X_g']])),\n      dict(\n          testcase_name='TwoInputs_DenseInt_DenseInt',\n          inputs=[dense_const([[1, 2], [3, 4]]),\n                  dense_const([[5, 6], [7, 8]])],\n          expected=ragged_const([[b'1_X_5', b'1_X_6', b'2_X_5', b'2_X_6'],\n                                 [b'3_X_7', b'3_X_8', b'4_X_7', b'4_X_8']])),\n      dict(\n          testcase_name='TwoInputs_DenseInt_DenseStr',\n          inputs=[\n              dense_const([[1, 2], [3, 4]]),\n              dense_const([[b'5', b'6'], [b'7', b'8']])\n          ],\n          expected=ragged_const([[b'1_X_5', b'1_X_6', b'2_X_5', b'2_X_6'],\n                                 [b'3_X_7', b'3_X_8', b'4_X_7', b'4_X_8']])),\n      dict(\n          testcase_name='TwoInputs_RaggedInt_DenseInt',\n          inputs=[\n              ragged_const([[], [], [1, 2], [3]]),\n              dense_const([[1, 2], [3, 4], [5, 6], [7, 8]])\n          ],\n          expected=ragged_const([[], [],\n                                 [b'1_X_5', b'1_X_6', b'2_X_5', b'2_X_6'],\n                                 [b'3_X_7', b'3_X_8']])),\n      dict(\n          # This test exercises `input_order`.\n          testcase_name='TwoInputs_DenseInt_RaggedStr',\n          inputs=[\n              dense_const([[1, 2], [3, 4], [5, 6]]),\n              ragged_const([['d', 'e'], ['f'], ['g']])\n          ],\n          expected=ragged_const([[b'1_X_d', b'1_X_e', b'2_X_d', b'2_X_e'],\n                                 [b'3_X_f', b'4_X_f'], [b'5_X_g', b'6_X_g']]),\n          matches_sparse_cross=False  # sparse doesn't preserve input order.\n      ),\n      dict(\n          # This test exercises `input_order`.\n          testcase_name='TwoInputs_SparseInt_RaggedStr',\n          inputs=[\n              sparse_const([[1, 2], [3, 4], [5, 6]]),\n              ragged_const([['d', 'e'], ['f'], ['g']])\n          ],\n          expected=ragged_const([[b'1_X_d', b'1_X_e', b'2_X_d', b'2_X_e'],\n                                 [b'3_X_f', b'4_X_f'], [b'5_X_g', b'6_X_g']]),\n          matches_sparse_cross=False  # sparse doesn't preserve input order.\n      ),\n      dict(\n          testcase_name='ThreeInputs_RaggedInt_RaggedInt_RaggedInt',\n          inputs=[\n              ragged_const([[11], [12, 13], [], [14, 15]]),\n              ragged_const([[21, 22], [23], [24, 25], [26, 27]]),\n              ragged_const([[31], [32, 33], [34, 35], [36, 37]])\n          ],\n          expected=ragged_const([[b'11_X_21_X_31', b'11_X_22_X_31'],\n                                 [\n                                     b'12_X_23_X_32', b'12_X_23_X_33',\n                                     b'13_X_23_X_32', b'13_X_23_X_33'\n                                 ], [],\n                                 [\n                                     b'14_X_26_X_36', b'14_X_26_X_37',\n                                     b'14_X_27_X_36', b'14_X_27_X_37',\n                                     b'15_X_26_X_36', b'15_X_26_X_37',\n                                     b'15_X_27_X_36', b'15_X_27_X_37'\n                                 ]])),\n      dict(\n          testcase_name='ThreeInputs_RaggedInt_SparseInt_DenseInt',\n          inputs=[\n              ragged_const([[11], [12, 13], [], [14, 15]]),\n              sparse_const([[21, 22], [23], [24, 25], [26, 27]]),\n              dense_const([[31], [32], [33], [34]])\n          ],\n          expected=ragged_const([[b'11_X_21_X_31', b'11_X_22_X_31'],\n                                 [\n                                     b'12_X_23_X_32',\n                                     b'13_X_23_X_32',\n                                 ], [],\n                                 [\n                                     b'14_X_26_X_34',\n                                     b'14_X_27_X_34',\n                                     b'15_X_26_X_34',\n                                     b'15_X_27_X_34',\n                                 ]])),\n      dict(\n          testcase_name='FiveInputs',\n          inputs=[\n              ragged_const([[1]]),\n              dense_const([[2]]),\n              ragged_const([[3]]),\n              sparse_const([[4]]),\n              ragged_const([[5]])\n          ],\n          expected=ragged_const([[b'1_X_2_X_3_X_4_X_5']]),\n          matches_sparse_cross=False  # sparse doesn't preserve input order.\n      ),\n      dict(\n          testcase_name='Permutation_3x3x3',\n          inputs=[[['11', '12', '13']], [['21', '22', '23']],\n                  [['31', '32', '33']]],\n          expected=[[\n              b'11_X_21_X_31', b'11_X_21_X_32', b'11_X_21_X_33',\n              b'11_X_22_X_31', b'11_X_22_X_32', b'11_X_22_X_33',\n              b'11_X_23_X_31', b'11_X_23_X_32', b'11_X_23_X_33',\n              b'12_X_21_X_31', b'12_X_21_X_32', b'12_X_21_X_33',\n              b'12_X_22_X_31', b'12_X_22_X_32', b'12_X_22_X_33',\n              b'12_X_23_X_31', b'12_X_23_X_32', b'12_X_23_X_33',\n              b'13_X_21_X_31', b'13_X_21_X_32', b'13_X_21_X_33',\n              b'13_X_22_X_31', b'13_X_22_X_32', b'13_X_22_X_33',\n              b'13_X_23_X_31', b'13_X_23_X_32', b'13_X_23_X_33'\n          ]]),\n      dict(\n          testcase_name='BatchSizeZero',\n          inputs=[\n              ragged_const([], ragged_rank=1, dtype=dtypes.int32),\n              sparse_const([]),\n              np.zeros([0, 3], dtype=np.int32),\n          ],\n          expected=ragged_const([], ragged_rank=1, dtype=dtypes.int32)),\n      dict(\n          testcase_name='ThreeInputs_OneEmpty',\n          inputs=[\n              ragged_const([[1, 2]]),\n              ragged_const([[]], dtype=dtypes.int32),\n              ragged_const([[3, 4]])\n          ],\n          expected=ragged_const([[]], dtype=dtypes.string)),\n      dict(\n          testcase_name='ThreeInputs_AllEmpty',\n          inputs=[\n              ragged_const([[]], dtype=dtypes.int64),\n              ragged_const([[]], dtype=dtypes.string),\n              ragged_const([[]], dtype=dtypes.int32)\n          ],\n          expected=ragged_const([[]], ragged_rank=1, dtype=dtypes.string)),\n      dict(\n          testcase_name='HashedZeroBucketsDefaultKey',\n          inputs=[\n              ragged_const([['batch1-FC1-F1']]),\n              ragged_const([['batch1-FC2-F1']]),\n              ragged_const([['batch1-FC3-F1']])\n          ],\n          expected_hashed=ragged_const([[1971693436396284976]])),\n      dict(\n          testcase_name='Hashed100BucketsDefaultKey',\n          inputs=[\n              ragged_const([['batch1-FC1-F1']]),\n              ragged_const([['batch1-FC2-F1']]),\n              ragged_const([['batch1-FC3-F1']])\n          ],\n          num_buckets=100,\n          expected_hashed=ragged_const([[83]])),\n      dict(\n          testcase_name='HashedZeroBucketsCustomKey',\n          inputs=[\n              ragged_const([['batch1-FC1-F1']]),\n              ragged_const([['batch1-FC2-F1']]),\n              ragged_const([['batch1-FC3-F1']])\n          ],\n          hash_key=ragged_array_ops._DEFAULT_CROSS_HASH_KEY + 1,\n          expected_hashed=ragged_const([[4847552627144134031]])),\n      dict(\n          testcase_name='Hashed100BucketsCustomKey',\n          inputs=[\n              ragged_const([['batch1-FC1-F1']]),\n              ragged_const([['batch1-FC2-F1']]),\n              ragged_const([['batch1-FC3-F1']])\n          ],\n          num_buckets=100,\n          hash_key=ragged_array_ops._DEFAULT_CROSS_HASH_KEY + 1,\n          expected_hashed=ragged_const([[31]])),\n      dict(\n          testcase_name='HashedZeroKey',\n          inputs=[\n              ragged_const([['batch1-FC1-F1']]),\n              ragged_const([['batch1-FC2-F1']]),\n              ragged_const([['batch1-FC3-F1']])\n          ],\n          hash_key=0,\n          expected_hashed=ragged_const([[9077905385164735582]]),\n          matches_sparse_cross=False  # sparse treats hash_key=0 as None.\n      ),\n      dict(\n          testcase_name='UInt64',\n          inputs=[ragged_const([[2**64 - 1]], dtype=dtypes.uint64)],\n          expected=ragged_const([[b'-1']])),\n  ])\n  def testRaggedCross(self,\n                      inputs,\n                      num_buckets=0,\n                      hash_key=None,\n                      expected=None,\n                      expected_hashed=None,\n                      matches_sparse_cross=True):\n    ragged_cross = ragged_array_ops.cross(inputs)\n    ragged_cross_hashed = ragged_array_ops.cross_hashed(inputs, num_buckets,\n                                                        hash_key)\n\n    if expected is not None:\n      self.assertAllEqual(ragged_cross, expected)\n    if expected_hashed is not None:\n      self.assertAllEqual(ragged_cross_hashed, expected_hashed)\n\n    if matches_sparse_cross:\n      # Check that ragged.cross & sparse.cross match.\n      sparse_inputs = [self._ragged_to_sparse(t) for t in inputs]\n      sparse_cross = sparse_ops.sparse_cross(sparse_inputs)\n      self.assertAllEqual(ragged_cross,\n                          ragged_tensor.RaggedTensor.from_sparse(sparse_cross))\n\n      # Check that ragged.cross_hashed & sparse.cross_hashed match.\n      sparse_inputs = [self._ragged_to_sparse(t) for t in inputs]\n      sparse_cross_hashed = sparse_ops.sparse_cross_hashed(\n          sparse_inputs, num_buckets, hash_key)\n      self.assertAllEqual(\n          ragged_cross_hashed,\n          ragged_tensor.RaggedTensor.from_sparse(sparse_cross_hashed))\n\n  def testRaggedCrossLargeBatch(self):\n    batch_size = 5000\n    inputs = [\n        ragged_const([[1, 2, 3]] * batch_size),\n        ragged_const([[b'4']] * batch_size),\n        dense_const([[5]] * batch_size),\n        sparse_const([[6, 7]] * batch_size)\n    ]\n\n    expected = [[\n        b'1_X_4_X_5_X_6', b'1_X_4_X_5_X_7', b'2_X_4_X_5_X_6', b'2_X_4_X_5_X_7',\n        b'3_X_4_X_5_X_6', b'3_X_4_X_5_X_7'\n    ]] * batch_size\n\n    ragged_cross = ragged_array_ops.cross(inputs)\n\n    # Note: we don't use assertAllEqual here because if they don't match,\n    # then the code in assertAllEqual that tries to build the error message\n    # is very slow, causing the test to timeout.\n    # pylint: disable=g-generic-assert\n    self.assertTrue(self.evaluate(ragged_cross).to_list() == expected)\n\n  @parameterized.named_parameters([\n      dict(\n          testcase_name='BadDType',\n          inputs=[ragged_const([[1.1], [2.2, 3.3]])],\n          message=r'Unexpected dtype for inputs\\[0\\]'),\n      dict(\n          testcase_name='StaticBatchSizeMismatch1',\n          inputs=[ragged_const([[1]]),\n                  ragged_const([[2], [3]])],\n          exception=(ValueError, errors.InvalidArgumentError),\n          message='inputs must all have the same batch dimension size'),\n      dict(\n          testcase_name='StaticBatchSizeMismatch2',\n          inputs=[ragged_const([[1]]),\n                  dense_const([[2], [3]])],\n          exception=(ValueError, errors.InvalidArgumentError),\n          message='inputs must all have the same batch dimension size'),\n  ])\n  def testStaticError(self, inputs, exception=ValueError, message=None):\n    with self.assertRaisesRegex(exception, message):\n      ragged_array_ops.cross(inputs)\n\n  @parameterized.named_parameters([\n      dict(\n          testcase_name='3DRaggedTensor',\n          inputs=[ragged_const([[[1]]], ragged_rank=1)],\n          message='tf.ragged.cross only supports inputs with rank=2'),\n      dict(\n          testcase_name='3DDenseTensor',\n          inputs=[dense_const([[[1]]])],\n          message='tf.ragged.cross only supports inputs with rank=2'),\n  ])\n  def testRuntimeError(self,\n                       inputs,\n                       exception=errors.InvalidArgumentError,\n                       message=None):\n    with self.assertRaisesRegex(exception, message):\n      self.evaluate(ragged_array_ops.cross(inputs))\n\n  def _ragged_to_sparse(self, t):\n    if ragged_tensor.is_ragged(t):\n      return ragged_tensor.convert_to_tensor_or_ragged_tensor(t).to_sparse()\n    elif sparse_tensor.is_sparse(t):\n      return sparse_tensor.SparseTensor.from_value(t)\n    else:\n      return ops.convert_to_tensor(t)\n\n\nif __name__ == '__main__':\n  googletest.main()"