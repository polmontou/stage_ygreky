"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/platform/errors.h\"\n\nnamespace tensorflow {\n\nusing shape_inference::DimensionHandle;\nusing shape_inference::InferenceContext;\nusing shape_inference::ShapeHandle;\n\nnamespace {\n\nStatus SparseSparseMinOrMaxShapeFn(InferenceContext* c) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));  // a_indices\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));  // a_values\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));  // a_shape\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(3), 2, &unused));  // b_indices\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(4), 1, &unused));  // b_values\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(5), 1, &unused));  // b_shape\n  c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                             InferenceContext::kUnknownDim));\n  c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n  return Status::OK();\n}\n\n}  // namespace\n\nREGISTER_OP(\"SparseAddGrad\")\n    .Input(\"backprop_val_grad: T\")\n    .Input(\"a_indices: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"sum_indices: int64\")\n    .Output(\"a_val_grad: T\")\n    .Output(\"b_val_grad: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle a_indices;\n      ShapeHandle b_indices;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 2, &a_indices));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 2, &b_indices));\n      c->set_output(0, c->Vector(c->Dim(a_indices, 0)));\n      c->set_output(1, c->Vector(c->Dim(b_indices, 0)));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseAdd\")\n    .Input(\"a_indices: int64\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"b_values: T\")\n    .Input(\"b_shape: int64\")\n    .Input(\"thresh: Treal\")\n    .Output(\"sum_indices: int64\")\n    .Output(\"sum_values: T\")\n    .Output(\"sum_shape: int64\")\n    .Attr(\"T: numbertype\")\n    .Attr(\"Treal: realnumbertype\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle a_shape;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &a_shape));\n      c->set_output(\n          0, c->Matrix(InferenceContext::kUnknownDim, c->Dim(a_shape, 0)));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, a_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseTensorDenseMatMul\")\n    .Input(\"a_indices: Tindices\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b: T\")\n    .Output(\"product: T\")\n    .Attr(\"T: type\")\n    .Attr(\"Tindices: {int32,int64} = DT_INT64\")\n    .Attr(\"adjoint_a: bool = false\")\n    .Attr(\"adjoint_b: bool = false\")\n    .SetShapeFn([](InferenceContext* c) {\n      DimensionHandle unused_dim;\n      ShapeHandle unused;\n      ShapeHandle b;\n      ShapeHandle a_shape;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));  // a_indices\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));  // a_values\n      TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensor(2, &a_shape));\n      TF_RETURN_IF_ERROR(c->WithRank(a_shape, 2, &a_shape));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(3), 2, &b));\n\n      bool adjoint_a;\n      bool adjoint_b;\n      TF_RETURN_IF_ERROR(c->GetAttr(\"adjoint_a\", &adjoint_a));\n      TF_RETURN_IF_ERROR(c->GetAttr(\"adjoint_b\", &adjoint_b));\n\n      DimensionHandle output_right = c->Dim(b, adjoint_b ? 0 : 1);\n      DimensionHandle output_left = c->Dim(a_shape, adjoint_a ? 1 : 0);\n      DimensionHandle inner_left = c->Dim(a_shape, adjoint_a ? 0 : 1);\n      DimensionHandle inner_right = c->Dim(b, adjoint_b ? 1 : 0);\n      TF_RETURN_IF_ERROR(c->Merge(inner_left, inner_right, &unused_dim));\n      c->set_output(0, c->Matrix(output_left, output_right));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SerializeSparse\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Attr(\"T: type\")\n    .Output(\"serialized_sparse: out_type\")\n    .Attr(\"out_type: {string, variant} = DT_STRING\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Vector(3));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SerializeManySparse\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Attr(\"T: type\")\n    .Output(\"serialized_sparse: out_type\")\n    .Attr(\"out_type: {string, variant} = DT_STRING\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim, 3));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"DeserializeSparse\")\n    .Input(\"serialized_sparse: Tserialized\")\n    .Output(\"sparse_indices: int64\")\n    .Output(\"sparse_values: dtype\")\n    .Output(\"sparse_shape: int64\")\n    .Attr(\"dtype: type\")\n    .Attr(\"Tserialized: {string, variant} = DT_STRING\")\n    .SetShapeFn([](InferenceContext* c) {\n      // serialized sparse is [?, ..., ?, 3] vector.\n      ShapeHandle unused_shape;\n      TF_RETURN_IF_ERROR(c->WithRankAtLeast(c->input(0), 1, &unused_shape));\n      DimensionHandle unused;\n      TF_RETURN_IF_ERROR(c->WithValue(c->Dim(c->input(0), -1), 3, &unused));\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                                 InferenceContext::kUnknownDim));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"DeserializeManySparse\")\n    .Input(\"serialized_sparse: string\")\n    .Output(\"sparse_indices: int64\")\n    .Output(\"sparse_values: dtype\")\n    .Output(\"sparse_shape: int64\")\n    .Attr(\"dtype: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      // serialized sparse is [?,3] matrix.\n      ShapeHandle serialized_sparse;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &serialized_sparse));\n      DimensionHandle unused;\n      TF_RETURN_IF_ERROR(\n          c->WithValue(c->Dim(serialized_sparse, 1), 3, &unused));\n\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                                 InferenceContext::kUnknownDim));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseToDense\")\n    .Input(\"sparse_indices: Tindices\")\n    .Input(\"output_shape: Tindices\")\n    .Input(\"sparse_values: T\")\n    .Input(\"default_value: T\")\n    .Attr(\"validate_indices: bool = true\")\n    .Attr(\"T: type\")\n    .Output(\"dense: T\")\n    .Attr(\"Tindices: {int32, int64}\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle out;\n      TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensor(1, &out));\n      c->set_output(0, out);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseConcat\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: N * T\")\n    .Input(\"shapes: N * int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"concat_dim: int\")\n    .Attr(\"N: int >= 2\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      // These accumulates the sum.\n      DimensionHandle output_row_count = c->MakeDim(0ll);\n\n      // These are only merged.\n      DimensionHandle output_ind_cols = c->UnknownDim();\n      ShapeHandle output_shape = c->UnknownShape();\n\n      const int n = c->num_inputs() / 3;\n      for (int i = 0; i < n; i++) {\n        ShapeHandle ind;\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i), 2, &ind));\n        ShapeHandle val;\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i + n), 1, &val));\n        ShapeHandle shape;\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i + 2 * n), 1, &shape));\n\n        // Add to output_ind_rows.\n        DimensionHandle num_dim;\n        TF_RETURN_IF_ERROR(c->Merge(c->Dim(ind, 0), c->Dim(val, 0), &num_dim));\n        TF_RETURN_IF_ERROR(\n            c->Add(output_row_count, num_dim, &output_row_count));\n\n        // Merge into output_ind_cols and output_shape.\n        TF_RETURN_IF_ERROR(\n            c->Merge(output_ind_cols, c->Dim(ind, 1), &output_ind_cols));\n        TF_RETURN_IF_ERROR(c->Merge(output_shape, shape, &output_shape));\n      }\n\n      c->set_output(0, c->Matrix(output_row_count, output_ind_cols));\n      c->set_output(1, c->Vector(output_row_count));\n      c->set_output(2, output_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseCross\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: sparse_types\")\n    .Input(\"shapes: N * int64\")\n    .Input(\"dense_inputs: dense_types\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: out_type\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"N: int >= 0\")\n    .Attr(\"hashed_output: bool\")\n    .Attr(\"num_buckets: int >= 0\")\n    .Attr(\"hash_key: int\")\n    .Attr(\"sparse_types: list({int64, string}) >= 0\")\n    .Attr(\"dense_types: list({int64, string}) >= 0\")\n    .Attr(\"out_type: {int64, string}\")\n    .Attr(\"internal_type: {int64, string}\")\n    .SetShapeFn([](shape_inference::InferenceContext* c) {\n      c->set_output(0, c->Matrix(c->UnknownDim(), 2));\n      c->set_output(1, c->Vector(c->UnknownDim()));\n      c->set_output(2, c->Vector(2));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseCrossV2\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: sparse_types\")\n    .Input(\"shapes: N * int64\")\n    .Input(\"dense_inputs: dense_types\")\n    .Input(\"sep: string\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: string\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"N: int >= 0\")\n    .Attr(\"sparse_types: list({int64, string}) >= 0\")\n    .Attr(\"dense_types: list({int64, string}) >= 0\")\n    .SetShapeFn([](shape_inference::InferenceContext* c) {\n      c->set_output(0, c->Matrix(c->UnknownDim(), 2));\n      c->set_output(1, c->Vector(c->UnknownDim()));\n      c->set_output(2, c->Vector(2));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseCrossHashed\")\n    .Input(\"indices: N * int64\")\n    .Input(\"values: sparse_types\")\n    .Input(\"shapes: N * int64\")\n    .Input(\"dense_inputs: dense_types\")\n    .Input(\"num_buckets: int64\")\n    .Input(\"strong_hash: bool\")\n    .Input(\"salt: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: int64\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"N: int >= 0\")\n    .Attr(\"sparse_types: list({int64, string}) >= 0\")\n    .Attr(\"dense_types: list({int64, string}) >= 0\")\n    .SetShapeFn([](shape_inference::InferenceContext* c) {\n      c->set_output(0, c->Matrix(c->UnknownDim(), 2));\n      c->set_output(1, c->Vector(c->UnknownDim()));\n      c->set_output(2, c->Vector(2));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSplit\")\n    .Input(\"split_dim: int64\")\n    .Input(\"indices: int64\")\n    .Input(\"values: T\")\n    .Input(\"shape: int64\")\n    .Output(\"output_indices: num_split * int64\")\n    .Output(\"output_values:  num_split * T\")\n    .Output(\"output_shape:   num_split * int64\")\n    .Attr(\"num_split: int >= 1\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle input_shape = c->input(3);\n      ShapeHandle output_indices =\n          c->Matrix(InferenceContext::kUnknownDim, c->NumElements(input_shape));\n      ShapeHandle output_values = c->Vector(InferenceContext::kUnknownDim);\n      ShapeHandle output_shape = input_shape;\n\n      // Copy the outputs into the output ranges.\n      int num_splits = c->num_outputs() / 3;\n      int out_idx = 0;\n      for (int i = 0; i < num_splits; ++i)\n        c->set_output(out_idx++, output_indices);\n      for (int i = 0; i < num_splits; ++i)\n        c->set_output(out_idx++, output_values);\n      for (int i = 0; i < num_splits; ++i)\n        c->set_output(out_idx++, output_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSliceGrad\")\n    .Input(\"backprop_val_grad: T\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_start: int64\")\n    .Input(\"output_indices: int64\")\n    .Output(\"val_grad: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle indices;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 2, &indices));\n      c->set_output(0, c->Vector(c->Dim(indices, 0)));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSlice\")\n    .Input(\"indices: int64\")\n    .Input(\"values: T\")\n    .Input(\"shape: int64\")\n    .Input(\"start: int64\")\n    .Input(\"size: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle input_shape = c->input(2);\n      ShapeHandle output_indices =\n          c->Matrix(InferenceContext::kUnknownDim, c->NumElements(input_shape));\n      ShapeHandle output_values = c->Vector(InferenceContext::kUnknownDim);\n      ShapeHandle output_shape = input_shape;\n\n      c->set_output(0, output_indices);\n      c->set_output(1, output_values);\n      c->set_output(2, output_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseReorder\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle indices;\n      ShapeHandle values;\n      ShapeHandle unused;\n\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &indices));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &values));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n\n      c->set_output(0, indices);\n      c->set_output(1, values);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseReshape\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_shape: int64\")\n    .Input(\"new_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_shape: int64\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle indices;\n      ShapeHandle unused;\n      ShapeHandle new_shape;\n\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &indices));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &new_shape));\n\n      c->set_output(0, c->Matrix(c->Dim(indices, 0), c->Dim(new_shape, 0)));\n      c->set_output(1, new_shape);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseTensorDenseAdd\")\n    .Input(\"a_indices: Tindices\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: Tindices\")\n    .Input(\"b: T\")\n    .Output(\"output: T\")\n    .Attr(\"T: numbertype\")\n    .Attr(\"Tindices: {int32, int64}\")\n    .SetShapeFn([](InferenceContext* c) {\n      c->set_output(0, c->input(3));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseReduceMax\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output: T\")\n    .Attr(\"T: realnumbertype\")\n    .SetShapeFn(shape_inference::SparseReduceShapeFn);\n\nREGISTER_OP(\"SparseReduceMaxSparse\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"T: realnumbertype\")\n    .SetShapeFn(shape_inference::UnknownShape);\n\nREGISTER_OP(\"SparseReduceSum\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn(shape_inference::SparseReduceShapeFn);\n\nREGISTER_OP(\"SparseReduceSumSparse\")\n    .Input(\"input_indices: int64\")\n    .Input(\"input_values: T\")\n    .Input(\"input_shape: int64\")\n    .Input(\"reduction_axes: int32\")\n    .Attr(\"keep_dims: bool = False\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"output_shape: int64\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn(shape_inference::UnknownShape);\n\n#define SPARSE_DENSE_CWISE_SIGNATURE()                           \\\n  Input(\"sp_indices: int64\")                                     \\\n      .Input(\"sp_values: T\")                                     \\\n      .Input(\"sp_shape: int64\")                                  \\\n      .Input(\"dense: T\")                                         \\\n      .Output(\"output: T\")                                       \\\n      .Attr(\"T: numbertype\")                                     \\\n      .SetShapeFn([](InferenceContext* c) {                      \\\n        ShapeHandle input;                                       \\\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input)); \\\n        c->set_output(0, c->Vector(c->Dim(input, 0)));           \\\n        return Status::OK();                                     \\\n      })\n\nREGISTER_OP(\"SparseDenseCwiseMul\").SPARSE_DENSE_CWISE_SIGNATURE();\n\nREGISTER_OP(\"SparseDenseCwiseDiv\").SPARSE_DENSE_CWISE_SIGNATURE();\n\nREGISTER_OP(\"SparseDenseCwiseAdd\").SPARSE_DENSE_CWISE_SIGNATURE();\n\n#undef SPARSE_DENSE_CWISE_SIGNATURE\n\nREGISTER_OP(\"SparseSoftmax\")\n    .Input(\"sp_indices: int64\")\n    .Input(\"sp_values: T\")\n    .Input(\"sp_shape: int64\")\n    .Output(\"output: T\")\n    .Attr(\"T: {float, double}\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      ShapeHandle values;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));  // sp_indices\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &values));  // sp_values\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, values);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseSparseMaximum\")\n    .Input(\"a_indices: int64\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"b_values: T\")\n    .Input(\"b_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Attr(\"T: realnumbertype\")\n    .SetShapeFn(SparseSparseMinOrMaxShapeFn);\n\nREGISTER_OP(\"SparseSparseMinimum\")\n    .Input(\"a_indices: int64\")\n    .Input(\"a_values: T\")\n    .Input(\"a_shape: int64\")\n    .Input(\"b_indices: int64\")\n    .Input(\"b_values: T\")\n    .Input(\"b_shape: int64\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Attr(\"T: numbertype\")\n    .SetShapeFn(SparseSparseMinOrMaxShapeFn);\n\nREGISTER_OP(\"AddSparseToTensorsMap\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Output(\"sparse_handle: int64\")\n    .Attr(\"T: type\")\n    .Attr(\"container: string = ''\")\n    .Attr(\"shared_name: string = ''\")\n    .SetIsStateful()\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Scalar());\n      return Status::OK();\n    });\n\nREGISTER_OP(\"AddManySparseToTensorsMap\")\n    .Input(\"sparse_indices: int64\")\n    .Input(\"sparse_values: T\")\n    .Input(\"sparse_shape: int64\")\n    .Output(\"sparse_handles: int64\")\n    .Attr(\"T: type\")\n    .Attr(\"container: string = ''\")\n    .Attr(\"shared_name: string = ''\")\n    .SetIsStateful()\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle unused;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 1, &unused));\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(2), 1, &unused));\n      c->set_output(0, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"TakeManySparseFromTensorsMap\")\n    .Input(\"sparse_handles: int64\")\n    .Output(\"sparse_indices: int64\")\n    .Output(\"sparse_values: dtype\")\n    .Output(\"sparse_shape: int64\")\n    .Attr(\"dtype: type\")\n    .Attr(\"container: string = ''\")\n    .Attr(\"shared_name: string = ''\")\n    .SetIsStateful()\n    .SetShapeFn([](InferenceContext* c) {\n      // serialized sparse is [?,1] matrix.\n      ShapeHandle sparse_handles;\n      TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 1, &sparse_handles));\n\n      c->set_output(0, c->Matrix(InferenceContext::kUnknownDim,\n                                 InferenceContext::kUnknownDim));\n      c->set_output(1, c->Vector(InferenceContext::kUnknownDim));\n      c->set_output(2, c->Vector(InferenceContext::kUnknownDim));\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseFillEmptyRows\")\n    .Input(\"indices: int64\")\n    .Input(\"values: T\")\n    .Input(\"dense_shape: int64\")\n    .Input(\"default_value: T\")\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: T\")\n    .Output(\"empty_row_indicator: bool\")\n    .Output(\"reverse_index_map: int64\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle input_indices = c->input(0);\n      TF_RETURN_IF_ERROR(c->WithRank(input_indices, 2, &input_indices));\n      ShapeHandle input_values = c->input(1);\n      TF_RETURN_IF_ERROR(c->WithRank(input_values, 1, &input_values));\n      ShapeHandle input_shape = c->input(2);\n      TF_RETURN_IF_ERROR(c->WithRank(input_shape, 1, &input_shape));\n      ShapeHandle default_value = c->input(3);\n      TF_RETURN_IF_ERROR(c->WithRank(default_value, 0, &default_value));\n      DimensionHandle N = c->Dim(input_indices, 0);\n      TF_RETURN_IF_ERROR(c->Merge(N, c->Dim(input_values, 0), &N));\n      DimensionHandle unused_dim;\n      TF_RETURN_IF_ERROR(c->Merge(c->Dim(input_indices, 1),\n                                  c->Dim(input_shape, 0), &unused_dim));\n      if (c->Value(c->NumElements(input_shape)) == 0)\n        return errors::InvalidArgument(\"dense_shape must not be empty\");\n      ShapeHandle output_indices =\n          c->Matrix(InferenceContext::kUnknownDim, c->NumElements(input_shape));\n      ShapeHandle output_values = c->Vector(InferenceContext::kUnknownDim);\n      ShapeHandle constant_input_shape;\n      TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensor(2, &constant_input_shape));\n      ShapeHandle empty_row_indicator =\n          c->Vector(c->Dim(constant_input_shape, 0));\n      ShapeHandle reverse_index_map = c->Vector(N);\n      c->set_output(0, output_indices);\n      c->set_output(1, output_values);\n      c->set_output(2, empty_row_indicator);\n      c->set_output(3, reverse_index_map);\n      return Status::OK();\n    });\n\nREGISTER_OP(\"SparseFillEmptyRowsGrad\")\n    .Input(\"reverse_index_map: int64\")\n    .Input(\"grad_values: T\")\n    .Output(\"d_values: T\")\n    .Output(\"d_default_value: T\")\n    .Attr(\"T: type\")\n    .SetShapeFn([](InferenceContext* c) {\n      ShapeHandle reverse_index_map = c->input(0);\n      TF_RETURN_IF_ERROR(c->WithRank(reverse_index_map, 1, &reverse_index_map));\n      ShapeHandle grad_values = c->input(1);\n      TF_RETURN_IF_ERROR(c->WithRank(grad_values, 1, &grad_values));\n      c->set_output(0, reverse_index_map);\n      c->set_output(1, c->Scalar());\n      return Status::OK();\n    });\n\n}  // namespace tensorflow"