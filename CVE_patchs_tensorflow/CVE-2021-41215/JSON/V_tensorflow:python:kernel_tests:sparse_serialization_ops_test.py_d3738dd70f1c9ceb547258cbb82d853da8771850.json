"# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for SerializeSparse.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import sparse_tensor as sparse_tensor_lib\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import test\n\n\nclass SerializeSparseTest(test.TestCase):\n\n  def _SparseTensorPlaceholder(self, dtype=None):\n    if dtype is None:\n      dtype = dtypes.int32\n    return sparse_tensor_lib.SparseTensor(\n        array_ops.placeholder(dtypes.int64),\n        array_ops.placeholder(dtype), array_ops.placeholder(dtypes.int64))\n\n  def _SparseTensorValue_5x6(self, permutation):\n    ind = np.array([[0, 0], [1, 0], [1, 3], [1, 4], [3, 2],\n                    [3, 3]]).astype(np.int64)\n    val = np.array([0, 10, 13, 14, 32, 33]).astype(np.int32)\n\n    ind = ind[permutation]\n    val = val[permutation]\n\n    shape = np.array([5, 6]).astype(np.int64)\n    return sparse_tensor_lib.SparseTensorValue(ind, val, shape)\n\n  def _SparseTensorValue_3x4(self, permutation):\n    ind = np.array([[0, 0], [1, 0], [1, 2], [1, 3], [2, 2],\n                    [2, 3]]).astype(np.int64)\n    val = np.array([0, 10, 13, 14, 32, 33]).astype(np.int32)\n\n    ind = ind[permutation]\n    val = val[permutation]\n\n    shape = np.array([3, 4]).astype(np.int64)\n    return sparse_tensor_lib.SparseTensorValue(ind, val, shape)\n\n  def _SparseTensorValue_1x1x1(self):\n    ind = np.array([[0, 0, 0]]).astype(np.int64)\n    val = np.array([0]).astype(np.int32)\n    shape = np.array([3, 4, 5]).astype(np.int64)\n    return sparse_tensor_lib.SparseTensorValue(ind, val, shape)\n\n  def _testSerializeDeserializeHelper(self,\n                                      serialize_fn,\n                                      deserialize_fn,\n                                      out_type=dtypes.string):\n    with self.cached_session(use_gpu=False) as sess:\n      sp_input = self._SparseTensorValue_5x6(np.arange(6))\n      serialized = serialize_fn(sp_input, out_type=out_type)\n      sp_deserialized = deserialize_fn(serialized, dtype=dtypes.int32)\n\n      indices, values, shape = self.evaluate(sp_deserialized)\n\n      self.assertAllEqual(indices, sp_input[0])\n      self.assertAllEqual(values, sp_input[1])\n      self.assertAllEqual(shape, sp_input[2])\n\n  def testSerializeDeserialize(self):\n    self._testSerializeDeserializeHelper(sparse_ops.serialize_sparse,\n                                         sparse_ops.deserialize_sparse)\n\n  def testVariantSerializeDeserialize(self):\n    self._testSerializeDeserializeHelper(sparse_ops.serialize_sparse,\n                                         sparse_ops.deserialize_sparse,\n                                         dtypes.variant)\n\n  def _testSerializeDeserializeBatchHelper(self,\n                                           serialize_fn,\n                                           deserialize_fn,\n                                           out_type=dtypes.string):\n    with self.cached_session(use_gpu=False) as sess:\n      sp_input = self._SparseTensorValue_5x6(np.arange(6))\n      serialized = serialize_fn(sp_input, out_type=out_type)\n      serialized = array_ops.stack([serialized, serialized])\n\n      sp_deserialized = deserialize_fn(serialized, dtype=dtypes.int32)\n\n      combined_indices, combined_values, combined_shape = sess.run(\n          sp_deserialized)\n\n      self.assertAllEqual(combined_indices[:6, 0], [0] * 6)  # minibatch 0\n      self.assertAllEqual(combined_indices[:6, 1:], sp_input[0])\n      self.assertAllEqual(combined_indices[6:, 0], [1] * 6)  # minibatch 1\n      self.assertAllEqual(combined_indices[6:, 1:], sp_input[0])\n      self.assertAllEqual(combined_values[:6], sp_input[1])\n      self.assertAllEqual(combined_values[6:], sp_input[1])\n      self.assertAllEqual(combined_shape, [2, 5, 6])\n\n  @test_util.run_deprecated_v1\n  def testSerializeDeserializeBatch(self):\n    self._testSerializeDeserializeBatchHelper(sparse_ops.serialize_sparse,\n                                              sparse_ops.deserialize_sparse)\n\n  @test_util.run_deprecated_v1\n  def testSerializeDeserializeManyBatch(self):\n    self._testSerializeDeserializeBatchHelper(\n        sparse_ops.serialize_sparse, sparse_ops.deserialize_many_sparse)\n\n  @test_util.run_deprecated_v1\n  def testVariantSerializeDeserializeBatch(self):\n    self._testSerializeDeserializeBatchHelper(sparse_ops.serialize_sparse,\n                                              sparse_ops.deserialize_sparse,\n                                              dtypes.variant)\n\n  def _testSerializeDeserializeBatchInconsistentShapeHelper(\n      self, serialize_fn, deserialize_fn, out_type=dtypes.string):\n    with self.cached_session(use_gpu=False) as sess:\n      sp_input0 = self._SparseTensorValue_5x6(np.arange(6))\n      sp_input1 = self._SparseTensorValue_3x4(np.arange(6))\n      serialized0 = serialize_fn(sp_input0, out_type=out_type)\n      serialized1 = serialize_fn(sp_input1, out_type=out_type)\n      serialized = array_ops.stack([serialized0, serialized1])\n\n      sp_deserialized = deserialize_fn(serialized, dtype=dtypes.int32)\n\n      combined_indices, combined_values, combined_shape = sess.run(\n          sp_deserialized)\n\n      self.assertAllEqual(combined_indices[:6, 0], [0] * 6)  # minibatch 0\n      self.assertAllEqual(combined_indices[:6, 1:], sp_input0[0])\n      self.assertAllEqual(combined_indices[6:, 0], [1] * 6)  # minibatch 1\n      self.assertAllEqual(combined_indices[6:, 1:], sp_input1[0])\n      self.assertAllEqual(combined_values[:6], sp_input0[1])\n      self.assertAllEqual(combined_values[6:], sp_input1[1])\n      self.assertAllEqual(combined_shape, [2, 5, 6])\n\n  @test_util.run_deprecated_v1\n  def testSerializeDeserializeBatchInconsistentShape(self):\n    self._testSerializeDeserializeBatchInconsistentShapeHelper(\n        sparse_ops.serialize_sparse, sparse_ops.deserialize_sparse)\n\n  @test_util.run_deprecated_v1\n  def testVariantSerializeDeserializeBatchInconsistentShape(self):\n    self._testSerializeDeserializeBatchInconsistentShapeHelper(\n        sparse_ops.serialize_sparse, sparse_ops.deserialize_sparse,\n        dtypes.variant)\n\n  def _testSerializeDeserializeNestedBatchHelper(self,\n                                                 serialize_fn,\n                                                 deserialize_fn,\n                                                 out_type=dtypes.string):\n    with self.cached_session(use_gpu=False) as sess:\n      sp_input = self._SparseTensorValue_5x6(np.arange(6))\n      serialized = serialize_fn(sp_input, out_type=out_type)\n      serialized = array_ops.stack([serialized, serialized])\n      serialized = array_ops.stack([serialized, serialized])\n\n      sp_deserialized = deserialize_fn(serialized, dtype=dtypes.int32)\n\n      combined_indices, combined_values, combined_shape = sess.run(\n          sp_deserialized)\n\n      # minibatch 0\n      self.assertAllEqual(combined_indices[:6, :2], [[0, 0]] * 6)\n      self.assertAllEqual(combined_indices[:6, 2:], sp_input[0])\n      self.assertAllEqual(combined_values[:6], sp_input[1])\n      # minibatch 1\n      self.assertAllEqual(combined_indices[6:12, :2], [[0, 1]] * 6)\n      self.assertAllEqual(combined_indices[6:12, 2:], sp_input[0])\n      self.assertAllEqual(combined_values[6:12], sp_input[1])\n      # minibatch 2\n      self.assertAllEqual(combined_indices[12:18, :2], [[1, 0]] * 6)\n      self.assertAllEqual(combined_indices[12:18, 2:], sp_input[0])\n      self.assertAllEqual(combined_values[12:18], sp_input[1])\n      # minibatch 3\n      self.assertAllEqual(combined_indices[18:, :2], [[1, 1]] * 6)\n      self.assertAllEqual(combined_indices[18:, 2:], sp_input[0])\n      self.assertAllEqual(combined_values[18:], sp_input[1])\n\n      self.assertAllEqual(combined_shape, [2, 2, 5, 6])\n\n  @test_util.run_deprecated_v1\n  def testSerializeDeserializeNestedBatch(self):\n    self._testSerializeDeserializeNestedBatchHelper(\n        sparse_ops.serialize_sparse, sparse_ops.deserialize_sparse)\n\n  @test_util.run_deprecated_v1\n  def testVariantSerializeDeserializeNestedBatch(self):\n    self._testSerializeDeserializeNestedBatchHelper(\n        sparse_ops.serialize_sparse, sparse_ops.deserialize_sparse,\n        dtypes.variant)\n\n  def _testFeedSerializeDeserializeBatchHelper(self,\n                                               serialize_fn,\n                                               deserialize_fn,\n                                               out_type=dtypes.string):\n    with self.cached_session(use_gpu=False) as sess:\n      sp_input0 = self._SparseTensorPlaceholder()\n      sp_input1 = self._SparseTensorPlaceholder()\n      input0_val = self._SparseTensorValue_5x6(np.arange(6))\n      input1_val = self._SparseTensorValue_3x4(np.arange(6))\n      serialized0 = serialize_fn(sp_input0, out_type=out_type)\n      serialized1 = serialize_fn(sp_input1, out_type=out_type)\n      serialized_concat = array_ops.stack([serialized0, serialized1])\n\n      sp_deserialized = deserialize_fn(serialized_concat, dtype=dtypes.int32)\n\n      combined_indices, combined_values, combined_shape = sess.run(\n          sp_deserialized, {sp_input0: input0_val,\n                            sp_input1: input1_val})\n\n      self.assertAllEqual(combined_indices[:6, 0], [0] * 6)  # minibatch 0\n      self.assertAllEqual(combined_indices[:6, 1:], input0_val[0])\n      self.assertAllEqual(combined_indices[6:, 0], [1] * 6)  # minibatch 1\n      self.assertAllEqual(combined_indices[6:, 1:], input1_val[0])\n      self.assertAllEqual(combined_values[:6], input0_val[1])\n      self.assertAllEqual(combined_values[6:], input1_val[1])\n      self.assertAllEqual(combined_shape, [2, 5, 6])\n\n  @test_util.run_deprecated_v1\n  def testFeedSerializeDeserializeBatch(self):\n    self._testFeedSerializeDeserializeBatchHelper(sparse_ops.serialize_sparse,\n                                                  sparse_ops.deserialize_sparse)\n\n  @test_util.run_deprecated_v1\n  def testFeedSerializeDeserializeManyBatch(self):\n    self._testFeedSerializeDeserializeBatchHelper(\n        sparse_ops.serialize_sparse, sparse_ops.deserialize_many_sparse)\n\n  @test_util.run_deprecated_v1\n  def testFeedVariantSerializeDeserializeBatch(self):\n    self._testFeedSerializeDeserializeBatchHelper(sparse_ops.serialize_sparse,\n                                                  sparse_ops.deserialize_sparse,\n                                                  dtypes.variant)\n\n  def _testSerializeManyShapeHelper(self,\n                                    serialize_many_fn,\n                                    out_type=dtypes.string):\n    with self.cached_session(use_gpu=False) as sess:\n      # N == 4 because shape_value == [4, 5]\n      indices_value = np.array([[0, 0], [0, 1], [2, 0]], dtype=np.int64)\n      values_value = np.array([b\"a\", b\"b\", b\"c\"])\n      shape_value = np.array([4, 5], dtype=np.int64)\n      sparse_tensor = self._SparseTensorPlaceholder(dtype=dtypes.string)\n      serialized = serialize_many_fn(sparse_tensor, out_type=out_type)\n      serialized_value = sess.run(\n          serialized,\n          feed_dict={\n              sparse_tensor.indices: indices_value,\n              sparse_tensor.values: values_value,\n              sparse_tensor.dense_shape: shape_value\n          })\n      self.assertEqual(serialized_value.shape, (4, 3))\n\n  @test_util.run_deprecated_v1\n  def testSerializeManyShape(self):\n    self._testSerializeManyShapeHelper(sparse_ops.serialize_many_sparse)\n\n  def testVariantSerializeManyShape(self):\n    # NOTE: The following test is a no-op as it is currently not possible to\n    # convert the serialized variant value to a numpy value.\n    pass\n\n  def _testSerializeManyDeserializeBatchHelper(self,\n                                               serialize_many_fn,\n                                               deserialize_fn,\n                                               out_type=dtypes.string):\n    with self.cached_session(use_gpu=False) as sess:\n      # N == 4 because shape_value == [4, 5]\n      indices_value = np.array([[0, 0], [0, 1], [2, 0]], dtype=np.int64)\n      values_value = np.array([b\"a\", b\"b\", b\"c\"])\n      shape_value = np.array([4, 5], dtype=np.int64)\n      sparse_tensor = self._SparseTensorPlaceholder(dtype=dtypes.string)\n      serialized = serialize_many_fn(sparse_tensor, out_type=out_type)\n      deserialized = deserialize_fn(serialized, dtype=dtypes.string)\n      deserialized_value = sess.run(\n          deserialized,\n          feed_dict={\n              sparse_tensor.indices: indices_value,\n              sparse_tensor.values: values_value,\n              sparse_tensor.dense_shape: shape_value\n          })\n      self.assertAllEqual(deserialized_value.indices, indices_value)\n      self.assertAllEqual(deserialized_value.values, values_value)\n      self.assertAllEqual(deserialized_value.dense_shape, shape_value)\n\n  @test_util.run_deprecated_v1\n  def testSerializeManyDeserializeBatch(self):\n    self._testSerializeManyDeserializeBatchHelper(\n        sparse_ops.serialize_many_sparse, sparse_ops.deserialize_sparse)\n\n  @test_util.run_deprecated_v1\n  def testSerializeManyDeserializeManyBatch(self):\n    self._testSerializeManyDeserializeBatchHelper(\n        sparse_ops.serialize_many_sparse, sparse_ops.deserialize_many_sparse)\n\n  @test_util.run_deprecated_v1\n  def testVariantSerializeManyDeserializeBatch(self):\n    self._testSerializeManyDeserializeBatchHelper(\n        sparse_ops.serialize_many_sparse, sparse_ops.deserialize_sparse,\n        dtypes.variant)\n\n  @test_util.run_deprecated_v1\n  def testVariantSerializeDeserializeScalar(self):\n    with self.session(use_gpu=False) as sess:\n      indices_value = np.array([[]], dtype=np.int64)\n      values_value = np.array([37], dtype=np.int32)\n      shape_value = np.array([], dtype=np.int64)\n      sparse_tensor = self._SparseTensorPlaceholder()\n      serialized = sparse_ops.serialize_sparse(\n          sparse_tensor, out_type=dtypes.variant)\n      deserialized = sparse_ops.deserialize_sparse(\n          serialized, dtype=dtypes.int32)\n      deserialized_value = sess.run(\n          deserialized,\n          feed_dict={\n              sparse_tensor.indices: indices_value,\n              sparse_tensor.values: values_value,\n              sparse_tensor.dense_shape: shape_value\n          })\n      self.assertAllEqual(deserialized_value.indices, indices_value)\n      self.assertAllEqual(deserialized_value.values, values_value)\n      self.assertAllEqual(deserialized_value.dense_shape, shape_value)\n\n  @test_util.run_deprecated_v1\n  def testVariantSerializeDeserializeScalarBatch(self):\n    with self.session(use_gpu=False) as sess:\n      indices_value = np.array([[]], dtype=np.int64)\n      values_value = np.array([37], dtype=np.int32)\n      shape_value = np.array([], dtype=np.int64)\n      sparse_tensor = self._SparseTensorPlaceholder()\n      serialized = sparse_ops.serialize_sparse(\n          sparse_tensor, out_type=dtypes.variant)\n      stacked = array_ops.stack([serialized, serialized])\n      deserialized = sparse_ops.deserialize_sparse(stacked, dtype=dtypes.int32)\n      deserialized_value = sess.run(\n          deserialized,\n          feed_dict={\n              sparse_tensor.indices: indices_value,\n              sparse_tensor.values: values_value,\n              sparse_tensor.dense_shape: shape_value\n          })\n      self.assertAllEqual(deserialized_value.indices,\n                          np.array([[0], [1]], dtype=np.int64))\n      self.assertAllEqual(deserialized_value.values,\n                          np.array([37, 37], dtype=np.int32))\n      self.assertAllEqual(deserialized_value.dense_shape,\n                          np.array([2], dtype=np.int64))\n\n  def _testDeserializeFailsWrongTypeHelper(self,\n                                           serialize_fn,\n                                           deserialize_fn,\n                                           out_type=dtypes.string):\n    with self.cached_session(use_gpu=False) as sess:\n      sp_input0 = self._SparseTensorPlaceholder()\n      sp_input1 = self._SparseTensorPlaceholder()\n      input0_val = self._SparseTensorValue_5x6(np.arange(6))\n      input1_val = self._SparseTensorValue_3x4(np.arange(6))\n      serialized0 = serialize_fn(sp_input0, out_type=out_type)\n      serialized1 = serialize_fn(sp_input1, out_type=out_type)\n      serialized_concat = array_ops.stack([serialized0, serialized1])\n\n      sp_deserialized = deserialize_fn(serialized_concat, dtype=dtypes.int64)\n\n      with self.assertRaisesOpError(\n          r\"Requested SparseTensor of type int64 but \"\n          r\"SparseTensor\\[0\\].values.dtype\\(\\) == int32\"):\n        sess.run(sp_deserialized,\n                 {sp_input0: input0_val,\n                  sp_input1: input1_val})\n\n  @test_util.run_deprecated_v1\n  def testDeserializeFailsWrongType(self):\n    self._testDeserializeFailsWrongTypeHelper(sparse_ops.serialize_sparse,\n                                              sparse_ops.deserialize_sparse)\n\n  @test_util.run_deprecated_v1\n  def testDeserializeManyFailsWrongType(self):\n    self._testDeserializeFailsWrongTypeHelper(\n        sparse_ops.serialize_sparse, sparse_ops.deserialize_many_sparse)\n\n  @test_util.run_deprecated_v1\n  def testVariantDeserializeFailsWrongType(self):\n    self._testDeserializeFailsWrongTypeHelper(sparse_ops.serialize_sparse,\n                                              sparse_ops.deserialize_sparse,\n                                              dtypes.variant)\n\n  def _testDeserializeFailsInconsistentRankHelper(self,\n                                                  serialize_fn,\n                                                  deserialize_fn,\n                                                  out_type=dtypes.string):\n    with self.cached_session(use_gpu=False) as sess:\n      sp_input0 = self._SparseTensorPlaceholder()\n      sp_input1 = self._SparseTensorPlaceholder()\n      input0_val = self._SparseTensorValue_5x6(np.arange(6))\n      input1_val = self._SparseTensorValue_1x1x1()\n      serialized0 = serialize_fn(sp_input0, out_type=out_type)\n      serialized1 = serialize_fn(sp_input1, out_type=out_type)\n      serialized_concat = array_ops.stack([serialized0, serialized1])\n\n      sp_deserialized = deserialize_fn(serialized_concat, dtype=dtypes.int32)\n\n      with self.assertRaisesOpError(\n          r\"Inconsistent shape across SparseTensors: rank prior to \"\n          r\"SparseTensor\\[1\\] was: 2 but rank of SparseTensor\\[1\\] is: 3\"):\n        sess.run(sp_deserialized,\n                 {sp_input0: input0_val,\n                  sp_input1: input1_val})\n\n  @test_util.run_deprecated_v1\n  def testDeserializeFailsInconsistentRank(self):\n    self._testDeserializeFailsInconsistentRankHelper(\n        sparse_ops.serialize_sparse, sparse_ops.deserialize_sparse)\n\n  @test_util.run_deprecated_v1\n  def testDeserializeManyFailsInconsistentRank(self):\n    self._testDeserializeFailsInconsistentRankHelper(\n        sparse_ops.serialize_sparse, sparse_ops.deserialize_many_sparse)\n\n  @test_util.run_deprecated_v1\n  def testVariantDeserializeFailsInconsistentRank(self):\n    self._testDeserializeFailsInconsistentRankHelper(\n        sparse_ops.serialize_sparse, sparse_ops.deserialize_sparse,\n        dtypes.variant)\n\n  def _testDeserializeFailsInvalidProtoHelper(self,\n                                              serialize_fn,\n                                              deserialize_fn,\n                                              out_type=dtypes.string):\n    with self.cached_session(use_gpu=False) as sess:\n      sp_input0 = self._SparseTensorPlaceholder()\n      input0_val = self._SparseTensorValue_5x6(np.arange(6))\n      serialized0 = serialize_fn(sp_input0, out_type=out_type)\n      serialized1 = [\"a\", \"b\", \"c\"]\n      serialized_concat = array_ops.stack([serialized0, serialized1])\n\n      sp_deserialized = deserialize_fn(serialized_concat, dtype=dtypes.int32)\n\n      with self.assertRaisesOpError(r\"Could not parse serialized proto\"):\n        sess.run(sp_deserialized, {sp_input0: input0_val})\n\n  @test_util.run_deprecated_v1\n  def testDeserializeFailsInvalidProto(self):\n    self._testDeserializeFailsInvalidProtoHelper(sparse_ops.serialize_sparse,\n                                                 sparse_ops.deserialize_sparse)\n\n  @test_util.run_deprecated_v1\n  def testDeserializeManyFailsInvalidProto(self):\n    self._testDeserializeFailsInvalidProtoHelper(\n        sparse_ops.serialize_sparse, sparse_ops.deserialize_many_sparse)\n\n\nif __name__ == \"__main__\":\n  test.main()"