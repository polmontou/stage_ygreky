"/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_CORE_PLATFORM_CTSTRING_INTERNAL_H_\n#define TENSORFLOW_CORE_PLATFORM_CTSTRING_INTERNAL_H_\n\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && \\\n     __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) ||                  \\\n    defined(_WIN32)\n#define TF_TSTRING_LITTLE_ENDIAN 1\n#elif defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && \\\n    __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#define TF_TSTRING_LITTLE_ENDIAN 0\n#else\n#error \"Unable to detect endianness.\"\n#endif\n\n#if defined(__clang__) || \\\n    (defined(__GNUC__) && \\\n     ((__GNUC__ == 4 && __GNUC_MINOR__ >= 8) || __GNUC__ >= 5))\nstatic inline uint32_t TF_swap32(uint32_t host_int) {\n  return __builtin_bswap32(host_int);\n}\n\n#elif defined(_MSC_VER)\nstatic inline uint32_t TF_swap32(uint32_t host_int) {\n  return _byteswap_ulong(host_int);\n}\n\n#elif defined(__APPLE__)\nstatic inline uint32_t TF_swap32(uint32_t host_int) {\n  return OSSwapInt32(host_int);\n}\n\n#else\nstatic inline uint32_t TF_swap32(uint32_t host_int) {\n#if defined(__GLIBC__)\n  return bswap_32(host_int);\n#else   // defined(__GLIBC__)\n  return (((host_int & uint32_t{0xFF}) << 24) |\n          ((host_int & uint32_t{0xFF00}) << 8) |\n          ((host_int & uint32_t{0xFF0000}) >> 8) |\n          ((host_int & uint32_t{0xFF000000}) >> 24));\n#endif  // defined(__GLIBC__)\n}\n#endif\n\n#if TF_TSTRING_LITTLE_ENDIAN\n#define TF_le32toh(x) x\n#else  // TF_TSTRING_LITTLE_ENDIAN\n#define TF_le32toh(x) TF_swap32(x)\n#endif  // TF_TSTRING_LITTLE_ENDIAN\n\nstatic inline size_t TF_align16(size_t i) { return (i + 0xF) & ~0xF; }\n\nstatic inline size_t TF_max(size_t a, size_t b) { return a > b ? a : b; }\nstatic inline size_t TF_min(size_t a, size_t b) { return a < b ? a : b; }\n\ntypedef enum TF_TString_Type {  // NOLINT\n  TF_TSTR_SMALL = 0x00,\n  TF_TSTR_LARGE = 0x01,\n  TF_TSTR_OFFSET = 0x02,\n  TF_TSTR_VIEW = 0x03,\n  TF_TSTR_TYPE_MASK = 0x03\n} TF_TString_Type;\n\ntypedef struct TF_TString_Large {  // NOLINT\n  size_t size;\n  size_t cap;\n  char *ptr;\n} TF_TString_Large;\n\ntypedef struct TF_TString_Offset {  // NOLINT\n  uint32_t size;\n  uint32_t offset;\n  uint32_t count;\n} TF_TString_Offset;\n\ntypedef struct TF_TString_View {  // NOLINT\n  size_t size;\n  const char *ptr;\n} TF_TString_View;\n\ntypedef struct TF_TString_Raw {  // NOLINT\n  uint8_t raw[24];\n} TF_TString_Raw;\n\ntypedef union TF_TString_Union {  // NOLINT\n  TF_TString_Large large;\n  TF_TString_Offset offset;\n  TF_TString_View view;\n  TF_TString_Raw raw;\n} TF_TString_Union;\n\nenum {\n  TF_TString_SmallCapacity =\n      (sizeof(TF_TString_Union) - sizeof(/* null delim */ char) -\n       sizeof(/* uint8_t size */ uint8_t)),\n};\n\ntypedef struct TF_TString_Small {  // NOLINT\n  uint8_t size;\n  char str[TF_TString_SmallCapacity + sizeof(/* null delim */ char)];\n} TF_TString_Small;\n\ntypedef struct TF_TString {  // NOLINT\n  union {\n    // small conflicts with '#define small char' in RpcNdr.h for MSVC, so we use\n    // smll instead.\n    TF_TString_Small smll;\n    TF_TString_Large large;\n    TF_TString_Offset offset;\n    TF_TString_View view;\n    TF_TString_Raw raw;\n  } u;\n} TF_TString;\n\n// TODO(dero): Fix for OSS, and add C only build test.\n// _Static_assert(CHAR_BIT == 8);\n// _Static_assert(sizeof(TF_TString) == 24);\n\nstatic inline TF_TString_Type TF_TString_GetType(const TF_TString *str) {\n  return (TF_TString_Type)(str->u.raw.raw[0] & TF_TSTR_TYPE_MASK);  // NOLINT\n}\n\n// XXX(dero): For the big-endian case, this function could potentially be more\n// performant and readable by always storing the string size as little-endian\n// and always byte-swapping on big endian, resulting in a simple 'bswap'+'shr'\n// (for architectures that have a bswap op).\nstatic inline size_t TF_TString_ToActualSizeT(size_t size) {\n#if TF_TSTRING_LITTLE_ENDIAN\n  return size >> 2;\n#else   // TF_TSTRING_LITTLE_ENDIAN\n  // 0xFF000000 or 0xFF00000000000000 depending on platform\n  static const size_t mask = ~((~(size_t)0) >> 8);\n\n  return (((mask << 2) & size) >> 2) | (~mask & size);\n#endif  // TF_TSTRING_LITTLE_ENDIAN\n}\n\nstatic inline size_t TF_TString_ToInternalSizeT(size_t size,\n                                                TF_TString_Type type) {\n#if TF_TSTRING_LITTLE_ENDIAN\n  return (size << 2) | type;\n#else   // TF_TSTRING_LITTLE_ENDIAN\n  // 0xFF000000 or 0xFF00000000000000 depending on platform\n  static const size_t mask = ~((~(size_t)0) >> 8);\n\n  return (mask & (size << 2)) | (~mask & size) |\n         ((size_t)type << ((sizeof(size_t) - 1) * 8));  // NOLINT\n#endif  // TF_TSTRING_LITTLE_ENDIAN\n}\n\nstatic inline void TF_TString_Init(TF_TString *str) {\n  memset(str->u.raw.raw, 0, sizeof(TF_TString_Raw));\n}\n\nstatic inline void TF_TString_Dealloc(TF_TString *str) {\n  if (TF_TString_GetType(str) == TF_TSTR_LARGE &&\n      str->u.large.ptr != NULL) {  // NOLINT\n    free(str->u.large.ptr);\n    TF_TString_Init(str);\n  }\n}\n\nstatic inline size_t TF_TString_GetSize(const TF_TString *str) {\n  switch (TF_TString_GetType(str)) {\n    case TF_TSTR_SMALL:\n      return str->u.smll.size >> 2;\n    case TF_TSTR_LARGE:\n      return TF_TString_ToActualSizeT(str->u.large.size);\n    case TF_TSTR_OFFSET:\n      return TF_le32toh(str->u.offset.size) >> 2;\n    case TF_TSTR_VIEW:\n      return TF_TString_ToActualSizeT(str->u.view.size);\n    default:\n      return 0;  // Unreachable.\n  }\n}\n\nstatic inline size_t TF_TString_GetCapacity(const TF_TString *str) {\n  switch (TF_TString_GetType(str)) {\n    case TF_TSTR_SMALL:\n      return TF_TString_SmallCapacity;\n    case TF_TSTR_LARGE:\n      return str->u.large.cap;\n    case TF_TSTR_OFFSET:\n    case TF_TSTR_VIEW:\n    default:\n      return 0;\n  }\n}\n\nstatic inline const char *TF_TString_GetDataPointer(const TF_TString *str) {\n  switch (TF_TString_GetType(str)) {\n    case TF_TSTR_SMALL:\n      return str->u.smll.str;\n    case TF_TSTR_LARGE:\n      return str->u.large.ptr;\n    case TF_TSTR_OFFSET:\n      return (const char *)str + str->u.offset.offset;  // NOLINT\n    case TF_TSTR_VIEW:\n      return str->u.view.ptr;\n    default:\n      // Unreachable.\n      return NULL;  // NOLINT\n  }\n}\n\nstatic inline char *TF_TString_ResizeUninitialized(TF_TString *str,\n                                                   size_t new_size) {\n  size_t curr_size = TF_TString_GetSize(str);\n  size_t copy_size = TF_min(new_size, curr_size);\n\n  TF_TString_Type curr_type = TF_TString_GetType(str);\n  const char *curr_ptr = TF_TString_GetDataPointer(str);\n\n  // Case: SMALL/LARGE/VIEW/OFFSET -> SMALL\n  if (new_size <= TF_TString_SmallCapacity) {\n    str->u.smll.size = (uint8_t)((new_size << 2) | TF_TSTR_SMALL);  // NOLINT\n    str->u.smll.str[new_size] = '\\0';\n\n    if (curr_type != TF_TSTR_SMALL && copy_size) {\n      memcpy(str->u.smll.str, curr_ptr, copy_size);\n    }\n\n    if (curr_type == TF_TSTR_LARGE) {\n      free((void *)curr_ptr);  // NOLINT\n    }\n\n    // We do not clear out the newly excluded region.\n\n    return str->u.smll.str;\n  }\n\n  // Case: SMALL/LARGE/VIEW/OFFSET -> LARGE\n  size_t new_cap;\n  size_t curr_cap = TF_TString_GetCapacity(str);\n\n  if (new_size < curr_size && new_size < curr_cap / 2) {\n    // TODO(dero): Replace with shrink_to_fit flag.\n    new_cap = TF_align16(curr_cap / 2 + 1) - 1;\n  } else if (new_size > curr_cap) {\n    new_cap = TF_align16(new_size + 1) - 1;\n  } else {\n    new_cap = curr_cap;\n  }\n\n  char *new_ptr;\n  if (new_cap == curr_cap) {\n    new_ptr = str->u.large.ptr;\n  } else if (curr_type == TF_TSTR_LARGE) {\n    new_ptr = (char *)realloc(str->u.large.ptr, new_cap + 1);  // NOLINT\n  } else {\n    new_ptr = (char *)malloc(new_cap + 1);  // NOLINT\n    if (copy_size) {\n      memcpy(new_ptr, curr_ptr, copy_size);\n    }\n  }\n\n  str->u.large.size = TF_TString_ToInternalSizeT(new_size, TF_TSTR_LARGE);\n  str->u.large.ptr = new_ptr;\n  str->u.large.ptr[new_size] = '\\0';\n  str->u.large.cap = new_cap;\n\n  return str->u.large.ptr;\n}\n\nstatic inline char *TF_TString_GetMutableDataPointer(TF_TString *str) {\n  switch (TF_TString_GetType(str)) {\n    case TF_TSTR_SMALL:\n      return str->u.smll.str;\n    case TF_TSTR_OFFSET:\n    case TF_TSTR_VIEW:\n      // Convert OFFSET/VIEW to SMALL/LARGE\n      TF_TString_ResizeUninitialized(str, TF_TString_GetSize(str));\n      return (TF_TString_GetType(str) == TF_TSTR_SMALL) ? str->u.smll.str\n                                                        : str->u.large.ptr;\n    case TF_TSTR_LARGE:\n      return str->u.large.ptr;\n    default:\n      // Unreachable.\n      return NULL;  // NOLINT\n  }\n}\n\nstatic inline void TF_TString_Reserve(TF_TString *str, size_t new_cap) {\n  TF_TString_Type curr_type = TF_TString_GetType(str);\n\n  if (new_cap <= TF_TString_SmallCapacity) {\n    // We do nothing, we let Resize/GetMutableDataPointer handle the\n    // conversion to SMALL from VIEW/OFFSET when the need arises.\n    // In the degenerate case, where new_cap <= TF_TString_SmallCapacity,\n    // curr_size > TF_TString_SmallCapacity, and the type is VIEW/OFFSET, we\n    // defer the malloc to Resize/GetMutableDataPointer.\n    return;\n  }\n\n  if (curr_type == TF_TSTR_LARGE && new_cap <= str->u.large.cap) {\n    // We handle reduced cap in resize.\n    return;\n  }\n\n  // Case: VIEW/OFFSET -> LARGE or grow an existing LARGE type\n  size_t curr_size = TF_TString_GetSize(str);\n  const char *curr_ptr = TF_TString_GetDataPointer(str);\n\n  // Since VIEW and OFFSET types are read-only, their capacity is effectively 0.\n  // So we make sure we have enough room in the VIEW and OFFSET cases.\n  new_cap = TF_align16(TF_max(new_cap, curr_size) + 1) - 1;\n\n  if (curr_type == TF_TSTR_LARGE) {\n    str->u.large.ptr =\n        (char *)realloc(str->u.large.ptr, new_cap + 1);  // NOLINT\n  } else {\n    // Convert to Large\n    char *new_ptr = (char *)malloc(new_cap + 1);  // NOLINT\n    memcpy(new_ptr, curr_ptr, curr_size);\n\n    str->u.large.size = TF_TString_ToInternalSizeT(curr_size, TF_TSTR_LARGE);\n    str->u.large.ptr = new_ptr;\n    str->u.large.ptr[curr_size] = '\\0';\n  }\n\n  str->u.large.cap = new_cap;\n}\n\nstatic inline void TF_TString_ReserveAmortized(TF_TString *str,\n                                               size_t new_cap) {\n  const size_t curr_cap = TF_TString_GetCapacity(str);\n  if (new_cap > curr_cap) {\n    TF_TString_Reserve(str, new_cap > 2 * curr_cap ? new_cap : 2 * curr_cap);\n  }\n}\n\nstatic inline char *TF_TString_Resize(TF_TString *str, size_t new_size,\n                                      char c) {\n  size_t curr_size = TF_TString_GetSize(str);\n  char *cstr = TF_TString_ResizeUninitialized(str, new_size);\n\n  if (new_size > curr_size) {\n    memset(cstr + curr_size, c, new_size - curr_size);\n  }\n\n  return cstr;\n}\n\nstatic inline void TF_TString_AssignView(TF_TString *dst, const char *src,\n                                         size_t size) {\n  TF_TString_Dealloc(dst);\n\n  dst->u.view.size = TF_TString_ToInternalSizeT(size, TF_TSTR_VIEW);\n  dst->u.view.ptr = src;\n}\n\nstatic inline void TF_TString_AppendN(TF_TString *dst, const char *src,\n                                      size_t src_size) {\n  if (!src_size) return;\n\n  size_t dst_size = TF_TString_GetSize(dst);\n\n  // For append use cases, we want to ensure amortized growth.\n  TF_TString_ReserveAmortized(dst, dst_size + src_size);\n  char *dst_c = TF_TString_ResizeUninitialized(dst, dst_size + src_size);\n\n  memcpy(dst_c + dst_size, src, src_size);\n}\n\nstatic inline void TF_TString_Append(TF_TString *dst, const TF_TString *src) {\n  const char *src_c = TF_TString_GetDataPointer(src);\n  size_t size = TF_TString_GetSize(src);\n\n  TF_TString_AppendN(dst, src_c, size);\n}\n\nstatic inline void TF_TString_Copy(TF_TString *dst, const char *src,\n                                   size_t size) {\n  char *dst_c = TF_TString_ResizeUninitialized(dst, size);\n\n  if (size) memcpy(dst_c, src, size);\n}\n\nstatic inline void TF_TString_Assign(TF_TString *dst, const TF_TString *src) {\n  if (dst == src) return;\n\n  TF_TString_Dealloc(dst);\n\n  switch (TF_TString_GetType(src)) {\n    case TF_TSTR_SMALL:\n    case TF_TSTR_VIEW:\n      *dst = *src;\n      return;\n    case TF_TSTR_LARGE: {\n      const char *src_c = TF_TString_GetDataPointer(src);\n      size_t size = TF_TString_GetSize(src);\n\n      TF_TString_Copy(dst, src_c, size);\n    }\n      return;\n    case TF_TSTR_OFFSET: {\n      const char *src_c = TF_TString_GetDataPointer(src);\n      size_t size = TF_TString_GetSize(src);\n\n      TF_TString_AssignView(dst, src_c, size);\n    }\n      return;\n    default:\n      return;  // Unreachable.\n  }\n}\n\nstatic inline void TF_TString_Move(TF_TString *dst, TF_TString *src) {\n  if (dst == src) return;\n\n  TF_TString_Dealloc(dst);\n\n  switch (TF_TString_GetType(src)) {\n    case TF_TSTR_SMALL:\n    case TF_TSTR_VIEW:\n      *dst = *src;\n      return;\n    case TF_TSTR_LARGE:\n      *dst = *src;\n      TF_TString_Init(src);\n      return;\n    case TF_TSTR_OFFSET: {\n      const char *src_c = TF_TString_GetDataPointer(src);\n      size_t size = TF_TString_GetSize(src);\n\n      TF_TString_AssignView(dst, src_c, size);\n    }\n      return;\n    default:\n      return;  // Unreachable.\n  }\n}\n\n#endif  // TENSORFLOW_CORE_PLATFORM_CTSTRING_INTERNAL_H_"