"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/kernels/immutable_constant_op.h\"\n\n#include <unordered_set>\n\n#include \"tensorflow/core/framework/types.pb.h\"\n\nnamespace tensorflow {\n\nnamespace {\nclass MemmappedTensorAllocator : public Allocator {\n public:\n  MemmappedTensorAllocator() {}\n\n  Status InitializeFromRegion(const string& name, Env* env) {\n    const auto status =\n        env->NewReadOnlyMemoryRegionFromFile(name, &memory_region_);\n    if (!status.ok()) {\n      return status;\n    }\n    return Status::OK();\n  }\n  string Name() override { return \"MemmappedTensorAllocator\"; }\n\n  void* AllocateRaw(size_t alignment, size_t num_bytes) override {\n    if ((reinterpret_cast<intptr_t>(memory_region_->data())) % alignment != 0) {\n      allocation_status_ =\n          errors::Internal(\"Readonly memory region has wrong alignment\");\n      return nullptr;\n    }\n    if (num_bytes > memory_region_->length()) {\n      allocation_status_ = errors::Internal(\n          \"Readonly memory region has wrong length (\", memory_region_->length(),\n          \") when allocating \", num_bytes);\n      return nullptr;\n    }\n    return const_cast<void*>(memory_region_->data());\n  }\n\n  void DeallocateRaw(void* ptr) override {\n    if (ptr != memory_region_->data()) {\n      LOG(ERROR)\n          << \"Deallocating not allocated region for readonly memory region\";\n    }\n    if (delete_on_deallocate_) {\n      delete this;\n    }\n  }\n  const Status& allocation_status() const { return allocation_status_; }\n\n  void set_delete_on_deallocate() { delete_on_deallocate_ = true; }\n\n  // Make sure tensors or complex types (strings, variants, resources) don't get\n  // their constructor called via a placement new since that would require\n  // writing to immutable data.\n  // See also: tensorflow/core/framework/typed_allocator.h\n  bool AllocatesOpaqueHandle() const override { return true; }\n\n private:\n  std::unique_ptr<ReadOnlyMemoryRegion> memory_region_;\n  // If there is an error during allocation we keep it in this status.\n  Status allocation_status_;\n\n  // When the allocator is owned by TensorBuffer it will be deleted on\n  // de-allocation.\n  bool delete_on_deallocate_ = false;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(MemmappedTensorAllocator);\n};\n}  // namespace\n\nImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,\n              errors::InvalidArgument(\n                  \"Resource and variant dtypes are invalid for this op.\"));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}\n\nvoid ImmutableConstantOp::Compute(OpKernelContext* ctx) {\n  std::unique_ptr<MemmappedTensorAllocator> allocator(\n      new MemmappedTensorAllocator());\n\n  OP_REQUIRES_OK(ctx,\n                 allocator->InitializeFromRegion(region_name_, ctx->env()));\n  ctx->set_output(0, Tensor(allocator.get(), dtype_, shape_));\n  OP_REQUIRES_OK(ctx, allocator->allocation_status());\n  // Allocator is owned by the tensor from this point.\n  allocator.release()->set_delete_on_deallocate();\n}\n\nImmutableConstantOp::~ImmutableConstantOp() {}\nconstexpr char const* ImmutableConstantOp::kDTypeAttr;\nconstexpr char const* ImmutableConstantOp::kShapeAttr;\nconstexpr char const* ImmutableConstantOp::kMemoryRegionNameAttr;\n\nREGISTER_KERNEL_BUILDER(Name(\"ImmutableConst\").Device(DEVICE_CPU),\n                        ImmutableConstantOp);\n}  // namespace tensorflow"