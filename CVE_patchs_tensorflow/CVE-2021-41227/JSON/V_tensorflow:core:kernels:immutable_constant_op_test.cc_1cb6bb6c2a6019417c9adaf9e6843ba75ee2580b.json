"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/core/kernels/immutable_constant_op.h\"\n\n#include <algorithm>\n#include <tuple>\n\n#include \"tensorflow/cc/ops/standard_ops.h\"\n#include \"tensorflow/core/framework/allocator.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/graph/graph_def_builder.h\"\n#include \"tensorflow/core/lib/core/status_test_util.h\"\n#include \"tensorflow/core/lib/io/path.h\"\n#include \"tensorflow/core/platform/null_file_system.h\"\n#include \"tensorflow/core/platform/test.h\"\n#include \"tensorflow/core/platform/test_benchmark.h\"\n#include \"tensorflow/core/public/session.h\"\n\nnamespace tensorflow {\nnamespace {\n// A safe alignment that equal to memmapped page alignment on many modern\n// architectures.\nconstexpr size_t kTestAlignment = 4096;\nconstexpr size_t kTestTensorSize = 4;\nconstexpr size_t kTestTensorSizeBytes = kTestTensorSize * sizeof(float);\n\n// A test ReadOnlyMemoryRegion implementation.\nclass TestReadOnlyMemoryRegion : public ReadOnlyMemoryRegion {\n public:\n  TestReadOnlyMemoryRegion() = delete;\n  explicit TestReadOnlyMemoryRegion(uint64 length)\n      : memptr_(cpu_allocator()->AllocateRaw(kTestAlignment, length)),\n        length_(length) {}\n  ~TestReadOnlyMemoryRegion() override {\n    cpu_allocator()->DeallocateRaw(memptr_);\n  }\n  const void* data() override { return memptr_; }\n  float* GetWritableDataStart() { return reinterpret_cast<float*>(memptr_); }\n  uint64 length() override { return length_; }\n\n protected:\n  void* memptr_;\n  uint64 length_;\n};\n\n// A mock file system and environment class that creates ReadOnlyMemoryRegion\n// from allocated memory.\nclass TestFileSystem : public NullFileSystem {\n public:\n  ~TestFileSystem() override = default;\n\n  // import non-transactional method from the base class\n  using NullFileSystem::NewReadOnlyMemoryRegionFromFile;\n\n  Status NewReadOnlyMemoryRegionFromFile(\n      const string& fname, TransactionToken* token,\n      std::unique_ptr<ReadOnlyMemoryRegion>* result) override {\n    float val = 0;\n    StringPiece scheme, host, path;\n    io::ParseURI(fname, &scheme, &host, &path);\n    // For the tests create in-memory regions with float values equal to the\n    // region name.\n    if (path == \"/2\") {\n      val = 2.0f;\n    } else if (path == \"/3\") {\n      val = 3.0f;\n    } else {\n      val = 0.0f;\n    }\n\n    auto region = new TestReadOnlyMemoryRegion(kTestTensorSizeBytes);\n    std::fill_n(region->GetWritableDataStart(), kTestTensorSize, val);\n    result->reset(region);\n    return Status::OK();\n  }\n};\n\nREGISTER_FILE_SYSTEM(\"test\", TestFileSystem);\n\nstruct ImmutableConstantOpTest {};\n\nTEST(ImmutableConstantOpTest, Simple) {\n  const TensorShape kTestTensorShape({4, 1});\n  const TensorShape kTestTensorShapeT({1, 4});\n  auto root = Scope::NewRootScope().ExitOnError();\n  auto node1 =\n      ops::ImmutableConst(root, DT_FLOAT, kTestTensorShape, \"test:///2\");\n  auto node2 =\n      ops::ImmutableConst(root, DT_FLOAT, kTestTensorShapeT, \"test:///3\");\n  auto result = ops::MatMul(root, node1, node2);\n  GraphDef graph_def;\n  TF_ASSERT_OK(root.ToGraphDef(&graph_def));\n  SessionOptions session_options;\n  session_options.env = Env::Default();\n  session_options.config.mutable_graph_options()\n      ->mutable_optimizer_options()\n      ->set_opt_level(OptimizerOptions::L0);\n  std::unique_ptr<Session> session(NewSession(session_options));\n  ASSERT_TRUE(session != nullptr) << \"Failed to create session\";\n  TF_ASSERT_OK(session->Create(graph_def)) << \"Can't create test graph\";\n  std::vector<Tensor> outputs;\n  TF_ASSERT_OK(session->Run({}, {result.node()->name() + \":0\"}, {}, &outputs));\n  ASSERT_EQ(outputs.size(), 1);\n  EXPECT_EQ(outputs.front().flat<float>()(0), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(1), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(2), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(kTestTensorSize - 1), 2.0f * 3.0f);\n}\n\n// Creates a test graph with two immutable_const tensors and a simple math\n// operation, one of nodes has wrong size, check that error properly reported.\n\nTEST(ImmutableConstantOpTest, ExecutionError) {\n  const TensorShape kBadTensorShape({40, 100});\n  const TensorShape kTestTensorShapeT({1, 4});\n\n  auto root = Scope::DisabledShapeInferenceScope().ExitOnError();\n  auto node1 =\n      ops::ImmutableConst(root, DT_FLOAT, kBadTensorShape, \"test:///2\");\n  auto node2 =\n      ops::ImmutableConst(root, DT_FLOAT, kTestTensorShapeT, \"test:///3\");\n  auto result = ops::MatMul(root, node1, node2);\n  GraphDef graph_def;\n  TF_ASSERT_OK(root.ToGraphDef(&graph_def));\n  SessionOptions session_options;\n  session_options.env = Env::Default();\n  std::unique_ptr<Session> session(NewSession(session_options));\n  ASSERT_TRUE(session != nullptr) << \"Failed to create session\";\n  TF_ASSERT_OK(session->Create(graph_def)) << \"Can't create test graph\";\n  std::vector<Tensor> outputs;\n  // Check that the run returned error.\n  EXPECT_EQ(\n      session->Run({}, {result.node()->name() + \":0\"}, {}, &outputs).code(),\n      error::INTERNAL);\n}\n\nStatus CreateTempFile(Env* env, float value, uint64 size, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}\n\nTEST(ImmutableConstantOpTest, FromFile) {\n  const TensorShape kFileTensorShape({1000, 1});\n  Env* env = Env::Default();\n  auto root = Scope::NewRootScope().ExitOnError();\n\n  string two_file, three_file;\n  TF_ASSERT_OK(CreateTempFile(env, 2.0f, 1000, &two_file));\n  TF_ASSERT_OK(CreateTempFile(env, 3.0f, 1000, &three_file));\n  auto node1 = ops::ImmutableConst(root, DT_FLOAT, kFileTensorShape, two_file);\n  auto node2 =\n      ops::ImmutableConst(root, DT_FLOAT, kFileTensorShape, three_file);\n  auto result = ops::MatMul(root, node1, node2, ops::MatMul::TransposeB(true));\n\n  GraphDef graph_def;\n  TF_ASSERT_OK(root.ToGraphDef(&graph_def));\n  SessionOptions session_options;\n  session_options.config.mutable_graph_options()\n      ->mutable_optimizer_options()\n      ->set_opt_level(OptimizerOptions::L0);\n  std::unique_ptr<Session> session(NewSession(session_options));\n  ASSERT_TRUE(session != nullptr) << \"Failed to create session\";\n  TF_ASSERT_OK(session->Create(graph_def)) << \"Can't create test graph\";\n  std::vector<Tensor> outputs;\n  TF_ASSERT_OK(session->Run({}, {result.node()->name() + \":0\"}, {}, &outputs));\n  ASSERT_EQ(outputs.size(), 1);\n  EXPECT_EQ(outputs.front().flat<float>()(0), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(1), 2.0f * 3.0f);\n  EXPECT_EQ(outputs.front().flat<float>()(2), 2.0f * 3.0f);\n}\n\n}  // namespace\n}  // namespace tensorflow"