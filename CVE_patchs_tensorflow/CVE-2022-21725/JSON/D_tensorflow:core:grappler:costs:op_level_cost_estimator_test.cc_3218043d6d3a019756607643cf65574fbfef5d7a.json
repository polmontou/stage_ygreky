"diff --git a/tensorflow/core/grappler/costs/op_level_cost_estimator_test.cc b/tensorflow/core/grappler/costs/op_level_cost_estimator_test.cc\nindex 560845ee980..0cddce42df2 100644\n--- a/tensorflow/core/grappler/costs/op_level_cost_estimator_test.cc\n+++ b/tensorflow/core/grappler/costs/op_level_cost_estimator_test.cc\n@@ -24,6 +24,7 @@ limitations under the License.\n #include \"tensorflow/core/framework/tensor_shape.h\"\n #include \"tensorflow/core/framework/tensor_shape.pb.h\"\n #include \"tensorflow/core/framework/types.h\"\n+#include \"tensorflow/core/platform/status_matchers.h\"\n #include \"tensorflow/core/platform/test.h\"\n #include \"tensorflow/core/protobuf/device_properties.pb.h\"\n \n@@ -558,9 +559,10 @@ class OpLevelCostEstimatorTest : public ::testing::Test {\n     }\n \n     bool found_unknown_shapes;\n-    auto dims = OpLevelCostEstimator::OpDimensionsFromInputs(\n-        op_context.op_info.inputs(0).shape(), op_context.op_info,\n-        &found_unknown_shapes);\n+    TF_ASSERT_OK_AND_ASSIGN(\n+        auto dims, OpLevelCostEstimator::OpDimensionsFromInputs(\n+                       op_context.op_info.inputs(0).shape(), op_context.op_info,\n+                       &found_unknown_shapes));\n     Padding padding_enum;\n     if (padding == \"VALID\") {\n       padding_enum = Padding::VALID;\n@@ -581,6 +583,38 @@ class OpLevelCostEstimatorTest : public ::testing::Test {\n     EXPECT_EQ(padding_enum, dims.padding);\n   }\n \n+  StatusOr<OpLevelCostEstimator::ConvolutionDimensions>\n+  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n+                             const int kx, const int ky, const int sx,\n+                             const int sy, const string& data_format,\n+                             const string& padding) {\n+    OpContext op_context;\n+\n+    const std::vector<int> x = {n, h, w, c};\n+    const std::vector<int> ksize = {1, kx, ky, 1};\n+    std::vector<int> strides;\n+    if (data_format == \"NHWC\") {\n+      strides = {1, sy, sx, 1};\n+    } else {\n+      strides = {1, 1, sy, sx};\n+    }\n+\n+    auto& op_info = op_context.op_info;\n+    SetCpuDevice(&op_info);\n+    op_info.set_op(\"MaxPool\");\n+\n+    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n+    auto* attr = op_info.mutable_attr();\n+    SetAttrValue(data_format, &(*attr)[\"data_format\"]);\n+    SetAttrValue(padding, &(*attr)[\"padding\"]);\n+    SetAttrValue(strides, &(*attr)[\"strides\"]);\n+    SetAttrValue(ksize, &(*attr)[\"ksize\"]);\n+    bool found_unknown_shapes;\n+    return OpLevelCostEstimator::OpDimensionsFromInputs(\n+        op_context.op_info.inputs(0).shape(), op_context.op_info,\n+        &found_unknown_shapes);\n+  }\n+\n   OpLevelCostEstimator estimator_;\n };\n \n@@ -1383,6 +1417,26 @@ TEST_F(OpLevelCostEstimatorTest, OpDimensionsFromInputs) {\n   }\n }\n \n+TEST_F(OpLevelCostEstimatorTest, OpDimensionsFromInputsError) {\n+  std::vector<string> paddings = {\"VALID\", \"SAME\"};\n+  std::vector<string> formats = {\"NHWC\", \"NCHW\"};\n+  for (const auto& p : paddings) {\n+    for (const auto& f : formats) {\n+      // n, h, w, c, kx, ky, sx, sy, data_format, padding.\n+      ASSERT_THAT(\n+          CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 0, 2, f, p),\n+          testing::StatusIs(\n+              error::INVALID_ARGUMENT,\n+              \"Stride must be > 0 for Height and Width, but got (2, 0)\"));\n+      ASSERT_THAT(\n+          CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 2, 0, f, p),\n+          testing::StatusIs(\n+              error::INVALID_ARGUMENT,\n+              \"Stride must be > 0 for Height and Width, but got (0, 2)\"));\n+    }\n+  }\n+}\n+\n TEST_F(OpLevelCostEstimatorTest, PredictMaxPool) {\n   auto predict_max_pool = [this](const int n, const int in, const int c,\n                                  const int k, const int s,"