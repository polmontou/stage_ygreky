"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/core/kernels/data/experimental/threadpool_dataset_op.h\"\n\n#include <memory>\n\n#include \"tensorflow/core/data/dataset_utils.h\"\n#include \"tensorflow/core/framework/dataset.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/lib/core/refcount.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/platform/cpu_info.h\"\n#include \"tensorflow/core/platform/stringprintf.h\"\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\nnamespace data {\nnamespace experimental {\n\n/* static */ constexpr const char* const\n    MaxIntraOpParallelismDatasetOp::kDatasetType;\n/* static */ constexpr const char* const\n    MaxIntraOpParallelismDatasetOp::kDatasetOp;\n/* static */ constexpr const char* const\n    PrivateThreadPoolDatasetOp::kDatasetType;\n/* static */ constexpr const char* const PrivateThreadPoolDatasetOp::kDatasetOp;\n\nnamespace {\n// To prevent integer overflow issues when allocating threadpool memory for an\n// unreasonable number of threads.\nconstexpr int kThreadLimit = 65536;\n\nStatus ValidateNumThreads(int32_t num_threads) {\n  if (num_threads < 0) {\n    return errors::InvalidArgument(\"`num_threads` must be >= 0\");\n  }\n  if (num_threads >= kThreadLimit) {\n    return errors::InvalidArgument(\"`num_threads` must be < \", kThreadLimit);\n  }\n  return Status::OK();\n}\n}  // namespace\n\nclass ThreadPoolResource : public ResourceBase {\n public:\n  ThreadPoolResource(Env* env, const ThreadOptions& thread_options,\n                     const string& name, int num_threads, bool low_latency_hint,\n                     int max_intra_op_parallelism)\n      : thread_pool_(env, thread_options, name, num_threads, low_latency_hint),\n        max_intra_op_parallelism_(max_intra_op_parallelism) {}\n\n  // Schedules fn() for execution in the pool of threads.\n  void Schedule(std::function<void()> fn) {\n    if (max_intra_op_parallelism_ < 0) {\n      thread_pool_.Schedule(std::move(fn));\n    } else {\n      thread_pool_.Schedule(std::bind(\n          [this](std::function<void()> bound_fn) {\n            // TODO(mrry): Consider moving this thread-local configuration to\n            // the threads themselves.\n            ScopedPerThreadMaxParallelism scope(max_intra_op_parallelism_);\n            bound_fn();\n          },\n          std::move(fn)));\n    }\n  }\n\n  int32 NumThreads() { return thread_pool_.NumThreads(); }\n\n  string DebugString() const override { return \"ThreadPoolResource\"; }\n\n private:\n  thread::ThreadPool thread_pool_;\n  const int max_intra_op_parallelism_;\n};\n\n// Creates a handle to a ThreadPool resource. Note that we don't use\n// ResourceOpKernel here because the ThreadPoolResource constructor requires\n// access to `OpKernelContext::env()`, which isn't provided by\n// `ResourceOpKernel<T>::CreateResource()`.\nclass ThreadPoolHandleOp : public OpKernel {\n public:\n  explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads_));\n  }\n\n  // The resource is deleted from the resource manager only when it is private\n  // to kernel. Ideally the resource should be deleted when it is no longer held\n  // by anyone, but it would break backward compatibility.\n  ~ThreadPoolHandleOp() override {\n    if (cinfo_.resource_is_private_to_kernel()) {\n      if (!cinfo_.resource_manager()\n               ->Delete<ThreadPoolResource>(cinfo_.container(), cinfo_.name())\n               .ok()) {\n        // Do nothing; the resource can have been deleted by session resets.\n      }\n    }\n  }\n\n  void Compute(OpKernelContext* ctx) override TF_LOCKS_EXCLUDED(mu_) {\n    mutex_lock l(mu_);\n    if (!initialized_) {\n      ResourceMgr* mgr = ctx->resource_manager();\n      OP_REQUIRES_OK(ctx, cinfo_.Init(mgr, def()));\n      ThreadPoolResource* resource;\n      OP_REQUIRES_OK(ctx, mgr->LookupOrCreate<ThreadPoolResource>(\n                              cinfo_.container(), cinfo_.name(), &resource,\n                              [this, ctx](ThreadPoolResource** ret)\n                                  TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n                                    *ret = new ThreadPoolResource(\n                                        ctx->env(), {}, display_name_,\n                                        num_threads_,\n                                        /*low_latency_hint=*/false,\n                                        max_intra_op_parallelism_);\n                                    return Status::OK();\n                                  }));\n      initialized_ = true;\n    }\n    OP_REQUIRES_OK(ctx, MakeResourceHandleToOutput(\n                            ctx, 0, cinfo_.container(), cinfo_.name(),\n                            TypeIndex::Make<ThreadPoolResource>()));\n  }\n\n private:\n  mutex mu_;\n  ContainerInfo cinfo_ TF_GUARDED_BY(mu_);\n  bool initialized_ TF_GUARDED_BY(mu_) = false;\n  string display_name_;\n  int num_threads_;\n  int max_intra_op_parallelism_;\n};\n\nclass ThreadPoolDatasetOp : public UnaryDatasetOpKernel {\n public:\n  explicit ThreadPoolDatasetOp(OpKernelConstruction* ctx)\n      : UnaryDatasetOpKernel(ctx) {}\n\n  void MakeDataset(OpKernelContext* ctx, DatasetBase* input,\n                   DatasetBase** output) override {\n    core::RefCountPtr<ThreadPoolResource> threadpool_resource;\n    OP_REQUIRES_OK(ctx, LookupResource(ctx, HandleFromInput(ctx, 1),\n                                       &threadpool_resource));\n    *output = new Dataset(ctx, input, ctx->input(1), threadpool_resource.get());\n  }\n\n private:\n  class Dataset : public DatasetBase {\n   public:\n    Dataset(OpKernelContext* ctx, const DatasetBase* input,\n            const Tensor& resource_handle, ThreadPoolResource* threadpool)\n        : DatasetBase(DatasetContext(ctx)),\n          input_(input),\n          resource_handle_(resource_handle),\n          threadpool_(threadpool) {\n      input_->Ref();\n      threadpool_->Ref();\n    }\n\n    ~Dataset() override {\n      input_->Unref();\n      threadpool_->Unref();\n    }\n\n    std::unique_ptr<IteratorBase> MakeIteratorInternal(\n        const string& prefix) const override {\n      return absl::make_unique<Iterator>(\n          Iterator::Params{this, strings::StrCat(prefix, \"::ThreadPool\")});\n    }\n\n    const DataTypeVector& output_dtypes() const override {\n      return input_->output_dtypes();\n    }\n    const std::vector<PartialTensorShape>& output_shapes() const override {\n      return input_->output_shapes();\n    }\n\n    string DebugString() const override {\n      return \"ThreadPoolDatasetOp::Dataset\";\n    }\n\n    int64_t CardinalityInternal() const override {\n      return input_->Cardinality();\n    }\n\n    Status InputDatasets(\n        std::vector<const DatasetBase*>* inputs) const override {\n      inputs->push_back(input_);\n      return Status::OK();\n    }\n\n    Status CheckExternalState() const override {\n      return input_->CheckExternalState();\n    }\n\n   protected:\n    Status AsGraphDefInternal(SerializationContext* ctx,\n                              DatasetGraphDefBuilder* b,\n                              Node** output) const override {\n      Node* input_graph_node = nullptr;\n      TF_RETURN_IF_ERROR(b->AddInputDataset(ctx, input_, &input_graph_node));\n      Node* resource_handle_node = nullptr;\n      TF_RETURN_IF_ERROR(b->AddTensor(resource_handle_, &resource_handle_node));\n      TF_RETURN_IF_ERROR(b->AddDataset(\n          this, {input_graph_node, resource_handle_node}, output));\n      return Status::OK();\n    }\n\n   private:\n    class Iterator : public DatasetIterator<Dataset> {\n     public:\n      explicit Iterator(const Params& params)\n          : DatasetIterator<Dataset>(params) {}\n\n      Status Initialize(IteratorContext* ctx) override {\n        return dataset()->input_->MakeIterator(\n            IteratorContext(CreateParams(ctx)), this, prefix(), &input_impl_);\n      }\n\n      Status GetNextInternal(IteratorContext* ctx,\n                             std::vector<Tensor>* out_tensors,\n                             bool* end_of_sequence) override {\n        return input_impl_->GetNext(IteratorContext(CreateParams(ctx)),\n                                    out_tensors, end_of_sequence);\n      }\n\n     protected:\n      std::shared_ptr<model::Node> CreateNode(\n          IteratorContext* ctx, model::Node::Args args) const override {\n        return model::MakeKnownRatioNode(std::move(args),\n                                         /*ratio=*/1);\n      }\n\n      Status SaveInternal(SerializationContext* ctx,\n                          IteratorStateWriter* writer) override {\n        DCHECK(input_impl_ != nullptr);\n        TF_RETURN_IF_ERROR(SaveInput(ctx, writer, input_impl_));\n        return Status::OK();\n      }\n\n      Status RestoreInternal(IteratorContext* ctx,\n                             IteratorStateReader* reader) override {\n        TF_RETURN_IF_ERROR(RestoreInput(ctx, reader, input_impl_));\n        return Status::OK();\n      }\n\n     private:\n      IteratorContext::Params CreateParams(IteratorContext* ctx) {\n        ThreadPoolResource* pool = dataset()->threadpool_;\n        IteratorContext::Params params(ctx);\n        params.runner = [pool](std::function<void()> c) {\n          pool->Schedule(std::move(c));\n        };\n        params.runner_threadpool_size = pool->NumThreads();\n        return params;\n      }\n\n      std::unique_ptr<IteratorBase> input_impl_;\n    };\n\n    const DatasetBase* const input_;\n    const Tensor resource_handle_;\n    ThreadPoolResource* const threadpool_;\n  };\n};\n\nclass MaxIntraOpParallelismDatasetOp::Dataset : public DatasetBase {\n public:\n  Dataset(OpKernelContext* ctx, const DatasetBase* input,\n          int64_t max_intra_op_parallelism)\n      : Dataset(DatasetContext(ctx), input, max_intra_op_parallelism) {}\n\n  Dataset(DatasetContext&& ctx, const DatasetBase* input,\n          int64_t max_intra_op_parallelism)\n      : DatasetBase(std::move(ctx)),\n        input_(input),\n        max_intra_op_parallelism_(max_intra_op_parallelism),\n        traceme_metadata_(\n            {{\"parallelism\",\n              strings::Printf(\"%lld\", static_cast<long long>(\n                                          max_intra_op_parallelism_))}}) {\n    input_->Ref();\n  }\n\n  ~Dataset() override { input_->Unref(); }\n\n  std::unique_ptr<IteratorBase> MakeIteratorInternal(\n      const string& prefix) const override {\n    return absl::make_unique<Iterator>(Iterator::Params{\n        this, strings::StrCat(prefix, \"::MaxIntraOpParallelism\")});\n  }\n\n  const DataTypeVector& output_dtypes() const override {\n    return input_->output_dtypes();\n  }\n  const std::vector<PartialTensorShape>& output_shapes() const override {\n    return input_->output_shapes();\n  }\n\n  string DebugString() const override {\n    return \"MaxIntraOpParallelismDatasetOp::Dataset\";\n  }\n\n  int64_t CardinalityInternal() const override { return input_->Cardinality(); }\n\n  Status InputDatasets(std::vector<const DatasetBase*>* inputs) const override {\n    inputs->clear();\n    inputs->push_back(input_);\n    return Status::OK();\n  }\n\n  Status CheckExternalState() const override {\n    return input_->CheckExternalState();\n  }\n\n protected:\n  Status AsGraphDefInternal(SerializationContext* ctx,\n                            DatasetGraphDefBuilder* b,\n                            Node** output) const override {\n    Node* input_graph_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddInputDataset(ctx, input_, &input_graph_node));\n    Node* max_intra_op_parallelism_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddScalar(max_intra_op_parallelism_,\n                                    &max_intra_op_parallelism_node));\n    TF_RETURN_IF_ERROR(b->AddDataset(\n        this, {input_graph_node, max_intra_op_parallelism_node}, output));\n    return Status::OK();\n  }\n\n private:\n  class Iterator : public DatasetIterator<Dataset> {\n   public:\n    explicit Iterator(const Params& params)\n        : DatasetIterator<Dataset>(params) {}\n\n    Status Initialize(IteratorContext* ctx) override {\n      return dataset()->input_->MakeIterator(ctx, this, prefix(), &input_impl_);\n    }\n\n    Status GetNextInternal(IteratorContext* ctx,\n                           std::vector<Tensor>* out_tensors,\n                           bool* end_of_sequence) override {\n      IteratorContext::Params params(ctx);\n      auto max_parallelism = dataset()->max_intra_op_parallelism_;\n      params.runner = RunnerWithMaxParallelism(*ctx->runner(), max_parallelism);\n      return input_impl_->GetNext(IteratorContext{std::move(params)},\n                                  out_tensors, end_of_sequence);\n    }\n\n   protected:\n    std::shared_ptr<model::Node> CreateNode(\n        IteratorContext* ctx, model::Node::Args args) const override {\n      return model::MakeKnownRatioNode(std::move(args), /*ratio=*/1);\n    }\n\n    Status SaveInternal(SerializationContext* ctx,\n                        IteratorStateWriter* writer) override {\n      DCHECK(input_impl_ != nullptr);\n      TF_RETURN_IF_ERROR(SaveInput(ctx, writer, input_impl_));\n      return Status::OK();\n    }\n\n    Status RestoreInternal(IteratorContext* ctx,\n                           IteratorStateReader* reader) override {\n      TF_RETURN_IF_ERROR(RestoreInput(ctx, reader, input_impl_));\n      return Status::OK();\n    }\n\n    TraceMeMetadata GetTraceMeMetadata() const override {\n      return dataset()->traceme_metadata_;\n    }\n\n   private:\n    std::unique_ptr<IteratorBase> input_impl_;\n  };\n\n  const DatasetBase* const input_;\n  const int64_t max_intra_op_parallelism_;\n  const TraceMeMetadata traceme_metadata_;\n};\n\n/* static */\nvoid MaxIntraOpParallelismDatasetOp::MakeDatasetFromOptions(\n    OpKernelContext* ctx, DatasetBase* input, int32_t max_intra_op_parallelism,\n    DatasetBase** output) {\n  OP_REQUIRES(\n      ctx, max_intra_op_parallelism >= 0,\n      errors::InvalidArgument(\"`max_intra_op_parallelism` must be >= 0\"));\n  *output = new Dataset(DatasetContext(DatasetContext::Params(\n                            {MaxIntraOpParallelismDatasetOp::kDatasetType,\n                             MaxIntraOpParallelismDatasetOp::kDatasetOp})),\n                        input, max_intra_op_parallelism);\n}\n\nvoid MaxIntraOpParallelismDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                                 DatasetBase* input,\n                                                 DatasetBase** output) {\n  int64_t max_intra_op_parallelism;\n  OP_REQUIRES_OK(ctx,\n                 ParseScalarArgument<int64_t>(ctx, \"max_intra_op_parallelism\",\n                                              &max_intra_op_parallelism));\n  OP_REQUIRES(\n      ctx, max_intra_op_parallelism >= 0,\n      errors::InvalidArgument(\"`max_intra_op_parallelism` must be >= 0\"));\n  *output = new Dataset(ctx, input, max_intra_op_parallelism);\n}\n\nclass PrivateThreadPoolDatasetOp::Dataset : public DatasetBase {\n public:\n  Dataset(OpKernelContext* ctx, const DatasetBase* input, int num_threads)\n      : Dataset(ctx, DatasetContext(ctx), input, num_threads) {}\n\n  Dataset(OpKernelContext* ctx, DatasetContext&& dataset_ctx,\n          const DatasetBase* input, int num_threads)\n      : DatasetBase(std::move(dataset_ctx)),\n        input_(input),\n        num_threads_(num_threads == 0 ? port::MaxParallelism() : num_threads),\n        traceme_metadata_(\n            {{\"num_threads\",\n              strings::Printf(\"%lld\", static_cast<long long>(num_threads_))}}) {\n    thread_pool_ = absl::make_unique<thread::ThreadPool>(\n        ctx->env(), ThreadOptions{}, \"data_private_threadpool\", num_threads_);\n    input_->Ref();\n  }\n\n  ~Dataset() override { input_->Unref(); }\n\n  std::unique_ptr<IteratorBase> MakeIteratorInternal(\n      const string& prefix) const override {\n    return absl::make_unique<Iterator>(\n        Iterator::Params{this, strings::StrCat(prefix, \"::PrivateThreadPool\")});\n  }\n\n  const DataTypeVector& output_dtypes() const override {\n    return input_->output_dtypes();\n  }\n  const std::vector<PartialTensorShape>& output_shapes() const override {\n    return input_->output_shapes();\n  }\n\n  string DebugString() const override {\n    return \"PrivateThreadPoolDatasetOp::Dataset\";\n  }\n\n  int64_t CardinalityInternal() const override { return input_->Cardinality(); }\n\n  Status InputDatasets(std::vector<const DatasetBase*>* inputs) const override {\n    inputs->clear();\n    inputs->push_back(input_);\n    return Status::OK();\n  }\n\n  Status CheckExternalState() const override {\n    return input_->CheckExternalState();\n  }\n\n protected:\n  Status AsGraphDefInternal(SerializationContext* ctx,\n                            DatasetGraphDefBuilder* b,\n                            Node** output) const override {\n    Node* input_graph_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddInputDataset(ctx, input_, &input_graph_node));\n    Node* num_threads_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddScalar(num_threads_, &num_threads_node));\n    TF_RETURN_IF_ERROR(\n        b->AddDataset(this, {input_graph_node, num_threads_node}, output));\n    return Status::OK();\n  }\n\n private:\n  class Iterator : public DatasetIterator<Dataset> {\n   public:\n    explicit Iterator(const Params& params)\n        : DatasetIterator<Dataset>(params) {}\n\n    Status Initialize(IteratorContext* ctx) override {\n      return dataset()->input_->MakeIterator(ctx, this, prefix(), &input_impl_);\n    }\n\n    Status GetNextInternal(IteratorContext* ctx,\n                           std::vector<Tensor>* out_tensors,\n                           bool* end_of_sequence) override {\n      thread::ThreadPool* pool = dataset()->thread_pool_.get();\n      IteratorContext::Params params(ctx);\n      params.runner = [pool](std::function<void()> c) {\n        pool->Schedule(std::move(c));\n      };\n      params.runner_threadpool_size = dataset()->num_threads_;\n      return input_impl_->GetNext(IteratorContext{std::move(params)},\n                                  out_tensors, end_of_sequence);\n    }\n\n   protected:\n    std::shared_ptr<model::Node> CreateNode(\n        IteratorContext* ctx, model::Node::Args args) const override {\n      return model::MakeKnownRatioNode(std::move(args), /*ratio=*/1);\n    }\n\n    Status SaveInternal(SerializationContext* ctx,\n                        IteratorStateWriter* writer) override {\n      DCHECK(input_impl_ != nullptr);\n      TF_RETURN_IF_ERROR(SaveInput(ctx, writer, input_impl_));\n      return Status::OK();\n    }\n\n    Status RestoreInternal(IteratorContext* ctx,\n                           IteratorStateReader* reader) override {\n      TF_RETURN_IF_ERROR(RestoreInput(ctx, reader, input_impl_));\n      return Status::OK();\n    }\n\n    TraceMeMetadata GetTraceMeMetadata() const override {\n      return dataset()->traceme_metadata_;\n    }\n\n   private:\n    std::unique_ptr<IteratorBase> input_impl_;\n  };\n\n  const DatasetBase* const input_;\n  const int64_t num_threads_;\n  const TraceMeMetadata traceme_metadata_;\n  std::unique_ptr<thread::ThreadPool> thread_pool_;\n};\n\n/* static */\nvoid PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}\n\nvoid PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                             DatasetBase* input,\n                                             DatasetBase** output) {\n  int64_t num_threads = 0;\n  OP_REQUIRES_OK(\n      ctx, ParseScalarArgument<int64_t>(ctx, \"num_threads\", &num_threads));\n  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));\n  *output = new Dataset(ctx, input, num_threads);\n}\n\nnamespace {\n\nREGISTER_KERNEL_BUILDER(Name(\"MaxIntraOpParallelismDataset\").Device(DEVICE_CPU),\n                        MaxIntraOpParallelismDatasetOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"ExperimentalMaxIntraOpParallelismDataset\").Device(DEVICE_CPU),\n    MaxIntraOpParallelismDatasetOp);\n\nREGISTER_KERNEL_BUILDER(Name(\"PrivateThreadPoolDataset\").Device(DEVICE_CPU),\n                        PrivateThreadPoolDatasetOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"ExperimentalPrivateThreadPoolDataset\").Device(DEVICE_CPU),\n    PrivateThreadPoolDatasetOp);\n\nREGISTER_KERNEL_BUILDER(Name(\"ThreadPoolHandle\").Device(DEVICE_CPU),\n                        ThreadPoolHandleOp);\nREGISTER_KERNEL_BUILDER(Name(\"ExperimentalThreadPoolHandle\").Device(DEVICE_CPU),\n                        ThreadPoolHandleOp);\n\nREGISTER_KERNEL_BUILDER(Name(\"ThreadPoolDataset\").Device(DEVICE_CPU),\n                        ThreadPoolDatasetOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"ExperimentalThreadPoolDataset\").Device(DEVICE_CPU),\n    ThreadPoolDatasetOp);\n\n}  // namespace\n}  // namespace experimental\n}  // namespace data\n}  // namespace tensorflow"