"diff --git a/tensorflow/python/kernel_tests/data_structures/map_stage_op_test.py b/tensorflow/python/kernel_tests/data_structures/map_stage_op_test.py\nindex 313b5244ee1..8600ad1f8d7 100644\n--- a/tensorflow/python/kernel_tests/data_structures/map_stage_op_test.py\n+++ b/tensorflow/python/kernel_tests/data_structures/map_stage_op_test.py\n@@ -12,8 +12,11 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n # ==============================================================================\n-from tensorflow.python.framework import errors\n+import numpy as np\n+\n+from tensorflow.python.framework import constant_op\n from tensorflow.python.framework import dtypes\n+from tensorflow.python.framework import errors\n from tensorflow.python.framework import ops\n from tensorflow.python.framework import test_util\n from tensorflow.python.ops import array_ops\n@@ -28,7 +31,7 @@ class MapStageTest(test.TestCase):\n \n   @test_util.run_deprecated_v1\n   def testSimple(self):\n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.float32)\n         pi = array_ops.placeholder(dtypes.int64)\n@@ -40,9 +43,9 @@ class MapStageTest(test.TestCase):\n         k, y = stager.get(gi)\n         y = math_ops.reduce_max(math_ops.matmul(y, y))\n \n-    G.finalize()\n+    g.finalize()\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       sess.run(stage, feed_dict={x: -1, pi: 0})\n       for i in range(10):\n         _, yval = sess.run([stage, y], feed_dict={x: i, pi: i + 1, gi: i})\n@@ -50,7 +53,7 @@ class MapStageTest(test.TestCase):\n \n   @test_util.run_deprecated_v1\n   def testMultiple(self):\n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.float32)\n         pi = array_ops.placeholder(dtypes.int64)\n@@ -62,9 +65,9 @@ class MapStageTest(test.TestCase):\n         k, (z, y) = stager.get(gi)\n         y = math_ops.reduce_max(z * math_ops.matmul(y, y))\n \n-    G.finalize()\n+    g.finalize()\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       sess.run(stage, feed_dict={x: -1, pi: 0})\n       for i in range(10):\n         _, yval = sess.run([stage, y], feed_dict={x: i, pi: i + 1, gi: i})\n@@ -73,26 +76,25 @@ class MapStageTest(test.TestCase):\n \n   @test_util.run_deprecated_v1\n   def testDictionary(self):\n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.float32)\n         pi = array_ops.placeholder(dtypes.int64)\n         gi = array_ops.placeholder(dtypes.int64)\n         v = 2. * (array_ops.zeros([128, 128]) + x)\n       with ops.device(test.gpu_device_name()):\n-        stager = data_flow_ops.MapStagingArea(\n-            [dtypes.float32, dtypes.float32],\n-            shapes=[[], [128, 128]],\n-            names=['x', 'v'])\n+        stager = data_flow_ops.MapStagingArea([dtypes.float32, dtypes.float32],\n+                                              shapes=[[], [128, 128]],\n+                                              names=['x', 'v'])\n         stage = stager.put(pi, {'x': x, 'v': v})\n         key, ret = stager.get(gi)\n         z = ret['x']\n         y = ret['v']\n         y = math_ops.reduce_max(z * math_ops.matmul(y, y))\n \n-    G.finalize()\n+    g.finalize()\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       sess.run(stage, feed_dict={x: -1, pi: 0})\n       for i in range(10):\n         _, yval = sess.run([stage, y], feed_dict={x: i, pi: i + 1, gi: i})\n@@ -102,7 +104,7 @@ class MapStageTest(test.TestCase):\n   def testColocation(self):\n     gpu_dev = test.gpu_device_name()\n \n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.float32)\n         v = 2. * (array_ops.zeros([128, 128]) + x)\n@@ -119,58 +121,56 @@ class MapStageTest(test.TestCase):\n         self.assertEqual(y.device, '/device:CPU:0')\n         self.assertEqual(z[0].device, '/device:CPU:0')\n \n-    G.finalize()\n+    g.finalize()\n \n   @test_util.run_deprecated_v1\n   def testPeek(self):\n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.int32, name='x')\n         pi = array_ops.placeholder(dtypes.int64)\n         gi = array_ops.placeholder(dtypes.int64)\n         p = array_ops.placeholder(dtypes.int32, name='p')\n       with ops.device(test.gpu_device_name()):\n-        stager = data_flow_ops.MapStagingArea(\n-            [\n-                dtypes.int32,\n-            ], shapes=[[]])\n+        stager = data_flow_ops.MapStagingArea([\n+            dtypes.int32,\n+        ], shapes=[[]])\n         stage = stager.put(pi, [x], [0])\n         peek = stager.peek(gi)\n         size = stager.size()\n \n-    G.finalize()\n+    g.finalize()\n \n     n = 10\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       for i in range(n):\n         sess.run(stage, feed_dict={x: i, pi: i})\n \n       for i in range(n):\n-        self.assertTrue(sess.run(peek, feed_dict={gi: i})[0] == i)\n+        self.assertEqual(sess.run(peek, feed_dict={gi: i})[0], i)\n \n-      self.assertTrue(sess.run(size) == 10)\n+      self.assertEqual(sess.run(size), 10)\n \n   @test_util.run_deprecated_v1\n   def testSizeAndClear(self):\n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.float32, name='x')\n         pi = array_ops.placeholder(dtypes.int64)\n         gi = array_ops.placeholder(dtypes.int64)\n         v = 2. * (array_ops.zeros([128, 128]) + x)\n       with ops.device(test.gpu_device_name()):\n-        stager = data_flow_ops.MapStagingArea(\n-            [dtypes.float32, dtypes.float32],\n-            shapes=[[], [128, 128]],\n-            names=['x', 'v'])\n+        stager = data_flow_ops.MapStagingArea([dtypes.float32, dtypes.float32],\n+                                              shapes=[[], [128, 128]],\n+                                              names=['x', 'v'])\n         stage = stager.put(pi, {'x': x, 'v': v})\n         size = stager.size()\n         clear = stager.clear()\n \n-    G.finalize()\n+    g.finalize()\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       sess.run(stage, feed_dict={x: -1, pi: 3})\n       self.assertEqual(sess.run(size), 1)\n       sess.run(stage, feed_dict={x: -1, pi: 1})\n@@ -182,22 +182,23 @@ class MapStageTest(test.TestCase):\n   def testCapacity(self):\n     capacity = 3\n \n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.int32, name='x')\n         pi = array_ops.placeholder(dtypes.int64, name='pi')\n         gi = array_ops.placeholder(dtypes.int64, name='gi')\n       with ops.device(test.gpu_device_name()):\n-        stager = data_flow_ops.MapStagingArea(\n-            [\n-                dtypes.int32,\n-            ], capacity=capacity, shapes=[[]])\n+        stager = data_flow_ops.MapStagingArea([\n+            dtypes.int32,\n+        ],\n+                                              capacity=capacity,\n+                                              shapes=[[]])\n \n       stage = stager.put(pi, [x], [0])\n       get = stager.get()\n       size = stager.size()\n \n-    G.finalize()\n+    g.finalize()\n \n     from six.moves import queue as Queue\n     import threading\n@@ -205,7 +206,7 @@ class MapStageTest(test.TestCase):\n     queue = Queue.Queue()\n     n = 8\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       # Stage data in a separate thread which will block\n       # when it hits the staging area's capacity and thus\n       # not fill the queue with n tokens\n@@ -234,13 +235,13 @@ class MapStageTest(test.TestCase):\n                                              capacity))\n \n       # Should have capacity elements in the staging area\n-      self.assertTrue(sess.run(size) == capacity)\n+      self.assertEqual(sess.run(size), capacity)\n \n       # Clear the staging area completely\n       for i in range(n):\n         sess.run(get)\n \n-      self.assertTrue(sess.run(size) == 0)\n+      self.assertEqual(sess.run(size), 0)\n \n   @test_util.run_deprecated_v1\n   def testMemoryLimit(self):\n@@ -248,28 +249,28 @@ class MapStageTest(test.TestCase):\n     chunk = 200 * 1024  # 256K\n     capacity = memory_limit // chunk\n \n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.uint8, name='x')\n         pi = array_ops.placeholder(dtypes.int64, name='pi')\n         gi = array_ops.placeholder(dtypes.int64, name='gi')\n       with ops.device(test.gpu_device_name()):\n-        stager = data_flow_ops.MapStagingArea(\n-            [dtypes.uint8], memory_limit=memory_limit, shapes=[[]])\n+        stager = data_flow_ops.MapStagingArea([dtypes.uint8],\n+                                              memory_limit=memory_limit,\n+                                              shapes=[[]])\n         stage = stager.put(pi, [x], [0])\n         get = stager.get()\n         size = stager.size()\n \n-    G.finalize()\n+    g.finalize()\n \n     from six.moves import queue as Queue\n     import threading\n-    import numpy as np\n \n     queue = Queue.Queue()\n     n = 8\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       # Stage data in a separate thread which will block\n       # when it hits the staging area's capacity and thus\n       # not fill the queue with n tokens\n@@ -299,56 +300,57 @@ class MapStageTest(test.TestCase):\n                                              capacity))\n \n       # Should have capacity elements in the staging area\n-      self.assertTrue(sess.run(size) == capacity)\n+      self.assertEqual(sess.run(size), capacity)\n \n       # Clear the staging area completely\n       for i in range(n):\n         sess.run(get)\n \n-      self.assertTrue(sess.run(size) == 0)\n+      self.assertEqual(sess.run(size), 0)\n \n   @test_util.run_deprecated_v1\n   def testOrdering(self):\n     import six\n     import random\n \n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.int32, name='x')\n         pi = array_ops.placeholder(dtypes.int64, name='pi')\n         gi = array_ops.placeholder(dtypes.int64, name='gi')\n       with ops.device(test.gpu_device_name()):\n-        stager = data_flow_ops.MapStagingArea(\n-            [\n-                dtypes.int32,\n-            ], shapes=[[]], ordered=True)\n+        stager = data_flow_ops.MapStagingArea([\n+            dtypes.int32,\n+        ],\n+                                              shapes=[[]],\n+                                              ordered=True)\n         stage = stager.put(pi, [x], [0])\n         get = stager.get()\n         size = stager.size()\n \n-    G.finalize()\n+    g.finalize()\n \n     n = 10\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       # Keys n-1..0\n       keys = list(reversed(six.moves.range(n)))\n \n       for i in keys:\n         sess.run(stage, feed_dict={pi: i, x: i})\n \n-      self.assertTrue(sess.run(size) == n)\n+      self.assertEqual(sess.run(size), n)\n \n       # Check that key, values come out in ascending order\n       for i, k in enumerate(reversed(keys)):\n         get_key, values = sess.run(get)\n         self.assertTrue(i == k == get_key == values)\n \n-      self.assertTrue(sess.run(size) == 0)\n+      self.assertEqual(sess.run(size), 0)\n \n   @test_util.run_deprecated_v1\n   def testPartialDictInsert(self):\n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.float32)\n         f = array_ops.placeholder(dtypes.float32)\n@@ -366,41 +368,39 @@ class MapStageTest(test.TestCase):\n         size = stager.size()\n         isize = stager.incomplete_size()\n \n-    G.finalize()\n+    g.finalize()\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       # 0 complete and incomplete entries\n-      self.assertTrue(sess.run([size, isize]) == [0, 0])\n+      self.assertEqual(sess.run([size, isize]), [0, 0])\n       # Stage key 0, x and f tuple entries\n       sess.run(stage_xf, feed_dict={pi: 0, x: 1, f: 2})\n-      self.assertTrue(sess.run([size, isize]) == [0, 1])\n+      self.assertEqual(sess.run([size, isize]), [0, 1])\n       # Stage key 1, x and f tuple entries\n       sess.run(stage_xf, feed_dict={pi: 1, x: 1, f: 2})\n-      self.assertTrue(sess.run([size, isize]) == [0, 2])\n+      self.assertEqual(sess.run([size, isize]), [0, 2])\n \n       # Now complete key 0 with tuple entry v\n       sess.run(stage_v, feed_dict={pi: 0, v: 1})\n       # 1 complete and 1 incomplete entry\n-      self.assertTrue(sess.run([size, isize]) == [1, 1])\n+      self.assertEqual(sess.run([size, isize]), [1, 1])\n       # We can now obtain tuple associated with key 0\n-      self.assertTrue(\n-          sess.run([key, ret], feed_dict={\n-              gi: 0\n-          }) == [0, {\n+      self.assertEqual(\n+          sess.run([key, ret], feed_dict={gi: 0}),\n+          [0, {\n               'x': 1,\n               'f': 2,\n               'v': 1\n           }])\n \n       # 0 complete and 1 incomplete entry\n-      self.assertTrue(sess.run([size, isize]) == [0, 1])\n+      self.assertEqual(sess.run([size, isize]), [0, 1])\n       # Now complete key 1 with tuple entry v\n       sess.run(stage_v, feed_dict={pi: 1, v: 3})\n       # We can now obtain tuple associated with key 1\n-      self.assertTrue(\n-          sess.run([key, ret], feed_dict={\n-              gi: 1\n-          }) == [1, {\n+      self.assertEqual(\n+          sess.run([key, ret], feed_dict={gi: 1}),\n+          [1, {\n               'x': 1,\n               'f': 2,\n               'v': 3\n@@ -408,7 +408,7 @@ class MapStageTest(test.TestCase):\n \n   @test_util.run_deprecated_v1\n   def testPartialIndexInsert(self):\n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.float32)\n         f = array_ops.placeholder(dtypes.float32)\n@@ -424,35 +424,35 @@ class MapStageTest(test.TestCase):\n         size = stager.size()\n         isize = stager.incomplete_size()\n \n-    G.finalize()\n+    g.finalize()\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       # 0 complete and incomplete entries\n-      self.assertTrue(sess.run([size, isize]) == [0, 0])\n+      self.assertEqual(sess.run([size, isize]), [0, 0])\n       # Stage key 0, x and f tuple entries\n       sess.run(stage_xf, feed_dict={pi: 0, x: 1, f: 2})\n-      self.assertTrue(sess.run([size, isize]) == [0, 1])\n+      self.assertEqual(sess.run([size, isize]), [0, 1])\n       # Stage key 1, x and f tuple entries\n       sess.run(stage_xf, feed_dict={pi: 1, x: 1, f: 2})\n-      self.assertTrue(sess.run([size, isize]) == [0, 2])\n+      self.assertEqual(sess.run([size, isize]), [0, 2])\n \n       # Now complete key 0 with tuple entry v\n       sess.run(stage_v, feed_dict={pi: 0, v: 1})\n       # 1 complete and 1 incomplete entry\n-      self.assertTrue(sess.run([size, isize]) == [1, 1])\n+      self.assertEqual(sess.run([size, isize]), [1, 1])\n       # We can now obtain tuple associated with key 0\n-      self.assertTrue(sess.run([key, ret], feed_dict={gi: 0}) == [0, [1, 1, 2]])\n+      self.assertEqual(sess.run([key, ret], feed_dict={gi: 0}), [0, [1, 1, 2]])\n \n       # 0 complete and 1 incomplete entry\n-      self.assertTrue(sess.run([size, isize]) == [0, 1])\n+      self.assertEqual(sess.run([size, isize]), [0, 1])\n       # Now complete key 1 with tuple entry v\n       sess.run(stage_v, feed_dict={pi: 1, v: 3})\n       # We can now obtain tuple associated with key 1\n-      self.assertTrue(sess.run([key, ret], feed_dict={gi: 1}) == [1, [1, 3, 2]])\n+      self.assertEqual(sess.run([key, ret], feed_dict={gi: 1}), [1, [1, 3, 2]])\n \n   @test_util.run_deprecated_v1\n   def testPartialDictGetsAndPeeks(self):\n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.float32)\n         f = array_ops.placeholder(dtypes.float32)\n@@ -476,40 +476,38 @@ class MapStageTest(test.TestCase):\n         size = stager.size()\n         isize = stager.incomplete_size()\n \n-    G.finalize()\n+    g.finalize()\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       # 0 complete and incomplete entries\n-      self.assertTrue(sess.run([size, isize]) == [0, 0])\n+      self.assertEqual(sess.run([size, isize]), [0, 0])\n       # Stage key 0, x and f tuple entries\n       sess.run(stage_xf, feed_dict={pi: 0, x: 1, f: 2})\n-      self.assertTrue(sess.run([size, isize]) == [0, 1])\n+      self.assertEqual(sess.run([size, isize]), [0, 1])\n       # Stage key 1, x and f tuple entries\n       sess.run(stage_xf, feed_dict={pi: 1, x: 1, f: 2})\n-      self.assertTrue(sess.run([size, isize]) == [0, 2])\n+      self.assertEqual(sess.run([size, isize]), [0, 2])\n \n       # Now complete key 0 with tuple entry v\n       sess.run(stage_v, feed_dict={pi: 0, v: 1})\n       # 1 complete and 1 incomplete entry\n-      self.assertTrue(sess.run([size, isize]) == [1, 1])\n+      self.assertEqual(sess.run([size, isize]), [1, 1])\n \n       # We can now peek at 'x' and 'f' values associated with key 0\n-      self.assertTrue(sess.run(peek_xf, feed_dict={pei: 0}) == {'x': 1, 'f': 2})\n+      self.assertEqual(sess.run(peek_xf, feed_dict={pei: 0}), {'x': 1, 'f': 2})\n       # Peek at 'v' value associated with key 0\n-      self.assertTrue(sess.run(peek_v, feed_dict={pei: 0}) == {'v': 1})\n+      self.assertEqual(sess.run(peek_v, feed_dict={pei: 0}), {'v': 1})\n       # 1 complete and 1 incomplete entry\n-      self.assertTrue(sess.run([size, isize]) == [1, 1])\n+      self.assertEqual(sess.run([size, isize]), [1, 1])\n \n       # We can now obtain 'x' and 'f' values associated with key 0\n-      self.assertTrue(\n-          sess.run([key_xf, get_xf], feed_dict={\n-              gi: 0\n-          }) == [0, {\n+      self.assertEqual(\n+          sess.run([key_xf, get_xf], feed_dict={gi: 0}), [0, {\n               'x': 1,\n               'f': 2\n           }])\n       # Still have 1 complete and 1 incomplete entry\n-      self.assertTrue(sess.run([size, isize]) == [1, 1])\n+      self.assertEqual(sess.run([size, isize]), [1, 1])\n \n       # We can no longer get 'x' and 'f' from key 0\n       with self.assertRaises(errors.InvalidArgumentError) as cm:\n@@ -517,40 +515,36 @@ class MapStageTest(test.TestCase):\n \n       exc_str = (\"Tensor at index '0' for key '0' \" 'has already been removed.')\n \n-      self.assertTrue(exc_str in cm.exception.message)\n+      self.assertIn(exc_str, cm.exception.message)\n \n       # Obtain 'v' value associated with key 0\n-      self.assertTrue(\n-          sess.run([key_v, get_v], feed_dict={\n-              gi: 0\n-          }) == [0, {\n+      self.assertEqual(\n+          sess.run([key_v, get_v], feed_dict={gi: 0}), [0, {\n               'v': 1\n           }])\n       # 0 complete and 1 incomplete entry\n-      self.assertTrue(sess.run([size, isize]) == [0, 1])\n+      self.assertEqual(sess.run([size, isize]), [0, 1])\n \n       # Now complete key 1 with tuple entry v\n       sess.run(stage_v, feed_dict={pi: 1, v: 1})\n       # 1 complete and 1 incomplete entry\n-      self.assertTrue(sess.run([size, isize]) == [1, 0])\n+      self.assertEqual(sess.run([size, isize]), [1, 0])\n \n       # Pop without key to obtain 'x' and 'f' values associated with key 1\n-      self.assertTrue(sess.run([pop_key_xf, pop_xf]) == [1, {'x': 1, 'f': 2}])\n+      self.assertEqual(sess.run([pop_key_xf, pop_xf]), [1, {'x': 1, 'f': 2}])\n       # still 1 complete and 1 incomplete entry\n-      self.assertTrue(sess.run([size, isize]) == [1, 0])\n+      self.assertEqual(sess.run([size, isize]), [1, 0])\n       # We can now obtain 'x' and 'f' values associated with key 1\n-      self.assertTrue(\n-          sess.run([pop_key_v, pop_v], feed_dict={\n-              pi: 1\n-          }) == [1, {\n+      self.assertEqual(\n+          sess.run([pop_key_v, pop_v], feed_dict={pi: 1}), [1, {\n               'v': 1\n           }])\n       # Nothing is left\n-      self.assertTrue(sess.run([size, isize]) == [0, 0])\n+      self.assertEqual(sess.run([size, isize]), [0, 0])\n \n   @test_util.run_deprecated_v1\n   def testPartialIndexGets(self):\n-    with ops.Graph().as_default() as G:\n+    with ops.Graph().as_default() as g:\n       with ops.device('/cpu:0'):\n         x = array_ops.placeholder(dtypes.float32)\n         f = array_ops.placeholder(dtypes.float32)\n@@ -568,28 +562,72 @@ class MapStageTest(test.TestCase):\n         size = stager.size()\n         isize = stager.incomplete_size()\n \n-    G.finalize()\n+    g.finalize()\n \n-    with self.session(graph=G) as sess:\n+    with self.session(graph=g) as sess:\n       # Stage complete tuple\n       sess.run(stage_xvf, feed_dict={pi: 0, x: 1, f: 2, v: 3})\n \n-      self.assertTrue(sess.run([size, isize]) == [1, 0])\n+      self.assertEqual(sess.run([size, isize]), [1, 0])\n \n       # Partial get using indices\n-      self.assertTrue(\n-          sess.run([key_xf, get_xf], feed_dict={\n-              gi: 0\n-          }) == [0, [1, 2]])\n+      self.assertEqual(\n+          sess.run([key_xf, get_xf], feed_dict={gi: 0}), [0, [1, 2]])\n \n       # Still some of key 0 left\n-      self.assertTrue(sess.run([size, isize]) == [1, 0])\n+      self.assertEqual(sess.run([size, isize]), [1, 0])\n \n       # Partial get of remaining index\n-      self.assertTrue(sess.run([key_v, get_v], feed_dict={gi: 0}) == [0, [3]])\n+      self.assertEqual(sess.run([key_v, get_v], feed_dict={gi: 0}), [0, [3]])\n \n       # All gone\n-      self.assertTrue(sess.run([size, isize]) == [0, 0])\n+      self.assertEqual(sess.run([size, isize]), [0, 0])\n+\n+  @test_util.run_deprecated_v1\n+  def testNonScalarKeyOrderedMap(self):\n+    with ops.Graph().as_default() as g:\n+      x = array_ops.placeholder(dtypes.float32)\n+      v = 2. * (array_ops.zeros([128, 128]) + x)\n+      t = data_flow_ops.gen_data_flow_ops.ordered_map_stage(\n+          key=constant_op.constant(value=[1], shape=(1, 3), dtype=dtypes.int64),\n+          indices=np.array([[6]]),\n+          values=[x, v],\n+          dtypes=[dtypes.int64],\n+          capacity=0,\n+          memory_limit=0,\n+          container='container1',\n+          shared_name='',\n+          name=None)\n+\n+    g.finalize()\n+\n+    with self.session(graph=g) as sess:\n+      with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                  'key must be an int64 scalar'):\n+        sess.run(t, feed_dict={x: 1})\n+\n+  @test_util.run_deprecated_v1\n+  def testNonScalarKeyUnorderedMap(self):\n+    with ops.Graph().as_default() as g:\n+      x = array_ops.placeholder(dtypes.float32)\n+      v = 2. * (array_ops.zeros([128, 128]) + x)\n+      t = data_flow_ops.gen_data_flow_ops.map_stage(\n+          key=constant_op.constant(value=[1], shape=(1, 3), dtype=dtypes.int64),\n+          indices=np.array([[6]]),\n+          values=[x, v],\n+          dtypes=[dtypes.int64],\n+          capacity=0,\n+          memory_limit=0,\n+          container='container1',\n+          shared_name='',\n+          name=None)\n+\n+    g.finalize()\n+\n+    with self.session(graph=g) as sess:\n+      with self.assertRaisesRegex(errors.InvalidArgumentError,\n+                                  'key must be an int64 scalar'):\n+        sess.run(t, feed_dict={x: 1})\n \n \n if __name__ == '__main__':"