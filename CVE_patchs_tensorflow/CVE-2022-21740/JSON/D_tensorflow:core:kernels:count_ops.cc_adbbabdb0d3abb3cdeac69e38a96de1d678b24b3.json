"diff --git a/tensorflow/core/kernels/count_ops.cc b/tensorflow/core/kernels/count_ops.cc\nindex 1f99e0783e2..cc101b66f81 100644\n--- a/tensorflow/core/kernels/count_ops.cc\n+++ b/tensorflow/core/kernels/count_ops.cc\n@@ -206,6 +206,23 @@ class SparseCount : public OpKernel {\n     OP_REQUIRES(context, shape.NumElements() > 0,\n                 errors::InvalidArgument(\n                     \"The shape argument requires at least one element.\"));\n+    // Validate indices: each index must be valid for the corresponding\n+    // dimension. This could be possibly done better.\n+    const auto indices_values = indices.matrix<int64_t>();\n+    const auto shape_vector = shape.vec<int64_t>();\n+    int num_values = values.NumElements();  // same as first dim of indices\n+    int rank = indices.shape().dim_size(1);\n+    for (int i = 0; i < num_values; ++i) {\n+      for (int j = 0; j < rank; ++j) {\n+        OP_REQUIRES(\n+            context,\n+            indices_values(i, j) >= 0 && indices_values(i, j) < shape_vector(j),\n+            errors::InvalidArgument(\n+                \"Invalid index value at \", i, \": dimension \", j, \" has value \",\n+                indices_values(i, j), \" which is not in [0, \", shape_vector(j),\n+                \") (as given by dense shape \", shape.DebugString()));\n+      }\n+    }\n \n     if (use_weights) {\n       OP_REQUIRES(\n@@ -217,11 +234,8 @@ class SparseCount : public OpKernel {\n     }\n \n     bool is_1d = shape.NumElements() == 1;\n-    auto shape_vector = shape.flat<int64_t>();\n     int num_batches = is_1d ? 1 : shape_vector(0);\n-    int num_values = values.NumElements();\n \n-    const auto indices_values = indices.matrix<int64_t>();\n     const auto values_values = values.flat<T>();\n     const auto weight_values = weights.flat<W>();\n "