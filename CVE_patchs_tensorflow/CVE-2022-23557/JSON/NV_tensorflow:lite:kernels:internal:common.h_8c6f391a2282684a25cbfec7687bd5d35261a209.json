"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#ifndef TENSORFLOW_LITE_KERNELS_INTERNAL_COMMON_H_\n#define TENSORFLOW_LITE_KERNELS_INTERNAL_COMMON_H_\n\n#ifndef ALLOW_SLOW_GENERIC_DEPTHWISECONV_FALLBACK\n#ifdef GEMMLOWP_ALLOW_SLOW_SCALAR_FALLBACK\n#define ALLOW_SLOW_GENERIC_DEPTHWISECONV_FALLBACK\n#endif\n#endif\n\n#include <functional>\n\n#include \"fixedpoint/fixedpoint.h\"\n#include \"tensorflow/lite/kernels/internal/cppmath.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/neon_check.h\"\n#include \"tensorflow/lite/kernels/internal/types.h\"\n\nnamespace tflite {\n\nconstexpr int kReverseShift = -1;\n\ninline void GetActivationMinMax(FusedActivationFunctionType ac,\n                                float* output_activation_min,\n                                float* output_activation_max) {\n  switch (ac) {\n    case FusedActivationFunctionType::kNone:\n      *output_activation_min = std::numeric_limits<float>::lowest();\n      *output_activation_max = std::numeric_limits<float>::max();\n      break;\n    case FusedActivationFunctionType::kRelu:\n      *output_activation_min = 0.f;\n      *output_activation_max = std::numeric_limits<float>::max();\n      break;\n    case FusedActivationFunctionType::kRelu1:\n      *output_activation_min = -1.f;\n      *output_activation_max = 1.f;\n      break;\n    case FusedActivationFunctionType::kRelu6:\n      *output_activation_min = 0.f;\n      *output_activation_max = 6.f;\n      break;\n  }\n}\n\ntemplate <typename T>\ninline T ActivationFunctionWithMinMax(T x, T output_activation_min,\n                                      T output_activation_max) {\n  using std::max;\n  using std::min;\n  return min(max(x, output_activation_min), output_activation_max);\n}\n\n// Legacy function, left for compatibility only.\ntemplate <FusedActivationFunctionType Ac>\nfloat ActivationFunction(float x) {\n  float output_activation_min, output_activation_max;\n  GetActivationMinMax(Ac, &output_activation_min, &output_activation_max);\n  return ActivationFunctionWithMinMax(x, output_activation_min,\n                                      output_activation_max);\n}\n\ninline void BiasAndClamp(float clamp_min, float clamp_max, int bias_size,\n                         const float* bias_data, int array_size,\n                         float* array_data) {\n  if (bias_size == 0) return;\n  // Note: see b/132215220: in May 2019 we thought it would be OK to replace\n  // this with the Eigen one-liner:\n  //   return (array.colwise() + bias).cwiseMin(clamp_max).cwiseMin(clamp_max).\n  // This turned out to severely regress performance: +4ms (i.e. 8%) on\n  // MobileNet v2 / 1.0 / 224. So we keep custom NEON code for now.\n  TFLITE_DCHECK_EQ((array_size % bias_size), 0);\n#ifdef USE_NEON\n  float* array_ptr = array_data;\n  float* array_end_ptr = array_ptr + array_size;\n  const auto clamp_min_vec = vdupq_n_f32(clamp_min);\n  const auto clamp_max_vec = vdupq_n_f32(clamp_max);\n  for (; array_ptr != array_end_ptr; array_ptr += bias_size) {\n    int i = 0;\n    for (; i <= bias_size - 16; i += 16) {\n      auto b0 = vld1q_f32(bias_data + i);\n      auto b1 = vld1q_f32(bias_data + i + 4);\n      auto b2 = vld1q_f32(bias_data + i + 8);\n      auto b3 = vld1q_f32(bias_data + i + 12);\n      auto a0 = vld1q_f32(array_ptr + i);\n      auto a1 = vld1q_f32(array_ptr + i + 4);\n      auto a2 = vld1q_f32(array_ptr + i + 8);\n      auto a3 = vld1q_f32(array_ptr + i + 12);\n      auto x0 = vaddq_f32(a0, b0);\n      auto x1 = vaddq_f32(a1, b1);\n      auto x2 = vaddq_f32(a2, b2);\n      auto x3 = vaddq_f32(a3, b3);\n      x0 = vmaxq_f32(clamp_min_vec, x0);\n      x1 = vmaxq_f32(clamp_min_vec, x1);\n      x2 = vmaxq_f32(clamp_min_vec, x2);\n      x3 = vmaxq_f32(clamp_min_vec, x3);\n      x0 = vminq_f32(clamp_max_vec, x0);\n      x1 = vminq_f32(clamp_max_vec, x1);\n      x2 = vminq_f32(clamp_max_vec, x2);\n      x3 = vminq_f32(clamp_max_vec, x3);\n      vst1q_f32(array_ptr + i, x0);\n      vst1q_f32(array_ptr + i + 4, x1);\n      vst1q_f32(array_ptr + i + 8, x2);\n      vst1q_f32(array_ptr + i + 12, x3);\n    }\n    for (; i <= bias_size - 4; i += 4) {\n      auto b = vld1q_f32(bias_data + i);\n      auto a = vld1q_f32(array_ptr + i);\n      auto x = vaddq_f32(a, b);\n      x = vmaxq_f32(clamp_min_vec, x);\n      x = vminq_f32(clamp_max_vec, x);\n      vst1q_f32(array_ptr + i, x);\n    }\n    for (; i < bias_size; i++) {\n      array_ptr[i] = ActivationFunctionWithMinMax(array_ptr[i] + bias_data[i],\n                                                  clamp_min, clamp_max);\n    }\n  }\n#else  // not NEON\n  for (int array_offset = 0; array_offset < array_size;\n       array_offset += bias_size) {\n    for (int i = 0; i < bias_size; i++) {\n      array_data[array_offset + i] = ActivationFunctionWithMinMax(\n          array_data[array_offset + i] + bias_data[i], clamp_min, clamp_max);\n    }\n  }\n#endif\n}\n\n// Single-rounding MultiplyByQuantizedMultiplier\n#if TFLITE_SINGLE_ROUNDING\ninline int32_t MultiplyByQuantizedMultiplier(int32_t x,\n                                             int32_t quantized_multiplier,\n                                             int shift) {\n  TFLITE_DCHECK(quantized_multiplier >= 0);\n  TFLITE_DCHECK(shift >= -31 && shift <= 30);\n\n  const int64_t total_shift = 31 - shift;\n  const int64_t round = static_cast<int64_t>(1) << (total_shift - 1);\n  int64_t result = x * static_cast<int64_t>(quantized_multiplier) + round;\n  result = result >> total_shift;\n\n  TFLITE_DCHECK(result >= std::numeric_limits<int32_t>::min() &&\n                result <= std::numeric_limits<int32_t>::max());\n  return static_cast<int32_t>(result);\n}\n\ninline int32_t MultiplyByQuantizedMultiplierSmallerThanOneExp(\n    int32_t x, int32_t quantized_multiplier, int shift) {\n  TFLITE_DCHECK_LE(shift, 0);\n  return MultiplyByQuantizedMultiplier(x, quantized_multiplier, shift);\n}\n\ninline int32_t MultiplyByQuantizedMultiplierGreaterThanOne(\n    int32_t x, int32_t quantized_multiplier, int shift) {\n  TFLITE_DCHECK_GE(shift, 0);\n  return MultiplyByQuantizedMultiplier(x, quantized_multiplier, shift);\n}\n\ninline int32_t MultiplyByQuantizedMultiplier(int64_t x,\n                                             int32_t quantized_multiplier,\n                                             int shift) {\n  // Inputs:\n  // - quantized_multiplier has fixed point at bit 31\n  // - shift is -31 to +7 (negative for right shift)\n  //\n  // Assumptions: The following input ranges are assumed\n  // - quantize_scale>=0  (the usual range is (1<<30) to (1>>31)-1)\n  // - scaling is chosen so final scaled result fits in int32_t\n  // - input x is in the range -(1<<47) <= x < (1<<47)\n  TFLITE_DCHECK(quantized_multiplier >= 0);\n  TFLITE_DCHECK(shift >= -31 && shift < 8);\n  TFLITE_DCHECK(x >= -(static_cast<int64_t>(1) << 47) &&\n                x < (static_cast<int64_t>(1) << 47));\n\n  const int32_t reduced_multiplier =\n      (quantized_multiplier < 0x7FFF0000)\n          ? ((quantized_multiplier + (1 << 15)) >> 16)\n          : 0x7FFF;\n  const int64_t total_shift = 15 - shift;\n  const int64_t round = static_cast<int64_t>(1) << (total_shift - 1);\n  int64_t result = x * static_cast<int64_t>(reduced_multiplier) + round;\n  result = result >> total_shift;\n\n  TFLITE_DCHECK(result >= std::numeric_limits<int32_t>::min() &&\n                result <= std::numeric_limits<int32_t>::max());\n  return static_cast<int32_t>(result);\n}\n\n#ifdef USE_NEON\ninline int32x4x4_t MultiplyByQuantizedMultiplier4Rows(\n    int32x4x4_t input_val, int32_t quantized_multiplier, int shift) {\n  TFLITE_DCHECK(quantized_multiplier >= 0);\n\n  const int right_shift = std::min(-1, shift);\n  const int left_shift = shift - right_shift;\n\n  const int32x4_t multiplier_dup = vdupq_n_s32(quantized_multiplier);\n  const int32x4_t left_shift_dup = vdupq_n_s32(left_shift);\n  const int32x4_t right_shift_dup = vdupq_n_s32(right_shift);\n\n  int32x4x4_t result;\n  result.val[0] = vrshlq_s32(\n      vqdmulhq_s32(vshlq_s32(input_val.val[0], left_shift_dup), multiplier_dup),\n      right_shift_dup);\n\n  result.val[1] = vrshlq_s32(\n      vqdmulhq_s32(vshlq_s32(input_val.val[1], left_shift_dup), multiplier_dup),\n      right_shift_dup);\n\n  result.val[2] = vrshlq_s32(\n      vqdmulhq_s32(vshlq_s32(input_val.val[2], left_shift_dup), multiplier_dup),\n      right_shift_dup);\n\n  result.val[3] = vrshlq_s32(\n      vqdmulhq_s32(vshlq_s32(input_val.val[3], left_shift_dup), multiplier_dup),\n      right_shift_dup);\n\n  return result;\n}\n#endif  // USE_NEON\n// Double-rounding MultiplyByQuantizedMultiplier\n#else\ninline int32_t MultiplyByQuantizedMultiplierSmallerThanOneExp(\n    int32_t x, int32_t quantized_multiplier, int left_shift) {\n  using gemmlowp::RoundingDivideByPOT;\n  using gemmlowp::SaturatingRoundingDoublingHighMul;\n  return RoundingDivideByPOT(\n      SaturatingRoundingDoublingHighMul(x, quantized_multiplier), -left_shift);\n}\n\ninline int32_t MultiplyByQuantizedMultiplierGreaterThanOne(\n    int32_t x, int32_t quantized_multiplier, int left_shift) {\n  using gemmlowp::SaturatingRoundingDoublingHighMul;\n  return SaturatingRoundingDoublingHighMul(x * (1 << left_shift),\n                                           quantized_multiplier);\n}\n\ninline int32_t MultiplyByQuantizedMultiplier(int32_t x,\n                                             int32_t quantized_multiplier,\n                                             int shift) {\n  using gemmlowp::RoundingDivideByPOT;\n  using gemmlowp::SaturatingRoundingDoublingHighMul;\n  int left_shift = shift > 0 ? shift : 0;\n  int right_shift = shift > 0 ? 0 : -shift;\n  return RoundingDivideByPOT(SaturatingRoundingDoublingHighMul(\n                                 x * (1 << left_shift), quantized_multiplier),\n                             right_shift);\n}\n\ninline int32_t MultiplyByQuantizedMultiplier(int64_t x,\n                                             int32_t quantized_multiplier,\n                                             int shift) {\n  // Inputs:\n  // - quantized_multiplier has fixed point at bit 31\n  // - shift is -31 to +7 (negative for right shift)\n  //\n  // Assumptions: The following input ranges are assumed\n  // - quantize_scale>=0  (the usual range is (1<<30) to (1>>31)-1)\n  // - scaling is chosen so final scaled result fits in int32_t\n  // - input x is in the range -(1<<47) <= x < (1<<47)\n  assert(quantized_multiplier >= 0);\n  assert(shift >= -31 && shift < 8);\n  assert(x >= -(static_cast<int64_t>(1) << 47) &&\n         x < (static_cast<int64_t>(1) << 47));\n\n  int32_t reduced_multiplier = (quantized_multiplier < 0x7FFF0000)\n                                   ? ((quantized_multiplier + (1 << 15)) >> 16)\n                                   : 0x7FFF;\n  int total_shift = 15 - shift;\n  x = (x * (int64_t)reduced_multiplier) + ((int64_t)1 << (total_shift - 1));\n  int32_t result = x >> total_shift;\n  return result;\n}\n\n#ifdef USE_NEON\n// Round uses ARM's rounding shift right.\ninline int32x4x4_t MultiplyByQuantizedMultiplier4Rows(\n    int32x4x4_t input_val, int32_t quantized_multiplier, int shift) {\n  const int left_shift = std::max(shift, 0);\n  const int right_shift = std::min(shift, 0);\n  int32x4x4_t result;\n\n  int32x4_t multiplier_dup = vdupq_n_s32(quantized_multiplier);\n  int32x4_t left_shift_dup = vdupq_n_s32(left_shift);\n  int32x4_t right_shift_dup = vdupq_n_s32(right_shift);\n\n  result.val[0] =\n      vrshlq_s32(vqrdmulhq_s32(vshlq_s32(input_val.val[0], left_shift_dup),\n                               multiplier_dup),\n                 right_shift_dup);\n\n  result.val[1] =\n      vrshlq_s32(vqrdmulhq_s32(vshlq_s32(input_val.val[1], left_shift_dup),\n                               multiplier_dup),\n                 right_shift_dup);\n\n  result.val[2] =\n      vrshlq_s32(vqrdmulhq_s32(vshlq_s32(input_val.val[2], left_shift_dup),\n                               multiplier_dup),\n                 right_shift_dup);\n\n  result.val[3] =\n      vrshlq_s32(vqrdmulhq_s32(vshlq_s32(input_val.val[3], left_shift_dup),\n                               multiplier_dup),\n                 right_shift_dup);\n\n  return result;\n}\n#endif  // USE_NEON\n#endif  // TFLITE_SINGLE_ROUNDING\n\ntemplate <typename T>\nint CountLeadingZeros(T integer_input) {\n  static_assert(std::is_unsigned<T>::value,\n                \"Only unsigned integer types handled.\");\n#if defined(__GNUC__)\n  return integer_input ? __builtin_clz(integer_input)\n                       : std::numeric_limits<T>::digits;\n#else\n  if (integer_input == 0) {\n    return std::numeric_limits<T>::digits;\n  }\n\n  const T one_in_leading_positive = static_cast<T>(1)\n                                    << (std::numeric_limits<T>::digits - 1);\n  int leading_zeros = 0;\n  while (integer_input < one_in_leading_positive) {\n    integer_input <<= 1;\n    ++leading_zeros;\n  }\n  return leading_zeros;\n#endif\n}\n\ntemplate <typename T>\ninline int CountLeadingSignBits(T integer_input) {\n  static_assert(std::is_signed<T>::value, \"Only signed integer types handled.\");\n#if defined(__GNUC__) && !defined(__clang__)\n  return integer_input ? __builtin_clrsb(integer_input)\n                       : std::numeric_limits<T>::digits;\n#else\n  using U = typename std::make_unsigned<T>::type;\n  return integer_input >= 0\n             ? CountLeadingZeros(static_cast<U>(integer_input)) - 1\n         : integer_input != std::numeric_limits<T>::min()\n             ? CountLeadingZeros(2 * static_cast<U>(-integer_input) - 1)\n             : 0;\n#endif\n}\n\n// Use \"count leading zeros\" helper functions to do a fast Floor(log_2(x)).\ntemplate <typename Integer>\ninline Integer FloorLog2(Integer n) {\n  static_assert(std::is_integral<Integer>::value, \"\");\n  static_assert(std::is_signed<Integer>::value, \"\");\n  static_assert(sizeof(Integer) == 4 || sizeof(Integer) == 8, \"\");\n  TFLITE_CHECK_GT(n, 0);\n  if (sizeof(Integer) == 4) {\n    return 30 - CountLeadingSignBits(n);\n  } else {\n    return 62 - CountLeadingSignBits(n);\n  }\n}\n\n// The size of the LUT depends on the type of input. For int8 inputs a simple\n// 256 entries LUT is used. For int16 inputs the high 9 bits are used for\n// indexing and the 7 remaining bits are used for interpolation. We thus use a\n// 513-entries LUT for int16 cases, 512 for the 9-bit indexing and 1 extra entry\n// to interpolate the last value.\ntemplate <typename LutInT>\nconstexpr int lut_size() {\n  static_assert(std::is_same<LutInT, int8_t>::value ||\n                    std::is_same<LutInT, int16_t>::value,\n                \"Only LUTs with int8 or int16 inputs are supported.\");\n  return std::is_same<LutInT, int8_t>::value ? 256 : 513;\n}\n\n// Generate a LUT for 'func' which can be used to approximate functions like\n// exp, log, ...\n//\n// - func: the function to build the LUT for (e.g exp(x))\n// - input_min, input_max: range of the func inputs\n// - output_min, output_max: range of the func outputs\n// - lut: pointer to the LUT table to fill, the table must be of size\n// lut_size<LutInT>()\ntemplate <typename FloatT, typename LutInT, typename LutOutT>\ninline void gen_lut(FloatT (*func)(FloatT), FloatT input_min, FloatT input_max,\n                    FloatT output_min, FloatT output_max, LutOutT* lut) {\n  static_assert(std::is_same<LutInT, int8_t>::value ||\n                    std::is_same<LutInT, int16_t>::value,\n                \"Only LUTs with int8 or int16 inputs are supported.\");\n  static_assert(std::is_same<LutOutT, int8_t>::value ||\n                    std::is_same<LutOutT, int16_t>::value,\n                \"Only LUTs with int8 or int16 outputs are supported.\");\n  static_assert(std::is_floating_point<FloatT>::value,\n                \"FloatT must be a floating-point type.\");\n\n  const int nb_steps = std::is_same<LutInT, int8_t>::value ? 256 : 512;\n  const FloatT step = (input_max - input_min) / nb_steps;\n  const FloatT half_step = step / 2;\n  const FloatT output_scaling_inv =\n      static_cast<FloatT>(std::numeric_limits<LutOutT>::max() -\n                          std::numeric_limits<LutOutT>::min() + 1) /\n      (output_max - output_min);\n  const FloatT table_min =\n      static_cast<FloatT>(std::numeric_limits<LutOutT>::min());\n  const FloatT table_max =\n      static_cast<FloatT>(std::numeric_limits<LutOutT>::max());\n\n  for (int i = 0; i < nb_steps; i++) {\n    const FloatT val = func(input_min + i * step);\n    const FloatT val_midpoint = func(input_min + i * step + half_step);\n    const FloatT val_next = func(input_min + (i + 1) * step);\n\n    const FloatT sample_val = TfLiteRound(val * output_scaling_inv);\n    const FloatT midpoint_interp_val =\n        TfLiteRound((val_next * output_scaling_inv +\n                     TfLiteRound(val * output_scaling_inv)) /\n                    2);\n    const FloatT midpoint_val = TfLiteRound(val_midpoint * output_scaling_inv);\n    const FloatT midpoint_err = midpoint_interp_val - midpoint_val;\n    const FloatT bias = TfLiteRound(midpoint_err / 2);\n\n    lut[i] = static_cast<LutOutT>(std::min<FloatT>(\n        std::max<FloatT>(sample_val - bias, table_min), table_max));\n  }\n\n  const bool with_extra_interpolation_value =\n      std::is_same<LutInT, int16_t>::value;\n  if (with_extra_interpolation_value) {\n    lut[nb_steps] = static_cast<LutOutT>(std::min<FloatT>(\n        std::max<FloatT>(TfLiteRound(func(input_max) * output_scaling_inv),\n                         table_min),\n        table_max));\n  }\n}\n\n// LUT must have 513 values\ntemplate <typename LutOutT>\ninline LutOutT lut_lookup_with_interpolation(int16_t value,\n                                             const LutOutT* lut) {\n  static_assert(std::is_same<LutOutT, int8_t>::value ||\n                    std::is_same<LutOutT, int16_t>::value,\n                \"Only LUTs with int8 or int16 outputs are supported.\");\n  // 512 base values, lut[513] is only used to calculate the slope\n  const uint16_t index = static_cast<uint16_t>(256 + (value >> 7));\n  assert(index < 512 && \"LUT index out of range.\");\n  const int16_t offset = value & 0x7f;\n\n  // Base and slope are Q0.x\n  const LutOutT base = lut[index];\n  const LutOutT slope = lut[index + 1] - lut[index];\n\n  // Q0.x * Q0.7 = Q0.(x + 7)\n  // Round and convert from Q0.(x + 7) to Q0.x\n  const int delta = (slope * offset + 64) >> 7;\n\n  // Q0.15 + Q0.15\n  return static_cast<LutOutT>(base + delta);\n}\n\n// int16_t -> int16_t table lookup with interpolation\n// LUT must have 513 values\ninline int16_t lut_lookup(int16_t value, const int16_t* lut) {\n  return lut_lookup_with_interpolation(value, lut);\n}\n\n// int16_t -> int8_t table lookup with interpolation\n// LUT must have 513 values\ninline int8_t lut_lookup(int16_t value, const int8_t* lut) {\n  return lut_lookup_with_interpolation(value, lut);\n}\n\n// int8_t -> int8_t table lookup without interpolation\n// LUT must have 256 values\ninline int8_t lut_lookup(int8_t value, const int8_t* lut) {\n  return lut[128 + value];\n}\n\n// int8_t -> int16_t table lookup without interpolation\n// LUT must have 256 values\ninline int16_t lut_lookup(int8_t value, const int16_t* lut) {\n  return lut[128 + value];\n}\n\n// Table of sigmoid(i/24) at 0.16 format - 256 elements.\n\n// We use combined sigmoid and tanh look-up table, since\n// tanh(x) = 2*sigmoid(2*x) -1.\n// Both functions are symmetric, so the LUT table is only needed\n// for the absolute value of the input.\nstatic const uint16_t sigmoid_table_uint16[256] = {\n    32768, 33451, 34133, 34813, 35493, 36169, 36843, 37513, 38180, 38841, 39498,\n    40149, 40794, 41432, 42064, 42688, 43304, 43912, 44511, 45102, 45683, 46255,\n    46817, 47369, 47911, 48443, 48964, 49475, 49975, 50464, 50942, 51409, 51865,\n    52311, 52745, 53169, 53581, 53983, 54374, 54755, 55125, 55485, 55834, 56174,\n    56503, 56823, 57133, 57433, 57724, 58007, 58280, 58544, 58800, 59048, 59288,\n    59519, 59743, 59959, 60168, 60370, 60565, 60753, 60935, 61110, 61279, 61441,\n    61599, 61750, 61896, 62036, 62172, 62302, 62428, 62549, 62666, 62778, 62886,\n    62990, 63090, 63186, 63279, 63368, 63454, 63536, 63615, 63691, 63765, 63835,\n    63903, 63968, 64030, 64090, 64148, 64204, 64257, 64308, 64357, 64405, 64450,\n    64494, 64536, 64576, 64614, 64652, 64687, 64721, 64754, 64786, 64816, 64845,\n    64873, 64900, 64926, 64950, 64974, 64997, 65019, 65039, 65060, 65079, 65097,\n    65115, 65132, 65149, 65164, 65179, 65194, 65208, 65221, 65234, 65246, 65258,\n    65269, 65280, 65291, 65301, 65310, 65319, 65328, 65337, 65345, 65352, 65360,\n    65367, 65374, 65381, 65387, 65393, 65399, 65404, 65410, 65415, 65420, 65425,\n    65429, 65433, 65438, 65442, 65445, 65449, 65453, 65456, 65459, 65462, 65465,\n    65468, 65471, 65474, 65476, 65479, 65481, 65483, 65485, 65488, 65489, 65491,\n    65493, 65495, 65497, 65498, 65500, 65501, 65503, 65504, 65505, 65507, 65508,\n    65509, 65510, 65511, 65512, 65513, 65514, 65515, 65516, 65517, 65517, 65518,\n    65519, 65520, 65520, 65521, 65522, 65522, 65523, 65523, 65524, 65524, 65525,\n    65525, 65526, 65526, 65526, 65527, 65527, 65528, 65528, 65528, 65529, 65529,\n    65529, 65529, 65530, 65530, 65530, 65530, 65531, 65531, 65531, 65531, 65531,\n    65532, 65532, 65532, 65532, 65532, 65532, 65533, 65533, 65533, 65533, 65533,\n    65533, 65533, 65533, 65534, 65534, 65534, 65534, 65534, 65534, 65534, 65534,\n    65534, 65534, 65535};\n\n// TODO(b/77858996): Add these to gemmlowp.\ntemplate <typename IntegerType>\nIntegerType SaturatingAddNonGemmlowp(IntegerType a, IntegerType b) {\n  static_assert(std::is_same<IntegerType, void>::value, \"unimplemented\");\n  return a;\n}\n\ntemplate <>\ninline std::int32_t SaturatingAddNonGemmlowp(std::int32_t a, std::int32_t b) {\n  std::int64_t a64 = a;\n  std::int64_t b64 = b;\n  std::int64_t sum = a64 + b64;\n  return static_cast<std::int32_t>(std::min(\n      static_cast<std::int64_t>(std::numeric_limits<std::int32_t>::max()),\n      std::max(\n          static_cast<std::int64_t>(std::numeric_limits<std::int32_t>::min()),\n          sum)));\n}\n\ntemplate <typename tRawType, int tIntegerBits>\ngemmlowp::FixedPoint<tRawType, tIntegerBits> SaturatingAddNonGemmlowp(\n    gemmlowp::FixedPoint<tRawType, tIntegerBits> a,\n    gemmlowp::FixedPoint<tRawType, tIntegerBits> b) {\n  return gemmlowp::FixedPoint<tRawType, tIntegerBits>::FromRaw(\n      SaturatingAddNonGemmlowp(a.raw(), b.raw()));\n}\n\ntemplate <typename IntegerType>\nIntegerType SaturatingSub(IntegerType a, IntegerType b) {\n  static_assert(std::is_same<IntegerType, void>::value, \"unimplemented\");\n  return a;\n}\n\ntemplate <>\ninline std::int16_t SaturatingSub(std::int16_t a, std::int16_t b) {\n  std::int32_t a32 = a;\n  std::int32_t b32 = b;\n  std::int32_t diff = a32 - b32;\n  return static_cast<std::int16_t>(\n      std::min(static_cast<int32_t>(32767),\n               std::max(static_cast<int32_t>(-32768), diff)));\n}\n\ntemplate <>\ninline std::int32_t SaturatingSub(std::int32_t a, std::int32_t b) {\n  std::int64_t a64 = a;\n  std::int64_t b64 = b;\n  std::int64_t diff = a64 - b64;\n  return static_cast<std::int32_t>(std::min(\n      static_cast<std::int64_t>(std::numeric_limits<std::int32_t>::max()),\n      std::max(\n          static_cast<std::int64_t>(std::numeric_limits<std::int32_t>::min()),\n          diff)));\n}\n\ntemplate <typename tRawType, int tIntegerBits>\ngemmlowp::FixedPoint<tRawType, tIntegerBits> SaturatingSub(\n    gemmlowp::FixedPoint<tRawType, tIntegerBits> a,\n    gemmlowp::FixedPoint<tRawType, tIntegerBits> b) {\n  return gemmlowp::FixedPoint<tRawType, tIntegerBits>::FromRaw(\n      SaturatingSub(a.raw(), b.raw()));\n}\n// End section to be moved to gemmlowp.\n\ntemplate <typename IntegerType>\nIntegerType SaturatingRoundingMultiplyByPOTParam(IntegerType x, int exponent) {\n  if (exponent == 0) {\n    return x;\n  }\n  using ScalarIntegerType =\n      typename gemmlowp::FixedPointRawTypeTraits<IntegerType>::ScalarRawType;\n  const IntegerType min =\n      gemmlowp::Dup<IntegerType>(std::numeric_limits<ScalarIntegerType>::min());\n  const IntegerType max =\n      gemmlowp::Dup<IntegerType>(std::numeric_limits<ScalarIntegerType>::max());\n  const int ScalarIntegerTypeBits = 8 * sizeof(ScalarIntegerType);\n\n  const std::int32_t threshold =\n      ((1 << (ScalarIntegerTypeBits - 1 - exponent)) - 1);\n  const IntegerType positive_mask =\n      gemmlowp::MaskIfGreaterThan(x, gemmlowp::Dup<IntegerType>(threshold));\n  const IntegerType negative_mask =\n      gemmlowp::MaskIfLessThan(x, gemmlowp::Dup<IntegerType>(-threshold));\n\n  IntegerType result = gemmlowp::ShiftLeft(x, exponent);\n  result = gemmlowp::SelectUsingMask(positive_mask, max, result);\n  result = gemmlowp::SelectUsingMask(negative_mask, min, result);\n  return result;\n}\n\n// If we want to leave IntegerBits fixed, then multiplication\n// by a power of two has to be saturating/rounding, not exact anymore.\ntemplate <typename tRawType, int tIntegerBits>\ngemmlowp::FixedPoint<tRawType, tIntegerBits>\nSaturatingRoundingMultiplyByPOTParam(\n    gemmlowp::FixedPoint<tRawType, tIntegerBits> a, int exponent) {\n  return gemmlowp::FixedPoint<tRawType, tIntegerBits>::FromRaw(\n      SaturatingRoundingMultiplyByPOTParam(a.raw(), exponent));\n}\n\n// Convert int32_t multiplier to int16_t with rounding.\ninline void DownScaleInt32ToInt16Multiplier(int32_t multiplier_int32_t,\n                                            int16_t* multiplier_int16_t) {\n  TFLITE_DCHECK_GE(multiplier_int32_t, 0);\n  static constexpr int32_t kRoundingOffset = 1 << 15;\n  if (multiplier_int32_t >=\n      std::numeric_limits<int32_t>::max() - kRoundingOffset) {\n    *multiplier_int16_t = std::numeric_limits<int16_t>::max();\n    return;\n  }\n  const int32_t result = (multiplier_int32_t + kRoundingOffset) >> 16;\n  TFLITE_DCHECK_LE(result << 16, multiplier_int32_t + kRoundingOffset);\n  TFLITE_DCHECK_GT(result << 16, multiplier_int32_t - kRoundingOffset);\n  *multiplier_int16_t = result;\n  TFLITE_DCHECK_EQ(*multiplier_int16_t, result);\n}\n\n// Minimum output bits to accommodate log of maximum input range.  It actually\n// does not matter if one considers, say, [-64,64] or [-64,64).\n//\n// For example, run this through Octave:\n// [0:127; ...\n//  ceil(log(abs( log(2.^(0:127))+1 ))/log(2)); ...\n//  ceil(log(abs( log(2.^(0:127))+1 ))/log(2))]\nconstexpr int min_log_x_output_bits(int input_bits) {\n  return input_bits > 90   ? 7\n         : input_bits > 44 ? 6\n         : input_bits > 21 ? 5\n         : input_bits > 10 ? 4\n         : input_bits > 4  ? 3\n         : input_bits > 1  ? 2\n                           : 1;\n}\n\n// Although currently the name of this function says that it cannot handle\n// values less than 1, in practice it can handle as low as 1/x_max, where\n// x_max is the largest representable input.  In other words, the output range\n// is symmetric.\ntemplate <int OutputIntegerBits, int InputIntegerBits>\ninline gemmlowp::FixedPoint<int32_t, OutputIntegerBits>\nlog_x_for_x_greater_than_or_equal_to_1_impl(\n    gemmlowp::FixedPoint<int32_t, InputIntegerBits> input_val) {\n  // assert(__builtin_clz(0u) >= std::numeric_limits<uint32_t>::digits - 1);\n  // assert(__builtin_clz(0u) <= std::numeric_limits<uint32_t>::digits);\n  using FixedPoint0 = gemmlowp::FixedPoint<int32_t, 0>;\n  // The reason for accumulating the result with an extra bit of headroom is\n  // that z_pow_2_adj * log_2 might be saturated, and adding num_scaled *\n  // recip_denom will otherwise introduce an error.\n  static constexpr int kAccumIntegerBits = OutputIntegerBits + 1;\n  using FixedPointAccum = gemmlowp::FixedPoint<int32_t, kAccumIntegerBits>;\n\n  const FixedPoint0 log_2 = GEMMLOWP_CHECKED_FIXEDPOINT_CONSTANT(\n      FixedPoint0, 1488522236, std::log(2.0));\n  const FixedPoint0 sqrt_sqrt_half = GEMMLOWP_CHECKED_FIXEDPOINT_CONSTANT(\n      FixedPoint0, 1805811301, std::sqrt(std::sqrt(0.5)));\n  const FixedPoint0 sqrt_half = GEMMLOWP_CHECKED_FIXEDPOINT_CONSTANT(\n      FixedPoint0, 1518500250, std::sqrt(0.5));\n  const FixedPoint0 one_quarter =\n      GEMMLOWP_CHECKED_FIXEDPOINT_CONSTANT(FixedPoint0, 536870912, 1.0 / 4.0);\n\n  const FixedPoint0 alpha_n = GEMMLOWP_CHECKED_FIXEDPOINT_CONSTANT(\n      FixedPoint0, 117049297, 11.0 / 240.0 * std::sqrt(std::sqrt(2.0)));\n  const FixedPoint0 alpha_d = GEMMLOWP_CHECKED_FIXEDPOINT_CONSTANT(\n      FixedPoint0, 127690142, 1.0 / 20.0 * std::sqrt(std::sqrt(2.0)));\n  const FixedPoint0 alpha_i = GEMMLOWP_CHECKED_FIXEDPOINT_CONSTANT(\n      FixedPoint0, 1057819769,\n      2.0 / std::sqrt(std::sqrt(2.0)) - std::sqrt(std::sqrt(2.0)));\n  const FixedPoint0 alpha_f = GEMMLOWP_CHECKED_FIXEDPOINT_CONSTANT(\n      FixedPoint0, 638450708, 1.0 / 4.0 * std::sqrt(std::sqrt(2.0)));\n\n  const FixedPointAccum shifted_quarter =\n      gemmlowp::Rescale<kAccumIntegerBits>(one_quarter);\n\n  // Reinterpret the input value as Q0.31, because we will figure out the\n  // required shift \"ourselves\" instead of using, say, Rescale.\n  FixedPoint0 z_a = FixedPoint0::FromRaw(input_val.raw());\n  // z_a_pow_2 = input_integer_bits - z_a_headroom;\n  int z_a_headroom_plus_1 = CountLeadingZeros(static_cast<uint32_t>(z_a.raw()));\n  FixedPoint0 r_a_tmp =\n      SaturatingRoundingMultiplyByPOTParam(z_a, (z_a_headroom_plus_1 - 1));\n  const int32_t r_a_raw =\n      SaturatingRoundingMultiplyByPOTParam((r_a_tmp * sqrt_half).raw(), 1);\n  // z_pow_2_adj = max(z_pow_2_a - 0.75, z_pow_2_b - 0.25);\n  // z_pow_2_adj = max(InputIntegerBits - z_a_headroom_plus_1 + 0.25,\n  //                   InputIntegerBits - z_b_headroom - 0.25);\n  const FixedPointAccum z_a_pow_2_adj = SaturatingAddNonGemmlowp(\n      FixedPointAccum::FromRaw(SaturatingRoundingMultiplyByPOTParam(\n          static_cast<int32_t>(InputIntegerBits - z_a_headroom_plus_1),\n          31 - kAccumIntegerBits)),\n      shifted_quarter);\n\n  // z_b is treated like z_a, but premultiplying by sqrt(0.5).\n  FixedPoint0 z_b = z_a * sqrt_half;\n  int z_b_headroom = CountLeadingZeros(static_cast<uint32_t>(z_b.raw())) - 1;\n  const int32_t r_b_raw =\n      SaturatingRoundingMultiplyByPOTParam(z_a.raw(), z_b_headroom);\n  const FixedPointAccum z_b_pow_2_adj = SaturatingSub(\n      FixedPointAccum::FromRaw(SaturatingRoundingMultiplyByPOTParam(\n          static_cast<int32_t>(InputIntegerBits - z_b_headroom),\n          31 - kAccumIntegerBits)),\n      shifted_quarter);\n\n  const FixedPoint0 r = FixedPoint0::FromRaw(std::min(r_a_raw, r_b_raw));\n  const FixedPointAccum z_pow_2_adj = FixedPointAccum::FromRaw(\n      std::max(z_a_pow_2_adj.raw(), z_b_pow_2_adj.raw()));\n\n  const FixedPoint0 p = gemmlowp::RoundingHalfSum(r, sqrt_sqrt_half);\n  FixedPoint0 q = r - sqrt_sqrt_half;\n  q = q + q;\n\n  const FixedPoint0 common_sq = q * q;\n  const FixedPoint0 num = q * r + q * common_sq * alpha_n;\n  const FixedPoint0 denom_minus_one_0 =\n      p * (alpha_i + q + alpha_d * common_sq) + alpha_f * q;\n  const FixedPoint0 recip_denom =\n      one_over_one_plus_x_for_x_in_0_1(denom_minus_one_0);\n\n  const FixedPointAccum num_scaled = gemmlowp::Rescale<kAccumIntegerBits>(num);\n  return gemmlowp::Rescale<OutputIntegerBits>(z_pow_2_adj * log_2 +\n                                              num_scaled * recip_denom);\n}\n\ntemplate <int OutputIntegerBits, int InputIntegerBits>\ninline gemmlowp::FixedPoint<int32_t, OutputIntegerBits>\nlog_x_for_x_greater_than_or_equal_to_1(\n    gemmlowp::FixedPoint<int32_t, InputIntegerBits> input_val) {\n  static_assert(\n      OutputIntegerBits >= min_log_x_output_bits(InputIntegerBits),\n      \"Output integer bits must be sufficient to accommodate logs of inputs.\");\n  return log_x_for_x_greater_than_or_equal_to_1_impl<OutputIntegerBits,\n                                                     InputIntegerBits>(\n      input_val);\n}\n\ninline int32_t GetReciprocal(int32_t x, int x_integer_digits,\n                             int* num_bits_over_unit) {\n  int headroom_plus_one = CountLeadingZeros(static_cast<uint32_t>(x));\n  // This is the number of bits to the left of the binary point above 1.0.\n  // Consider x=1.25.  In that case shifted_scale=0.8 and\n  // no later adjustment will be needed.\n  *num_bits_over_unit = x_integer_digits - headroom_plus_one;\n  const int32_t shifted_sum_minus_one =\n      static_cast<int32_t>((static_cast<uint32_t>(x) << headroom_plus_one) -\n                           (static_cast<uint32_t>(1) << 31));\n\n  gemmlowp::FixedPoint<int32_t, 0> shifted_scale =\n      gemmlowp::one_over_one_plus_x_for_x_in_0_1(\n          gemmlowp::FixedPoint<int32_t, 0>::FromRaw(shifted_sum_minus_one));\n  return shifted_scale.raw();\n}\n\ninline void GetInvSqrtQuantizedMultiplierExp(int32_t input, int reverse_shift,\n                                             int32_t* output_inv_sqrt,\n                                             int* output_shift) {\n  TFLITE_DCHECK_GE(input, 0);\n  if (input <= 1) {\n    // Handle the input value 1 separately to avoid overflow in that case\n    // in the general computation below (b/143972021). Also handle 0 as if it\n    // were a 1. 0 is an invalid input here (divide by zero) and 1 is a valid\n    // but rare/unrealistic input value. We can expect both to occur in some\n    // incompletely trained models, but probably not in fully trained models.\n    *output_inv_sqrt = std::numeric_limits<std::int32_t>::max();\n    *output_shift = 0;\n    return;\n  }\n  TFLITE_DCHECK_GT(input, 1);\n  *output_shift = 11;\n  while (input >= (1 << 29)) {\n    input /= 4;\n    ++*output_shift;\n  }\n  const unsigned max_left_shift_bits =\n      CountLeadingZeros(static_cast<uint32_t>(input)) - 1;\n  const unsigned max_left_shift_bit_pairs = max_left_shift_bits / 2;\n  const unsigned left_shift_bit_pairs = max_left_shift_bit_pairs - 1;\n  *output_shift -= left_shift_bit_pairs;\n  input <<= 2 * left_shift_bit_pairs;\n  TFLITE_DCHECK_GE(input, (1 << 27));\n  TFLITE_DCHECK_LT(input, (1 << 29));\n  using gemmlowp::FixedPoint;\n  using gemmlowp::Rescale;\n  using gemmlowp::SaturatingRoundingMultiplyByPOT;\n  // Using 3 integer bits gives us enough room for the internal arithmetic in\n  // this Newton-Raphson iteration.\n  using F3 = FixedPoint<int32_t, 3>;\n  using F0 = FixedPoint<int32_t, 0>;\n  const F3 fixedpoint_input = F3::FromRaw(input >> 1);\n  const F3 fixedpoint_half_input =\n      SaturatingRoundingMultiplyByPOT<-1>(fixedpoint_input);\n  const F3 fixedpoint_half_three =\n      GEMMLOWP_CHECKED_FIXEDPOINT_CONSTANT(F3, (1 << 28) + (1 << 27), 1.5);\n  // Newton-Raphson iteration\n  // Naive unoptimized starting guess: x = 1\n  F3 x = F3::One();\n  // Naive unoptimized number of iterations: 5\n  for (int i = 0; i < 5; i++) {\n    const F3 x3 = Rescale<3>(x * x * x);\n    x = Rescale<3>(fixedpoint_half_three * x - fixedpoint_half_input * x3);\n  }\n  const F0 fixedpoint_half_sqrt_2 =\n      GEMMLOWP_CHECKED_FIXEDPOINT_CONSTANT(F0, 1518500250, std::sqrt(2.) / 2.);\n  x = x * fixedpoint_half_sqrt_2;\n  *output_inv_sqrt = x.raw();\n  if (*output_shift < 0) {\n    *output_inv_sqrt <<= -*output_shift;\n    *output_shift = 0;\n  }\n  // Convert right shift (right is positive) to left shift.\n  *output_shift *= reverse_shift;\n}\n\n// DO NOT USE THIS STRUCT FOR NEW FUNCTIONALITY BEYOND IMPLEMENTING\n// BROADCASTING.\n//\n// NdArrayDesc<N> describes the shape and memory layout of an N-dimensional\n// rectangular array of numbers.\n//\n// NdArrayDesc<N> is basically identical to Dims<N> defined in types.h.\n// However, as Dims<N> is to be deprecated, this class exists as an adaptor\n// to enable simple unoptimized implementations of element-wise broadcasting\n// operations.\ntemplate <int N>\nstruct NdArrayDesc {\n  // The \"extent\" of each dimension. Indices along dimension d must be in the\n  // half-open interval [0, extents[d]).\n  int extents[N];\n\n  // The number of *elements* (not bytes) between consecutive indices of each\n  // dimension.\n  int strides[N];\n};\n\n// DO NOT USE THIS FUNCTION FOR NEW FUNCTIONALITY BEYOND IMPLEMENTING\n// BROADCASTING.\n//\n// Same as Offset(), except takes as NdArrayDesc<N> instead of Dims<N>.\ninline int SubscriptToIndex(const NdArrayDesc<4>& desc, int i0, int i1, int i2,\n                            int i3) {\n  TFLITE_DCHECK(i0 >= 0 && i0 < desc.extents[0]);\n  TFLITE_DCHECK(i1 >= 0 && i1 < desc.extents[1]);\n  TFLITE_DCHECK(i2 >= 0 && i2 < desc.extents[2]);\n  TFLITE_DCHECK(i3 >= 0 && i3 < desc.extents[3]);\n  return i0 * desc.strides[0] + i1 * desc.strides[1] + i2 * desc.strides[2] +\n         i3 * desc.strides[3];\n}\n\ninline int SubscriptToIndex(const NdArrayDesc<5>& desc, int indexes[5]) {\n  return indexes[0] * desc.strides[0] + indexes[1] * desc.strides[1] +\n         indexes[2] * desc.strides[2] + indexes[3] * desc.strides[3] +\n         indexes[4] * desc.strides[4];\n}\n\ninline int SubscriptToIndex(const NdArrayDesc<8>& desc, int indexes[8]) {\n  return indexes[0] * desc.strides[0] + indexes[1] * desc.strides[1] +\n         indexes[2] * desc.strides[2] + indexes[3] * desc.strides[3] +\n         indexes[4] * desc.strides[4] + indexes[5] * desc.strides[5] +\n         indexes[6] * desc.strides[6] + indexes[7] * desc.strides[7];\n}\n\n// Given the dimensions of the operands for an element-wise binary broadcast,\n// adjusts them so that they can be directly iterated over with simple loops.\n// Returns the adjusted dims as instances of NdArrayDesc in 'desc0_out' and\n// 'desc1_out'. 'desc0_out' and 'desc1_out' cannot be nullptr.\n//\n// This function assumes that the two input shapes are compatible up to\n// broadcasting and the shorter one has already been prepended with 1s to be the\n// same length. E.g., if shape0 is (1, 16, 16, 64) and shape1 is (1, 64),\n// shape1 must already have been prepended to be (1, 1, 1, 64). Recall that\n// Dims<N> refer to shapes in reverse order. In this case, input0_dims will be\n// (64, 16, 16, 1) and input1_dims will be (64, 1, 1, 1).\n//\n// When two shapes are compatible up to broadcasting, for each dimension d,\n// the input extents are either equal, or one of them is 1.\n//\n// This function performs the following for each dimension d:\n// - If the extents are equal, then do nothing since the loop that walks over\n//   both of the input arrays is correct.\n// - Otherwise, one (and only one) of the extents must be 1. Say extent0 is 1\n//   and extent1 is e1. Then set extent0 to e1 and stride0 *to 0*. This allows\n//   array0 to be referenced *at any index* in dimension d and still access the\n//   same slice.\ntemplate <int N>\ninline void NdArrayDescsForElementwiseBroadcast(const Dims<N>& input0_dims,\n                                                const Dims<N>& input1_dims,\n                                                NdArrayDesc<N>* desc0_out,\n                                                NdArrayDesc<N>* desc1_out) {\n  TFLITE_DCHECK(desc0_out != nullptr);\n  TFLITE_DCHECK(desc1_out != nullptr);\n\n  // Copy dims to desc.\n  for (int i = 0; i < N; ++i) {\n    desc0_out->extents[i] = input0_dims.sizes[i];\n    desc0_out->strides[i] = input0_dims.strides[i];\n    desc1_out->extents[i] = input1_dims.sizes[i];\n    desc1_out->strides[i] = input1_dims.strides[i];\n  }\n\n  // Walk over each dimension. If the extents are equal do nothing.\n  // Otherwise, set the desc with extent 1 to have extent equal to the other and\n  // stride 0.\n  for (int i = 0; i < N; ++i) {\n    const int extent0 = ArraySize(input0_dims, i);\n    const int extent1 = ArraySize(input1_dims, i);\n    if (extent0 != extent1) {\n      if (extent0 == 1) {\n        desc0_out->strides[i] = 0;\n        desc0_out->extents[i] = extent1;\n      } else {\n        TFLITE_DCHECK_EQ(extent1, 1);\n        desc1_out->strides[i] = 0;\n        desc1_out->extents[i] = extent0;\n      }\n    }\n  }\n}\n\n// Copies dims to desc, calculating strides.\ntemplate <int N>\ninline void CopyDimsToDesc(const RuntimeShape& input_shape,\n                           NdArrayDesc<N>* desc_out) {\n  int desc_stride = 1;\n  for (int i = N - 1; i >= 0; --i) {\n    desc_out->extents[i] = input_shape.Dims(i);\n    desc_out->strides[i] = desc_stride;\n    desc_stride *= input_shape.Dims(i);\n  }\n}\n\ntemplate <int N>\ninline void NdArrayDescsForElementwiseBroadcast(\n    const RuntimeShape& input0_shape, const RuntimeShape& input1_shape,\n    NdArrayDesc<N>* desc0_out, NdArrayDesc<N>* desc1_out) {\n  TFLITE_DCHECK(desc0_out != nullptr);\n  TFLITE_DCHECK(desc1_out != nullptr);\n\n  auto extended_input0_shape = RuntimeShape::ExtendedShape(N, input0_shape);\n  auto extended_input1_shape = RuntimeShape::ExtendedShape(N, input1_shape);\n\n  // Copy dims to desc, calculating strides.\n  CopyDimsToDesc<N>(extended_input0_shape, desc0_out);\n  CopyDimsToDesc<N>(extended_input1_shape, desc1_out);\n\n  // Walk over each dimension. If the extents are equal do nothing.\n  // Otherwise, set the desc with extent 1 to have extent equal to the other and\n  // stride 0.\n  for (int i = 0; i < N; ++i) {\n    const int extent0 = extended_input0_shape.Dims(i);\n    const int extent1 = extended_input1_shape.Dims(i);\n    if (extent0 != extent1) {\n      if (extent0 == 1) {\n        desc0_out->strides[i] = 0;\n        desc0_out->extents[i] = extent1;\n      } else {\n        TFLITE_DCHECK_EQ(extent1, 1);\n        desc1_out->strides[i] = 0;\n        desc1_out->extents[i] = extent0;\n      }\n    }\n  }\n}\n\ntemplate <int N>\ninline void NdArrayDescsForElementwiseBroadcast(\n    const RuntimeShape& input0_shape, const RuntimeShape& input1_shape,\n    const RuntimeShape& input2_shape, NdArrayDesc<N>* desc0_out,\n    NdArrayDesc<N>* desc1_out, NdArrayDesc<N>* desc2_out) {\n  TFLITE_DCHECK(desc0_out != nullptr);\n  TFLITE_DCHECK(desc1_out != nullptr);\n  TFLITE_DCHECK(desc2_out != nullptr);\n\n  auto extended_input0_shape = RuntimeShape::ExtendedShape(N, input0_shape);\n  auto extended_input1_shape = RuntimeShape::ExtendedShape(N, input1_shape);\n  auto extended_input2_shape = RuntimeShape::ExtendedShape(N, input2_shape);\n\n  // Copy dims to desc, calculating strides.\n  CopyDimsToDesc<N>(extended_input0_shape, desc0_out);\n  CopyDimsToDesc<N>(extended_input1_shape, desc1_out);\n  CopyDimsToDesc<N>(extended_input2_shape, desc2_out);\n\n  // Walk over each dimension. If the extents are equal do nothing.\n  // Otherwise, set the desc with extent 1 to have extent equal to the other and\n  // stride 0.\n  for (int i = 0; i < N; ++i) {\n    const int extent0 = extended_input0_shape.Dims(i);\n    const int extent1 = extended_input1_shape.Dims(i);\n    const int extent2 = extended_input2_shape.Dims(i);\n\n    int extent = extent0;\n    if (extent1 != 1) extent = extent1;\n    if (extent2 != 1) extent = extent2;\n\n    TFLITE_DCHECK(extent0 == 1 || extent0 == extent);\n    TFLITE_DCHECK(extent1 == 1 || extent1 == extent);\n    TFLITE_DCHECK(extent2 == 1 || extent2 == extent);\n\n    if (!(extent0 == extent1 && extent1 == extent2)) {\n      if (extent0 == 1) {\n        desc0_out->strides[i] = 0;\n        desc0_out->extents[i] = extent;\n      }\n      if (extent1 == 1) {\n        desc1_out->strides[i] = 0;\n        desc1_out->extents[i] = extent;\n      }\n      if (extent2 == 1) {\n        desc2_out->strides[i] = 0;\n        desc2_out->extents[i] = extent;\n      }\n    }\n  }\n}\n\n// Detailed implementation of NDOpsHelper, the indexes must be a zero array.\n// This implementation is equivalent to N nested loops. Ex, if N=4, it can be\n// re-writen as:\n// for (int b = 0; b < output.extents[0]; ++b) {\n//   for (int y = 0; y < output.extents[1]; ++y) {\n//     for (int x = 0; x < output.extents[2]; ++x) {\n//       for (int c = 0; c < output.extents[3]; ++c) {\n//           calc({b,y,x,c});\n//       }\n//     }\n//   }\n// }\ntemplate <int N, int DIM, typename Calc>\ntypename std::enable_if<DIM != N - 1, void>::type NDOpsHelperImpl(\n    const NdArrayDesc<N>& output, const Calc& calc, int indexes[N]) {\n  for (indexes[DIM] = 0; indexes[DIM] < output.extents[DIM]; ++indexes[DIM]) {\n    NDOpsHelperImpl<N, DIM + 1, Calc>(output, calc, indexes);\n  }\n}\n\ntemplate <int N, int DIM, typename Calc>\ntypename std::enable_if<DIM == N - 1, void>::type NDOpsHelperImpl(\n    const NdArrayDesc<N>& output, const Calc& calc, int indexes[N]) {\n  for (indexes[DIM] = 0; indexes[DIM] < output.extents[DIM]; ++indexes[DIM]) {\n    calc(indexes);\n  }\n}\n\n// Execute the calc function in the innermost iteration based on the shape of\n// the output. The calc function should take a single argument of type int[N].\ntemplate <int N, typename Calc>\ninline void NDOpsHelper(const NdArrayDesc<N>& output, const Calc& calc) {\n  int indexes[N] = {0};\n  NDOpsHelperImpl<N, 0, Calc>(output, calc, indexes);\n}\n// Copied from gemmlowp::RoundDown when we dropped direct dependency on\n// gemmlowp.\n//\n// Returns the runtime argument rounded down to the nearest multiple of\n// the fixed Modulus.\ntemplate <unsigned Modulus, typename Integer>\nInteger RoundDown(Integer i) {\n  return i - (i % Modulus);\n}\n\n// Copied from gemmlowp::RoundUp when we dropped direct dependency on\n// gemmlowp.\n//\n// Returns the runtime argument rounded up to the nearest multiple of\n// the fixed Modulus.\ntemplate <unsigned Modulus, typename Integer>\nInteger RoundUp(Integer i) {\n  return RoundDown<Modulus>(i + Modulus - 1);\n}\n\n// Copied from gemmlowp::CeilQuotient when we dropped direct dependency on\n// gemmlowp.\n//\n// Returns the quotient a / b rounded up ('ceil') to the nearest integer.\ntemplate <typename Integer>\nInteger CeilQuotient(Integer a, Integer b) {\n  return (a + b - 1) / b;\n}\n\n// This function is a copy of gemmlowp::HowManyThreads, copied when we dropped\n// the direct dependency of internal/optimized/ on gemmlowp.\n//\n// It computes a reasonable number of threads to use for a GEMM of shape\n// (rows, cols, depth).\n//\n// TODO(b/131910176): get rid of this function by switching each call site\n// to its own more sensible logic for its own workload.\ntemplate <int KernelRows>\ninline int LegacyHowManyThreads(int max_num_threads, int rows, int cols,\n                                int depth) {\n  // Early-exit in the default case where multi-threading is disabled.\n  if (max_num_threads == 1) {\n    return 1;\n  }\n\n  // Ensure that each thread has KernelRows rows to process, if at all possible.\n  int thread_count = std::min(max_num_threads, rows / KernelRows);\n\n  // Limit the number of threads according to the overall size of the problem.\n  if (thread_count > 1) {\n    // Empirically determined value.\n    static constexpr std::uint64_t min_cubic_size_per_thread = 64 * 1024;\n\n    // We can only multiply two out of three sizes without risking overflow\n    const std::uint64_t cubic_size =\n        std::uint64_t(rows) * std::uint64_t(cols) * std::uint64_t(depth);\n\n    thread_count = std::min(\n        thread_count, static_cast<int>(cubic_size / min_cubic_size_per_thread));\n  }\n\n  if (thread_count < 1) {\n    thread_count = 1;\n  }\n\n  assert(thread_count > 0 && thread_count <= max_num_threads);\n  return thread_count;\n}\n\ntemplate <typename T>\nvoid optimized_ops_preload_l1_stream(const T* ptr) {\n#ifdef __GNUC__\n  // builtin offered by GCC-compatible compilers including clang\n  __builtin_prefetch(ptr, /* 0 means read */ 0, /* 0 means no locality */ 0);\n#else\n  (void)ptr;\n#endif\n}\n\ntemplate <typename T>\nvoid optimized_ops_preload_l1_keep(const T* ptr) {\n#ifdef __GNUC__\n  // builtin offered by GCC-compatible compilers including clang\n  __builtin_prefetch(ptr, /* 0 means read */ 0, /* 3 means high locality */ 3);\n#else\n  (void)ptr;\n#endif\n}\n\ntemplate <typename T>\nvoid optimized_ops_prefetch_write_l1_keep(const T* ptr) {\n#ifdef __GNUC__\n  // builtin offered by GCC-compatible compilers including clang\n  __builtin_prefetch(ptr, /* 1 means write */ 1, /* 3 means high locality */ 3);\n#else\n  (void)ptr;\n#endif\n}\n\n}  // namespace tflite\n\n#endif  // TENSORFLOW_LITE_KERNELS_INTERNAL_COMMON_H_"