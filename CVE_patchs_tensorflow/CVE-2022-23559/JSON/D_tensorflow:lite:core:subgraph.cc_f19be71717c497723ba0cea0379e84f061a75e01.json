"diff --git a/tensorflow/lite/core/subgraph.cc b/tensorflow/lite/core/subgraph.cc\nindex 78fab986abd..1eda305bdc1 100644\n--- a/tensorflow/lite/core/subgraph.cc\n+++ b/tensorflow/lite/core/subgraph.cc\n@@ -690,27 +690,6 @@ TfLiteStatus Subgraph::CheckInputAndOutputForOverlap(const int* input_indices,\n   return kTfLiteOk;\n }\n \n-namespace {\n-// Multiply two sizes and return true if overflow occurred;\n-// This is based off tensorflow/overflow.h but is simpler as we already\n-// have unsigned numbers. It is also generalized to work where sizeof(size_t)\n-// is not 8.\n-TfLiteStatus MultiplyAndCheckOverflow(size_t a, size_t b, size_t* product) {\n-  // Multiplying a * b where a and b are size_t cannot result in overflow in a\n-  // size_t accumulator if both numbers have no non-zero bits in their upper\n-  // half.\n-  constexpr size_t size_t_bits = 8 * sizeof(size_t);\n-  constexpr size_t overflow_upper_half_bit_position = size_t_bits / 2;\n-  *product = a * b;\n-  // If neither integers have non-zero bits past 32 bits can't overflow.\n-  // Otherwise check using slow devision.\n-  if (TFLITE_EXPECT_FALSE((a | b) >> overflow_upper_half_bit_position != 0)) {\n-    if (a != 0 && *product / a != b) return kTfLiteError;\n-  }\n-  return kTfLiteOk;\n-}\n-}  // namespace\n-\n TfLiteStatus Subgraph::BytesRequired(TfLiteType type, const int* dims,\n                                      size_t dims_size, size_t* bytes) {\n   TF_LITE_ENSURE(&context_, bytes != nullptr);"