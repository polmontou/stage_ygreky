"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Op that looks up items from a sparse tensor in an embedding matrix.\n// The sparse lookup tensor is represented by three individual tensors: lookup,\n// indices, and dense_shape. The representation assume that the corresponding\n// dense tensor would satisfy:\n//   * dense.shape = dense_shape\n//   * dense[tuple(indices[i])] = lookup[i]\n//\n// By convention, indices should be sorted.\n//\n// Options:\n//   combiner: The reduction op (SUM, MEAN, SQRTN).\n//     * SUM computes the weighted sum of the embedding results.\n//     * MEAN is the weighted sum divided by the total weight.\n//     * SQRTN is the weighted sum divided by the square root of the sum of the\n//       squares of the weights.\n//\n// Input:\n//     Tensor[0]: Ids to lookup, dim.size == 1, int32.\n//     Tensor[1]: Indices, int32.\n//     Tensor[2]: Dense shape, int32.\n//     Tensor[3]: Weights to use for aggregation, float.\n//     Tensor[4]: Params, a matrix of multi-dimensional items,\n//                dim.size >= 2, float.\n//\n// Output:\n//   A (dense) tensor representing the combined embeddings for the sparse ids.\n//   For each row in the sparse tensor represented by (lookup, indices, shape)\n//   the op looks up the embeddings for all ids in that row, multiplies them by\n//   the corresponding weight, and combines these embeddings as specified in the\n//   last dimension.\n//\n//   Output.dim = [l0, ... , ln-1, e1, ..., em]\n//   Where dense_shape == [l0, ..., ln] and Tensor[4].dim == [e0, e1, ..., em]\n//\n//   For instance, if params is a 10x20 matrix and ids, weights are:\n//\n//   [0, 0]: id 1, weight 2.0\n//   [0, 1]: id 3, weight 0.5\n//   [1, 0]: id 0, weight 1.0\n//   [2, 3]: id 1, weight 3.0\n//\n//   with combiner=MEAN, then the output will be a (3, 20) tensor where:\n//\n//   output[0, :] = (params[1, :] * 2.0 + params[3, :] * 0.5) / (2.0 + 0.5)\n//   output[1, :] = (params[0, :] * 1.0) / 1.0\n//   output[2, :] = (params[1, :] * 3.0) / 3.0\n//\n//   When indices are out of bound, the op will not succeed.\n\n#include <stdint.h>\n\n#include <algorithm>\n#include <cmath>\n\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_utils.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n#include \"tensorflow/lite/util.h\"\n\nnamespace tflite {\nnamespace ops {\nnamespace builtin {\n\nnamespace {\n\nTfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 5);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(ids), 1);\n  TF_LITE_ENSURE_EQ(context, ids->type, kTfLiteInt32);\n\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(indices), 2);\n  TF_LITE_ENSURE_EQ(context, indices->type, kTfLiteInt32);\n\n  const TfLiteTensor* shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &shape));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(shape), 1);\n  TF_LITE_ENSURE_EQ(context, shape->type, kTfLiteInt32);\n\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(weights), 1);\n  TF_LITE_ENSURE_EQ(context, weights->type, kTfLiteFloat32);\n\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(indices, 0),\n                    SizeOfDimension(ids, 0));\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(indices, 0),\n                    SizeOfDimension(weights, 0));\n\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n  TF_LITE_ENSURE(context, NumDimensions(value) >= 2);\n\n  // Mark the output as a dynamic tensor.\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, kTfLiteFloat32);\n  output->allocation_type = kTfLiteDynamic;\n\n  return kTfLiteOk;\n}\n\nvoid FinalizeAggregation(TfLiteCombinerType combiner, int num_elements,\n                         float current_total_weight,\n                         float current_squares_weight, int embedding_size,\n                         float* output) {\n  if (combiner != kTfLiteCombinerTypeSum && num_elements > 0) {\n    float multiplier = 1.0;\n    switch (combiner) {\n      case kTfLiteCombinerTypeMean:\n        multiplier = current_total_weight;\n        break;\n      case kTfLiteCombinerTypeSqrtn:\n        multiplier = std::sqrt(current_squares_weight);\n        break;\n      default:\n        break;\n    }\n    for (int k = 0; k < embedding_size; k++) {\n      output[k] /= multiplier;\n    }\n  }\n}\n\nTfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  const TfLiteTensor* dense_shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape));\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n\n  const int lookup_rank = SizeOfDimension(indices, 1);\n  const int embedding_rank = NumDimensions(value);\n  const int num_lookups = SizeOfDimension(ids, 0);\n  const int num_rows = SizeOfDimension(value, 0);\n\n  // The last dimension gets replaced by the embedding.\n  const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);\n\n  // Make sure that the actual dense shape of the sparse tensor represented by\n  // (loopkup, indices, dense_shape) is consistent.\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);\n\n  // Resize output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);\n  TF_LITE_ENSURE(context, output_shape != nullptr);\n  int k = 0;\n  size_t embedding_size = 1;\n  size_t lookup_size = 1;\n  for (int i = 0; i < lookup_rank - 1; i++, k++) {\n    const size_t dim = dense_shape->data.i32[i];\n    TF_LITE_ENSURE_MSG(\n        context,\n        MultiplyAndCheckOverflow(lookup_size, dim, &lookup_size) == kTfLiteOk,\n        \"Lookup size overflowed.\");\n    output_shape->data[k] = dim;\n  }\n  for (int i = 1; i < embedding_rank; i++, k++) {\n    const size_t dim = SizeOfDimension(value, i);\n    TF_LITE_ENSURE_MSG(context,\n                       MultiplyAndCheckOverflow(embedding_size, dim,\n                                                &embedding_size) == kTfLiteOk,\n                       \"Embedding size overflowed.\");\n    output_shape->data[k] = dim;\n  }\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n  const size_t output_size = lookup_size * embedding_size;\n  TfLiteTensorRealloc(output_size * sizeof(float), output);\n\n  float* output_ptr = GetTensorData<float>(output);\n  const float* weights_ptr = GetTensorData<float>(weights);\n  const float* value_ptr = GetTensorData<float>(value);\n  // Makes sure reallocation was successful.\n  TF_LITE_ENSURE(context, output_ptr != nullptr);\n\n  std::fill_n(output_ptr, output_size, 0.0f);\n\n  // Keep track of the current bucket for aggregation/combination.\n  int current_output_offset = 0;\n  float current_total_weight = 0.0;\n  float current_squares_weight = 0.0;\n  int num_elements = 0;\n\n  for (int i = 0; i < num_lookups; i++) {\n    int idx = ids->data.i32[i];\n    if (idx >= num_rows || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup Sparse: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, num_rows - 1);\n      return kTfLiteError;\n    }\n\n    // Check where we need to aggregate.\n    const int example_indices_offset = i * lookup_rank;\n    int output_bucket = 0;\n    int stride = 1;\n    for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {\n      output_bucket += indices->data.i32[example_indices_offset + k] * stride;\n      stride *= dense_shape->data.i32[k];\n    }\n    const int output_offset = output_bucket * embedding_size;\n\n    // If we are in a new aggregation bucket and the combiner is not the sum,\n    // go back and finalize the result of the previous bucket.\n    if (output_offset != current_output_offset) {\n      FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                          current_squares_weight, embedding_size,\n                          &output_ptr[current_output_offset]);\n\n      // Track next bucket.\n      num_elements = 0;\n      current_total_weight = 0.0;\n      current_squares_weight = 0.0;\n      current_output_offset = output_offset;\n    }\n\n    // Add element to aggregation.\n    ++num_elements;\n    const int example_embedding_offset = idx * embedding_size;\n    const float w = weights_ptr[i];\n    current_squares_weight += w * w;\n    current_total_weight += w;\n    for (int k = 0; k < embedding_size; k++) {\n      output_ptr[current_output_offset + k] +=\n          value_ptr[example_embedding_offset + k] * w;\n    }\n  }\n\n  // Finalize last bucket.\n  FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                      current_squares_weight, embedding_size,\n                      &GetTensorData<float>(output)[current_output_offset]);\n\n  return kTfLiteOk;\n}\n\n}  // namespace\n\nTfLiteRegistration* Register_EMBEDDING_LOOKUP_SPARSE() {\n  static TfLiteRegistration r = {nullptr, nullptr, Prepare, Eval};\n  return &r;\n}\n\n}  // namespace builtin\n}  // namespace ops\n}  // namespace tflite"