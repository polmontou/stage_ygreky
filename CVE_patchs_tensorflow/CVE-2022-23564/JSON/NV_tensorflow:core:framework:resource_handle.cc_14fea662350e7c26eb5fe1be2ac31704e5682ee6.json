"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/resource_handle.h\"\n\n#include \"absl/strings/str_format.h\"\n#include \"tensorflow/core/framework/resource_handle.pb.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/macros.h\"\n\nnamespace tensorflow {\n\n// Must be declared here for pre-C++17 compatibility.\n/* static */ constexpr const char* ResourceHandle::ANONYMOUS_NAME;\n\nResourceHandle::ResourceHandle() {}\n\nResourceHandle::ResourceHandle(const ResourceHandleProto& proto) {\n  TF_CHECK_OK(FromProto(proto));\n}\n\nStatus ResourceHandle::BuildResourceHandle(const ResourceHandleProto& proto,\n                                           ResourceHandle* out) {\n  if (out == nullptr)\n    return errors::Internal(\n        \"BuildResourceHandle() was called with nullptr for the output\");\n  return out->FromProto(proto);\n}\n\nResourceHandle::~ResourceHandle() {}\n\nvoid ResourceHandle::AsProto(ResourceHandleProto* proto) const {\n  proto->set_device(device());\n  proto->set_container(container());\n  proto->set_name(name());\n  proto->set_hash_code(hash_code());\n  proto->set_maybe_type_name(maybe_type_name());\n  for (const auto& dtype_and_shape_pair : dtypes_and_shapes_) {\n    auto dtype_and_shape = proto->add_dtypes_and_shapes();\n    dtype_and_shape->set_dtype(dtype_and_shape_pair.dtype);\n    dtype_and_shape_pair.shape.AsProto(dtype_and_shape->mutable_shape());\n  }\n}\n\nStatus ResourceHandle::FromProto(const ResourceHandleProto& proto) {\n  set_device(proto.device());\n  set_container(proto.container());\n  set_name(proto.name());\n  set_hash_code(proto.hash_code());\n  set_maybe_type_name(proto.maybe_type_name());\n  std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes;\n  for (const auto& dtype_and_shape : proto.dtypes_and_shapes()) {\n    DataType dtype = dtype_and_shape.dtype();\n    PartialTensorShape shape;\n    Status s = PartialTensorShape::BuildPartialTensorShape(\n        dtype_and_shape.shape(), &shape);\n    if (!s.ok()) {\n      return s;\n    }\n    dtypes_and_shapes.push_back(DtypeAndPartialTensorShape{dtype, shape});\n  }\n  dtypes_and_shapes_ = std::move(dtypes_and_shapes);\n  return Status::OK();\n}\n\nstring ResourceHandle::SerializeAsString() const {\n  ResourceHandleProto proto;\n  AsProto(&proto);\n  return proto.SerializeAsString();\n}\n\nbool ResourceHandle::ParseFromString(const string& s) {\n  ResourceHandleProto proto;\n  return proto.ParseFromString(s) && FromProto(proto).ok();\n}\n\nstring ResourceHandle::DebugString() const {\n  return strings::StrCat(\"device: \", device(), \" container: \", container(),\n                         \" name: \", name(), \" hash_code: \", hash_code(),\n                         \" maybe_type_name: \", maybe_type_name());\n}\n\nResourceHandle ResourceHandle::MakeRefCountingHandle(\n    ResourceBase* resource, const string& device_name,\n    const TypeIndex& type_index,\n    const std::vector<DtypeAndPartialTensorShape>& dtypes_and_shapes,\n    const absl::optional<ManagedStackTrace>& definition_stack_trace) {\n  ResourceHandle result;\n  result.resource_.reset(resource, /*add_ref=*/false);\n  result.set_device(device_name);\n  // All resources owned by anonymous handles are put into the same container,\n  // and they get process-unique handle names.\n  result.set_container(\"Anonymous\");\n  result.set_definition_stack_trace(definition_stack_trace);\n  result.set_name(\n      absl::StrFormat(\"Resource-%d-at-%p\", GenerateUniqueId(), resource));\n  result.set_hash_code(type_index.hash_code());\n  result.set_maybe_type_name(type_index.name());\n  result.set_dtypes_and_shapes(dtypes_and_shapes);\n  return result;\n}\n\nStatus ResourceHandle::ValidateType(const TypeIndex& type_index) const {\n  if (type_index.hash_code() != hash_code()) {\n    return errors::InvalidArgument(\n        \"Trying to access a handle's resource using the wrong type. \",\n        \"The handle points to a resource (name '\", name(), \"') of type '\",\n        maybe_type_name(), \"' (hash code \", hash_code(),\n        \") but you are trying to access the resource as type '\",\n        type_index.name(), \"' (hash code \", type_index.hash_code(), \")\");\n  }\n  return Status::OK();\n}\n\nstd::atomic<int64_t> ResourceHandle::current_id_;\n\nint64_t ResourceHandle::GenerateUniqueId() { return current_id_.fetch_add(1); }\n\nstring ProtoDebugString(const ResourceHandle& handle) {\n  return handle.DebugString();\n}\n\nvoid EncodeResourceHandleList(const ResourceHandle* p, int64_t n,\n                              std::unique_ptr<port::StringListEncoder> e) {\n  ResourceHandleProto proto;\n  for (int i = 0; i < n; ++i) {\n    p[i].AsProto(&proto);\n    e->Append(proto);\n  }\n  e->Finalize();\n}\n\nbool DecodeResourceHandleList(std::unique_ptr<port::StringListDecoder> d,\n                              ResourceHandle* ps, int64_t n) {\n  std::vector<uint32> sizes(n);\n  if (!d->ReadSizes(&sizes)) return false;\n\n  ResourceHandleProto proto;\n  for (int i = 0; i < n; ++i) {\n    if (!proto.ParseFromArray(d->Data(sizes[i]), sizes[i])) {\n      return false;\n    }\n    if (!ps[i].FromProto(proto).ok()) {\n      return false;\n    }\n  }\n  return true;\n}\n\n}  // namespace tensorflow"