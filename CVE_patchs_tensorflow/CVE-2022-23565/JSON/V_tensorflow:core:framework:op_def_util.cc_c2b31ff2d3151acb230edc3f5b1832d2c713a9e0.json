"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/op_def_util.h\"\n\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include \"tensorflow/core/framework/attr_value.pb.h\"\n#include \"tensorflow/core/framework/attr_value_util.h\"\n#include \"tensorflow/core/framework/op_def.pb.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/gtl/map_util.h\"\n#include \"tensorflow/core/lib/hash/hash.h\"\n#include \"tensorflow/core/lib/strings/proto_serialization.h\"\n#include \"tensorflow/core/lib/strings/scanner.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/platform/protobuf.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\nnamespace {  // ------ Helper functions ------\n\nbool HasAttrStyleType(const OpDef::ArgDef& arg) {\n  return arg.type() != DT_INVALID || !arg.type_attr().empty() ||\n         !arg.type_list_attr().empty();\n}\n\nStatus AllowedTypeValue(DataType dt, const OpDef::AttrDef& attr) {\n  const AttrValue& allowed_values(attr.allowed_values());\n  for (auto allowed : allowed_values.list().type()) {\n    if (dt == allowed) {\n      return Status::OK();\n    }\n  }\n  string allowed_str;\n  for (int i = 0; i < allowed_values.list().type_size(); ++i) {\n    if (!allowed_str.empty()) {\n      strings::StrAppend(&allowed_str, \", \");\n    }\n    strings::StrAppend(&allowed_str,\n                       DataTypeString(allowed_values.list().type(i)));\n  }\n  return errors::InvalidArgument(\n      \"Value for attr '\", attr.name(), \"' of \", DataTypeString(dt),\n      \" is not in the list of allowed values: \", allowed_str);\n}\n\nStatus AllowedStringValue(const string& str, const OpDef::AttrDef& attr) {\n  const AttrValue& allowed_values(attr.allowed_values());\n  for (const auto& allowed : allowed_values.list().s()) {\n    if (str == allowed) {\n      return Status::OK();\n    }\n  }\n  string allowed_str;\n  for (const string& allowed : allowed_values.list().s()) {\n    if (!allowed_str.empty()) {\n      strings::StrAppend(&allowed_str, \", \");\n    }\n    strings::StrAppend(&allowed_str, \"\\\"\", allowed, \"\\\"\");\n  }\n  return errors::InvalidArgument(\n      \"Value for attr '\", attr.name(), \"' of \\\"\", str,\n      \"\\\" is not in the list of allowed values: \", allowed_str);\n}\n\n}  // namespace\n\n// Requires: attr has already been validated.\nStatus ValidateAttrValue(const AttrValue& attr_value,\n                         const OpDef::AttrDef& attr) {\n  // Is it a valid value?\n  TF_RETURN_WITH_CONTEXT_IF_ERROR(AttrValueHasType(attr_value, attr.type()),\n                                  \" for attr '\", attr.name(), \"'\");\n\n  // Does the value satisfy the minimum constraint in the AttrDef?\n  if (attr.has_minimum()) {\n    if (attr.type() == \"int\") {\n      if (attr_value.i() < attr.minimum()) {\n        return errors::InvalidArgument(\n            \"Value for attr '\", attr.name(), \"' of \", attr_value.i(),\n            \" must be at least minimum \", attr.minimum());\n      }\n    } else {\n      int length = -1;\n      if (attr.type() == \"list(string)\") {\n        length = attr_value.list().s_size();\n      } else if (attr.type() == \"list(int)\") {\n        length = attr_value.list().i_size();\n      } else if (attr.type() == \"list(float)\") {\n        length = attr_value.list().f_size();\n      } else if (attr.type() == \"list(bool)\") {\n        length = attr_value.list().b_size();\n      } else if (attr.type() == \"list(type)\") {\n        length = attr_value.list().type_size();\n      } else if (attr.type() == \"list(shape)\") {\n        length = attr_value.list().shape_size();\n      } else if (attr.type() == \"list(tensor)\") {\n        length = attr_value.list().tensor_size();\n      } else if (attr.type() == \"list(func)\") {\n        length = attr_value.list().func_size();\n      }\n      if (length < attr.minimum()) {\n        return errors::InvalidArgument(\n            \"Length for attr '\", attr.name(), \"' of \", length,\n            \" must be at least minimum \", attr.minimum());\n      }\n    }\n  }\n\n  // Does the value satisfy the allowed_value constraint in the AttrDef?\n  if (attr.has_allowed_values()) {\n    if (attr.type() == \"type\") {\n      TF_RETURN_IF_ERROR(AllowedTypeValue(attr_value.type(), attr));\n    } else if (attr.type() == \"list(type)\") {\n      for (int dt : attr_value.list().type()) {\n        TF_RETURN_IF_ERROR(AllowedTypeValue(static_cast<DataType>(dt), attr));\n      }\n    } else if (attr.type() == \"string\") {\n      TF_RETURN_IF_ERROR(AllowedStringValue(attr_value.s(), attr));\n    } else if (attr.type() == \"list(string)\") {\n      for (const string& str : attr_value.list().s()) {\n        TF_RETURN_IF_ERROR(AllowedStringValue(str, attr));\n      }\n    } else {\n      return errors::Unimplemented(\n          \"Support for allowed_values not implemented for type \", attr.type());\n    }\n  }\n  return Status::OK();\n}\n\nconst OpDef::AttrDef* FindAttr(StringPiece name, const OpDef& op_def) {\n  for (int i = 0; i < op_def.attr_size(); ++i) {\n    if (op_def.attr(i).name() == name) {\n      return &op_def.attr(i);\n    }\n  }\n  return nullptr;\n}\n\nOpDef::AttrDef* FindAttrMutable(StringPiece name, OpDef* op_def) {\n  for (int i = 0; i < op_def->attr_size(); ++i) {\n    if (op_def->attr(i).name() == name) {\n      return op_def->mutable_attr(i);\n    }\n  }\n  return nullptr;\n}\n\nconst OpDef::ArgDef* FindInputArg(StringPiece name, const OpDef& op_def) {\n  for (int i = 0; i < op_def.input_arg_size(); ++i) {\n    if (op_def.input_arg(i).name() == name) {\n      return &op_def.input_arg(i);\n    }\n  }\n  return nullptr;\n}\n\nconst ApiDef::Arg* FindInputArg(StringPiece name, const ApiDef& api_def) {\n  for (int i = 0; i < api_def.in_arg_size(); ++i) {\n    if (api_def.in_arg(i).name() == name) {\n      return &api_def.in_arg(i);\n    }\n  }\n  return nullptr;\n}\n\n#define VALIDATE(EXPR, ...)                                        \\\n  do {                                                             \\\n    if (!(EXPR)) {                                                 \\\n      return errors::InvalidArgument(                              \\\n          __VA_ARGS__, \"; in OpDef: \", op_def.ShortDebugString()); \\\n    }                                                              \\\n  } while (false)\n\nstatic Status ValidateArg(const OpDef::ArgDef& arg, const OpDef& op_def,\n                          bool output, std::set<string>* names) {\n  const string suffix = strings::StrCat(\n      output ? \" for output '\" : \" for input '\", arg.name(), \"'\");\n  VALIDATE(gtl::InsertIfNotPresent(names, arg.name()),\n           \"Duplicate name: \", arg.name());\n  VALIDATE(HasAttrStyleType(arg), \"Missing type\", suffix);\n\n  if (!arg.number_attr().empty()) {\n    const OpDef::AttrDef* attr = FindAttr(arg.number_attr(), op_def);\n    VALIDATE(attr != nullptr, \"No attr with name '\", arg.number_attr(), \"'\",\n             suffix);\n    VALIDATE(attr->type() == \"int\", \"Attr '\", attr->name(), \"' used as length\",\n             suffix, \" has type \", attr->type(), \" != int\");\n    VALIDATE(attr->has_minimum(), \"Attr '\", attr->name(), \"' used as length\",\n             suffix, \" must have minimum\");\n    VALIDATE(attr->minimum() >= 0, \"Attr '\", attr->name(), \"' used as length\",\n             suffix, \" must have minimum >= 0\");\n    VALIDATE(arg.type_list_attr().empty(),\n             \"Can't have both number_attr and type_list_attr\", suffix);\n    VALIDATE((arg.type() != DT_INVALID ? 1 : 0) +\n                     (!arg.type_attr().empty() ? 1 : 0) ==\n                 1,\n             \"Exactly one of type, type_attr must be set\", suffix);\n  } else {\n    const int num_type_fields = (arg.type() != DT_INVALID ? 1 : 0) +\n                                (!arg.type_attr().empty() ? 1 : 0) +\n                                (!arg.type_list_attr().empty() ? 1 : 0);\n    VALIDATE(num_type_fields == 1,\n             \"Exactly one of type, type_attr, type_list_attr must be set\",\n             suffix);\n  }\n\n  if (!arg.type_attr().empty()) {\n    const OpDef::AttrDef* attr = FindAttr(arg.type_attr(), op_def);\n    VALIDATE(attr != nullptr, \"No attr with name '\", arg.type_attr(), \"'\",\n             suffix);\n    VALIDATE(attr->type() == \"type\", \"Attr '\", attr->name(),\n             \"' used as type_attr\", suffix, \" has type \", attr->type(),\n             \" != type\");\n  } else if (!arg.type_list_attr().empty()) {\n    const OpDef::AttrDef* attr = FindAttr(arg.type_list_attr(), op_def);\n    VALIDATE(attr != nullptr, \"No attr with name '\", arg.type_list_attr(), \"'\",\n             suffix);\n    VALIDATE(attr->type() == \"list(type)\", \"Attr '\", attr->name(),\n             \"' used as type_list_attr\", suffix, \" has type \", attr->type(),\n             \" != list(type)\");\n  } else {\n    // All argument types should be non-reference types at this point.\n    // ArgDef.is_ref is set to true for reference arguments.\n    VALIDATE(!IsRefType(arg.type()), \"Illegal use of ref type '\",\n             DataTypeString(arg.type()), \"'. Use 'Ref(type)' instead\", suffix);\n  }\n\n  return Status::OK();\n}\n\nbool IsValidOpName(StringPiece sp) {\n  using ::tensorflow::strings::Scanner;\n\n  Scanner scanner(sp);\n  scanner.One(Scanner::UPPERLETTER).Any(Scanner::LETTER_DIGIT_UNDERSCORE);\n\n  while (true) {\n    if (!scanner.GetResult())  // Some error in previous iteration.\n      return false;\n    if (scanner.empty())  // No error, but nothing left, good.\n      return true;\n\n    // Absorb another name/namespace, starting with a '>'\n    scanner.One(Scanner::RANGLE)\n        .One(Scanner::UPPERLETTER)\n        .Any(Scanner::LETTER_DIGIT_UNDERSCORE);\n  }\n}\n\nStatus ValidateOpDef(const OpDef& op_def) {\n  if (!absl::StartsWith(op_def.name(), \"_\")) {\n    VALIDATE(IsValidOpName(op_def.name()), \"Invalid name: \", op_def.name(),\n             \" (Did you use CamelCase?)\");\n  }\n\n  std::set<string> names;  // for detecting duplicate names\n  for (const auto& attr : op_def.attr()) {\n    // Validate name\n    VALIDATE(gtl::InsertIfNotPresent(&names, attr.name()),\n             \"Duplicate name: \", attr.name());\n    DataType dt;\n    VALIDATE(!DataTypeFromString(attr.name(), &dt), \"Attr can't have name \",\n             attr.name(), \" that matches a data type\");\n\n    // Validate type\n    StringPiece type(attr.type());\n    bool is_list = absl::ConsumePrefix(&type, \"list(\");\n    bool found = false;\n    for (StringPiece valid : {\"string\", \"int\", \"float\", \"bool\", \"type\", \"shape\",\n                              \"tensor\", \"func\"}) {\n      if (absl::ConsumePrefix(&type, valid)) {\n        found = true;\n        break;\n      }\n    }\n    VALIDATE(found, \"Unrecognized type '\", type, \"' in attr '\", attr.name(),\n             \"'\");\n    if (is_list) {\n      VALIDATE(absl::ConsumePrefix(&type, \")\"),\n               \"'list(' is missing ')' in attr \", attr.name(), \"'s type \",\n               attr.type());\n    }\n    VALIDATE(type.empty(), \"Extra '\", type, \"' at the end of attr \",\n             attr.name(), \"'s type \", attr.type());\n\n    // Validate minimum\n    if (attr.has_minimum()) {\n      VALIDATE(attr.type() == \"int\" || is_list, \"Attr '\", attr.name(),\n               \"' has minimum for unsupported type \", attr.type());\n      if (is_list) {\n        VALIDATE(attr.minimum() >= 0, \"Attr '\", attr.name(),\n                 \"' with list type must have a non-negative minimum, not \",\n                 attr.minimum());\n      }\n    } else {\n      VALIDATE(attr.minimum() == 0, \"Attr '\", attr.name(),\n               \"' with has_minimum = false but minimum \", attr.minimum(),\n               \" not equal to default of 0\");\n    }\n\n    // Validate allowed_values\n    if (attr.has_allowed_values()) {\n      const string list_type =\n          is_list ? attr.type() : strings::StrCat(\"list(\", attr.type(), \")\");\n      TF_RETURN_WITH_CONTEXT_IF_ERROR(\n          AttrValueHasType(attr.allowed_values(), list_type), \" for attr '\",\n          attr.name(), \"' in Op '\", op_def.name(), \"'\");\n    }\n\n    // Validate default_value (after we have validated the rest of the attr,\n    // so we can use ValidateAttrValue()).\n    if (attr.has_default_value()) {\n      TF_RETURN_WITH_CONTEXT_IF_ERROR(\n          ValidateAttrValue(attr.default_value(), attr), \" in Op '\",\n          op_def.name(), \"'\");\n    }\n  }\n\n  for (const auto& arg : op_def.input_arg()) {\n    TF_RETURN_IF_ERROR(ValidateArg(arg, op_def, false, &names));\n  }\n\n  for (const auto& arg : op_def.output_arg()) {\n    TF_RETURN_IF_ERROR(ValidateArg(arg, op_def, true, &names));\n  }\n\n  return Status::OK();\n}\n\n#undef VALIDATE\n\nStatus CheckOpDeprecation(const OpDef& op_def, int graph_def_version) {\n  if (op_def.has_deprecation()) {\n    const OpDeprecation& dep = op_def.deprecation();\n    if (graph_def_version >= dep.version()) {\n      return errors::Unimplemented(\n          \"Op \", op_def.name(), \" is not available in GraphDef version \",\n          graph_def_version, \". It has been removed in version \", dep.version(),\n          \". \", dep.explanation(), \".\");\n    } else {\n      // Warn only once for each op name, and do it in a threadsafe manner.\n      static mutex mu(LINKER_INITIALIZED);\n      static std::unordered_set<string> warned;\n      bool warn;\n      {\n        mutex_lock lock(mu);\n        warn = warned.insert(op_def.name()).second;\n      }\n      if (warn) {\n        LOG(WARNING) << \"Op \" << op_def.name() << \" is deprecated.\"\n                     << \" It will cease to work in GraphDef version \"\n                     << dep.version() << \". \" << dep.explanation() << \".\";\n      }\n    }\n  }\n  return Status::OK();\n}\n\nnamespace {\n\nstring SummarizeArgs(const protobuf::RepeatedPtrField<OpDef::ArgDef>& args) {\n  string ret;\n  for (const OpDef::ArgDef& arg : args) {\n    if (!ret.empty()) strings::StrAppend(&ret, \", \");\n    strings::StrAppend(&ret, arg.name(), \":\");\n    if (arg.is_ref()) strings::StrAppend(&ret, \"Ref(\");\n    if (!arg.number_attr().empty()) {\n      strings::StrAppend(&ret, arg.number_attr(), \"*\");\n    }\n    if (arg.type() != DT_INVALID) {\n      strings::StrAppend(&ret, DataTypeString(arg.type()));\n    } else {\n      strings::StrAppend(&ret, arg.type_attr());\n    }\n    if (arg.is_ref()) strings::StrAppend(&ret, \")\");\n  }\n  return ret;\n}\n\n}  // namespace\n\nstring SummarizeOpDef(const OpDef& op_def) {\n  string ret = strings::StrCat(\"Op<name=\", op_def.name());\n  strings::StrAppend(&ret, \"; signature=\", SummarizeArgs(op_def.input_arg()),\n                     \" -> \", SummarizeArgs(op_def.output_arg()));\n  for (int i = 0; i < op_def.attr_size(); ++i) {\n    strings::StrAppend(&ret, \"; attr=\", op_def.attr(i).name(), \":\",\n                       op_def.attr(i).type());\n    if (op_def.attr(i).has_default_value()) {\n      strings::StrAppend(&ret, \",default=\",\n                         SummarizeAttrValue(op_def.attr(i).default_value()));\n    }\n    if (op_def.attr(i).has_minimum()) {\n      strings::StrAppend(&ret, \",min=\", op_def.attr(i).minimum());\n    }\n    if (op_def.attr(i).has_allowed_values()) {\n      strings::StrAppend(&ret, \",allowed=\",\n                         SummarizeAttrValue(op_def.attr(i).allowed_values()));\n    }\n  }\n  if (op_def.is_commutative()) {\n    strings::StrAppend(&ret, \"; is_commutative=true\");\n  }\n  if (op_def.is_aggregate()) {\n    strings::StrAppend(&ret, \"; is_aggregate=true\");\n  }\n  if (op_def.is_stateful()) {\n    strings::StrAppend(&ret, \"; is_stateful=true\");\n  }\n  if (op_def.allows_uninitialized_input()) {\n    strings::StrAppend(&ret, \"; allows_uninitialized_input=true\");\n  }\n  if (op_def.is_distributed_communication()) {\n    strings::StrAppend(&ret, \"; is_distributed_communication=true\");\n  }\n  strings::StrAppend(&ret, \">\");\n  return ret;\n}\n\nnamespace {\n\n// Returns true if every element of `sub` is contained in `super`.\ntemplate <class T>\nbool IsSubsetOf(const T& sub, const T& super) {\n  for (const auto& o : sub) {\n    bool found = false;\n    for (const auto& n : super) {\n      if (o == n) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) return false;\n  }\n  return true;\n}\n\nbool MoreRestrictive(const OpDef::AttrDef& old_attr,\n                     const OpDef::AttrDef& new_attr) {\n  // Anything -> no restriction : not more restrictive.\n  if (!new_attr.has_allowed_values()) return false;\n  // No restriction -> restriction : more restrictive.\n  if (!old_attr.has_allowed_values()) return true;\n  // If anything that was previously allowed is no longer allowed:\n  // more restrictive.\n  if (!IsSubsetOf(old_attr.allowed_values().list().type(),\n                  new_attr.allowed_values().list().type())) {\n    return true;\n  }\n  if (!IsSubsetOf(old_attr.allowed_values().list().s(),\n                  new_attr.allowed_values().list().s())) {\n    return true;\n  }\n  return false;\n}\n\nstring AllowedStr(const OpDef::AttrDef& attr) {\n  if (!attr.has_allowed_values()) return \"no restriction\";\n  return SummarizeAttrValue(attr.allowed_values());\n}\n\nstring DefaultAttrStr(const OpDef::AttrDef& attr) {\n  if (!attr.has_default_value()) return \"no default\";\n  return SummarizeAttrValue(attr.default_value());\n}\n\nbool HigherMinimum(const OpDef::AttrDef& old_attr,\n                   const OpDef::AttrDef& new_attr) {\n  // Anything -> no restriction : not more restrictive.\n  if (!new_attr.has_minimum()) return false;\n  // No restriction -> restriction : more restrictive.\n  if (!old_attr.has_minimum()) return true;\n  // If anything that was previously allowed is no longer allowed:\n  // more restrictive.\n  return new_attr.minimum() > old_attr.minimum();\n}\n\nstring MinStr(const OpDef::AttrDef& attr) {\n  if (!attr.has_minimum()) return \"no minimum\";\n  return strings::StrCat(attr.minimum());\n}\n\ntypedef std::unordered_map<string, const OpDef::AttrDef*> AttrMap;\nvoid FillAttrMap(const OpDef& op_def, AttrMap* attr_map) {\n  for (const auto& attr : op_def.attr()) {\n    (*attr_map)[attr.name()] = &attr;\n  }\n}\n\n// Add a comma to *s every call but the first (*add_comma should be\n// initialized to false).\nvoid AddComma(string* s, bool* add_comma) {\n  if (*add_comma) {\n    strings::StrAppend(s, \", \");\n  } else {\n    *add_comma = true;\n  }\n}\n\n// Will add the `name` from arg if name is true.\nvoid AddName(string* s, bool name, const OpDef::ArgDef& arg) {\n  if (name) {\n    strings::StrAppend(s, arg.name(), \":\");\n  }\n}\n\n// Compute a signature for either inputs or outputs that will be the\n// same for both the old and new OpDef if they are compatible.  We\n// assume that new_attrs is a superset of old_attrs, and that any attr\n// in the difference has a default.  Our strategy is to make a list of\n// types, where the types are things like:\n// * \"int32\", \"float\", etc.,\n// * \"T\" for some attr \"T\" in old_attrs, or\n// * \"N * type\" for \"N\" either some attr in old_attrs.\n//\n// We get the types by either using the attrs in args if they are in\n// old_attrs, or substituting the default value from new_attrs.\nstring ComputeArgSignature(\n    const protobuf::RepeatedPtrField<OpDef::ArgDef>& args,\n    const AttrMap& old_attrs, const AttrMap& new_attrs, std::vector<bool>* ref,\n    bool names) {\n  string s;\n  bool add_comma = false;\n  for (const OpDef::ArgDef& arg : args) {\n    if (!arg.type_list_attr().empty()) {\n      const OpDef::AttrDef* old_attr =\n          gtl::FindPtrOrNull(old_attrs, arg.type_list_attr());\n      if (old_attr) {\n        // Both old and new have the list(type) attr, so can use it directly.\n        AddComma(&s, &add_comma);\n        AddName(&s, names, arg);\n        strings::StrAppend(&s, arg.type_list_attr());\n        ref->push_back(arg.is_ref());\n      } else {\n        // Missing the list(type) attr in the old, so use the default\n        // value for the attr from new instead.\n        const OpDef::AttrDef* new_attr =\n            gtl::FindPtrOrNull(new_attrs, arg.type_list_attr());\n        const auto& type_list = new_attr->default_value().list().type();\n        if (type_list.empty()) continue;\n        for (int i = 0; i < type_list.size(); ++i) {\n          AddComma(&s, &add_comma);\n          AddName(&s, names, arg);\n          strings::StrAppend(\n              &s, DataTypeString(static_cast<DataType>(type_list.Get(i))));\n          ref->push_back(arg.is_ref());\n        }\n      }\n    } else {\n      int num = 1;  // How many input/outputs does this represent?\n      string type;  // What is the type of this arg?\n      AddName(&type, names, arg);\n      if (!arg.number_attr().empty()) {\n        // N * type case.\n        const OpDef::AttrDef* old_attr =\n            gtl::FindPtrOrNull(old_attrs, arg.number_attr());\n        if (old_attr) {\n          // Both old and new have the number attr, so can use it directly.\n          strings::StrAppend(&type, arg.number_attr(), \" * \");\n        } else {\n          // Missing the number attr in the old, so use the default\n          // value for the attr from new instead.\n          const OpDef::AttrDef* new_attr =\n              gtl::FindPtrOrNull(new_attrs, arg.number_attr());\n          num = new_attr->default_value().i();\n        }\n      }\n\n      if (arg.type() != DT_INVALID) {\n        // int32, float, etc. case\n        strings::StrAppend(&type, DataTypeString(arg.type()));\n      } else {\n        const OpDef::AttrDef* old_attr =\n            gtl::FindPtrOrNull(old_attrs, arg.type_attr());\n        if (old_attr) {\n          // Both old and new have the type attr, so can use it directly.\n          strings::StrAppend(&type, arg.type_attr());\n        } else {\n          // Missing the type attr in the old, so use the default\n          // value for the attr from new instead.\n          const OpDef::AttrDef* new_attr =\n              gtl::FindPtrOrNull(new_attrs, arg.type_attr());\n          strings::StrAppend(&type,\n                             DataTypeString(new_attr->default_value().type()));\n        }\n      }\n\n      // Record `num` * `type` in the signature.\n      for (int i = 0; i < num; ++i) {\n        AddComma(&s, &add_comma);\n        strings::StrAppend(&s, type);\n        ref->push_back(arg.is_ref());\n      }\n    }\n  }\n\n  return s;\n}\n\n}  // namespace\n\nStatus OpDefCompatible(const OpDef& old_op, const OpDef& new_op) {\n#define VALIDATE(CONDITION, ...)                                            \\\n  if (!(CONDITION)) {                                                       \\\n    return errors::InvalidArgument(\"Incompatible Op change: \", __VA_ARGS__, \\\n                                   \"; old: \", SummarizeOpDef(old_op),       \\\n                                   \"; new: \", SummarizeOpDef(new_op));      \\\n  }\n\n  VALIDATE(old_op.name() == new_op.name(), \"Name mismatch\");\n\n  AttrMap new_attrs, old_attrs;\n  FillAttrMap(old_op, &old_attrs);\n  FillAttrMap(new_op, &new_attrs);\n  for (const auto& old_attr : old_op.attr()) {\n    const OpDef::AttrDef* new_attr =\n        gtl::FindPtrOrNull(new_attrs, old_attr.name());\n    VALIDATE(new_attr != nullptr, \"Attr '\", old_attr.name(), \"' removed\");\n    VALIDATE(old_attr.type() == new_attr->type(), \"Attr '\", old_attr.name(),\n             \"' changed type '\", old_attr.type(), \"' -> '\", new_attr->type(),\n             \"'\");\n    VALIDATE(!MoreRestrictive(old_attr, *new_attr), \"Attr '\", old_attr.name(),\n             \"' has a stricter set of allowed values; from \",\n             AllowedStr(old_attr), \" to \", AllowedStr(*new_attr));\n    VALIDATE(!HigherMinimum(old_attr, *new_attr), \"Attr '\", old_attr.name(),\n             \"' has a higher minimum; from \", MinStr(old_attr), \" to \",\n             MinStr(*new_attr));\n  }\n\n  for (const auto& new_attr : new_op.attr()) {\n    const OpDef::AttrDef* old_attr =\n        gtl::FindPtrOrNull(old_attrs, new_attr.name());\n    VALIDATE(old_attr != nullptr || new_attr.has_default_value(), \"Attr '\",\n             new_attr.name(), \"' added without default\");\n  }\n\n  std::vector<bool> old_in_ref, new_in_ref, old_out_ref, new_out_ref;\n  const string old_in_sig = ComputeArgSignature(\n      old_op.input_arg(), old_attrs, new_attrs, &old_in_ref, false /* names */);\n  const string new_in_sig = ComputeArgSignature(\n      new_op.input_arg(), old_attrs, new_attrs, &new_in_ref, false /* names */);\n  VALIDATE(old_in_sig == new_in_sig, \"Input signature mismatch '\", old_in_sig,\n           \"' vs. '\", new_in_sig, \"'\");\n  VALIDATE(old_in_ref.size() == new_in_ref.size(),  // Should not happen\n           \"Unexpected change in input ref lists.\");\n  for (int i = 0, end = old_in_ref.size(); i < end; ++i) {\n    // Allowed to remove \"ref\" from an input (or leave it unchanged).\n    VALIDATE(old_in_ref[i] || !new_in_ref[i], \"Input \", i,\n             \" changed from non-ref to ref\");\n  }\n\n  const string old_out_sig =\n      ComputeArgSignature(old_op.output_arg(), old_attrs, new_attrs,\n                          &old_out_ref, true /* names */);\n  const string new_out_sig =\n      ComputeArgSignature(new_op.output_arg(), old_attrs, new_attrs,\n                          &new_out_ref, true /* names */);\n  VALIDATE(old_out_sig == new_out_sig, \"Output signature mismatch '\",\n           old_out_sig, \"' vs. '\", new_out_sig, \"'\");\n  VALIDATE(old_out_ref.size() == new_out_ref.size(),  // Should not happen\n           \"Unexpected change in output ref lists\");\n  for (int i = 0, end = old_out_ref.size(); i < end; ++i) {\n    // Allowed to add \"ref\" to an output (or leave it unchanged).\n    VALIDATE(!old_out_ref[i] || new_out_ref[i], \"Output \", i,\n             \" changed from ref to non-ref\");\n  }\n\n  return Status::OK();\n}\n\nStatus OpDefAddedDefaultsUnchanged(const OpDef& old_op,\n                                   const OpDef& penultimate_op,\n                                   const OpDef& new_op) {\n  AttrMap new_attrs, old_attrs;\n  FillAttrMap(old_op, &old_attrs);\n  FillAttrMap(new_op, &new_attrs);\n\n  for (const auto& penultimate_attr : penultimate_op.attr()) {\n    const OpDef::AttrDef* old_attr =\n        gtl::FindPtrOrNull(old_attrs, penultimate_attr.name());\n    if (old_attr != nullptr) continue;  // attr wasn't added\n    const OpDef::AttrDef* new_attr =\n        gtl::FindPtrOrNull(new_attrs, penultimate_attr.name());\n\n    // These shouldn't happen if the op passed OpDefCompatible().\n    if (new_attr == nullptr) {\n      return errors::InvalidArgument(\"Missing attr '\", penultimate_attr.name(),\n                                     \"' in op: \", SummarizeOpDef(new_op));\n    }\n    if (!penultimate_attr.has_default_value() ||\n        !new_attr->has_default_value()) {\n      return errors::InvalidArgument(\"Missing default for attr '\",\n                                     penultimate_attr.name(),\n                                     \"' in op: \", SummarizeOpDef(new_op));\n    }\n\n    // Actually test that the attr's default value hasn't changed.\n    if (!AreAttrValuesEqual(penultimate_attr.default_value(),\n                            new_attr->default_value())) {\n      return errors::InvalidArgument(\n          \"Can't change default value for attr '\", penultimate_attr.name(),\n          \"' from \", SummarizeAttrValue(penultimate_attr.default_value()),\n          \" in op: \", SummarizeOpDef(new_op));\n    }\n  }\n\n  return Status::OK();\n}\n\nStatus OpDefAttrDefaultsUnchanged(const OpDef& old_op, const OpDef& new_op) {\n  AttrMap new_attrs, old_attrs;\n  FillAttrMap(old_op, &old_attrs);\n  FillAttrMap(new_op, &new_attrs);\n\n  for (const auto& old_attr : old_op.attr()) {\n    const OpDef::AttrDef* new_attr =\n        gtl::FindPtrOrNull(new_attrs, old_attr.name());\n    if (new_attr == nullptr) continue;\n    if (new_attr->has_default_value() && !old_attr.has_default_value()) {\n      continue;  // Adding new default values is safe.\n    }\n    if (old_attr.has_default_value() && !new_attr->has_default_value()) {\n      return errors::InvalidArgument(\n          \"Attr '\", old_attr.name(), \"' has removed it's default; \", \"from \",\n          DefaultAttrStr(old_attr), \" to \", DefaultAttrStr(*new_attr));\n    }\n    if (old_attr.has_default_value() &&\n        !AreAttrValuesEqual(old_attr.default_value(),\n                            new_attr->default_value())) {\n      return errors::InvalidArgument(\n          \"Attr '\", old_attr.name(), \"' has changed it's default value; \",\n          \"from \", DefaultAttrStr(old_attr), \" to \", DefaultAttrStr(*new_attr));\n    }\n  }\n\n  return Status::OK();\n}\n\nvoid RemoveNonDeprecationDescriptionsFromOpDef(OpDef* op_def) {\n  for (int i = 0; i < op_def->input_arg_size(); ++i) {\n    op_def->mutable_input_arg(i)->clear_description();\n  }\n  for (int i = 0; i < op_def->output_arg_size(); ++i) {\n    op_def->mutable_output_arg(i)->clear_description();\n  }\n  for (int i = 0; i < op_def->attr_size(); ++i) {\n    op_def->mutable_attr(i)->clear_description();\n  }\n  op_def->clear_summary();\n  op_def->clear_description();\n}\n\nvoid RemoveDescriptionsFromOpDef(OpDef* op_def) {\n  RemoveNonDeprecationDescriptionsFromOpDef(op_def);\n  if (op_def->has_deprecation()) {\n    op_def->mutable_deprecation()->clear_explanation();\n  }\n}\n\nvoid RemoveDescriptionsFromOpList(OpList* op_list) {\n  for (int i = 0; i < op_list->op_size(); ++i) {\n    OpDef* op_def = op_list->mutable_op(i);\n    RemoveDescriptionsFromOpDef(op_def);\n  }\n}\n\nbool AttrDefEqual(const OpDef::AttrDef& a1, const OpDef::AttrDef& a2) {\n  if (std::is_base_of<protobuf::Message, OpDef::AttrDef>()) {\n    DCHECK_EQ(7, reinterpret_cast<const protobuf::Message*>(&a1)\n                     ->GetDescriptor()\n                     ->field_count())\n        << \"Please modify these equality and hash functions to reflect the \"\n           \"changes to the AttrDef protobuf\";\n  }\n\n  if (a1.name() != a2.name()) return false;\n  if (a1.type() != a2.type()) return false;\n  if (a1.description() != a2.description()) return false;\n  if (a1.has_minimum() != a2.has_minimum()) return false;\n  if (a1.has_minimum() && a1.minimum() != a2.minimum()) return false;\n  if (!AreAttrValuesEqual(a1.default_value(), a2.default_value())) return false;\n  if (!AreAttrValuesEqual(a1.allowed_values(), a2.allowed_values()))\n    return false;\n  return true;\n}\n\nuint64 AttrDefHash(const OpDef::AttrDef& a) {\n  uint64 h = Hash64(a.name());\n  h = Hash64(a.type().data(), a.type().size(), h);\n  h = Hash64Combine(AttrValueHash(a.default_value()), h);\n  h = Hash64(a.description().data(), a.description().size(), h);\n  h = Hash64Combine(static_cast<uint64>(a.has_minimum()), h);\n  h = Hash64Combine(static_cast<uint64>(a.minimum()), h);\n  h = Hash64Combine(AttrValueHash(a.allowed_values()), h);\n  return h;\n}\n\nbool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;\n}\n\nuint64 RepeatedAttrDefHash(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a) {\n  // Insert AttrDefs into map to deterministically sort by name\n  std::map<string, const OpDef::AttrDef*> a_set;\n  for (const OpDef::AttrDef& def : a) {\n    a_set[def.name()] = &def;\n  }\n  // Iterate and combines hashes of keys and values\n  uint64 h = 0xDECAFCAFFE;\n  for (const auto& pair : a_set) {\n    h = Hash64(pair.first.data(), pair.first.size(), h);\n    h = Hash64Combine(AttrDefHash(*pair.second), h);\n  }\n  return h;\n}\n\nbool OpDefEqual(const OpDef& o1, const OpDef& o2) {\n  // attr order doesn't matter.\n  // Compare it separately here instead of serializing below.\n  if (!RepeatedAttrDefEqual(o1.attr(), o2.attr())) return false;\n\n  // `control_output` order doesn't matter.\n  std::set<string> control_output1(o1.control_output().begin(),\n                                   o1.control_output().end());\n  std::set<string> control_output2(o2.control_output().begin(),\n                                   o2.control_output().end());\n  if (control_output1 != control_output2) return false;\n\n  // Clear `attr` and `control_output` fields, serialize, and compare serialized\n  // strings.\n  OpDef o1_copy = o1;\n  OpDef o2_copy = o2;\n  o1_copy.clear_attr();\n  o1_copy.clear_control_output();\n  o2_copy.clear_attr();\n  o2_copy.clear_control_output();\n\n  return AreSerializedProtosEqual(o1_copy, o2_copy);\n}\n\nuint64 OpDefHash(const OpDef& o) {\n  uint64 h = RepeatedAttrDefHash(o.attr());\n\n  // Compute deterministic order-independent control outputs hash.\n  std::set<string> control_output(o.control_output().begin(),\n                                  o.control_output().end());\n  for (const auto& co : control_output) h = Hash64Combine(h, Hash64(co));\n\n  OpDef o_copy = o;\n  o_copy.clear_attr();\n  o_copy.clear_control_output();\n  return DeterministicProtoHash64(o_copy, h);\n}\n\n}  // namespace tensorflow"