"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/grappler/costs/graph_properties.h\"\n\n#include \"absl/types/optional.h\"\n#include \"tensorflow/core/common_runtime/function.h\"\n#include \"tensorflow/core/common_runtime/graph_constructor.h\"\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/function.pb.h\"\n#include \"tensorflow/core/framework/node_def_util.h\"\n#include \"tensorflow/core/framework/tensor.pb.h\"\n#include \"tensorflow/core/framework/tensor_shape.pb.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/framework/versions.pb.h\"\n#include \"tensorflow/core/graph/tensor_id.h\"\n#include \"tensorflow/core/grappler/costs/utils.h\"\n#include \"tensorflow/core/grappler/mutable_graph_view.h\"\n#include \"tensorflow/core/grappler/op_types.h\"\n#include \"tensorflow/core/grappler/optimizers/evaluation_utils.h\"\n#include \"tensorflow/core/grappler/utils.h\"\n#include \"tensorflow/core/grappler/utils/functions.h\"\n#include \"tensorflow/core/grappler/utils/topological_sort.h\"\n#include \"tensorflow/core/lib/gtl/cleanup.h\"\n#include \"tensorflow/core/lib/gtl/flatset.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n\nnamespace tensorflow {\nnamespace grappler {\n\nnamespace {\n\nusing shape_inference::DimensionHandle;\nusing shape_inference::InferenceContext;\nusing shape_inference::ShapeAndType;\nusing shape_inference::ShapeHandle;\nusing TensorVector = gtl::InlinedVector<TensorValue, 4>;\n\n// A large value for UnknownDim from Const used as a dim value in shape.\n// Some ops treat \"-1\" specially, different from UnknownDim:\n// e.g., shape input to Reshape op.\nconst int64_t kUnknownDimFromConst = INT64_MAX;\n\n// Skip const value instantiation if the number of elements in a const tensor\n// is greater than this threshold.\nconst int kThresholdToSkipConstTensorInstantiation = 128;\n\ntemplate <typename Handle>\nstruct HashHandle {\n  std::size_t operator()(const Handle& h) const { return h.Handle(); }\n};\ntemplate <typename Handle>\nstruct CompareHandle {\n  bool operator()(const Handle& h1, const Handle& h2) const {\n    return h1.SameHandle(h2);\n  }\n};\n\ntemplate <typename Handle>\nstruct HandleToObject {};\ntemplate <>\nstruct HandleToObject<ShapeHandle> {\n  typedef ShapeHandle Object;\n\n  static ShapeHandle Unknown() { return ShapeHandle(); }\n};\n\ntemplate <>\nstruct HandleToObject<DimensionHandle> {\n  typedef int64_t Object;\n\n  static int64_t Unknown() { return -1; }\n};\n\ntemplate <typename Handle>\nstruct Processor {};\n\ntemplate <>\nstruct Processor<ShapeHandle> {\n  // Extract the shape or dim denoted by the handle.\n  void ExtractValue(ShapeHandle h, ShapeHandle* result) { *result = h; }\n  // Merge the shapes or dims.\n  Status Merge(ShapeHandle h1, ShapeHandle h2, ShapeHandle* result) {\n    if (InferenceContext::RankKnown(*result)) {\n      // The result was initialized in a previous merge to a shape of known\n      // rank, make sure we preserve that information.\n      return Status::OK();\n    }\n    if (InferenceContext::RankKnown(h1)) {\n      *result = h1;\n    } else {\n      *result = h2;\n    }\n    return Status::OK();\n  }\n};\n\ntemplate <>\nstruct Processor<DimensionHandle> {\n  // Assign a negative id to unknown dimensions, starting at -2 (the -1 id\n  // reserved by TensorFlow).\n  void ExtractValue(DimensionHandle d, int64_t* result) {\n    if (!InferenceContext::ValueKnown(d)) {\n      *result = -counter;\n      counter++;\n    } else {\n      int64_t val = InferenceContext::Value(d);\n      if (val >= 0) {\n        *result = val;\n      } else {\n        // A shape inference function generated an invalid dimension handle.\n        // Use a symbolic dimension to encode this.\n        *result = -counter;\n        counter++;\n      }\n    }\n  }\n\n  // Merge the dimensions d1 and d2. Return the known shape if there is one,\n  // otherwise look for a symbolic shape. If there is no symbolic shape and no\n  // known shape, the shape if fully unknown so return -1.\n  Status Merge(DimensionHandle d1, DimensionHandle d2, int64_t* result) {\n    const int64_t dim1 = InferenceContext::Value(d1);\n    const int64_t dim2 = InferenceContext::Value(d2);\n\n    if (dim1 >= 0 && dim2 >= 0) {\n      CHECK_EQ(dim1, dim2);\n      return RefineDim(dim1, result);\n    } else if (dim1 >= 0 && dim2 < 0) {\n      return RefineDim(dim1, result);\n    } else if (dim1 < 0 && dim2 >= 0) {\n      return RefineDim(dim2, result);\n    } else if (dim1 < -1) {\n      return RefineDim(dim1, result);\n    } else if (dim2 < -1) {\n      return RefineDim(dim2, result);\n    } else {\n      CHECK_EQ(dim1, dim2);\n      CHECK_EQ(-1, dim1);\n      return RefineDim(-1, result);\n    }\n    return Status::OK();\n  }\n\n private:\n  Status RefineDim(int64_t dim, int64_t* result) {\n    if (*result >= 0) {\n      if (!(*result == dim || dim < 0)) {\n        return errors::InvalidArgument(\"Inconsistent dimensions detected\");\n      }\n    } else if (dim >= 0) {\n      *result = dim;\n    } else if (dim < *result) {\n      *result = dim;\n    }\n    return Status::OK();\n  }\n\n  int64_t counter = 2;\n};\n\n// Traditional Disjoint-Set datastructure with path compression.\n// (https://en.wikipedia.org/wiki/Disjoint-set_data_structure)\ntemplate <typename Handle>\nclass DisjointSet {\n public:\n  DisjointSet() {}\n  ~DisjointSet() {\n    for (auto rep : nodes_) {\n      delete rep.second;\n    }\n  }\n\n  Status Merge(Handle x, Handle y);\n  const typename HandleToObject<Handle>::Object GetMergedValue(Handle value);\n\n private:\n  // All the handles that belong to the same set are part of the same tree, and\n  // utimately represented by the root of that tree.\n  struct Rep {\n    // Parent in the tree used to encode the set.\n    Rep* parent;\n    // Rank in the tree, used to figure out how to compress the path to the root\n    // of the tree.\n    int rank;\n    // The handle.\n    typename HandleToObject<Handle>::Object value;\n  };\n\n  // Create a new set for the value if none exists, or return its representative\n  // node otherwise.\n  Rep* Find(Handle value);\n\n private:\n  Processor<Handle> processor_;\n  absl::flat_hash_map<Handle, Rep*, HashHandle<Handle>, CompareHandle<Handle>>\n      nodes_;\n};\n\ntemplate <typename Handle>\nconst typename HandleToObject<Handle>::Object\nDisjointSet<Handle>::GetMergedValue(Handle value) {\n  Rep* rep = Find(value);\n  if (!rep) {\n    // We don't know anything about this handle.\n    return HandleToObject<Handle>::Unknown();\n  }\n  return rep->value;\n}\n\ntemplate <typename Handle>\nStatus DisjointSet<Handle>::Merge(Handle x, Handle y) {\n  Rep* x_root = Find(x);\n  Rep* y_root = Find(y);\n\n  // x and y are already in the same set\n  if (x_root == y_root) {\n    return Status::OK();\n  }\n  // x and y are not in same set, so we merge them\n  // Use the occasion to strengthen what we know about the handle by merging the\n  // information about the 2 subsets.\n  if (x_root->rank < y_root->rank) {\n    TF_RETURN_IF_ERROR(processor_.Merge(y, x, &y_root->value));\n    x_root->parent = y_root;\n  } else if (x_root->rank > y_root->rank) {\n    TF_RETURN_IF_ERROR(processor_.Merge(x, y, &x_root->value));\n    y_root->parent = x_root;\n  } else {\n    TF_RETURN_IF_ERROR(processor_.Merge(x, y, &x_root->value));\n    // Arbitrarily make one root the new parent\n    y_root->parent = x_root;\n    x_root->rank = x_root->rank + 1;\n  }\n  return Status::OK();\n}\n\ntemplate <typename Handle>\ntypename DisjointSet<Handle>::Rep* DisjointSet<Handle>::Find(Handle value) {\n  auto it = nodes_.find(value);\n  if (it == nodes_.end()) {\n    // This is the first time we process this handle, create an entry for it.\n    Rep* node = new Rep;\n    node->parent = node;\n    node->rank = 0;\n    processor_.ExtractValue(value, &node->value);\n    nodes_[value] = node;\n    return node;\n  }\n  // Return the representative for the set, which is the root of the tree. Apply\n  // path compression to speedup future queries.\n  Rep* node = it->second;\n  Rep* root = node->parent;\n  while (root != root->parent) {\n    root = root->parent;\n  }\n  while (node->parent != root) {\n    Rep* next = node->parent;\n    node->parent = root;\n    node = next;\n  }\n  return root;\n}\n\n// TODO(dyoon): Move many helper functions in this file (including those within\n// SymbolicShapeRefiner class) to shared utils.\nbool IsEnqueue(const NodeDef& n) {\n  return (n.op().find(\"Enqueue\") != string::npos &&\n          n.op().find(\"EnqueueMany\") == string::npos);\n}\n\nbool IsDequeue(const NodeDef& n) {\n  return (n.op().find(\"Dequeue\") != string::npos &&\n          n.op().find(\"DequeueMany\") == string::npos);\n}\n\nbool HasAnyUnknownDimensions(const TensorShapeProto& proto) {\n  if (proto.unknown_rank()) {\n    return true;\n  }\n  for (const auto& dim : proto.dim()) {\n    if (dim.size() < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// This really should be done in an external debugging tool\nvoid VerboseLogUnknownDimensionSources(\n    const GraphDef& graph,\n    const absl::flat_hash_map<string, std::vector<OpInfo::TensorProperties>>&\n        input_properties_map,\n    const absl::flat_hash_map<string, std::vector<OpInfo::TensorProperties>>&\n        output_properties_map) {\n  if (!VLOG_IS_ON(2)) {\n    return;\n  }\n\n  VLOG(2) << \"Nodes with known inputs, but with unknown output dimensions:\";\n\n  // Find all nodes in the graph for which we\n  // do not have any unknown dimensions in their inputs, but\n  // we have some unknown dimensions in their outputs.\n  std::map<string, int> op_to_count;\n  for (const NodeDef& node : graph.node()) {\n    const auto& input_properties = input_properties_map.at(node.name());\n    const auto& output_properties = output_properties_map.at(node.name());\n\n    bool has_unknown_inputs = false;\n    for (const auto& input_prop : input_properties) {\n      if (HasAnyUnknownDimensions(input_prop.shape())) {\n        has_unknown_inputs = true;\n        break;\n      }\n    }\n\n    if (has_unknown_inputs) {\n      continue;\n    }\n\n    for (const auto& output_prop : output_properties) {\n      if (HasAnyUnknownDimensions(output_prop.shape())) {\n        string inputs = \"input_shapes=[\";\n        for (const auto& input_prop : input_properties) {\n          inputs += PartialTensorShape::DebugString(input_prop.shape());\n        }\n        inputs += \"]\";\n\n        string outputs = \"output_shapes=[\";\n        for (const auto& output_prop : output_properties) {\n          outputs += PartialTensorShape::DebugString(output_prop.shape());\n        }\n        outputs += \"]\";\n\n        VLOG(2) << \"Node: \" << node.name() << \", Op: \" << node.op() << \", \"\n                << inputs << \", \" << outputs;\n\n        op_to_count[node.op()]++;\n\n        // don't log again for this node\n        break;\n      }\n    }\n  }\n  VLOG(2) << \"Op types with known inputs, but with unknown output dimensions \"\n          << \"(format: <op_type> (<count>)):\";\n  for (const auto& p : op_to_count) {\n    VLOG(2) << p.first << \" (\" << p.second << \")\";\n  }\n}\n\n// Helper function to convert kUnknownDimFromConst into UnknownDim.\nstd::vector<ShapeHandle> ReplaceUnknownDimFromConstWithUnknownDim(\n    InferenceContext* ic, const std::vector<ShapeHandle>& shapes) {\n  std::vector<ShapeHandle> converted_shapes(shapes.size());\n  for (int i = 0, shapes_size = shapes.size(); i < shapes_size; i++) {\n    const auto& shape = shapes[i];\n    if (!ic->RankKnown(shape)) {\n      converted_shapes[i] = shape;\n      continue;\n    }\n    bool just_copy = true;\n    std::vector<DimensionHandle> dims;\n    for (int32_t i = 0; i < ic->Rank(shape); ++i) {\n      DimensionHandle dim = ic->Dim(shape, i);\n      if (ic->ValueKnown(dim) && ic->Value(dim) == kUnknownDimFromConst) {\n        just_copy = false;\n        dims.push_back(ic->UnknownDim());\n      } else {\n        dims.push_back(dim);\n      }\n    }\n    if (just_copy) {\n      converted_shapes[i] = shape;\n      continue;\n    }\n    converted_shapes[i] = ic->MakeShape(dims);\n  }\n  return converted_shapes;\n}\n\n// Returned tensor's shape is like `shape`, and its values and dtype are from\n// `tensor_as_shape` and `dtype`.\nTensorProto MakeTensorProtoFromShape(InferenceContext* ic,\n                                     const ShapeHandle& shape,\n                                     const ShapeHandle& tensor_as_shape,\n                                     const DataType& dtype) {\n  TensorProto tensor_proto;\n  tensor_proto.set_dtype(dtype);\n  auto* shape_proto = tensor_proto.mutable_tensor_shape();\n  if (ic->Rank(shape) == 1) {\n    shape_proto->add_dim()->set_size(ic->Rank(tensor_as_shape));\n  }\n  // For a scalar tensor, tensor_shape field will be left empty; no dim.\n  for (int i = 0; i < ic->Rank(tensor_as_shape); i++) {\n    int64_t value = ic->Value(ic->Dim(tensor_as_shape, i));\n    if (dtype == DT_INT32) {\n      tensor_proto.add_int_val(value);\n    } else {\n      tensor_proto.add_int64_val(value);\n    }\n  }\n  return tensor_proto;\n}\n\n// Returns a Const NodeDef with tensor `tensor_proto` and dtype = `dtype`.\nNodeDef MakeConstNodeDefFromTensorProto(InferenceContext* ic,\n                                        const TensorProto& tensor_proto,\n                                        const DataType& dtype) {\n  NodeDef const_node;\n  const_node.set_name(\"const_from_shape\");\n  const_node.set_op(\"Const\");\n  auto* attr = const_node.mutable_attr();\n  (*attr)[\"dtype\"].set_type(dtype);\n  auto* tensor = (*attr)[\"value\"].mutable_tensor();\n  *tensor = tensor_proto;\n  return const_node;\n}\n\n// Returns a Const NodeDef with shape = `shape`, values = `tensor_as_shape`,\n// and dtype = `dtype`.\nNodeDef MakeConstNodeDefFromShape(InferenceContext* ic,\n                                  const ShapeHandle& shape,\n                                  const ShapeHandle& tensor_as_shape,\n                                  const DataType& dtype) {\n  return MakeConstNodeDefFromTensorProto(\n      ic, MakeTensorProtoFromShape(ic, shape, tensor_as_shape, dtype), dtype);\n}\n\nbool IsNumericType(const DataType dtype) {\n  static const gtl::FlatSet<DataType>* const kRealNumberTypes =\n      CHECK_NOTNULL((new gtl::FlatSet<DataType>{\n          // Floating point.\n          DT_BFLOAT16,\n          DT_HALF,\n          DT_FLOAT,\n          DT_DOUBLE,\n          // Int / UInt.\n          DT_INT8,\n          DT_INT16,\n          DT_INT32,\n          DT_INT64,\n          DT_UINT8,\n          DT_UINT16,\n          DT_UINT32,\n          DT_UINT64,\n          // Quantized Int.\n          DT_QINT8,\n          DT_QUINT8,\n          DT_QINT16,\n          DT_QUINT16,\n          DT_QINT32,\n          // Bool.\n          DT_BOOL,\n      }));\n  return kRealNumberTypes->find(dtype) != kRealNumberTypes->end();\n}\n\n// Returns the number of elements in the input (const) tensor.\n// -1 if the tensor has no shape or unknown rank.\nuint64 NumElementsFromTensorProto(const TensorProto& tensor_proto) {\n  if (!tensor_proto.has_tensor_shape()) {\n    return -1;\n  }\n  const auto& tensor_shape_proto = tensor_proto.tensor_shape();\n  if (tensor_shape_proto.unknown_rank()) {\n    return -1;\n  }\n  int64_t num_elements = 1;\n  for (const auto& dim : tensor_shape_proto.dim()) {\n    // Note that in some cases, dim.size() can be zero (e.g., empty vector).\n    num_elements *= dim.size();\n  }\n  return num_elements;\n}\n\n}  // namespace\n\n// Note that tensor_as_shape input should not include kUnknownDimFromConst.\n// This function check kUnknownDimFromConst, but will log WARNING.\n// If checking input_tensors_as_shape_to_propgate or output_tensors_as_shape,\n// which may include kUnknownDimFromConst, run\n// convert it using ReplaceUnknownDimFromConstWithUnknownDim() before.\nbool IsShapeFullyDefinedIntegerVectorOrScalar(\n    InferenceContext* ic, const ShapeHandle& shape,\n    const ShapeHandle& tensor_as_shape, const DataType& dtype) {\n  if (!ic->FullyDefined(shape) || ic->Rank(shape) > 1 ||\n      !ic->FullyDefined(tensor_as_shape) ||\n      (dtype != DT_INT32 && dtype != DT_INT64)) {\n    return false;\n  }\n  // Also check whether any dim in tensor_as_shape is kUnknownDimFromConst.\n  for (int32_t i = 0; i < ic->Rank(tensor_as_shape); ++i) {\n    DimensionHandle dim = ic->Dim(tensor_as_shape, i);\n    if (ic->Value(dim) == kUnknownDimFromConst) {\n      LOG(WARNING) << \"IsShapeFullyDefinedIntegerVectorOrScalar(): \"\n                   << \"tensor_as_shape input includes kUnknownDimFromConst -- \"\n                   << ic->DebugString(tensor_as_shape);\n      return false;\n    }\n  }\n  return true;\n}\n\n// Queue of nodes to process. Nodes can be enqueued in any order, but will be\n// dequeued in (roughly) topological order. Propagating shapes following a\n// topological ordering isn't required for correctness but helps speed things up\n// since it avoids processing the same node multiple times as its inputs\n// information is refined.\nclass TopoQueue {\n public:\n  explicit TopoQueue(const std::vector<const NodeDef*>& topo_order)\n      : topo_order_(TopoOrder(topo_order)) {}\n\n  void push(const NodeDef* n) { queue_.emplace(n, topo_order_.at(n)); }\n\n  const NodeDef* pop() {\n    CHECK(!empty());\n    auto it = queue_.begin();\n    const NodeDef* n = it->first;\n    queue_.erase(it);\n    return n;\n  }\n\n  bool empty() const { return queue_.empty(); }\n  std::size_t size() const { return queue_.size(); }\n\n private:\n  using NodeAndId = std::pair<const NodeDef*, int>;\n  // Graph nodes are created in (roughly) topological order. Therefore we can\n  // use their id to ensure they're sorted topologically.\n  struct OrderByIdAscending {\n    bool operator()(const NodeAndId& lhs, const NodeAndId& rhs) const {\n      return lhs.second < rhs.second;\n    }\n  };\n\n  const absl::flat_hash_map<const NodeDef*, int> TopoOrder(\n      const std::vector<const NodeDef*>& topo_order) const {\n    absl::flat_hash_map<const NodeDef*, int> map;\n    map.reserve(topo_order.size());\n    for (int i = 0, topo_order_size = topo_order.size(); i < topo_order_size;\n         ++i) {\n      map.emplace(topo_order[i], i);\n    }\n    return map;\n  }\n\n  const absl::flat_hash_map<const NodeDef*, int> topo_order_;\n  std::set<NodeAndId, OrderByIdAscending> queue_;\n};\n\n\nbool IsAllowListedOpTypeForEvaluateNode(const string& op_type) {\n  static const gtl::FlatSet<string>* const kOpTpeAllowlist =\n      CHECK_NOTNULL((new gtl::FlatSet<string>{\n          // Unary arithmetic ops\n          \"Floor\",\n          \"Round\",\n          \"Sqrt\",\n          \"Square\",\n          \"Sign\",\n          // Binary arithmetic ops\n          \"Add\",\n          \"AddV2\",\n          \"Div\",\n          \"FloorDiv\",\n          \"FloorMod\",\n          \"Greater\",\n          \"GreaterEqual\",\n          \"Less\",\n          \"LessEqual\",\n          \"LogicalAnd\",\n          \"LogicalNot\",\n          \"LogicalOr\",\n          \"Maximum\",\n          \"Minimum\",\n          \"Mod\",\n          \"Mul\",\n          \"NotEqual\",\n          \"QuantizedAdd\",\n          \"QuantizedMul\",\n          \"SquareDifference\",\n          \"Sub\",\n          \"TruncateDiv\",\n          \"TruncateMod\",\n          \"RealDiv\",\n          // N-ary arithmetic ops\n          \"AddN\",\n          // Others\n          \"StridedSlice\",\n          \"OnesLike\",\n          \"ZerosLike\",\n          \"Concat\",\n          \"ConcatV2\",\n          \"Split\",\n          \"Range\",\n          \"Fill\",\n          \"Cast\",\n          \"Prod\",\n          \"Unpack\",\n          \"GatherV2\",\n          \"Pack\",\n          // Used in batch_gather_nd: tensorflow/python/ops/array_ops.py\n          \"ExpandDims\",\n      }));\n  return kOpTpeAllowlist->find(op_type) != kOpTpeAllowlist->end();\n}\n\n// Negative shape size of '-1' represents unknown, while negative shape sizes\n// less than -1 represent unknown symbolic shapes (e.g. the shape of [-5, 5, -1,\n// -5] really means [x, 5, ?, x]). Before we can output the tensors as shapes,\n// we need to normalize them: mark all values <-1 as \"unknown\" (-1).\nstatic void NormalizeShapeForOutput(TensorShapeProto* shape) {\n  for (int i = 0; i < shape->dim_size(); i++) {\n    if (shape->dim(i).size() < -1) {\n      VLOG(2) << \"Normalizing dimension: \" << i << \" from \"\n              << shape->dim(i).size() << \" to -1\";\n      shape->mutable_dim(i)->set_size(-1);\n    }\n  }\n}\n\n// Processes symbolic shapes.\n// Each symbolic shape or dimension is represented by a handle. Unlike the TF\n// shape refiner which creates new handles every time it processes an unknown\n// shape/dimension, the symbolic shape refiner assigns a specific handle to each\n// unknown shape/dimension of a given node.\nclass SymbolicShapeRefiner {\n public:\n  explicit SymbolicShapeRefiner(\n      const GraphView& graph,\n      const absl::flat_hash_map<string, absl::flat_hash_set<int>>& fed_ports,\n      const bool aggressive_shape_inference)\n      : graph_(graph),\n        function_library_(OpRegistry::Global(), graph.graph()->library()),\n        fed_ports_(fed_ports),\n        aggressive_shape_inference_(aggressive_shape_inference) {\n    graph_def_version_ = graph.graph()->versions().producer();\n    node_to_context_.reserve(graph.graph()->node_size());\n  }\n\n  const GraphView& graph() const { return graph_; }\n\n  struct NodeContext {\n    const OpRegistrationData* op_data;\n    DataTypeVector input_types;\n    DataTypeVector output_types;\n    std::unique_ptr<InferenceContext> inference_context;\n    // Additional info for propagating tensor values and tensor shapes.\n    std::vector<const TensorProto*> input_tensor_protos;\n    std::vector<const TensorProto*> output_tensor_protos;\n    // This is the same to inference_context->input_tensors_as_shapes, except\n    // that some UnknownDims (-1) can be kUnknownDimFromConst.\n    std::vector<ShapeHandle> input_tensors_as_shapes_to_propagate;\n    std::vector<ShapeHandle> output_tensors_as_shapes;\n\n    // Output shapes incompatible between annotation and shape inference.\n    bool shape_incompatible = false;\n\n    // Similar to DebugString() in InferenceContext, but prints out\n    // kUnknownDimFromConst properly.\n    std::string StringifyShapeHandle(ShapeHandle s) {\n      auto* ic = inference_context.get();\n      if (ic->RankKnown(s)) {\n        std::vector<std::string> vals;\n        for (int i = 0; i < ic->Rank(s); i++) {\n          DimensionHandle d = ic->Dim(s, i);\n          if (ic->ValueKnown(d) && ic->Value(d) == kUnknownDimFromConst) {\n            vals.push_back(\"?(Const)\");\n          } else {\n            vals.push_back(ic->DebugString(d));\n          }\n        }\n        return strings::StrCat(\"[\", absl::StrJoin(vals, \",\"), \"]\");\n      } else {\n        return \"?\";\n      }\n    }\n\n    std::string DebugString(const NodeDef& node) {\n      std::string output;\n      auto* ic = inference_context.get();\n      absl::StrAppend(\n          &output, node.name(), \" [\", node.op(), \"] has \", ic->num_inputs(),\n          (ic->num_inputs() > 1 ? \" inputs and \" : \" input and \"),\n          ic->num_outputs(), (ic->num_outputs() > 1 ? \" outputs\" : \" output\"));\n      if (op_data->is_function_op) {\n        absl::StrAppend(&output, \" (function op)\");\n      }\n      absl::StrAppend(&output, \": \\n\");\n\n      for (int i = 0; i < ic->num_inputs(); i++) {\n        absl::StrAppend(&output, \" input [\", i, \"] \", node.input(i),\n                        \" -- type: \", DataTypeString(input_types.at(i)),\n                        \", shape: \", ic->DebugString(ic->input(i)),\n                        \", tensor: \");\n        Tensor t1;\n        int input_tensor_protos_size = input_tensor_protos.size();\n        if (input_tensor_protos_size > i &&\n            input_tensor_protos.at(i) != nullptr &&\n            t1.FromProto(*input_tensor_protos.at(i))) {\n          absl::StrAppend(&output, t1.DebugString(), \", tensor_as_shape: \");\n        } else {\n          absl::StrAppend(&output, \" null, tensor_as_shape: \");\n        }\n        int input_tensors_as_shapes_to_propagate_size =\n            input_tensors_as_shapes_to_propagate.size();\n        if (input_tensors_as_shapes_to_propagate_size > i) {\n          absl::StrAppend(\n              &output,\n              StringifyShapeHandle(input_tensors_as_shapes_to_propagate.at(i)),\n              \"\\n\");\n        } else {\n          absl::StrAppend(&output, \" null\\n\");\n        }\n      }\n      for (int i = 0; i < ic->num_outputs(); i++) {\n        absl::StrAppend(&output, \" output [\", i,\n                        \"] -- type: \", DataTypeString(output_types.at(i)),\n                        \", shape: \", ic->DebugString(ic->output(i)),\n                        \", tensor: \");\n        Tensor t2;\n        int output_tensor_protos_size = output_tensor_protos.size();\n        if (output_tensor_protos_size > i &&\n            output_tensor_protos.at(i) != nullptr &&\n            t2.FromProto(*output_tensor_protos.at(i))) {\n          absl::StrAppend(&output, t2.DebugString(), \", tensor_as_shape: \");\n        } else {\n          absl::StrAppend(&output, \" null, tensor_as_shape: \");\n        }\n        int output_tensors_as_shapes_size = output_tensors_as_shapes.size();\n        if (output_tensors_as_shapes_size > i) {\n          absl::StrAppend(&output,\n                          StringifyShapeHandle(output_tensors_as_shapes.at(i)),\n                          \"\\n\");\n        } else {\n          absl::StrAppend(&output, \" null\\n\");\n        }\n      }\n      return output;\n    }\n  };\n\n  NodeContext* GetNodeContext(const NodeDef* node) {\n    auto it = node_to_context_.find(node);\n    if (it == node_to_context_.end()) {\n      return nullptr;\n    }\n    return &it->second;\n  }\n\n  InferenceContext* GetContext(const NodeDef* node) {\n    auto it = node_to_context_.find(node);\n    if (it == node_to_context_.end()) {\n      return nullptr;\n    }\n    return it->second.inference_context.get();\n  }\n\n  // Forward the shapes from the function input nodes, PartitionedCalls or\n  // StatefulPartitionedCall to\n  // the argument nodes (which are Placeholder nodes), then\n  // perform shape inference on the function body.\n  //\n  // Propagate shape information of final function body node\n  // to function node `function_node`.\n  //\n  // In the event of an error, UpdateNode will simply set `function_node`'s\n  // output shape to be Unknown.\n  Status UpdateFunction(const NodeDef* function_node) {\n    NameAttrList function;\n    TF_RETURN_IF_ERROR(NameAndAttrsFromFunctionCall(*function_node, &function));\n    auto it = fun_to_grappler_function_item_.find(function.name());\n    if (it == fun_to_grappler_function_item_.end()) {\n      return errors::InvalidArgument(\n          function.name(),\n          \" was not previously added to SymbolicShapeRefiner.\");\n    }\n\n    const absl::optional<GrapplerFunctionItem>& maybe_grappler_function_item =\n        it->second;\n    if (!maybe_grappler_function_item.has_value()) {\n      VLOG(3) << \"Skip failed to instantiate function call: function_name=\"\n              << function.name();\n\n      auto* ctx = GetNodeContext(function_node);\n      auto* ic = ctx->inference_context.get();\n      for (int i = 0; i < ic->num_outputs(); ++i) {\n        TF_RETURN_IF_ERROR(SetUnknownShape(function_node, i));\n      }\n\n      return Status::OK();\n    }\n\n    // Copy (not reference) so that changes we make here (e.g., replacing\n    // _Arg with Const and _Retval with Identity) don't affect one in\n    // fun_to_grappler_function_item_.\n    GrapplerFunctionItem grappler_function_item = *maybe_grappler_function_item;\n    MutableGraphView gv(&grappler_function_item.graph);\n\n    // Forward shapes from function input nodes to argument nodes.\n    for (int i = 0, end = grappler_function_item.inputs().size(); i < end;\n         ++i) {\n      auto& fun_input = grappler_function_item.input(i);\n      NodeDef* fun_node = gv.GetNode(fun_input.node_name);\n      const TensorId input_tensor = ParseTensorName(function_node->input(i));\n\n      if (IsControlInput(input_tensor)) {\n        return errors::FailedPrecondition(\n            \"Function inputs should not contain control nodes.\");\n      }\n\n      const NodeDef* input_node = graph_.GetNode(input_tensor.node());\n      if (input_node == nullptr) {\n        return errors::FailedPrecondition(input_tensor.node(),\n                                          \" was not found in the graph.\");\n      }\n\n      InferenceContext* input_ic = GetContext(input_node);\n      if (input_ic == nullptr) {\n        return errors::FailedPrecondition(\n            \"Inference context has not been created for \", input_tensor.node());\n      }\n\n      int output_port_num = input_tensor.index();\n      AttrValue attr_output_shape;\n      TensorShapeProto proto;\n      const auto handle = input_ic->output(output_port_num);\n      input_ic->ShapeHandleToProto(handle, &proto);\n      // There may be dim.size < -1 in SymbolicShapeRefiner. Change those to -1.\n      NormalizeShapeForOutput(&proto);\n      // _Arg op's output shape uses _output_shapes attr.\n      AttrValue output_attr;\n      output_attr.mutable_list()->add_shape()->Swap(&proto);\n      (*fun_node->mutable_attr())[\"_output_shapes\"] = output_attr;\n\n      // If dtype is DT_RESOURCE, ops that read _Arg op use _handle_dtypes and\n      // _handle_shapes attr for its shapes and dtypes.\n      if (fun_input.data_type == DT_RESOURCE) {\n        auto* shapes_and_types =\n            input_ic->output_handle_shapes_and_types(output_port_num);\n        if (shapes_and_types != nullptr && !shapes_and_types->empty()) {\n          AttrValue dtype_attr;\n          AttrValue shape_attr;\n          for (const auto& shape_and_type : *shapes_and_types) {\n            const auto& dtype = shape_and_type.dtype;\n            const auto& shape_handle = shape_and_type.shape;\n            dtype_attr.mutable_list()->add_type(dtype);\n            input_ic->ShapeHandleToProto(\n                shape_handle, shape_attr.mutable_list()->add_shape());\n          }\n          (*fun_node->mutable_attr())[\"_handle_dtypes\"] = dtype_attr;\n          (*fun_node->mutable_attr())[\"_handle_shapes\"] = shape_attr;\n        } else {\n          // Note that we do not return error here, even if the input node does\n          // not have shapes_and_types. Within the function, we cannot infer the\n          // output shape of the DT_RESOURCE input; hence, potentially unknown\n          // shapes/dims in the function output shapes.\n          VLOG(2)\n              << \"A function node (\" << function_node->name()\n              << \") has input with DT_RESOURCE, but the input node does not \"\n              << \"have shapes_and_types information: \\n\"\n              << \"function_node: \" << function_node->ShortDebugString() << \"\\n\"\n              << \"function input: \" << i\n              << \", input node's output: \" << output_port_num << \"\\n\"\n              << \"input node: \" << input_node->ShortDebugString();\n        }\n      }\n    }\n\n    // ReplaceInputWithConst() may break GraphView's internal node mapping\n    // structure; hence, we separately build node name to NodeDef* map, for the\n    // output nodes (before GraphView becomes invalid). Note that we use string,\n    // not string_view.\n    absl::flat_hash_map<std::string, NodeDef*> output_nodes;\n    for (const auto& output_arg : grappler_function_item.outputs()) {\n      output_nodes[output_arg.node_name] = gv.GetNode(output_arg.node_name);\n    }\n\n    // Replace input nodes with Consts, if values are known. Note that\n    // we don't check exceptions here as it's done in the above loop.\n    auto* ctx = GetNodeContext(function_node);\n    auto* ic = ctx->inference_context.get();\n    for (int i = grappler_function_item.inputs().size() - 1; i >= 0; --i) {\n      const string& input = function_node->input(i);\n      const string node_name = NodeName(input);\n      const NodeDef* input_node = graph_.GetNode(node_name);\n      if (IsConstant(*input_node)) {\n        TF_CHECK_OK(\n            ReplaceInputWithConst(*input_node, i, &grappler_function_item));\n      } else if (static_cast<int>(ctx->input_tensor_protos.size()) > i &&\n                 ctx->input_tensor_protos[i] != nullptr) {\n        NodeDef const_input_node = MakeConstNodeDefFromTensorProto(\n            ic, *ctx->input_tensor_protos[i], ctx->input_types[i]);\n        TF_CHECK_OK(ReplaceInputWithConst(const_input_node, i,\n                                          &grappler_function_item));\n      } else if (static_cast<int>(ic->input_tensors_as_shapes().size()) > i &&\n                 IsShapeFullyDefinedIntegerVectorOrScalar(\n                     ic, ic->input(i), ic->input_tensors_as_shapes()[i],\n                     ctx->input_types[i])) {\n        // We have fully defined input_tensors_as_shapes for this input; use it\n        // as a const input to the function node.\n        NodeDef const_input_node = MakeConstNodeDefFromShape(\n            ic, ic->input(i), ic->input_tensors_as_shapes()[i],\n            ctx->input_types[i]);\n        TF_CHECK_OK(ReplaceInputWithConst(const_input_node, i,\n                                          &grappler_function_item));\n      }\n    }\n    // node_name to NodeDef* map in GraphView gv can be broken due to\n    // ReplaceInputWithConst(). gv should not be used after this.\n\n    // Replace output _Retval nodes with Identity nodes. _Retval is a system op\n    // without outputs and registered shape function.\n    for (const auto& output_arg : grappler_function_item.outputs()) {\n      NodeDef* output_node = output_nodes[output_arg.node_name];\n      DCHECK_EQ(output_node->op(), \"_Retval\");\n      output_node->set_op(\"Identity\");\n      output_node->mutable_attr()->erase(\"index\");\n    }\n\n    // Perform inference on function body.\n    GraphProperties gp(grappler_function_item);\n    TF_RETURN_IF_ERROR(gp.InferStatically(\n        /*assume_valid_feeds=*/true,\n        /*aggressive_shape_inference=*/aggressive_shape_inference_,\n        /*include_tensor_values=*/true));\n\n    // Add return nodes for output shapes.\n    int output = 0;\n    ctx->output_tensors_as_shapes.resize(grappler_function_item.output_size());\n    ctx->output_tensor_protos.resize(grappler_function_item.output_size(),\n                                     nullptr);\n    for (auto const& out_arg : grappler_function_item.outputs()) {\n      // It is guaranteed that output_tensors does not contain any control\n      // inputs, so port_id >= 0.\n      TensorId out_tensor = ParseTensorName(out_arg.node_name);\n\n      if (output_nodes.count(out_tensor.node()) <= 0) {\n        return errors::FailedPrecondition(\n            \"Unable to find return function_node \", out_tensor.node(), \" for \",\n            function_node->name());\n      }\n      const NodeDef* retnode = output_nodes[out_tensor.node()];\n\n      auto output_properties = gp.GetOutputProperties(retnode->name());\n      int output_properties_size = output_properties.size();\n      if (out_tensor.index() >= output_properties_size) {\n        return errors::InvalidArgument(\n            out_tensor.ToString(), \" has invalid position \", out_tensor.index(),\n            \" (output_properties.size() = \", output_properties.size(), \").\");\n      }\n      auto& outprop = output_properties[out_tensor.index()];\n      TensorShapeProto shape = outprop.shape();\n      NormalizeShapeForOutput(&shape);\n      ShapeHandle out;\n      TF_RETURN_IF_ERROR(ic->MakeShapeFromShapeProto(shape, &out));\n      ic->set_output(output, out);\n      if (outprop.has_value()) {\n        // Forward tensor value to output_tensors_as_shape.\n        MaybeTensorProtoToShape(ic, outprop.value(),\n                                &ctx->output_tensors_as_shapes[output]);\n        const_tensors_to_propagate_.push_back(outprop.value());\n        ctx->output_tensor_protos[output] = &const_tensors_to_propagate_.back();\n      }\n      output++;\n    }\n\n    return Status::OK();\n  }\n\n  // Prepares input shapes/values/handles, then runs shape inference, and\n  // finally sets output shapes/values/handles.\n  Status UpdateNode(const NodeDef* node, bool* refined) {\n    NodeContext* ctx = GetNodeContext(node);\n    if (ctx == nullptr) {\n      TF_RETURN_IF_ERROR(AddNode(node));\n      ctx = CHECK_NOTNULL(GetNodeContext(node));\n      *refined = true;\n    }\n\n    // Check if the shapes of the nodes in the fan-in of this node have changed,\n    // and if they have, update the node input shapes.\n    InferenceContext* ic = ctx->inference_context.get();\n    ctx->input_tensors_as_shapes_to_propagate.resize(ic->num_inputs());\n    ctx->input_tensor_protos.resize(ic->num_inputs(), nullptr);\n\n    for (int dst_input = 0; dst_input < ic->num_inputs(); ++dst_input) {\n      const GraphView::InputPort port(node, dst_input);\n      const GraphView::OutputPort fanin = graph_.GetRegularFanin(port);\n      int src_output = fanin.port_id;\n      const NodeDef* src = fanin.node;\n      NodeContext* src_ctx = GetNodeContext(src);\n      if (src_ctx == nullptr) {\n        return errors::FailedPrecondition(\n            \"Input \", dst_input, \" for '\", node->name(),\n            \"' was not previously added to SymbolicShapeRefiner.\");\n      }\n\n      InferenceContext* src_ic = src_ctx->inference_context.get();\n      if (src_output >= src_ic->num_outputs()) {\n        return errors::OutOfRange(\"src_output = \", src_output,\n                                  \", but num_outputs is only \",\n                                  src_ic->num_outputs());\n      }\n\n      // Propagate input node's NodeContext info to the current node's\n      // NodeContext:\n      // output_tensor_protos to input_tensor_protos and input_tensors, and\n      // output_tensors_as_shapes to input_tensors_as_shapes.\n      if (static_cast<int>(src_ctx->output_tensors_as_shapes.size()) >\n          src_output) {\n        ctx->input_tensors_as_shapes_to_propagate[dst_input] =\n            src_ctx->output_tensors_as_shapes[src_output];\n      }\n\n      if (static_cast<int>(src_ctx->output_tensor_protos.size()) > src_output) {\n        const auto* tensor_proto = src_ctx->output_tensor_protos[src_output];\n        if (tensor_proto != nullptr) {\n          ctx->input_tensor_protos[dst_input] = tensor_proto;\n        }\n      }\n\n      // NOTE: we check only shape is refined; we do not (yet) check whether\n      // tensor value is refined.\n      if (!*refined &&\n          !ic->input(dst_input).SameHandle(src_ic->output(src_output))) {\n        *refined = true;\n      }\n      ic->SetInput(dst_input, src_ic->output(src_output));\n\n      if (!*refined && ic->requested_input_tensor_as_partial_shape(dst_input)) {\n        // The input value may have changed. Since we have no way to know if\n        // that's indeed the case, err on the safe side.\n        *refined = true;\n      }\n\n      // Also propagate handle shape and dtype of edges which are carrying\n      // resource handles.\n      if (ctx->input_types[dst_input] == DT_RESOURCE) {\n        auto* outputs = src_ic->output_handle_shapes_and_types(src_output);\n        if (!outputs) continue;\n        auto* inputs = ic->input_handle_shapes_and_types(dst_input);\n\n        if (!inputs || !EquivalentShapesAndTypes(*outputs, *inputs))\n          *refined = true;\n        ic->set_input_handle_shapes_and_types(dst_input, *outputs);\n      }\n    }\n\n    // Make sure we schedule the fanout of resources (which have no input)\n    // whenever the resources are updated.\n    *refined |= ic->num_inputs() == 0;\n\n    if (!*refined) {\n      // No input shape has changed, we're done.\n      return Status::OK();\n    }\n\n    // Convert all kUnknownDimFromConst to -1 for shape inference.\n    ic->set_input_tensors_as_shapes(ReplaceUnknownDimFromConstWithUnknownDim(\n        ic, ctx->input_tensors_as_shapes_to_propagate));\n    // Note: UpdateFunction uses input_tensors_as_shapes and\n    // input_tensor_protos (not the Tensor object) for input values.\n    // so for function nodes, we don't need to convert TensorProtos\n    // to Tensors here. If the current op is not a function op, we convert\n    // TensorProtos to Tensors before calling InferShapes.\n\n    // Properly handle function nodes.\n    if (ctx->op_data && ctx->op_data->is_function_op) {\n      // TODO(jmdecker): Detect if the input shapes have changed for this\n      // function. Note that when we hit a function call node, refined will be\n      // true, as the updates to the call node will have changed, even if it's\n      // the same function being called twice with the same input shapes.\n      // Example: simple_function.pbtxt\n      if (aggressive_shape_inference_) {\n        // If output shapes are annotated, use it and skip UpdateFunction();\n        // it can be very expensive when a function node has nested function\n        // nodes internally. One downside with this approach is that we do not\n        // get output values or output shapes as tensor from function node.\n        auto s = UpdateOutputShapesUsingAnnotatedInformation(*node, ctx);\n        if (s.ok() && AllOutputShapesKnown(ctx)) {\n          return Status::OK();\n        }\n        // If shape annotation was not available, incomplete, or incompatible,\n        // fall through to call UpdateFunction().\n      }\n      auto s = UpdateFunction(node);\n      if (s.ok()) {\n        return Status::OK();\n      } else {\n        VLOG(1) << \"UpdateFunction failed for \" << node->op()\n                << \". Defaulting to ShapeUnknown.\\n\"\n                << s.ToString();\n      }\n    }\n\n    //  Construct Tensors for constant inputs used by shape functions.\n    std::vector<Tensor> const_values(ic->num_inputs());\n    std::vector<const Tensor*> input_tensors(ic->num_inputs(), nullptr);\n    for (int dst_input = 0; dst_input < ic->num_inputs(); ++dst_input) {\n      const TensorProto* tensor_proto = ctx->input_tensor_protos[dst_input];\n      if (tensor_proto != nullptr &&\n          // Skip if the const tensor is too large.\n          NumElementsFromTensorProto(*tensor_proto) <=\n              kThresholdToSkipConstTensorInstantiation &&\n          const_values[dst_input].FromProto(*tensor_proto)) {\n        input_tensors[dst_input] = &const_values[dst_input];\n      }\n    }\n    ic->set_input_tensors(input_tensors);\n\n    // Update the shapes of the outputs.\n    return InferShapes(*node, ctx);\n  }\n\n  Status SetUnknownShape(const NodeDef* node, int output_port) {\n    shape_inference::ShapeHandle shape =\n        GetUnknownOutputShape(node, output_port);\n    InferenceContext* ctx = GetContext(node);\n    if (ctx == nullptr) {\n      return errors::InvalidArgument(\"SetUnknownShape: Missing context\");\n    }\n    if (output_port < 0 || output_port >= ctx->num_outputs()) {\n      return errors::InvalidArgument(\n          \"SetUnknownShape: output_port must be in [0, \", ctx->num_outputs(),\n          \") but was \", output_port);\n    }\n    ctx->set_output(output_port, shape);\n    return Status::OK();\n  }\n\n  struct ShapeId {\n    const NodeDef* node;\n    int port_id;\n    bool operator==(const ShapeId& other) const {\n      return node == other.node && port_id == other.port_id;\n    }\n  };\n  struct HashShapeId {\n    std::size_t operator()(const ShapeId& shp) const {\n      return std::hash<const NodeDef*>{}(shp.node) + shp.port_id;\n    }\n  };\n\n  struct DimId {\n    const NodeDef* node;\n    int port_id;\n    int dim_index;\n    bool operator==(const DimId& other) const {\n      return node == other.node && port_id == other.port_id &&\n             dim_index == other.dim_index;\n    }\n  };\n\n  struct HashDimId {\n    std::size_t operator()(const DimId& dim) const {\n      return std::hash<const NodeDef*>{}(dim.node) + dim.port_id +\n             dim.dim_index;\n    }\n  };\n\n  // 'port_index' as the union of shape1 and shape2.\n  ShapeHandle OutputAsUnion(const NodeDef* node, int port_index,\n                            ShapeHandle shape1, ShapeHandle shape2) {\n    if (shape1.SameHandle(shape2)) {\n      return shape1;\n    }\n    InferenceContext* ctx = GetContext(node);\n    ShapeHandle relaxed = shape1;\n    const int rank = ctx->Rank(shape1);\n    if (!ctx->RankKnown(shape2) || ctx->Rank(shape2) != rank) {\n      relaxed = GetUnknownOutputShape(node, port_index);\n    } else {\n      for (int d = 0; d < rank; ++d) {\n        if (!ctx->Dim(shape1, d).SameHandle(ctx->Dim(shape2, d))) {\n          int64_t val1 = ctx->Value(ctx->Dim(shape1, d));\n          int64_t val2 = ctx->Value(ctx->Dim(shape2, d));\n          if (val1 != val2 || (val1 < 0 && val2 < 0)) {\n            DimensionHandle new_dim = GetUnknownOutputDim(node, port_index, d);\n            TF_CHECK_OK(ctx->ReplaceDim(relaxed, d, new_dim, &relaxed));\n          }\n        }\n      }\n    }\n    return relaxed;\n  }\n\n  bool EquivalentShapes(ShapeHandle s1, ShapeHandle s2) const {\n    if (s1.SameHandle(s2)) {\n      return true;\n    }\n    if (InferenceContext::Rank(s1) != InferenceContext::Rank(s2)) {\n      return false;\n    }\n    if (!InferenceContext::RankKnown(s1) && !InferenceContext::RankKnown(s2)) {\n      return true;\n    }\n    const int rank = InferenceContext::Rank(s1);\n    for (int i = 0; i < rank; ++i) {\n      if (!InferenceContext::DimKnownRank(s1, i).SameHandle(\n              InferenceContext::DimKnownRank(s2, i))) {\n        int64_t val1 =\n            InferenceContext::Value(InferenceContext::DimKnownRank(s1, i));\n        int64_t val2 =\n            InferenceContext::Value(InferenceContext::DimKnownRank(s2, i));\n        if (val1 >= 0 && val2 >= 0 && val1 == val2) {\n          continue;\n        }\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Return true if the annotated shape is compatible with shape inference\n  // result. Examples:\n  // Inferred shape: ?, annotated shape: [10, 10] -> true;\n  // Inferred shape: [-1, 10], annotated shape: [10, 10] -> true;\n  // Inferred shape: [-1, 100], annotated shape: [10, 10] -> false;\n  // Inferred shape: [-1, 10, 10], annotated shape: [10, 10] -> false.\n  bool CompatibleShapes(ShapeHandle inferred_shape,\n                        ShapeHandle annotated_shape) const {\n    if (inferred_shape.SameHandle(annotated_shape)) {\n      return true;\n    }\n    if (!InferenceContext::RankKnown(inferred_shape)) {\n      return true;\n    }\n    if (InferenceContext::Rank(inferred_shape) !=\n        InferenceContext::Rank(annotated_shape)) {\n      return false;\n    }\n    const int rank = InferenceContext::Rank(inferred_shape);\n    for (int i = 0; i < rank; ++i) {\n      if (!InferenceContext::DimKnownRank(inferred_shape, i)\n               .SameHandle(\n                   InferenceContext::DimKnownRank(annotated_shape, i))) {\n        int64_t val1 = InferenceContext::Value(\n            InferenceContext::DimKnownRank(inferred_shape, i));\n        int64_t val2 = InferenceContext::Value(\n            InferenceContext::DimKnownRank(annotated_shape, i));\n        if (val1 >= 0 && val1 != val2) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  bool SameShapes(ShapeHandle inferred_shape,\n                  ShapeHandle annotated_shape) const {\n    if (inferred_shape.SameHandle(annotated_shape)) {\n      return true;\n    }\n    if (InferenceContext::Rank(inferred_shape) !=\n        InferenceContext::Rank(annotated_shape)) {\n      return false;\n    }\n    const int rank = InferenceContext::Rank(inferred_shape);\n    for (int i = 0; i < rank; ++i) {\n      int64_t val1 = InferenceContext::Value(\n          InferenceContext::DimKnownRank(inferred_shape, i));\n      int64_t val2 = InferenceContext::Value(\n          InferenceContext::DimKnownRank(annotated_shape, i));\n      if (val1 != val2) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  bool EquivalentShapesAndTypes(const std::vector<ShapeAndType>& st1,\n                                const std::vector<ShapeAndType>& st2) const {\n    if (st1.size() != st2.size()) {\n      return false;\n    }\n    for (int i = 0, st1_size = st1.size(); i < st1_size; ++i) {\n      const ShapeAndType& s1 = st1[i];\n      const ShapeAndType& s2 = st2[i];\n      if (s1.dtype != s2.dtype) {\n        return false;\n      }\n      if (!EquivalentShapes(s1.shape, s2.shape)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  Status AddFunction(const NodeDef* function_node, NameAttrList function) {\n    auto it = fun_to_grappler_function_item_.find(function.name());\n    if (it != fun_to_grappler_function_item_.end()) {\n      return Status::OK();\n    }\n\n    const FunctionDef* function_def =\n        CHECK_NOTNULL(function_library_.Find(function.name()));\n    GrapplerFunctionItem grappler_function_item;\n    Status function_instantiated =\n        MakeGrapplerFunctionItem(*function_def, function_library_,\n                                 graph_def_version_, &grappler_function_item);\n\n    // If function instantiation failed we will skip it during shape inference.\n    if (!function_instantiated.ok()) {\n      VLOG(3) << \"Failed to instantiate a function. Error: \"\n              << function_instantiated.error_message();\n      fun_to_grappler_function_item_[function_def->signature().name()] =\n          absl::nullopt;\n      return Status::OK();\n    }\n\n    if (static_cast<int>(grappler_function_item.inputs().size()) >\n        function_node->input_size()) {\n      return errors::FailedPrecondition(\n          \"Function input size should be smaller than node input size.\");\n    }\n\n    for (int i = grappler_function_item.inputs().size(),\n             end = function_node->input_size();\n         i < end; ++i) {\n      const string& input = function_node->input(i);\n      if (!IsControlInput(input)) {\n        return errors::FailedPrecondition(\n            \"Found regular input (\", input,\n            \") instead of control nodes for node \", function_node->name());\n      }\n    }\n\n    fun_to_grappler_function_item_[function_def->signature().name()] =\n        grappler_function_item;\n\n    return Status::OK();\n  }\n\n  Status AddNode(const NodeDef* node) {\n    NodeContext& node_ctx = node_to_context_[node];\n    NameAttrList function;\n    TF_RETURN_IF_ERROR(NameAndAttrsFromFunctionCall(*node, &function));\n\n    // For PartitionedCall, op_data represents the function info.\n    TF_RETURN_IF_ERROR(\n        function_library_.LookUp(function.name(), &node_ctx.op_data));\n\n    if (node_ctx.op_data->is_function_op) {\n      TF_RETURN_IF_ERROR(AddFunction(node, function));\n    }\n\n    TF_RETURN_IF_ERROR(InOutTypesForNode(*node, node_ctx.op_data->op_def,\n                                         &node_ctx.input_types,\n                                         &node_ctx.output_types));\n\n    // Create the inference context for this node.\n    const int num_inputs = node_ctx.input_types.size();\n    std::vector<ShapeHandle> input_shapes(num_inputs);\n    std::vector<std::unique_ptr<std::vector<ShapeAndType>>>\n        input_handle_shapes_and_types(num_inputs);\n    std::vector<const Tensor*> input_tensors(num_inputs, nullptr);\n    std::vector<ShapeHandle> input_tensors_as_shapes;\n\n    node_ctx.inference_context.reset(new InferenceContext(\n        graph_def_version_, *node, node_ctx.op_data->op_def, input_shapes,\n        input_tensors, input_tensors_as_shapes,\n        std::move(input_handle_shapes_and_types)));\n    const Status s = node_ctx.inference_context->construction_status();\n    if (!s.ok()) {\n      node_ctx.inference_context.reset(nullptr);\n    }\n    return s;\n  }\n\n private:\n  // Return the one ShapeHandle used to denote a fully unknown shape for a node\n  // output.\n  ShapeHandle GetUnknownOutputShape(const NodeDef* node, int index) {\n    ShapeId id{node, index};\n    auto it = unknown_shapes_.find(id);\n    if (it != unknown_shapes_.end()) {\n      return it->second;\n    }\n    InferenceContext* c = GetContext(node);\n    ShapeHandle shp = c->UnknownShape();\n    unknown_shapes_[id] = shp;\n    return shp;\n  }\n  // Return the one ShapeHandle used to denote a fully unknown dimension for a\n  // node output.\n  DimensionHandle GetUnknownOutputDim(const NodeDef* node, int index,\n                                      int dim_id) {\n    DimId id{node, index, dim_id};\n    auto it = unknown_dims_.find(id);\n    if (it != unknown_dims_.end()) {\n      return it->second;\n    }\n    InferenceContext* c = GetContext(node);\n    DimensionHandle dim = c->UnknownDim();\n    unknown_dims_[id] = dim;\n    return dim;\n  }\n\n  // Returns true if all the output tensors have known values.\n  bool AllOutputValuesKnown(NodeContext* c) {\n    InferenceContext* ic = c->inference_context.get();\n    int c_output_tensors_as_shapes_size = c->output_tensors_as_shapes.size();\n    int c_output_tensor_protos_size = c->output_tensor_protos.size();\n    if (c_output_tensors_as_shapes_size < ic->num_outputs() &&\n        c_output_tensor_protos_size < ic->num_outputs()) {\n      return false;\n    } else {\n      // Checks if we can get output value via either output_tensor_proto or\n      // output_tensors_as_shapes.\n      for (int i = 0; i < ic->num_outputs(); i++) {\n        if (c_output_tensor_protos_size > i &&\n            c->output_tensor_protos[i] != nullptr) {\n          continue;\n        }\n        if (c_output_tensors_as_shapes_size > i &&\n            ic->FullyDefined(c->output_tensors_as_shapes[i])) {\n          bool no_unknown_dim_from_const = true;\n          for (int32_t j = 0; j < ic->Rank(c->output_tensors_as_shapes[i]);\n               ++j) {\n            const auto dim = ic->Dim(c->output_tensors_as_shapes[i], j);\n            if (ic->ValueKnown(dim) && ic->Value(dim) == kUnknownDimFromConst) {\n              no_unknown_dim_from_const = false;\n              break;\n            }\n          }\n          if (no_unknown_dim_from_const) {\n            continue;\n          }\n        }\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Returns true if all the output shapes are known.\n  bool AllOutputShapesKnown(NodeContext* c) {\n    InferenceContext* ic = c->inference_context.get();\n    // Checks if all the output shapes are fully defined.\n    for (int i = 0; i < ic->num_outputs(); i++) {\n      if (!ic->FullyDefined(ic->output(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Returns true if we can infer output tensors' values -- we know values of\n  // all the input tensors.\n  bool AllInputValuesKnown(NodeContext* c) {\n    InferenceContext* ic = c->inference_context.get();\n\n    // Check inputs are fully defined and values are known.\n    for (int i = 0; i < ic->num_inputs(); i++) {\n      const Tensor* tensor = ic->input_tensor(i);\n      // Note that we don't check c->input_tensor_protos[i], as UpdateNode()\n      // already converted it to ic->input_tensor(i);\n      const ShapeHandle& input_tensors_as_shape =\n          ic->input_tensors_as_shapes()[i];\n      // Either input_tensor is valid or input_tensors_as_shape, which has\n      // value of input tensors as shape format, should be fully defined.\n      if (tensor == nullptr && !ic->FullyDefined(input_tensors_as_shape)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Returns true if we want to update output shapes and values with running\n  // EvaluateNode() for this op, based on op type, data type, and size.\n  bool ShouldUpdateOutputShapesAndValues(NodeContext* c, int64_t max_size) {\n    InferenceContext* ic = c->inference_context.get();\n\n    // Due to the cost of running EvaluateNode(), we limit only to white listed\n    // op types.\n    if (!IsAllowListedOpTypeForEvaluateNode(c->op_data->op_def.name())) {\n      return false;\n    }\n\n    // Check input dtypes are number types.\n    for (const auto& input_type : c->input_types) {\n      if (!IsNumericType(input_type)) {\n        return false;\n      }\n    }\n\n    // Check output dtypes are number types.\n    for (const auto& output_type : c->output_types) {\n      if (!IsNumericType(output_type)) {\n        return false;\n      }\n    }\n\n    // Check if the number of elements of each of input tensor is no larger than\n    // the given max size.\n    for (int i = 0; i < ic->num_inputs(); i++) {\n      const Tensor* tensor = ic->input_tensor(i);\n      const ShapeHandle& input_shape_handle = ic->input(i);\n      if (tensor != nullptr) {\n        if (tensor->NumElements() > max_size) {\n          return false;\n        }\n      } else if (ic->Value(ic->NumElements(input_shape_handle)) > max_size) {\n        return false;\n      }\n    }\n\n    // Check if we know the shape of each output tensor, and the number of\n    // elements is larger than the given max size.\n    for (int i = 0; i < ic->num_outputs(); i++) {\n      const ShapeHandle& shape_handle = ic->output(i);\n      if (!ic->FullyDefined(shape_handle) ||\n          ic->Value(ic->NumElements(shape_handle)) > max_size) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Create input tensors from the NodeContext.\n  void CreateInputTensors(NodeContext* c,\n                          std::vector<Tensor>* input_tensor_vector,\n                          TensorVector* inputs) {\n    InferenceContext* ic = c->inference_context.get();\n    for (int i = 0; i < ic->num_inputs(); i++) {\n      if (ic->input_tensor(i)) {\n        input_tensor_vector->at(i) = *ic->input_tensor(i);\n        inputs->emplace_back(&input_tensor_vector->at(i));\n        // Note that we don't check c->input_tensor_protos[i], as UpdateNode()\n        // already converted it to ic->input_tensor(i);\n      } else {\n        // Create Tensor from input_tensors_as_shapes, and then emplace it\n        // back to inputs.\n        // Note that input_tensors_as_shapes is scalar or vector.\n        const ShapeHandle& shape_handle = ic->input_tensors_as_shapes()[i];\n        const DataType& data_type = c->input_types[i];\n        int32_t rank = ic->Rank(shape_handle);\n        if (rank < 1) {\n          input_tensor_vector->at(i) = Tensor(data_type, {});\n        } else {\n          input_tensor_vector->at(i) = Tensor(data_type, {rank});\n        }\n        auto* tensor = &input_tensor_vector->at(i);\n        if (data_type == DT_INT32) {\n          auto flat = tensor->flat<int32>();\n          for (int j = 0; j < rank; j++) {\n            int32_t dim = ic->Value(ic->Dim(shape_handle, j));\n            flat(j) = dim;\n          }\n        } else {\n          auto flat = tensor->flat<int64_t>();\n          for (int j = 0; j < rank; j++) {\n            int64_t dim = ic->Value(ic->Dim(shape_handle, j));\n            flat(j) = dim;\n          }\n        }\n        inputs->emplace_back(tensor);\n      }\n    }\n  }\n\n  // Run a node to infer output shapes and values, and add it to the\n  // NodeContext.\n  Status UpdateOutputShapesAndValues(const NodeDef& node, NodeContext* c) {\n    InferenceContext* ic = c->inference_context.get();\n\n    // Input to EvaluateNode()\n    TensorVector inputs;\n    // Container for temporarily created tensor object.\n    std::vector<Tensor> input_tensor_vector(ic->num_inputs());\n    CreateInputTensors(c, &input_tensor_vector, &inputs);\n\n    // Output for EvaluateNode() and output tensor clean up object.\n    TensorVector outputs;\n    auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n      for (const auto& output : outputs) {\n        if (output.tensor) {\n          delete output.tensor;\n        }\n      }\n    });\n\n    TF_RETURN_IF_ERROR(EvaluateNode(node, inputs, /*cpu_device=*/nullptr,\n                                    &resource_mgr_, &outputs));\n    c->output_tensors_as_shapes.resize(outputs.size());\n    c->output_tensor_protos.resize(outputs.size(), nullptr);\n    for (int k = 0, outputs_size = outputs.size(); k < outputs_size; k++) {\n      const auto& t = outputs[k];\n      // Override output shape.\n      ShapeHandle output_shape;\n      TF_RETURN_IF_ERROR(\n          ic->MakeShapeFromTensorShape(t->shape(), &output_shape));\n      if (ic->FullyDefined(ic->output(k)) &&\n          !EquivalentShapes(ic->output(k), output_shape)) {\n        LOG(WARNING) << \"UpdateOutputShapesAndValues() -- node: \" << node.name()\n                     << \", inferred output shape \"\n                     << \"doesn't match for k=\" << k << \": \"\n                     << \"ic->output(k): \" << ic->DebugString(ic->output(k))\n                     << \", output_shape: \" << ic->DebugString(output_shape)\n                     << \" -- \" << node.DebugString();\n      }\n      ic->set_output(k, output_shape);\n      // Set output_tensors_as_shape.\n      MaybeTensorValueToShape(ic, *t.tensor, &c->output_tensors_as_shapes[k]);\n\n      // Set output_tensor_protos.\n      TensorProto tensor_proto;\n      t->AsProtoTensorContent(&tensor_proto);\n      const_tensors_to_propagate_.push_back(tensor_proto);\n      c->output_tensor_protos[k] = &const_tensors_to_propagate_.back();\n    }\n    return Status::OK();\n  }\n\n  // Update output shapes with annotated information.\n  // Currently only handle nodes with static shapes, i.e. shapes do not change\n  // during execution.\n  // TODO(andiryxu): Use annotated shapes in Enter/Merge etc as well.\n  Status UpdateOutputShapesUsingAnnotatedInformation(const NodeDef& node,\n                                                     NodeContext* c) const {\n    const auto& attr = node.attr();\n    if (attr.count(kOutputSame) == 0 || !attr.at(kOutputSame).b() ||\n        attr.count(kOutputShapes) == 0)\n      return Status::OK();\n\n    InferenceContext* ic = c->inference_context.get();\n    int output_size = attr.at(kOutputShapes).list().shape_size();\n\n    for (int i = 0; i < ic->num_outputs(); i++) {\n      // Annotated Switch node has only one output. Propagate the shape to all\n      // the outputs.\n      int shape_index = IsSwitch(node) ? 0 : i;\n      if (shape_index >= output_size) {\n        LOG(WARNING)\n            << \"UpdateOutputShapesUsingAnnotatedInformation() -- node: \"\n            << node.name() << \", inferred output shape size \"\n            << ic->num_outputs() << \", annotated output shape size \"\n            << output_size;\n        break;\n      }\n\n      const TensorShapeProto& shape =\n          attr.at(kOutputShapes).list().shape(shape_index);\n      if (shape.dim().empty()) continue;\n\n      ShapeHandle output_shape;\n      TF_RETURN_IF_ERROR(ic->MakeShapeFromShapeProto(shape, &output_shape));\n\n      // Check if annotated shapes are incompatible with inferred shapes.\n      if ((ic->FullyDefined(ic->output(i)) &&\n           !SameShapes(ic->output(i), output_shape)) ||\n          (!ic->FullyDefined(ic->output(i)) &&\n           !CompatibleShapes(ic->output(i), output_shape))) {\n        LOG(WARNING)\n            << \"UpdateOutputShapesUsingAnnotatedInformation() -- node: \"\n            << node.name() << \", inferred output shape \"\n            << \"doesn't match for i=\" << i << \": \"\n            << \"ic->output(k): \" << ic->DebugString(ic->output(i))\n            << \", annotated output shape: \" << ic->DebugString(output_shape)\n            << \" -- \" << node.DebugString();\n        c->shape_incompatible = true;\n      }\n\n      // Only use annotated shapes if the inference shape is unknown and\n      // compatible with annotated shapes.\n      if (!ic->FullyDefined(ic->output(i)) &&\n          CompatibleShapes(ic->output(i), output_shape)) {\n        VLOG(3) << \"UpdateOutputShapesUsingAnnotatedInformation() -- node: \"\n                << node.name() << \", inferred output shape \" << i << \": \"\n                << \"ic->output(i): \" << ic->DebugString(ic->output(i))\n                << \", annotated output shape: \" << ic->DebugString(output_shape)\n                << \" -- \" << node.ShortDebugString();\n        ic->set_output(i, output_shape);\n      }\n    }\n\n    return Status::OK();\n  }\n\n  Status MaybeUpdateNodeContextOutput(const NodeDef& node, const bool is_fed,\n                                      NodeContext* c) {\n    // Propagate tensors and shape tensors unless the node is fed.\n    // TODO(bsteiner) We should still propagate the shapes to the ports that\n    // aren't fed in the case of a ShapeN node.\n\n    // Note that when propagating tensors_as_shapes, we use\n    // c->input_tensors_as_shapes_to_progate instead of\n    // ic->input_tensors_as_shapes. The former uses kUnknownDimFromConst if\n    // UnknownDim is from Const tensor, and it is propagated through shape\n    // inference. Before calling shape functions, we convert it to UnknownDim,\n    // but instantiate a new UnknownDim to prevent incorrect symbolic shape\n    // inference through UnknownDim from Const.\n    InferenceContext* ic = c->inference_context.get();\n    if (!is_fed) {\n      if (IsConstant(node)) {\n        const TensorProto& tensor_proto = node.attr().at(\"value\").tensor();\n        c->output_tensor_protos.resize(1);\n        c->output_tensor_protos[0] = &tensor_proto;\n        c->output_tensors_as_shapes.resize(1);\n        MaybeTensorProtoToShape(ic, tensor_proto,\n                                &c->output_tensors_as_shapes[0]);\n      } else if (IsRank(node)) {\n        if (ic->RankKnown(ic->input(0))) {\n          // Propagate rank value.\n          int32_t rank = ic->Rank(ic->input(0));\n          const_tensors_to_propagate_.push_back(\n              MakeIntegerScalarTensorProto(DT_INT32, rank));\n          c->output_tensor_protos.resize(1);\n          c->output_tensor_protos[0] = &const_tensors_to_propagate_.back();\n        }\n      } else if (IsSize(node)) {\n        DimensionHandle size = ic->NumElements(ic->input(0));\n        if (ic->ValueKnown(size)) {\n          // Propagate size value.\n          int64_t sz = ic->Value(size);\n          bool valid = false;\n          if (node.attr().at(\"out_type\").type() == DT_INT32) {\n            if (sz < std::numeric_limits<int32>::max()) {\n              const_tensors_to_propagate_.push_back(\n                  MakeIntegerScalarTensorProto(DT_INT32, sz));\n              valid = true;\n            }\n          } else {\n            const_tensors_to_propagate_.push_back(\n                MakeIntegerScalarTensorProto(DT_INT64, sz));\n            valid = true;\n          }\n          if (valid) {\n            c->output_tensor_protos.resize(1);\n            c->output_tensor_protos[0] = &const_tensors_to_propagate_.back();\n          }\n        }\n      } else if (IsShape(node)) {\n        c->output_tensors_as_shapes.resize(1);\n        c->output_tensors_as_shapes[0] = c->inference_context->input(0);\n      } else if (IsShapeN(node)) {\n        c->output_tensors_as_shapes.resize(c->inference_context->num_inputs());\n        for (int i = 0; i < c->inference_context->num_inputs(); ++i) {\n          c->output_tensors_as_shapes[i] = c->inference_context->input(i);\n        }\n      } else if (node.op() == \"ConcatV2\") {\n        bool valid = true;\n        ShapeHandle result;\n        for (int i = 0; i < ic->num_inputs() - 1; ++i) {\n          ShapeHandle input = c->input_tensors_as_shapes_to_propagate[i];\n          if (!ic->RankKnown(input)) {\n            valid = false;\n            break;\n          } else if (i == 0) {\n            result = input;\n          } else {\n            TF_RETURN_IF_ERROR(ic->Concatenate(result, input, &result));\n          }\n        }\n        if (valid) {\n          c->output_tensors_as_shapes.resize(1);\n          c->output_tensors_as_shapes[0] = result;\n        }\n      } else if (IsPack(node)) {\n        // A Pack node concatenating scalars is often used to generate a shape.\n        std::vector<DimensionHandle> dims;\n        bool valid = true;\n        for (int i = 0; i < ic->num_inputs(); ++i) {\n          const Tensor* t = ic->input_tensor(i);\n          if (t) {\n            if (t->dims() != 0 ||\n                (t->dtype() != DT_INT32 && t->dtype() != DT_INT64)) {\n              valid = false;\n              break;\n            }\n            int64_t size = t->dtype() == DT_INT32 ? t->scalar<int32>()()\n                                                  : t->scalar<int64_t>()();\n            dims.push_back(size < 0 ? ic->MakeDim(kUnknownDimFromConst)\n                                    : ic->MakeDim(size));\n          } else {\n            // Don't have tensor value, but use input_tensors_as_shapes, if\n            // possible.\n            const ShapeHandle& shape_handle =\n                c->input_tensors_as_shapes_to_propagate[i];\n            if (ic->RankKnown(shape_handle) && ic->Rank(shape_handle) >= 1 &&\n                ic->ValueKnown(ic->Dim(shape_handle, 0))) {\n              dims.push_back(ic->Dim(shape_handle, 0));\n            } else {\n              // This is not from Const, but as it shouldn'be used as symbolic\n              // unknown dim for different ops, we use kUnknownDimFromConst.\n              dims.push_back(ic->MakeDim(kUnknownDimFromConst));\n            }\n          }\n        }\n        if (valid) {\n          c->output_tensors_as_shapes.resize(1);\n          c->output_tensors_as_shapes[0] = ic->MakeShape(dims);\n        }\n      } else if (IsIdentity(node) || IsIdentityNSingleInput(node)) {\n        c->output_tensors_as_shapes.resize(1);\n        c->output_tensors_as_shapes[0] =\n            c->input_tensors_as_shapes_to_propagate[0];\n        if (c->input_tensor_protos[0] != nullptr) {\n          c->output_tensor_protos.resize(1);\n          c->output_tensor_protos[0] = c->input_tensor_protos[0];\n        }\n      } else if (IsSlice(node)) {\n        ShapeHandle input = c->input_tensors_as_shapes_to_propagate[0];\n        bool valid = ic->RankKnown(input);\n        const Tensor* slice_offset = ic->input_tensor(1);\n        valid &= slice_offset != nullptr && slice_offset->NumElements() == 1;\n        const Tensor* slice_size = ic->input_tensor(2);\n        valid &= slice_size != nullptr && slice_size->NumElements() == 1;\n        if (valid) {\n          int64_t start = slice_offset->dtype() == DT_INT32\n                              ? slice_offset->flat<int32>()(0)\n                              : slice_offset->flat<int64_t>()(0);\n          int64_t size = (slice_size->dtype() == DT_INT32\n                              ? slice_size->flat<int32>()(0)\n                              : slice_size->flat<int64_t>()(0));\n          ShapeHandle result;\n          if (size == -1) {\n            TF_RETURN_IF_ERROR(ic->Subshape(input, start, &result));\n          } else {\n            int64_t end = start + size;\n            TF_RETURN_IF_ERROR(ic->Subshape(input, start, end, &result));\n          }\n          c->output_tensors_as_shapes.resize(1);\n          c->output_tensors_as_shapes[0] = result;\n        }\n      } else if (IsStridedSlice(node)) {\n        ShapeHandle input = c->input_tensors_as_shapes_to_propagate[0];\n        bool valid = ic->RankKnown(input);\n        const Tensor* slice_begin = ic->input_tensor(1);\n        valid &= slice_begin != nullptr && slice_begin->NumElements() == 1;\n        const Tensor* slice_end = ic->input_tensor(2);\n        valid &= slice_end != nullptr && slice_end->NumElements() == 1;\n        const Tensor* slice_stride = ic->input_tensor(3);\n        valid &= slice_stride != nullptr && slice_stride->NumElements() == 1;\n\n        if (node.attr().count(\"ellipsis_mask\") > 0 &&\n            node.attr().at(\"ellipsis_mask\").i() != 0) {\n          valid = false;\n        }\n        if (node.attr().count(\"new_axis_mask\") > 0 &&\n            node.attr().at(\"new_axis_mask\").i() != 0) {\n          valid = false;\n        }\n        if (node.attr().count(\"shrink_axis_mask\") > 0 &&\n            node.attr().at(\"shrink_axis_mask\").i() != 0) {\n          valid = false;\n        }\n        int begin_mask = 0;\n        if (node.attr().count(\"begin_mask\") > 0) {\n          begin_mask = node.attr().at(\"begin_mask\").i();\n        }\n        int end_mask = 0;\n        if (node.attr().count(\"end_mask\") > 0) {\n          end_mask = node.attr().at(\"end_mask\").i();\n        }\n        if (begin_mask < 0 || begin_mask > 1 || end_mask < 0 || end_mask > 1) {\n          valid = false;\n        }\n        if (valid) {\n          int64_t begin = 0;\n          if (begin_mask == 0) {\n            begin = slice_begin->dtype() == DT_INT32\n                        ? slice_begin->flat<int32>()(0)\n                        : slice_begin->flat<int64_t>()(0);\n          }\n          int64_t end = std::numeric_limits<int64_t>::max();\n          if (end_mask == 0) {\n            end = (slice_end->dtype() == DT_INT32\n                       ? slice_end->flat<int32>()(0)\n                       : slice_end->flat<int64_t>()(0));\n          }\n          int64_t stride = slice_stride->dtype() == DT_INT32\n                               ? slice_stride->flat<int32>()(0)\n                               : slice_stride->flat<int64_t>()(0);\n          ShapeHandle result;\n          TF_RETURN_IF_ERROR(ic->Subshape(input, begin, end, stride, &result));\n          c->output_tensors_as_shapes.resize(1);\n          c->output_tensors_as_shapes[0] = result;\n        }\n      }\n    }\n\n    if (aggressive_shape_inference_) {\n      // Update output shapes with annotated information. This is optional.\n      UpdateOutputShapesUsingAnnotatedInformation(node, c).IgnoreError();\n\n      // Update output tensor values using EvaluateNode() if we can.\n      // Due to the cost of EvaluateNode(), we run it only for certain op types\n      // (white listed) and small integer tensors.\n\n      const int max_element_size = 17;  // Max up to 4x4 matrix or similar.\n      if (AllOutputValuesKnown(c) || !AllInputValuesKnown(c) ||\n          !ShouldUpdateOutputShapesAndValues(c, max_element_size)) {\n        return Status::OK();\n      }\n      UpdateOutputShapesAndValues(node, c).IgnoreError();  // This is optional.\n    }\n    return Status::OK();\n  }\n\n  Status InferShapes(const NodeDef& node, NodeContext* c) {\n    // Infer the shapes of output tensors.\n    if (!c->op_data || c->op_data->shape_inference_fn == nullptr ||\n        !c->inference_context->Run(c->op_data->shape_inference_fn).ok()) {\n      // Annotate outputs with unknown shapes. Update output shapes with\n      // annotated information later on if available.\n      // Note that shape inference function may return an error, but we ignore\n      // it, and use UnknownShape in that case.\n      TF_RETURN_IF_ERROR(\n          c->inference_context->Run(shape_inference::UnknownShape));\n    }\n    Status status = Status::OK();\n    auto it = fed_ports_.find(node.name());\n    const bool is_fed = it != fed_ports_.end();\n    if (is_fed) {\n      // It is possible to feed node output ports with tensors of any shape: as\n      // a result, the shape of a fed port is completely unknown.\n      for (const int output_port : it->second) {\n        status.Update(SetUnknownShape(&node, output_port));\n      }\n    }\n\n    // Update NodeContext output fields after shape inference function runs.\n    status.Update(MaybeUpdateNodeContextOutput(node, is_fed, c));\n\n    return status;\n  }\n\n private:\n  bool IsIntegerVector(const Tensor& tensor) {\n    if (tensor.dims() == 1 &&\n        (tensor.dtype() == DT_INT32 || tensor.dtype() == DT_INT64)) {\n      return true;\n    }\n    return false;\n  }\n\n  bool IsIntegerScalar(const Tensor& tensor) {\n    if (tensor.dims() == 0 &&\n        (tensor.dtype() == DT_INT32 || tensor.dtype() == DT_INT64) &&\n        tensor.NumElements() == 1) {\n      return true;\n    }\n    return false;\n  }\n\n  TensorProto MakeIntegerScalarTensorProto(const DataType dtype,\n                                           const int64_t val) {\n    TensorProto tensor_proto;\n    tensor_proto.set_dtype(dtype);\n    // Scalar TensorProto has an empty tensor_shape; no dim, no dim.size.\n    tensor_proto.mutable_tensor_shape();\n    if (dtype == DT_INT32) {\n      tensor_proto.add_int_val(val);\n    } else if (dtype == DT_INT64) {\n      tensor_proto.add_int64_val(val);\n    }\n    return tensor_proto;\n  }\n\n  bool MaybeTensorProtoToShape(InferenceContext* ic,\n                               const TensorProto& tensor_proto,\n                               ShapeHandle* tensors_as_shapes) {\n    // Skip if dtype is not integer.\n    if (tensor_proto.dtype() != DT_INT32 && tensor_proto.dtype() != DT_INT64) {\n      return false;\n    }\n    // Skip if the const tensor is too large.\n    if (NumElementsFromTensorProto(tensor_proto) >\n        kThresholdToSkipConstTensorInstantiation) {\n      return false;\n    }\n    // Skip if shape is neither scalar nor vector.\n    if (tensor_proto.tensor_shape().unknown_rank() ||\n        tensor_proto.tensor_shape().dim_size() > 1) {\n      return false;\n    }\n    Tensor tensor;\n    if (!tensor.FromProto(tensor_proto)) {\n      return false;\n    }\n    return MaybeTensorValueToShape(ic, tensor, tensors_as_shapes);\n  }\n\n  bool MaybeTensorValueToShape(InferenceContext* ic, const Tensor& tensor,\n                               ShapeHandle* tensors_as_shapes) {\n    // Integer tensors of rank one can also be interpreted as a shape\n    // provided all their values are >= -1.\n\n    if (IsIntegerVector(tensor)) {\n      bool has_values_smaller_than_minus_1 = false;\n      std::vector<DimensionHandle> dims;\n      for (int i = 0; i < tensor.NumElements(); i++) {\n        int64_t value = tensor.dtype() == DT_INT32 ? tensor.flat<int32>()(i)\n                                                   : tensor.flat<int64_t>()(i);\n        has_values_smaller_than_minus_1 |= (value < -1);\n        // Mark this as UnknownDim from Const.\n        dims.push_back(value < 0 ? ic->MakeDim(kUnknownDimFromConst)\n                                 : ic->MakeDim(value));\n      }\n\n      if (!has_values_smaller_than_minus_1) {\n        *tensors_as_shapes = ic->MakeShape(dims);\n        return true;\n      }\n    } else if (IsIntegerScalar(tensor)) {\n      // Scalar constant.\n      int64_t value = tensor.dtype() == DT_INT32 ? tensor.flat<int32>()(0)\n                                                 : tensor.flat<int64_t>()(0);\n      if (value == -1) {\n        // Scalar value -1 represents an unknown shape. If we would try to\n        // MakeShape(MakeDim) with it, we would get vector of unknown size.\n        *tensors_as_shapes = ic->UnknownShape();\n        return true;\n      } else if (value >= 0) {\n        // Ideally, values can be < -1, but MakeDim() fails with a value < -1.\n        // It's a limitation as we use ShapeHandle as a means to pass values.\n        *tensors_as_shapes = ic->MakeShape({ic->MakeDim(value)});\n        return true;\n      }\n    }\n    return false;\n  }\n\n  const GraphView& graph_;\n  int graph_def_version_;\n  absl::flat_hash_map<const NodeDef*, NodeContext> node_to_context_;\n  absl::flat_hash_map<ShapeId, ShapeHandle, HashShapeId> unknown_shapes_;\n  absl::flat_hash_map<DimId, DimensionHandle, HashDimId> unknown_dims_;\n  // Store function instantiations only for valid function. If function\n  // instantiation failed it will have an `absl::nullopt`.\n  absl::flat_hash_map<string, absl::optional<GrapplerFunctionItem>>\n      fun_to_grappler_function_item_;\n  FunctionLibraryDefinition function_library_;\n  const absl::flat_hash_map<string, absl::flat_hash_set<int>>& fed_ports_;\n  // Store TensorProtos for tensor value propagation. Note that we use deque,\n  // not vector, as we use pointers to the TensorProtos in this container.\n  // Vector may resize and copy the objects into a new buffer, then the existing\n  // pointers become dangling pointers.\n  std::deque<TensorProto> const_tensors_to_propagate_;\n\n  // For more aggressive shape and value inference.\n  bool aggressive_shape_inference_;\n  ResourceMgr resource_mgr_;\n};\n\n// Keep track of shapes and dimensions in a graph.\n// In particular, use disjoint sets to track equivalence between shapes and\n// dims, and consolidate the information globally.\nclass SymbolicShapeManager {\n public:\n  SymbolicShapeManager() {}\n\n  Status Merge(ShapeHandle s1, ShapeHandle s2) {\n    if (!s1.IsSet() || !s2.IsSet()) {\n      return Status::OK();\n    }\n    TF_RETURN_IF_ERROR(shapes_.Merge(s1, s2));\n    if (InferenceContext::Rank(s1) > 0 && InferenceContext::Rank(s2) > 0) {\n      CHECK_EQ(InferenceContext::Rank(s1), InferenceContext::Rank(s2));\n      for (int i = 0; i < InferenceContext::Rank(s1); ++i) {\n        TF_RETURN_IF_ERROR(dims_.Merge(InferenceContext::DimKnownRank(s1, i),\n                                       InferenceContext::DimKnownRank(s2, i)));\n      }\n    }\n    return Status::OK();\n  }\n  Status Merge(DimensionHandle d1, DimensionHandle d2) {\n    if (!d1.IsSet() || !d2.IsSet()) {\n      return Status::OK();\n    }\n    return dims_.Merge(d1, d2);\n  }\n\n  void AsTensorProperties(const ShapeHandle& shape, const DataType& type,\n                          OpInfo::TensorProperties* properties) {\n    properties->set_dtype(type);\n    ShapeHandle actual_shape = shapes_.GetMergedValue(shape);\n    if (!InferenceContext::RankKnown(actual_shape)) {\n      properties->mutable_shape()->set_unknown_rank(true);\n    } else {\n      for (int j = 0; j < InferenceContext::Rank(actual_shape); ++j) {\n        shape_inference::DimensionHandle dim =\n            InferenceContext::DimKnownRank(actual_shape, j);\n        int64_t d = dims_.GetMergedValue(dim);\n        properties->mutable_shape()->add_dim()->set_size(d);\n      }\n    }\n  }\n\n  // Returns merged shape with merged dimensions.\n  ShapeHandle GetMergedShape(InferenceContext* ic, ShapeHandle s) {\n    const auto& actual_shape = shapes_.GetMergedValue(s);\n    if (!InferenceContext::RankKnown(actual_shape)) {\n      return ic->UnknownShape();\n    } else {\n      std::vector<DimensionHandle> dims;\n      for (int j = 0; j < InferenceContext::Rank(actual_shape); ++j) {\n        shape_inference::DimensionHandle dim =\n            InferenceContext::DimKnownRank(actual_shape, j);\n        int64_t d = dims_.GetMergedValue(dim);\n        // Symbolic shape manager may made some dims < -1, which causes errors\n        // in creating Dimension.\n        if (d < -1) {\n          d = -1;\n        }\n        dims.push_back(ic->MakeDim(d));\n      }\n      return ic->MakeShape(dims);\n    }\n  }\n\n private:\n  DisjointSet<shape_inference::ShapeHandle> shapes_;\n  DisjointSet<shape_inference::DimensionHandle> dims_;\n};\n\n// Checks whether there is any conflict in merged shapes and dims in\n// SymbolicShapeManager.\nStatus ValidateSymbolicShapeManager(const GraphDef& graph_def,\n                                    SymbolicShapeRefiner* refiner,\n                                    SymbolicShapeManager* shape_manager) {\n  if (!VLOG_IS_ON(1)) {\n    return Status::OK();\n  }\n\n  VLOG(1) << \"Checking any conflics in shapes and dimensions ...\";\n  int64_t num_incompatible_shapes = 0;\n  for (const NodeDef& node : graph_def.node()) {\n    auto ctx = refiner->GetNodeContext(&node);\n    if (!ctx) {\n      continue;\n    }\n    auto* ic = ctx->inference_context.get();\n    for (int i = 0; i < ic->num_inputs(); ++i) {\n      const auto& shape = ic->input(i);\n      const auto& merged_shape = shape_manager->GetMergedShape(ic, shape);\n      if (!refiner->CompatibleShapes(shape, merged_shape)) {\n        num_incompatible_shapes++;\n        VLOG(1) << \"**** Incompatible shape from SymbolicShapeManager \"\n                << \"for node \" << node.name() << \" input (\" << i << \") \"\n                << ic->DebugString(shape)\n                << \" vs. merged: \" << ic->DebugString(merged_shape);\n      }\n    }\n    for (int i = 0; i < ic->num_outputs(); ++i) {\n      const auto& shape = ic->output(i);\n      const auto& merged_shape = shape_manager->GetMergedShape(ic, shape);\n      if (!refiner->CompatibleShapes(shape, merged_shape)) {\n        num_incompatible_shapes++;\n        VLOG(1) << \"**** Incompatible shape from SymbolicShapeManager \"\n                << \"for node \" << node.name() << \" output (\" << i << \") \"\n                << ic->DebugString(shape)\n                << \" vs. merged: \" << ic->DebugString(merged_shape);\n      }\n    }\n  }\n  if (num_incompatible_shapes > 0) {\n    VLOG(1) << \"**** WARNING: \" << num_incompatible_shapes\n            << \" incompatible shapes from SymbolicShapeManager.\";\n  } else {\n    VLOG(1) << \"**** No incompatible shape found from SymbolicShapeManager.\";\n  }\n\n  return Status::OK();\n}\n\n// Log shape inference and its merged shapes.\nStatus VerboseShapeInferenceLogging(const GraphDef& graph_def,\n                                    SymbolicShapeRefiner* refiner,\n                                    SymbolicShapeManager* shape_manager) {\n  // As logging all the nodes would generate too many lines, we by default\n  // skip this detailed logging. Users may add nodes of interest to\n  // node_names_for_logging to enable detailed logging.\n  absl::flat_hash_set<std::string> node_names_for_logging = {};\n  if (!VLOG_IS_ON(3) || node_names_for_logging.empty()) {\n    return Status::OK();\n  }\n\n  auto should_log = [&node_names_for_logging](std::string node_name) {\n    return node_names_for_logging.find(node_name) !=\n           node_names_for_logging.end();\n  };\n\n  for (const NodeDef& node : graph_def.node()) {\n    if (!should_log(node.name())) {\n      continue;\n    }\n    auto ctx = refiner->GetNodeContext(&node);\n    if (!ctx) {\n      continue;\n    }\n    auto* ic = ctx->inference_context.get();\n    VLOG(3) << \"Shape inference for node : \" << node.name();\n    VLOG(3) << ctx->DebugString(node);\n    std::string merged_shapes = \"Merged shapes from SymbolicShapManager:\\n\";\n    for (int i = 0; i < ic->num_inputs(); ++i) {\n      absl::StrAppend(\n          &merged_shapes, \" input[\", i, \"] -- \",\n          ic->DebugString(shape_manager->GetMergedShape(ic, ic->input(i))),\n          \"\\n\");\n    }\n    for (int i = 0; i < ic->num_outputs(); ++i) {\n      absl::StrAppend(\n          &merged_shapes, \" output[\", i, \"] -- \",\n          ic->DebugString(shape_manager->GetMergedShape(ic, ic->output(i))),\n          \"\\n\");\n    }\n    VLOG(3) << merged_shapes;\n    VLOG(3) << \"--------------------------------\";\n    VLOG(3) << \"\";\n  }\n\n  return Status::OK();\n}\n\nStatus GraphProperties::RelaxEnqueueShapesAndMergeTypes(\n    SymbolicShapeRefiner* shape_refiner, const NodeDef* qnode,\n    const std::vector<ShapeAndType>& shapes_and_types,\n    std::vector<ShapeAndType>* queue_shapes_and_types) {\n  if (shapes_and_types.size() != queue_shapes_and_types->size()) {\n    return errors::InvalidArgument(\n        \"Enqueue nodes mixed number of tensors: \", shapes_and_types.size(),\n        \"  vs \", queue_shapes_and_types->size());\n  }\n  for (size_t i = 0; i < shapes_and_types.size(); ++i) {\n    const ShapeAndType& a = shapes_and_types[i];\n    ShapeAndType& b = (*queue_shapes_and_types)[i];\n    if (a.dtype != b.dtype) {\n      return errors::InvalidArgument(\"Enqueue nodes mixed dtypes for tensor \",\n                                     i, \": \", DataTypeString(a.dtype), \" vs \",\n                                     DataTypeString(b.dtype));\n    }\n\n    b.shape = shape_refiner->OutputAsUnion(qnode, i, a.shape, b.shape);\n  }\n  return Status::OK();\n}\n\n// Compute the output shape of the merge node as the union of the available\n// input shapes.\nStatus GraphProperties::UpdateMerge(SymbolicShapeRefiner* shape_refiner,\n                                    const NodeDef* node,\n                                    bool* new_shapes) const {\n  InferenceContext* ic = shape_refiner->GetContext(node);\n  if (!ic) {\n    // Now we can run shape inference\n    TF_RETURN_IF_ERROR(shape_refiner->AddNode(node));\n    ic = CHECK_NOTNULL(shape_refiner->GetContext(node));\n    *new_shapes = true;\n\n    // Infer the shape of the second output once and for all since it never\n    // changes.\n    ShapeHandle out1 = ic->Scalar();\n    if (ic->num_outputs() >= 2) ic->set_output(1, out1);\n  }\n\n  ShapeHandle out;\n  const std::vector<ShapeAndType>* out_handle = nullptr;\n  bool out_initialized = false;\n  for (const GraphView::Edge fanin : shape_refiner->graph().GetFaninEdges(\n           *node, /*include_controlling_edges=*/false)) {\n    InferenceContext* src_ic = shape_refiner->GetContext(fanin.src.node);\n    if (!src_ic) {\n      // Handling a loop for the first time, the back edge won't have any shape\n      // info.\n      continue;\n    }\n    ShapeHandle input = src_ic->output(fanin.src.port_id);\n    ic->SetInput(fanin.dst.port_id, input);\n    auto* input_handle =\n        src_ic->output_handle_shapes_and_types(fanin.src.port_id);\n    if (input_handle)\n      ic->set_input_handle_shapes_and_types(fanin.dst.port_id, *input_handle);\n    if (!out_initialized) {\n      out_initialized = true;\n      out = input;\n      out_handle = input_handle;\n    } else {\n      // Note here only out, not out_handle, is modified.\n      out = shape_refiner->OutputAsUnion(node, 0, input, out);\n    }\n  }\n\n  if (*new_shapes || !shape_refiner->EquivalentShapes(out, ic->output(0))) {\n    ic->set_output(0, out);\n    if (out_handle) ic->set_output_handle_shapes_and_types(0, *out_handle);\n    *new_shapes = true;\n  }\n\n  return Status::OK();\n}\n\n// Manually propagate the input shape for Enter nodes.\nStatus GraphProperties::UpdateEnter(SymbolicShapeRefiner* shape_refiner,\n                                    const NodeDef* node, bool* new_shapes) {\n  InferenceContext* ic = shape_refiner->GetContext(node);\n  if (!ic) {\n    TF_RETURN_IF_ERROR(shape_refiner->UpdateNode(node, new_shapes));\n    ic = shape_refiner->GetContext(node);\n  }\n\n  GraphView::InputPort port(node, 0);\n  GraphView::OutputPort fanin = shape_refiner->graph().GetRegularFanin(port);\n\n  InferenceContext* src_ic = shape_refiner->GetContext(fanin.node);\n  ShapeHandle input = src_ic->output(fanin.port_id);\n  if (!ic->output(0).SameHandle(input)) {\n    ic->SetInput(0, input);\n    ic->set_output(0, input);\n    *new_shapes = true;\n  }\n  auto* outputs = src_ic->output_handle_shapes_and_types(fanin.port_id);\n  if (outputs) {\n    ic->set_input_handle_shapes_and_types(0, *outputs);\n    ic->set_output_handle_shapes_and_types(0, *outputs);\n    *new_shapes = true;\n  }\n  return Status::OK();\n}\n\nStatus GraphProperties::UpdateShapes(\n    SymbolicShapeRefiner* shape_refiner,\n    const absl::flat_hash_map<const NodeDef*, const NodeDef*>& resource_handles,\n    const NodeDef* n, bool* new_shapes) const {\n  if (IsEnter(*n)) {\n    // The Enter shape function always forwards an UnknownShape, so do the right\n    // thing here.\n    TF_RETURN_IF_ERROR(UpdateEnter(shape_refiner, n, new_shapes));\n  } else if (IsMerge(*n)) {\n    // Properly handle merge nodes.\n    TF_RETURN_IF_ERROR(UpdateMerge(shape_refiner, n, new_shapes));\n  } else if (IsEnqueue(*n)) {\n    // Make sure the shapes of enqueued tensors are propagated to the queue\n    // itself.\n    TF_RETURN_IF_ERROR(\n        UpdateEnqueue(n, resource_handles, shape_refiner, new_shapes));\n  } else if (IsQueue(*n)) {\n    // Set shapes and types of Queue ops, if needed.\n    TF_RETURN_IF_ERROR(UpdateQueue(n, shape_refiner, new_shapes));\n  } else {\n    // Rely on regular TF shape refinement for all the other nodes.\n    // UpdateNode calls UpdateFunction if a function node is detected.\n    TF_RETURN_IF_ERROR(shape_refiner->UpdateNode(n, new_shapes));\n  }\n\n  return Status::OK();\n}\n\n// Propagates the shapes in the transitive fan-out of <new_shapes>.\nStatus GraphProperties::PropagateShapes(\n    SymbolicShapeRefiner* shape_refiner, TopoQueue* new_shapes,\n    const absl::flat_hash_map<const NodeDef*, const NodeDef*>& resource_handles,\n    int num_loops) const {\n  // Limit the number of iterations to prevent infinite loops in the presence of\n  // incorrect shape functions. The algorithm should converge in at most\n  // num_nested_loops^2 * max_rank. We approximate max_rank with the constant 4.\n  // The same applies to resources.\n  VLOG(1) << \"Propagating \" << new_shapes->size() << \" new shapes through \"\n          << num_loops << \" loops and \" << resource_handles.size()\n          << \" resources\" << std::endl;\n\n  const int64_t max_loop_length = item_.graph.node_size();\n  const int64_t max_rank = 4;\n  const int64_t max_loop_iterations =\n      max_rank * max_loop_length * std::max<int64_t>(1, num_loops * num_loops);\n  const int64_t num_queues = resource_handles.size();\n  const int64_t max_resource_iterations = num_queues * num_queues * max_rank;\n\n  int64_t num_resource_iterations = 0;\n  do {\n    int64_t num_loop_iterations = 0;\n    while (!new_shapes->empty() &&\n           num_loop_iterations++ < max_loop_iterations) {\n      const NodeDef* n = new_shapes->pop();\n      bool updated = false;\n      TF_RETURN_IF_ERROR(\n          UpdateShapes(shape_refiner, resource_handles, n, &updated));\n      if (updated) {\n        for (const auto& fanout : shape_refiner->graph().GetFanouts(\n                 *n, /*include_controlled_nodes=*/false)) {\n          new_shapes->push(fanout.node);\n        }\n        // Make sure the corresponding queue nodes are (re)processed.\n        if (IsEnqueue(*n)) {\n          auto it = resource_handles.find(n);\n          if (it != resource_handles.end()) {\n            new_shapes->push(it->second);\n          }\n        }\n      }\n    }\n  } while (!new_shapes->empty() &&\n           num_resource_iterations++ < max_resource_iterations);\n\n  if (!new_shapes->empty()) {\n    return errors::Internal(\"Shape inference failed to converge\");\n  }\n\n  return Status::OK();\n}\n\nStatus GraphProperties::UpdateQueue(const NodeDef* queue_node,\n                                    SymbolicShapeRefiner* shape_refiner,\n                                    bool* new_shapes) {\n  auto* ctx = shape_refiner->GetNodeContext(queue_node);\n  if (!ctx) {\n    TF_RETURN_IF_ERROR(shape_refiner->AddNode(queue_node));\n    ctx = CHECK_NOTNULL(shape_refiner->GetNodeContext(queue_node));\n  }\n  auto* ic = ctx->inference_context.get();\n\n  auto* outputs = ic->output_handle_shapes_and_types(0);\n  if (outputs) {\n    // Shapes and types are already set, presumably by Enqueue ops.\n    return shape_refiner->UpdateNode(queue_node, new_shapes);\n  }\n\n  if (queue_node->attr().count(\"shapes\") <= 0 ||\n      queue_node->attr().count(\"component_types\") <= 0 ||\n      queue_node->attr().at(\"shapes\").list().shape_size() !=\n          queue_node->attr().at(\"component_types\").list().type_size()) {\n    // Errors in shapes and component_types attr.\n    return shape_refiner->UpdateNode(queue_node, new_shapes);\n  }\n\n  // Extract types and shapes from Queue attr.\n  const auto& shapes = queue_node->attr().at(\"shapes\").list().shape();\n  const auto& types = queue_node->attr().at(\"component_types\").list().type();\n  std::vector<ShapeAndType> shapes_and_types;\n  for (int i = 0; i < types.size(); i++) {\n    const auto& shape = shapes[i];\n    ShapeHandle shape_handle;\n    TF_RETURN_IF_ERROR(\n        ic->MakeShapeFromPartialTensorShape(shape, &shape_handle));\n    DataType data_type =\n        queue_node->attr().at(\"component_types\").list().type(i);\n    ShapeAndType shape_and_type(shape_handle, data_type);\n    shapes_and_types.push_back(shape_and_type);\n  }\n  ic->set_output_handle_shapes_and_types(0, shapes_and_types);\n\n  // Queue node is updated with output_handle_shapes_and_types, so set\n  // new_shapes and ignore it from UpdateNoe().\n  *new_shapes = true;\n  bool dummy_new_shapes = false;\n  return shape_refiner->UpdateNode(queue_node, &dummy_new_shapes);\n}\n\nStatus GraphProperties::UpdateEnqueue(\n    const NodeDef* enqueue_node,\n    const absl::flat_hash_map<const NodeDef*, const NodeDef*>& resource_handles,\n    SymbolicShapeRefiner* shape_refiner, bool* new_shapes) {\n  auto ctx = shape_refiner->GetNodeContext(enqueue_node);\n  if (!ctx) {\n    TF_RETURN_IF_ERROR(shape_refiner->AddNode(enqueue_node));\n    ctx = CHECK_NOTNULL(shape_refiner->GetNodeContext(enqueue_node));\n  }\n\n  auto it = resource_handles.find(enqueue_node);\n  if (it == resource_handles.end()) {\n    // The corresponding queue was not found, there isn't much we can do.\n    return Status::OK();\n  }\n  const NodeDef* qnode = it->second;\n  auto qctx = shape_refiner->GetContext(qnode);\n  if (!qctx) {\n    return Status::OK();\n  }\n  auto* queue_handle_data = qctx->output_handle_shapes_and_types(0);\n\n  // TODO(bsteiner): handle EnqueueMany as well.\n  std::vector<ShapeAndType> shapes_and_types;\n  for (int i = 1, end = ctx->input_types.size(); i < end; ++i) {\n    GraphView::InputPort inp(enqueue_node, i);\n    GraphView::OutputPort fanin = shape_refiner->graph().GetRegularFanin(inp);\n    InferenceContext* in = shape_refiner->GetContext(fanin.node);\n    ShapeHandle input = in->output(fanin.port_id);\n    ctx->inference_context->SetInput(i, input);\n    shapes_and_types.push_back({input, ctx->input_types[i]});\n  }\n\n  if (queue_handle_data == nullptr) {\n    qctx->set_output_handle_shapes_and_types(0, shapes_and_types);\n    *new_shapes = true;\n  } else {\n    TF_RETURN_IF_ERROR(RelaxEnqueueShapesAndMergeTypes(\n        shape_refiner, qnode, *queue_handle_data, &shapes_and_types));\n    *new_shapes |= !shape_refiner->EquivalentShapesAndTypes(*queue_handle_data,\n                                                            shapes_and_types);\n    qctx->set_output_handle_shapes_and_types(0, shapes_and_types);\n  }\n\n  return Status::OK();\n}\n\nStatus GraphProperties::InferStatically(bool assume_valid_feeds,\n                                        bool aggressive_shape_inference,\n                                        bool include_input_tensor_values,\n                                        bool include_output_tensor_values) {\n  FunctionLibraryDefinition function_library(OpRegistry::Global(),\n                                             item_.graph.library());\n  absl::flat_hash_map<string, absl::flat_hash_set<int>> fed_ports;\n  if (!assume_valid_feeds) {\n    for (const auto& feed : item_.feed) {\n      SafeTensorId tensor_id = ParseTensorName(feed.first);\n      fed_ports[tensor_id.node()].insert(tensor_id.index());\n    }\n  }\n\n  GraphView graph_view(&item_.graph);\n\n  // List the resources and the nodes using them. Also collect the Merge nodes,\n  // fed nodes, and primary inputs.\n  absl::flat_hash_map<const NodeDef*,\n                      std::pair<absl::flat_hash_set<const NodeDef*>,\n                                absl::flat_hash_set<const NodeDef*>>>\n      resources;\n  absl::flat_hash_set<const NodeDef*> merge_nodes;\n  absl::flat_hash_set<const NodeDef*> fed_nodes;\n  absl::flat_hash_set<const NodeDef*> primary_inputs;\n  int num_loops = 0;\n  for (const NodeDef& node : item_.graph.node()) {\n    if (IsQueue(node)) {\n      for (const GraphView::InputPort& fanout :\n           graph_view.GetFanouts(node, false)) {\n        if (IsEnter(*fanout.node)) {\n          const NodeDef& enter = *fanout.node;\n          for (const GraphView::InputPort& fanout :\n               graph_view.GetFanouts(enter, false)) {\n            if (IsEnqueue(*fanout.node)) {\n              resources[&node].first.insert(fanout.node);\n            } else if (IsDequeue(*fanout.node)) {\n              resources[&node].second.insert(fanout.node);\n            }\n          }\n        } else {\n          if (IsEnqueue(*fanout.node)) {\n            resources[&node].first.insert(fanout.node);\n          } else if (IsDequeue(*fanout.node)) {\n            resources[&node].second.insert(fanout.node);\n          }\n        }\n      }\n    }\n    if (!HasRegularInputs(node)) {\n      primary_inputs.insert(&node);\n    } else if (IsMerge(node)) {\n      merge_nodes.insert(&node);\n    } else if (IsNextIteration(node)) {\n      ++num_loops;\n    }\n    if (fed_ports.find(node.name()) != fed_ports.end()) {\n      fed_nodes.insert(&node);\n    }\n  }\n\n  absl::flat_hash_map<const NodeDef*, const NodeDef*> resource_handles;\n  std::vector<TopologicalDependency> extra_deps;\n  for (const auto& resource : resources) {\n    for (const NodeDef* src : resource.second.first) {\n      resource_handles[src] = resource.first;\n      for (const NodeDef* dst : resource.second.second) {\n        // Add control edges from enqueue to dequeue nodes to ensure they are\n        // processed in their logical order.\n        extra_deps.emplace_back(src, dst);\n      }\n    }\n  }\n\n  std::vector<const NodeDef*> topo_order;\n  Status s = ComputeTopologicalOrder(item_.graph, extra_deps, &topo_order);\n  if (!s.ok()) {\n    if (extra_deps.empty()) {\n      return s;\n    } else {\n      // There is a loop between queues: we'll just use the graph topological\n      // order. This will make the shape inference less precise but since this\n      // isn't common it's not worth to figure out where to break the loop and\n      // do a proper relaxation.\n      TF_RETURN_IF_ERROR(ComputeTopologicalOrder(item_.graph, &topo_order));\n    }\n  }\n\n  // Heap-allocate SymbolicShapeRefiner in order to not consume a large amount\n  // of stack space.\n  auto refiner = absl::make_unique<SymbolicShapeRefiner>(\n      graph_view, fed_ports, aggressive_shape_inference);\n\n  TopoQueue new_shapes(topo_order);\n  // Also seed the propagation of shapes in the fanout of primary inputs.\n  for (const NodeDef* node : primary_inputs) {\n    new_shapes.push(node);\n  }\n  // Also seed the propagation of shapes in the fanout of fed nodes.\n  for (const NodeDef* node : fed_nodes) {\n    new_shapes.push(node);\n  }\n  // Propagate shapes normally.\n  TF_RETURN_IF_ERROR(\n      PropagateShapes(refiner.get(), &new_shapes, resource_handles, num_loops));\n\n  // Track shapes globally across the graph.\n  std::unique_ptr<SymbolicShapeManager> shape_manager =\n      absl::make_unique<SymbolicShapeManager>();\n  bool found_error = false;\n  for (const NodeDef& node : item_.graph.node()) {\n    auto node_ctx = refiner->GetContext(&node);\n    if (!node_ctx) {\n      continue;\n    }\n    // Skip any information that comes from fed nodes.\n    if (fed_ports.find(node.name()) != fed_ports.end()) {\n      VLOG(2) << \"Skipping feed node shape: \" << node.name();\n      continue;\n    }\n    for (const auto& merged_shapes : node_ctx->MergedShapes()) {\n      if (!shape_manager->Merge(merged_shapes.first, merged_shapes.second)\n               .ok()) {\n        found_error = true;\n        break;\n      }\n    }\n    for (const auto& merged_dims : node_ctx->MergedDims()) {\n      if (!shape_manager->Merge(merged_dims.first, merged_dims.second).ok()) {\n        found_error = true;\n        break;\n      }\n    }\n    if (found_error) {\n      // The shapes aren't consistent, we can't infer safely: discard all the\n      // information discovered so far.\n      shape_manager = absl::make_unique<SymbolicShapeManager>();\n      break;\n    }\n  }\n\n  TF_RETURN_IF_ERROR(ValidateSymbolicShapeManager(item_.graph, refiner.get(),\n                                                  shape_manager.get()));\n\n  for (const NodeDef& node : item_.graph.node()) {\n    VLOG(4) << \"Filling in graph properties for node: \" << node.name();\n    auto ctx = refiner->GetNodeContext(&node);\n    if (!ctx) {\n      continue;\n    }\n\n    auto* ic = ctx->inference_context.get();\n\n    // Fill input properties.\n    {\n      auto& input_properties = input_properties_[node.name()];\n\n      // Should always be empty, node names in graph are supposed to be unique.\n      CHECK_EQ(input_properties.size(), 0);\n\n      input_properties.resize(ic->num_inputs());\n      GraphView::InputPort input(&node, -1);\n      for (int i = 0; i < ic->num_inputs(); ++i) {\n        shape_manager->AsTensorProperties(ic->input(i), ctx->input_types[i],\n                                          &input_properties[i]);\n        input.port_id = i;\n        GraphView::OutputPort fanin = graph_view.GetRegularFanin(input);\n        if (include_input_tensor_values) {\n          // Export tensor value to input_properties.value.\n          if (IsConstant(*fanin.node)) {\n            const TensorProto& raw_val =\n                fanin.node->attr().at(\"value\").tensor();\n            *input_properties[i].mutable_value() = raw_val;\n          } else if (static_cast<int>(ctx->input_tensor_protos.size()) > i &&\n                     ctx->input_tensor_protos[i] != nullptr) {\n            *input_properties[i].mutable_value() = *ctx->input_tensor_protos[i];\n          } else if (static_cast<int>(ic->input_tensors_as_shapes().size()) >\n                         i &&\n                     IsShapeFullyDefinedIntegerVectorOrScalar(\n                         ic, ic->input(i), ic->input_tensors_as_shapes()[i],\n                         ctx->input_types[i])) {\n            *input_properties[i].mutable_value() = MakeTensorProtoFromShape(\n                ic, ic->input(i), ic->input_tensors_as_shapes()[i],\n                ctx->input_types[i]);\n          }\n        }\n      }\n    }\n\n    // Fill output properties.\n    {\n      auto& output_properties = output_properties_[node.name()];\n\n      // Should always be empty, node names in graph are supposed to be unique.\n      CHECK_EQ(output_properties.size(), 0);\n\n      output_properties.resize(ic->num_outputs());\n      for (int i = 0; i < ic->num_outputs(); ++i) {\n        shape_manager->AsTensorProperties(ic->output(i), ctx->output_types[i],\n                                          &output_properties[i]);\n        auto converted_output_tensors_as_shapes =\n            ReplaceUnknownDimFromConstWithUnknownDim(\n                ic, ctx->output_tensors_as_shapes);\n        if (include_output_tensor_values) {\n          // Export tensor value to output_properties.value.\n          if (IsConstant(node)) {\n            // TODO(rmlarsen): Eliminate this copy.\n            const TensorProto& raw_val = node.attr().at(\"value\").tensor();\n            *output_properties[i].mutable_value() = raw_val;\n          } else if (static_cast<int>(ctx->output_tensor_protos.size()) > i &&\n                     ctx->output_tensor_protos[i] != nullptr) {\n            *output_properties[i].mutable_value() =\n                *ctx->output_tensor_protos[i];\n          } else if (static_cast<int>(\n                         converted_output_tensors_as_shapes.size()) > i &&\n                     IsShapeFullyDefinedIntegerVectorOrScalar(\n                         ic, ic->output(i),\n                         converted_output_tensors_as_shapes[i],\n                         ctx->output_types[i])) {\n            *output_properties[i].mutable_value() = MakeTensorProtoFromShape(\n                ic, ic->output(i), converted_output_tensors_as_shapes[i],\n                ctx->output_types[i]);\n          }\n        }\n      }\n    }\n\n    if (aggressive_shape_inference && ctx->shape_incompatible)\n      incompatible_shape_nodes_.insert(node.name());\n  }\n\n  if (aggressive_shape_inference && !incompatible_shape_nodes_.empty())\n    LOG(WARNING) << incompatible_shape_nodes_.size()\n                 << \" nodes have incompatible output shapes.\";\n\n  // Help trace the unknown dimensions to their origins.\n  VerboseLogUnknownDimensionSources(item_.graph, input_properties_,\n                                    output_properties_);\n\n  TF_RETURN_IF_ERROR(VerboseShapeInferenceLogging(item_.graph, refiner.get(),\n                                                  shape_manager.get()));\n\n  return Status::OK();\n}\n\nStatus GraphProperties::InferDynamically(Cluster* cluster) {\n  TF_RETURN_IF_ERROR(cluster->Initialize(item_));\n\n  // Runs the model once to collect the shapes in the cost model.\n  RunMetadata metadata;\n  TF_RETURN_IF_ERROR(\n      cluster->Run(item_.graph, item_.feed, item_.fetch, &metadata));\n\n  return InferFromCostGraph(metadata.cost_graph());\n}\n\nStatus GraphProperties::AnnotateOutputShapes(GraphDef* output_graph_def) const {\n  *output_graph_def = item_.graph;\n  for (int i = 0; i < output_graph_def->node_size(); i++) {\n    auto node = output_graph_def->mutable_node(i);\n    AttrValue attr_output_shape;\n    auto tensor_properties = GetOutputProperties(node->name());\n    for (const auto& tensor_property : tensor_properties) {\n      TensorShapeProto* proto = attr_output_shape.mutable_list()->add_shape();\n      *proto = tensor_property.shape();\n      NormalizeShapeForOutput(proto);\n    }\n    (*node->mutable_attr())[\"_output_shapes\"] = std::move(attr_output_shape);\n  }\n  return Status::OK();\n}\n\nStatus GraphProperties::InferFromCostGraph(const CostGraphDef& cost_graph) {\n  if (cost_graph.node_size() == 0) {\n    LOG(WARNING) << \"cost_graph is empty: nothing can be inferred!\";\n  }\n  std::unordered_map<string, const CostGraphDef::Node*> name_to_cost;\n  std::unordered_map<string, const NodeDef*> name_to_node;  // Empty\n  for (auto& node : cost_graph.node()) {\n    name_to_cost[node.name()] = &node;\n\n    std::vector<OpInfo::TensorProperties> output_properties;\n    for (const auto& out : node.output_info()) {\n      OpInfo::TensorProperties properties;\n      properties.set_dtype(out.dtype());\n      *properties.mutable_shape() = out.shape();\n      output_properties.push_back(properties);\n    }\n    output_properties_[node.name()] = output_properties;\n  }\n\n  for (const auto& node : item_.graph.node()) {\n    // Skip the nodes that are not in the cost graph: these are nodes that\n    // aren't run, because they aren't in the intersection of transitive fan-in\n    // of a fetch node and the transitive fan-out of an input, or nodes that\n    // were optimized away by the optimizer.\n    auto it = name_to_cost.find(node.name());\n    if (it == name_to_cost.end()) {\n      continue;\n    }\n    std::vector<OpInfo::TensorProperties> inputs =\n        FindInputFeatures(node, name_to_cost, name_to_node);\n\n    input_properties_[node.name()] = inputs;\n  }\n  return Status::OK();\n}\n\nbool GraphProperties::HasInputProperties(const string& node_name) const {\n  return input_properties_.find(node_name) != input_properties_.end();\n}\n\nbool GraphProperties::HasOutputProperties(const string& node_name) const {\n  return output_properties_.find(node_name) != output_properties_.end();\n}\n\nconst std::vector<OpInfo::TensorProperties>&\nGraphProperties::GetInputProperties(const string& node_name) const {\n  auto it = input_properties_.find(node_name);\n  if (it != input_properties_.end()) {\n    return it->second;\n  }\n  return missing_properties_;\n}\n\nconst std::vector<OpInfo::TensorProperties>&\nGraphProperties::GetOutputProperties(const string& node_name) const {\n  auto it = output_properties_.find(node_name);\n  if (it != output_properties_.end()) {\n    return it->second;\n  }\n  return missing_properties_;\n}\n\nvoid GraphProperties::ClearInputProperties(const string& node_name) {\n  input_properties_.erase(node_name);\n}\nvoid GraphProperties::ClearOutputProperties(const string& node_name) {\n  output_properties_.erase(node_name);\n}\n\n}  // end namespace grappler\n}  // end namespace tensorflow"