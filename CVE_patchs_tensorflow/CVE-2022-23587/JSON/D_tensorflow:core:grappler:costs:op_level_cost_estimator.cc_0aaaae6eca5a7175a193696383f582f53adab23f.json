"diff --git a/tensorflow/core/grappler/costs/op_level_cost_estimator.cc b/tensorflow/core/grappler/costs/op_level_cost_estimator.cc\nindex 640a530bf08..6e516e2a686 100644\n--- a/tensorflow/core/grappler/costs/op_level_cost_estimator.cc\n+++ b/tensorflow/core/grappler/costs/op_level_cost_estimator.cc\n@@ -2681,27 +2681,42 @@ Status OpLevelCostEstimator::PredictCropAndResize(const OpContext& op_context,\n   // calculation differs from rough estimate in implementation, as it separates\n   // out cost per box from cost per pixel and cost per element.\n \n+  // Since crop arguments are user controlled, check for overflow.\n+  int64_t crop_area = MultiplyWithoutOverflow(crop_height, crop_width);\n+  if (crop_area < 0)\n+    return errors::InvalidArgument(\"Cannot estimate cost, multiplying \",\n+                                   crop_height, \" with \", crop_width,\n+                                   \" would overflow\");\n+  int64_t crop_volume = MultiplyWithoutOverflow(crop_area, num_boxes);\n+  if (crop_volume < 0)\n+    return errors::InvalidArgument(\"Cannot estimate cost, multiplying \",\n+                                   crop_area, \" with \", num_boxes,\n+                                   \" would overflow\");\n+  int64_t crop_depth = MultiplyWithoutOverflow(crop_height, num_boxes);\n+  if (crop_depth < 0)\n+    return errors::InvalidArgument(\"Cannot estimate cost, multiplying \",\n+                                   crop_height, \" with \", num_boxes,\n+                                   \" would overflow\");\n+\n   // Ops for variables height_scale and width_scale.\n   int64_t ops = (sub_cost * 6 + mul_cost * 2 + div_cost * 2) * num_boxes;\n   // Ops for variable in_y.\n-  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * num_boxes;\n+  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_depth;\n   // Ops for variable in_x (same computation across both branches).\n-  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * crop_width *\n-         num_boxes;\n+  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_volume;\n   // Specify op_cost based on the method.\n   if (use_bilinear_interp) {\n     // Ops for variables top_y_index, bottom_y_index, y_lerp.\n-    ops += (floor_cost + ceil_cost + sub_cost) * crop_height * num_boxes;\n+    ops += (floor_cost + ceil_cost + sub_cost) * crop_depth;\n     // Ops for variables left_x, right_x, x_lerp;\n-    ops += (floor_cost + ceil_cost + sub_cost) * crop_height * crop_width *\n-           num_boxes;\n+    ops += (floor_cost + ceil_cost + sub_cost) * crop_volume;\n     // Ops for innermost loop across depth.\n     ops +=\n         (cast_to_float_cost * 4 + add_cost * 3 + sub_cost * 3 + mul_cost * 3) *\n         output_elements;\n   } else /* method == \"nearest\" */ {\n     // Ops for variables closest_x_index and closest_y_index.\n-    ops += round_cost * 2 * crop_height * crop_width * num_boxes;\n+    ops += round_cost * 2 * crop_volume;\n     // Ops for innermost loop across depth.\n     ops += cast_to_float_cost * output_elements;\n   }"