"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/data_flow_ops.cc.\n\n#include <limits.h>\n\n#include <vector>\n\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/map_util.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\n\nclass GetSessionHandleOp : public OpKernel {\n public:\n  explicit GetSessionHandleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionHandle called on null session state\"));\n    int64_t id = session_state->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      // Legacy behavior in V1.\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(GetSessionHandleOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionHandle\").Device(DEVICE_CPU),\n                        GetSessionHandleOp);\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionHandleV2\").Device(DEVICE_CPU),\n                        GetSessionHandleOp);\n\n#define REGISTER_DEFAULT_KERNEL(type)                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionHandle\")        \\\n                              .Device(DEVICE_DEFAULT)     \\\n                              .HostMemory(\"handle\")       \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          GetSessionHandleOp)             \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionHandleV2\")      \\\n                              .Device(DEVICE_DEFAULT)     \\\n                              .HostMemory(\"handle\")       \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          GetSessionHandleOp)\n\nTF_CALL_NUMBER_TYPES(REGISTER_DEFAULT_KERNEL);\nREGISTER_DEFAULT_KERNEL(bool);\n#undef REGISTER_DEFAULT_KERNEL\n\nclass GetSessionTensorOp : public OpKernel {\n public:\n  explicit GetSessionTensorOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument(\"handle must be scalar\"));\n    const string& name = handle.scalar<tstring>()();\n    Tensor val;\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->GetTensor(name, &val));\n    ctx->set_output(0, val);\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(GetSessionTensorOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"GetSessionTensor\").Device(DEVICE_CPU),\n                        GetSessionTensorOp);\n\n#define REGISTER_DEFAULT_KERNEL(type)                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"GetSessionTensor\")            \\\n                              .Device(DEVICE_DEFAULT)         \\\n                              .HostMemory(\"handle\")           \\\n                              .TypeConstraint<type>(\"dtype\"), \\\n                          GetSessionTensorOp)\n\nTF_CALL_NUMBER_TYPES(REGISTER_DEFAULT_KERNEL);\nREGISTER_DEFAULT_KERNEL(bool);\n#undef REGISTER_DEFAULT_KERNEL\n\nclass DeleteSessionTensorOp : public OpKernel {\n public:\n  explicit DeleteSessionTensorOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(DeleteSessionTensorOp);\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"DeleteSessionTensor\").Device(DEVICE_CPU),\n                        DeleteSessionTensorOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"DeleteSessionTensor\").Device(DEVICE_DEFAULT).HostMemory(\"handle\"),\n    DeleteSessionTensorOp);\n\n}  // namespace tensorflow"