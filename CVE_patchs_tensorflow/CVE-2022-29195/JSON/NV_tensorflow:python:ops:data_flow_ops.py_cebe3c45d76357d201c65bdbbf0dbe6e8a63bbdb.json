"# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#==============================================================================\n\"\"\"Data Flow Operations.\"\"\"\n# pylint: disable=g-bad-name\nimport functools\nimport hashlib\nimport threading\n\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import dtypes as _dtypes\nfrom tensorflow.python.framework import indexed_slices\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import random_seed\nfrom tensorflow.python.framework import tensor_shape\nfrom tensorflow.python.framework import tensor_util\nfrom tensorflow.python.lib.io import python_io\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import gen_data_flow_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import resource_variable_ops\n# go/tf-wildcard-import\n# pylint: disable=wildcard-import\nfrom tensorflow.python.ops.gen_data_flow_ops import *\nfrom tensorflow.python.util import deprecation\nfrom tensorflow.python.util.compat import collections_abc\nfrom tensorflow.python.util.tf_export import tf_export\n\n# pylint: enable=wildcard-import\n\n\ndef _as_type_list(dtypes):\n  \"\"\"Convert dtypes to a list of types.\"\"\"\n  assert dtypes is not None\n  if not (isinstance(dtypes, list) or isinstance(dtypes, tuple)):\n    # We have a single type.\n    return [dtypes]\n  else:\n    # We have a list or tuple of types.\n    return list(dtypes)\n\n\ndef _as_shape_list(shapes,\n                   dtypes,\n                   unknown_dim_allowed=False,\n                   unknown_rank_allowed=False):\n  \"\"\"Convert shapes to a list of tuples of int (or None).\"\"\"\n  del dtypes\n  if unknown_dim_allowed:\n    if (not isinstance(shapes, collections_abc.Sequence) or not shapes or\n        any(shape is None or isinstance(shape, int) for shape in shapes)):\n      raise ValueError(\n          \"When providing partial shapes, a list of shapes must be provided.\")\n  if shapes is None:\n    return None\n  if isinstance(shapes, tensor_shape.TensorShape):\n    shapes = [shapes]\n  if not isinstance(shapes, (tuple, list)):\n    raise TypeError(\n        \"Shapes must be a TensorShape or a list or tuple of TensorShapes, \"\n        f\"got {type(shapes)} instead.\")\n  if all(shape is None or isinstance(shape, int) for shape in shapes):\n    # We have a single shape.\n    shapes = [shapes]\n  shapes = [tensor_shape.as_shape(shape) for shape in shapes]\n  if not unknown_dim_allowed:\n    if any(not shape.is_fully_defined() for shape in shapes):\n      raise ValueError(f\"All shapes must be fully defined: {shapes}\")\n  if not unknown_rank_allowed:\n    if any(shape.dims is None for shape in shapes):\n      raise ValueError(f\"All shapes must have a defined rank: {shapes}\")\n\n  return shapes\n\n\ndef _as_name_list(names, dtypes):\n  if names is None:\n    return None\n  if not isinstance(names, (list, tuple)):\n    names = [names]\n  if len(names) != len(dtypes):\n    raise ValueError(\"List of names must have the same length as the list \"\n                     f\"of dtypes, received len(names)={len(names)},\"\n                     f\"len(dtypes)={len(dtypes)}\")\n  return list(names)\n\n\ndef _shape_common(s1, s2):\n  \"\"\"The greatest lower bound (ordered by specificity) TensorShape.\"\"\"\n  s1 = tensor_shape.TensorShape(s1)\n  s2 = tensor_shape.TensorShape(s2)\n  if s1.ndims is None or s2.ndims is None or s1.ndims != s2.ndims:\n    return tensor_shape.unknown_shape()\n  d = [\n      d1 if d1 is not None and d1 == d2 else None\n      for (d1, d2) in zip(s1.as_list(), s2.as_list())\n  ]\n  return tensor_shape.TensorShape(d)\n\n\n# pylint: disable=protected-access\n@tf_export(\"queue.QueueBase\",\n           v1=[\"queue.QueueBase\", \"io.QueueBase\", \"QueueBase\"])\n@deprecation.deprecated_endpoints([\"io.QueueBase\", \"QueueBase\"])\nclass QueueBase:\n  \"\"\"Base class for queue implementations.\n\n  A queue is a TensorFlow data structure that stores tensors across\n  multiple steps, and exposes operations that enqueue and dequeue\n  tensors.\n\n  Each queue element is a tuple of one or more tensors, where each\n  tuple component has a static dtype, and may have a static shape. The\n  queue implementations support versions of enqueue and dequeue that\n  handle single elements, versions that support enqueuing and\n  dequeuing a batch of elements at once.\n\n  See `tf.queue.FIFOQueue` and\n  `tf.queue.RandomShuffleQueue` for concrete\n  implementations of this class, and instructions on how to create\n  them.\n  \"\"\"\n\n  def __init__(self, dtypes, shapes, names, queue_ref):\n    \"\"\"Constructs a queue object from a queue reference.\n\n    The two optional lists, `shapes` and `names`, must be of the same length\n    as `dtypes` if provided.  The values at a given index `i` indicate the\n    shape and name to use for the corresponding queue component in `dtypes`.\n\n    Args:\n      dtypes:  A list of types.  The length of dtypes must equal the number\n        of tensors in each element.\n      shapes: Constraints on the shapes of tensors in an element:\n        A list of shape tuples or None. This list is the same length\n        as dtypes.  If the shape of any tensors in the element are constrained,\n        all must be; shapes can be None if the shapes should not be constrained.\n      names: Optional list of names.  If provided, the `enqueue()` and\n        `dequeue()` methods will use dictionaries with these names as keys.\n        Must be None or a list or tuple of the same length as `dtypes`.\n      queue_ref: The queue reference, i.e. the output of the queue op.\n\n    Raises:\n      ValueError: If one of the arguments is invalid.\n    \"\"\"\n    self._dtypes = dtypes\n    if shapes is not None:\n      if len(shapes) != len(dtypes):\n        raise ValueError(\"Queue shapes must have the same length as dtypes, \"\n                         f\"received len(shapes)={len(shapes)}, \"\n                         f\"len(dtypes)={len(dtypes)}\")\n      self._shapes = [tensor_shape.TensorShape(s) for s in shapes]\n    else:\n      self._shapes = [tensor_shape.unknown_shape() for _ in self._dtypes]\n    if names is not None:\n      if len(names) != len(dtypes):\n        raise ValueError(\"Queue names must have the same length as dtypes,\"\n                         f\"received len(names)={len(names)},\"\n                         f\"len {len(dtypes)}\")\n      self._names = names\n    else:\n      self._names = None\n    self._queue_ref = queue_ref\n    if isinstance(queue_ref, ops.EagerTensor):\n      if context.context().scope_name:\n        self._name = context.context().scope_name\n      else:\n        self._name = \"Empty\"\n      self._resource_deleter = resource_variable_ops.EagerResourceDeleter(\n          queue_ref, None)\n    else:\n      self._name = self._queue_ref.op.name.split(\"/\")[-1]\n\n  @staticmethod\n  def from_list(index, queues):\n    \"\"\"Create a queue using the queue reference from `queues[index]`.\n\n    Args:\n      index: An integer scalar tensor that determines the input that gets\n        selected.\n      queues: A list of `QueueBase` objects.\n\n    Returns:\n      A `QueueBase` object.\n\n    Raises:\n      TypeError: When `queues` is not a list of `QueueBase` objects,\n        or when the data types of `queues` are not all the same.\n    \"\"\"\n    if ((not queues) or (not isinstance(queues, list)) or\n        (not all(isinstance(x, QueueBase) for x in queues))):\n      raise TypeError(\"A list of queues expected\")\n\n    dtypes = queues[0].dtypes\n    if not all(dtypes == q.dtypes for q in queues[1:]):\n      raise TypeError(\"Queues do not have matching component dtypes.\")\n\n    names = queues[0].names\n    if not all(names == q.names for q in queues[1:]):\n      raise TypeError(\"Queues do not have matching component names.\")\n\n    queue_shapes = [q.shapes for q in queues]\n    reduced_shapes = [\n        functools.reduce(_shape_common, s) for s in zip(*queue_shapes)\n    ]\n\n    queue_refs = array_ops.stack([x.queue_ref for x in queues])\n    selected_queue = array_ops.gather(queue_refs, index)\n    return QueueBase(\n        dtypes=dtypes,\n        shapes=reduced_shapes,\n        names=names,\n        queue_ref=selected_queue)\n\n  @property\n  def queue_ref(self):\n    \"\"\"The underlying queue reference.\"\"\"\n    return self._queue_ref\n\n  @property\n  def name(self):\n    \"\"\"The name of the underlying queue.\"\"\"\n    if context.executing_eagerly():\n      return self._name\n    return self._queue_ref.op.name\n\n  @property\n  def dtypes(self):\n    \"\"\"The list of dtypes for each component of a queue element.\"\"\"\n    return self._dtypes\n\n  @property\n  def shapes(self):\n    \"\"\"The list of shapes for each component of a queue element.\"\"\"\n    return self._shapes\n\n  @property\n  def names(self):\n    \"\"\"The list of names for each component of a queue element.\"\"\"\n    return self._names\n\n  def _check_enqueue_dtypes(self, vals):\n    \"\"\"Validate and convert `vals` to a list of `Tensor`s.\n\n    The `vals` argument can be a Tensor, a list or tuple of tensors, or a\n    dictionary with tensor values.\n\n    If it is a dictionary, the queue must have been constructed with a\n    `names` attribute and the dictionary keys must match the queue names.\n    If the queue was constructed with a `names` attribute, `vals` must\n    be a dictionary.\n\n    Args:\n      vals: A tensor, a list or tuple of tensors, or a dictionary..\n\n    Returns:\n      A list of `Tensor` objects.\n\n    Raises:\n      ValueError: If `vals` is invalid.\n    \"\"\"\n    if isinstance(vals, dict):\n      if not self._names:\n        raise ValueError(\"Queue must have names to enqueue a dictionary\")\n      if sorted(self._names, key=str) != sorted(vals.keys(), key=str):\n        raise ValueError(\"Keys in dictionary to enqueue do not match \"\n                         f\"names of Queue.  Dictionary: {sorted(vals.keys())},\"\n                         f\"Queue: {sorted(self._names)}\")\n      # The order of values in `self._names` indicates the order in which the\n      # tensors in the dictionary `vals` must be listed.\n      vals = [vals[k] for k in self._names]\n    else:\n      if self._names:\n        raise ValueError(\"You must enqueue a dictionary in a Queue with names\")\n      if not isinstance(vals, (list, tuple)):\n        vals = [vals]\n\n    tensors = []\n    for i, (val, dtype) in enumerate(zip(vals, self._dtypes)):\n      tensors.append(\n          ops.convert_to_tensor(val, dtype=dtype, name=\"component_%d\" % i))\n\n    return tensors\n\n  def _scope_vals(self, vals):\n    \"\"\"Return a list of values to pass to `name_scope()`.\n\n    Args:\n      vals: A tensor, a list or tuple of tensors, or a dictionary.\n\n    Returns:\n      The values in vals as a list.\n    \"\"\"\n    if isinstance(vals, (list, tuple)):\n      return vals\n    elif isinstance(vals, dict):\n      return vals.values()\n    else:\n      return [vals]\n\n  def enqueue(self, vals, name=None):\n    \"\"\"Enqueues one element to this queue.\n\n    If the queue is full when this operation executes, it will block\n    until the element has been enqueued.\n\n    At runtime, this operation may raise an error if the queue is\n    `tf.QueueBase.close` before or during its execution. If the\n    queue is closed before this operation runs,\n    `tf.errors.CancelledError` will be raised. If this operation is\n    blocked, and either (i) the queue is closed by a close operation\n    with `cancel_pending_enqueues=True`, or (ii) the session is\n    `tf.Session.close`,\n    `tf.errors.CancelledError` will be raised.\n\n    Args:\n      vals: A tensor, a list or tuple of tensors, or a dictionary containing\n        the values to enqueue.\n      name: A name for the operation (optional).\n\n    Returns:\n      The operation that enqueues a new tuple of tensors to the queue.\n    \"\"\"\n    with ops.name_scope(name, \"%s_enqueue\" % self._name,\n                        self._scope_vals(vals)) as scope:\n      vals = self._check_enqueue_dtypes(vals)\n\n      # NOTE(mrry): Not using a shape function because we need access to\n      # the `QueueBase` object.\n      for val, shape in zip(vals, self._shapes):\n        val.get_shape().assert_is_compatible_with(shape)\n\n      if self._queue_ref.dtype == _dtypes.resource:\n        return gen_data_flow_ops.queue_enqueue_v2(\n            self._queue_ref, vals, name=scope)\n      else:\n        return gen_data_flow_ops.queue_enqueue(\n            self._queue_ref, vals, name=scope)\n\n  def enqueue_many(self, vals, name=None):\n    \"\"\"Enqueues zero or more elements to this queue.\n\n    This operation slices each component tensor along the 0th dimension to\n    make multiple queue elements. All of the tensors in `vals` must have the\n    same size in the 0th dimension.\n\n    If the queue is full when this operation executes, it will block\n    until all of the elements have been enqueued.\n\n    At runtime, this operation may raise an error if the queue is\n    `tf.QueueBase.close` before or during its execution. If the\n    queue is closed before this operation runs,\n    `tf.errors.CancelledError` will be raised. If this operation is\n    blocked, and either (i) the queue is closed by a close operation\n    with `cancel_pending_enqueues=True`, or (ii) the session is\n    `tf.Session.close`,\n    `tf.errors.CancelledError` will be raised.\n\n    Args:\n      vals: A tensor, a list or tuple of tensors, or a dictionary\n        from which the queue elements are taken.\n      name: A name for the operation (optional).\n\n    Returns:\n      The operation that enqueues a batch of tuples of tensors to the queue.\n    \"\"\"\n    with ops.name_scope(name, \"%s_EnqueueMany\" % self._name,\n                        self._scope_vals(vals)) as scope:\n      vals = self._check_enqueue_dtypes(vals)\n\n      # NOTE(mrry): Not using a shape function because we need access to\n      # the `QueueBase` object.\n      # NOTE(fchollet): the code that follow is verbose because it needs to be\n      # compatible with both TF v1 TensorShape behavior and TF v2 behavior.\n      batch_dim = tensor_shape.dimension_value(\n          vals[0].get_shape().with_rank_at_least(1)[0])\n      batch_dim = tensor_shape.Dimension(batch_dim)\n      for val, shape in zip(vals, self._shapes):\n        val_batch_dim = tensor_shape.dimension_value(\n            val.get_shape().with_rank_at_least(1)[0])\n        val_batch_dim = tensor_shape.Dimension(val_batch_dim)\n        batch_dim = batch_dim.merge_with(val_batch_dim)\n        val.get_shape()[1:].assert_is_compatible_with(shape)\n\n      return gen_data_flow_ops.queue_enqueue_many_v2(\n          self._queue_ref, vals, name=scope)\n\n  def _dequeue_return_value(self, tensors):\n    \"\"\"Return the value to return from a dequeue op.\n\n    If the queue has names, return a dictionary with the\n    names as keys.  Otherwise return either a single tensor\n    or a list of tensors depending on the length of `tensors`.\n\n    Args:\n      tensors: List of tensors from the dequeue op.\n\n    Returns:\n      A single tensor, a list of tensors, or a dictionary\n      of tensors.\n    \"\"\"\n    if self._names:\n      # The returned values in `tensors` are in the same order as\n      # the names in `self._names`.\n      return {n: tensors[i] for i, n in enumerate(self._names)}\n    elif len(tensors) == 1:\n      return tensors[0]\n    else:\n      return tensors\n\n  def dequeue(self, name=None):\n    \"\"\"Dequeues one element from this queue.\n\n    If the queue is empty when this operation executes, it will block\n    until there is an element to dequeue.\n\n    At runtime, this operation may raise an error if the queue is\n    `tf.QueueBase.close` before or during its execution. If the\n    queue is closed, the queue is empty, and there are no pending\n    enqueue operations that can fulfill this request,\n    `tf.errors.OutOfRangeError` will be raised. If the session is\n    `tf.Session.close`,\n    `tf.errors.CancelledError` will be raised.\n\n    Args:\n      name: A name for the operation (optional).\n\n    Returns:\n      The tuple of tensors that was dequeued.\n    \"\"\"\n    if name is None:\n      name = \"%s_Dequeue\" % self._name\n    if self._queue_ref.dtype == _dtypes.resource:\n      ret = gen_data_flow_ops.queue_dequeue_v2(\n          self._queue_ref, self._dtypes, name=name)\n    else:\n      ret = gen_data_flow_ops.queue_dequeue(\n          self._queue_ref, self._dtypes, name=name)\n\n    # NOTE(mrry): Not using a shape function because we need access to\n    # the `QueueBase` object.\n    if not context.executing_eagerly():\n      op = ret[0].op\n      for output, shape in zip(op.values(), self._shapes):\n        output.set_shape(shape)\n\n    return self._dequeue_return_value(ret)\n\n  def dequeue_many(self, n, name=None):\n    \"\"\"Dequeues and concatenates `n` elements from this queue.\n\n    This operation concatenates queue-element component tensors along\n    the 0th dimension to make a single component tensor.  All of the\n    components in the dequeued tuple will have size `n` in the 0th dimension.\n\n    If the queue is closed and there are less than `n` elements left, then an\n    `OutOfRange` exception is raised.\n\n    At runtime, this operation may raise an error if the queue is\n    `tf.QueueBase.close` before or during its execution. If the\n    queue is closed, the queue contains fewer than `n` elements, and\n    there are no pending enqueue operations that can fulfill this\n    request, `tf.errors.OutOfRangeError` will be raised. If the\n    session is `tf.Session.close`,\n    `tf.errors.CancelledError` will be raised.\n\n    Args:\n      n: A scalar `Tensor` containing the number of elements to dequeue.\n      name: A name for the operation (optional).\n\n    Returns:\n      The list of concatenated tensors that was dequeued.\n    \"\"\"\n    if name is None:\n      name = \"%s_DequeueMany\" % self._name\n\n    ret = gen_data_flow_ops.queue_dequeue_many_v2(\n        self._queue_ref, n=n, component_types=self._dtypes, name=name)\n\n    # NOTE(mrry): Not using a shape function because we need access to\n    # the Queue object.\n    if not context.executing_eagerly():\n      op = ret[0].op\n      batch_dim = tensor_shape.Dimension(\n          tensor_util.constant_value(op.inputs[1]))\n      for output, shape in zip(op.values(), self._shapes):\n        output.set_shape(\n            tensor_shape.TensorShape([batch_dim]).concatenate(shape))\n\n    return self._dequeue_return_value(ret)\n\n  def dequeue_up_to(self, n, name=None):\n    \"\"\"Dequeues and concatenates `n` elements from this queue.\n\n    **Note** This operation is not supported by all queues.  If a queue does not\n    support DequeueUpTo, then a `tf.errors.UnimplementedError` is raised.\n\n    This operation concatenates queue-element component tensors along\n    the 0th dimension to make a single component tensor. If the queue\n    has not been closed, all of the components in the dequeued tuple\n    will have size `n` in the 0th dimension.\n\n    If the queue is closed and there are more than `0` but fewer than\n    `n` elements remaining, then instead of raising a\n    `tf.errors.OutOfRangeError` like `tf.QueueBase.dequeue_many`,\n    less than `n` elements are returned immediately.  If the queue is\n    closed and there are `0` elements left in the queue, then a\n    `tf.errors.OutOfRangeError` is raised just like in `dequeue_many`.\n    Otherwise the behavior is identical to `dequeue_many`.\n\n    Args:\n      n: A scalar `Tensor` containing the number of elements to dequeue.\n      name: A name for the operation (optional).\n\n    Returns:\n      The tuple of concatenated tensors that was dequeued.\n    \"\"\"\n    if name is None:\n      name = \"%s_DequeueUpTo\" % self._name\n\n    ret = gen_data_flow_ops.queue_dequeue_up_to_v2(\n        self._queue_ref, n=n, component_types=self._dtypes, name=name)\n\n    # NOTE(mrry): Not using a shape function because we need access to\n    # the Queue object.\n    if not context.executing_eagerly():\n      op = ret[0].op\n      for output, shape in zip(op.values(), self._shapes):\n        output.set_shape(tensor_shape.TensorShape([None]).concatenate(shape))\n\n    return self._dequeue_return_value(ret)\n\n  def close(self, cancel_pending_enqueues=False, name=None):\n    \"\"\"Closes this queue.\n\n    This operation signals that no more elements will be enqueued in\n    the given queue. Subsequent `enqueue` and `enqueue_many`\n    operations will fail. Subsequent `dequeue` and `dequeue_many`\n    operations will continue to succeed if sufficient elements remain\n    in the queue. Subsequently dequeue and dequeue_many operations\n    that would otherwise block waiting for more elements (if close\n    hadn't been called) will now fail immediately.\n\n    If `cancel_pending_enqueues` is `True`, all pending requests will also\n    be canceled.\n\n    Args:\n      cancel_pending_enqueues: (Optional.) A boolean, defaulting to\n        `False` (described above).\n      name: A name for the operation (optional).\n\n    Returns:\n      The operation that closes the queue.\n    \"\"\"\n    if name is None:\n      name = \"%s_Close\" % self._name\n    if self._queue_ref.dtype == _dtypes.resource:\n      return gen_data_flow_ops.queue_close_v2(\n          self._queue_ref,\n          cancel_pending_enqueues=cancel_pending_enqueues,\n          name=name)\n    else:\n      return gen_data_flow_ops.queue_close(\n          self._queue_ref,\n          cancel_pending_enqueues=cancel_pending_enqueues,\n          name=name)\n\n  def is_closed(self, name=None):\n    \"\"\"Returns true if queue is closed.\n\n    This operation returns true if the queue is closed and false if the queue\n    is open.\n\n    Args:\n      name: A name for the operation (optional).\n\n    Returns:\n      True if the queue is closed and false if the queue is open.\n    \"\"\"\n    if name is None:\n      name = \"%s_Is_Closed\" % self._name\n    if self._queue_ref.dtype == _dtypes.resource:\n      return gen_data_flow_ops.queue_is_closed_v2(self._queue_ref, name=name)\n    else:\n      return gen_data_flow_ops.queue_is_closed_(self._queue_ref, name=name)\n\n  def size(self, name=None):\n    \"\"\"Compute the number of elements in this queue.\n\n    Args:\n      name: A name for the operation (optional).\n\n    Returns:\n      A scalar tensor containing the number of elements in this queue.\n    \"\"\"\n    if name is None:\n      name = \"%s_Size\" % self._name\n    if self._queue_ref.dtype == _dtypes.resource:\n      return gen_data_flow_ops.queue_size_v2(self._queue_ref, name=name)\n    else:\n      return gen_data_flow_ops.queue_size(self._queue_ref, name=name)\n\ndef _shared_name(shared_name):\n  if context.executing_eagerly():\n    return str(ops.uid())\n  return shared_name\n\n\n@tf_export(\n    \"queue.RandomShuffleQueue\",\n    v1=[\"queue.RandomShuffleQueue\",\n        \"io.RandomShuffleQueue\", \"RandomShuffleQueue\"])\n@deprecation.deprecated_endpoints(\n    [\"io.RandomShuffleQueue\", \"RandomShuffleQueue\"])\nclass RandomShuffleQueue(QueueBase):\n  \"\"\"A queue implementation that dequeues elements in a random order.\n\n  See `tf.queue.QueueBase` for a description of the methods on\n  this class.\n  \"\"\"\n\n  def __init__(self,\n               capacity,\n               min_after_dequeue,\n               dtypes,\n               shapes=None,\n               names=None,\n               seed=None,\n               shared_name=None,\n               name=\"random_shuffle_queue\"):\n    \"\"\"Create a queue that dequeues elements in a random order.\n\n    A `RandomShuffleQueue` has bounded capacity; supports multiple\n    concurrent producers and consumers; and provides exactly-once\n    delivery.\n\n    A `RandomShuffleQueue` holds a list of up to `capacity`\n    elements. Each element is a fixed-length tuple of tensors whose\n    dtypes are described by `dtypes`, and whose shapes are optionally\n    described by the `shapes` argument.\n\n    If the `shapes` argument is specified, each component of a queue\n    element must have the respective fixed shape. If it is\n    unspecified, different queue elements may have different shapes,\n    but the use of `dequeue_many` is disallowed.\n\n    The `min_after_dequeue` argument allows the caller to specify a\n    minimum number of elements that will remain in the queue after a\n    `dequeue` or `dequeue_many` operation completes, to ensure a\n    minimum level of mixing of elements. This invariant is maintained\n    by blocking those operations until sufficient elements have been\n    enqueued. The `min_after_dequeue` argument is ignored after the\n    queue has been closed.\n\n    Args:\n      capacity: An integer. The upper bound on the number of elements\n        that may be stored in this queue.\n      min_after_dequeue: An integer (described above).\n      dtypes:  A list of `DType` objects. The length of `dtypes` must equal\n        the number of tensors in each queue element.\n      shapes: (Optional.) A list of fully-defined `TensorShape` objects\n        with the same length as `dtypes`, or `None`.\n      names: (Optional.) A list of string naming the components in the queue\n        with the same length as `dtypes`, or `None`.  If specified the dequeue\n        methods return a dictionary with the names as keys.\n      seed: A Python integer. Used to create a random seed. See\n        `tf.compat.v1.set_random_seed`\n        for behavior.\n      shared_name: (Optional.) If non-empty, this queue will be shared under\n        the given name across multiple sessions.\n      name: Optional name for the queue operation.\n    \"\"\"\n    dtypes = _as_type_list(dtypes)\n    shapes = _as_shape_list(shapes, dtypes)\n    names = _as_name_list(names, dtypes)\n    seed1, seed2 = random_seed.get_seed(seed)\n    if seed1 is None and seed2 is None:\n      seed1, seed2 = 0, 0\n    elif seed is None and shared_name is not None:\n      # This means that graph seed is provided but op seed is not provided.\n      # If shared_name is also provided, make seed2 depend only on the graph\n      # seed and shared_name. (seed2 from get_seed() is generally dependent on\n      # the id of the last op created.)\n      string = (str(seed1) + shared_name).encode(\"utf-8\")\n      seed2 = int(hashlib.md5(string).hexdigest()[:8], 16) & 0x7FFFFFFF\n    queue_ref = gen_data_flow_ops.random_shuffle_queue_v2(\n        component_types=dtypes,\n        shapes=shapes,\n        capacity=capacity,\n        min_after_dequeue=min_after_dequeue,\n        seed=seed1,\n        seed2=seed2,\n        shared_name=_shared_name(shared_name),\n        name=name)\n\n    super(RandomShuffleQueue, self).__init__(dtypes, shapes, names, queue_ref)\n\n\n@tf_export(\"queue.FIFOQueue\", v1=[\"queue.FIFOQueue\", \"FIFOQueue\"])\n@deprecation.deprecated_endpoints(\"FIFOQueue\")\nclass FIFOQueue(QueueBase):\n  \"\"\"A queue implementation that dequeues elements in first-in first-out order.\n\n  See `tf.queue.QueueBase` for a description of the methods on\n  this class.\n  \"\"\"\n\n  def __init__(self,\n               capacity,\n               dtypes,\n               shapes=None,\n               names=None,\n               shared_name=None,\n               name=\"fifo_queue\"):\n    \"\"\"Creates a queue that dequeues elements in a first-in first-out order.\n\n    A `FIFOQueue` has bounded capacity; supports multiple concurrent\n    producers and consumers; and provides exactly-once delivery.\n\n    A `FIFOQueue` holds a list of up to `capacity` elements. Each\n    element is a fixed-length tuple of tensors whose dtypes are\n    described by `dtypes`, and whose shapes are optionally described\n    by the `shapes` argument.\n\n    If the `shapes` argument is specified, each component of a queue\n    element must have the respective fixed shape. If it is\n    unspecified, different queue elements may have different shapes,\n    but the use of `dequeue_many` is disallowed.\n\n    Args:\n      capacity: An integer. The upper bound on the number of elements\n        that may be stored in this queue.\n      dtypes:  A list of `DType` objects. The length of `dtypes` must equal\n        the number of tensors in each queue element.\n      shapes: (Optional.) A list of fully-defined `TensorShape` objects\n        with the same length as `dtypes`, or `None`.\n      names: (Optional.) A list of string naming the components in the queue\n        with the same length as `dtypes`, or `None`.  If specified the dequeue\n        methods return a dictionary with the names as keys.\n      shared_name: (Optional.) If non-empty, this queue will be shared under\n        the given name across multiple sessions.\n      name: Optional name for the queue operation.\n    \"\"\"\n    dtypes = _as_type_list(dtypes)\n    shapes = _as_shape_list(shapes, dtypes)\n    names = _as_name_list(names, dtypes)\n    with ops.init_scope(), ops.device(\"CPU\"):\n      queue_ref = gen_data_flow_ops.fifo_queue_v2(\n          component_types=dtypes,\n          shapes=shapes,\n          capacity=capacity,\n          shared_name=_shared_name(shared_name),\n          name=name)\n\n    super(FIFOQueue, self).__init__(dtypes, shapes, names, queue_ref)\n\n\n# TODO(allenl): If GPU-compatible queues turn out to be useful, we should\n# implement GPU kernels for EnqueueMany and DequeueMany so we can make the\n# public FIFOQueue GPU-compatible and remove this internal version.\nclass GPUCompatibleFIFOQueue(QueueBase):\n  \"\"\"A queue implementation that dequeues elements in first-in first-out order.\n\n  GPUCompatibleFIFOQueue is like FIFOQueue, but the queue resource may be placed\n  either on a CPU or on a GPU. It is not cross-device: enqueues and dequeues\n  will be colocated with the queue resource. GPUCompatibleFIFOQueue only\n  supports enqueue and dequeue at the moment, not enqueue_many or dequeue_many.\n\n  See `tf.queue.QueueBase` for a description of the methods on this class.\n  \"\"\"\n\n  def __init__(self,\n               capacity,\n               dtypes,\n               shapes=None,\n               names=None,\n               shared_name=None,\n               name=\"fifo_queue\"):\n    \"\"\"Creates a queue that dequeues elements in a first-in first-out order.\n\n    A `FIFOQueue` has bounded capacity; supports multiple concurrent\n    producers and consumers; and provides exactly-once delivery.\n\n    A `FIFOQueue` holds a list of up to `capacity` elements. Each\n    element is a fixed-length tuple of tensors whose dtypes are\n    described by `dtypes`, and whose shapes are optionally described\n    by the `shapes` argument.\n\n    If the `shapes` argument is specified, each component of a queue\n    element must have the respective fixed shape. If it is\n    unspecified, different queue elements may have different shapes,\n    but the use of `dequeue_many` is disallowed.\n\n    Args:\n      capacity: An integer. The upper bound on the number of elements\n        that may be stored in this queue.\n      dtypes:  A list of `DType` objects. The length of `dtypes` must equal\n        the number of tensors in each queue element.\n      shapes: (Optional.) A list of fully-defined `TensorShape` objects\n        with the same length as `dtypes`, or `None`.\n      names: (Optional.) A list of string naming the components in the queue\n        with the same length as `dtypes`, or `None`.  If specified the dequeue\n        methods return a dictionary with the names as keys.\n      shared_name: (Optional.) If non-empty, this queue will be shared under\n        the given name across multiple sessions.\n      name: Optional name for the queue operation.\n    \"\"\"\n    dtypes = _as_type_list(dtypes)\n    shapes = _as_shape_list(shapes, dtypes)\n    names = _as_name_list(names, dtypes)\n    with ops.init_scope():\n      queue_ref = gen_data_flow_ops.fifo_queue_v2(\n          component_types=dtypes,\n          shapes=shapes,\n          capacity=capacity,\n          shared_name=_shared_name(shared_name),\n          name=name)\n\n    super(GPUCompatibleFIFOQueue, self).__init__(\n        dtypes, shapes, names, queue_ref)\n\n  def enqueue_many(self, vals, name=None):\n    \"\"\"enqueue_many is not supported on GPUCompatibleFIFOQueue.\"\"\"\n    raise NotImplementedError(\n        \"GPUCompatibleFIFOQueue does not support enqueue_many or dequeue_many, \"\n        \"only enqueue and dequeue.\")\n\n  def dequeue_many(self, n, name=None):\n    \"\"\"dequeue_many is not supported on GPUCompatibleFIFOQueue.\"\"\"\n    raise NotImplementedError(\n        \"GPUCompatibleFIFOQueue does not support enqueue_many or dequeue_many, \"\n        \"only enqueue and dequeue.\")\n\n\n@tf_export(\n    \"queue.PaddingFIFOQueue\",\n    v1=[\"queue.PaddingFIFOQueue\", \"io.PaddingFIFOQueue\", \"PaddingFIFOQueue\"])\n@deprecation.deprecated_endpoints([\"io.PaddingFIFOQueue\", \"PaddingFIFOQueue\"])\nclass PaddingFIFOQueue(QueueBase):\n  \"\"\"A FIFOQueue that supports batching variable-sized tensors by padding.\n\n  A `PaddingFIFOQueue` may contain components with dynamic shape, while also\n  supporting `dequeue_many`.  See the constructor for more details.\n\n  See `tf.queue.QueueBase` for a description of the methods on\n  this class.\n  \"\"\"\n\n  def __init__(self,\n               capacity,\n               dtypes,\n               shapes,\n               names=None,\n               shared_name=None,\n               name=\"padding_fifo_queue\"):\n    \"\"\"Creates a queue that dequeues elements in a first-in first-out order.\n\n    A `PaddingFIFOQueue` has bounded capacity; supports multiple concurrent\n    producers and consumers; and provides exactly-once delivery.\n\n    A `PaddingFIFOQueue` holds a list of up to `capacity` elements. Each\n    element is a fixed-length tuple of tensors whose dtypes are\n    described by `dtypes`, and whose shapes are described by the `shapes`\n    argument.\n\n    The `shapes` argument must be specified; each component of a queue\n    element must have the respective shape.  Shapes of fixed\n    rank but variable size are allowed by setting any shape dimension to None.\n    In this case, the inputs' shape may vary along the given dimension, and\n    `dequeue_many` will pad the given dimension with zeros up to the maximum\n    shape of all elements in the given batch.\n\n    Args:\n      capacity: An integer. The upper bound on the number of elements\n        that may be stored in this queue.\n      dtypes:  A list of `DType` objects. The length of `dtypes` must equal\n        the number of tensors in each queue element.\n      shapes: A list of `TensorShape` objects, with the same length as\n        `dtypes`.  Any dimension in the `TensorShape` containing value\n        `None` is dynamic and allows values to be enqueued with\n         variable size in that dimension.\n      names: (Optional.) A list of string naming the components in the queue\n        with the same length as `dtypes`, or `None`.  If specified the dequeue\n        methods return a dictionary with the names as keys.\n      shared_name: (Optional.) If non-empty, this queue will be shared under\n        the given name across multiple sessions.\n      name: Optional name for the queue operation.\n\n    Raises:\n      ValueError: If shapes is not a list of shapes, or the lengths of dtypes\n        and shapes do not match, or if names is specified and the lengths of\n        dtypes and names do not match.\n    \"\"\"\n    dtypes = _as_type_list(dtypes)\n    shapes = _as_shape_list(shapes, dtypes, unknown_dim_allowed=True)\n    names = _as_name_list(names, dtypes)\n    if len(dtypes) != len(shapes):\n      raise ValueError(\"Shapes must be provided for all components, \"\n                       f\"but received {len(dtypes)} dtypes and \"\n                       f\"{len(shapes)} shapes.\")\n    queue_ref = gen_data_flow_ops.padding_fifo_queue_v2(\n        component_types=dtypes,\n        shapes=shapes,\n        capacity=capacity,\n        shared_name=_shared_name(shared_name),\n        name=name)\n\n    super(PaddingFIFOQueue, self).__init__(dtypes, shapes, names, queue_ref)\n\n\n@tf_export(\"queue.PriorityQueue\",\n           v1=[\"queue.PriorityQueue\", \"io.PriorityQueue\", \"PriorityQueue\"])\n@deprecation.deprecated_endpoints([\"io.PriorityQueue\", \"PriorityQueue\"])\nclass PriorityQueue(QueueBase):\n  \"\"\"A queue implementation that dequeues elements in prioritized order.\n\n  See `tf.queue.QueueBase` for a description of the methods on\n  this class.\n  \"\"\"\n\n  def __init__(self,\n               capacity,\n               types,\n               shapes=None,\n               names=None,\n               shared_name=None,\n               name=\"priority_queue\"):\n    \"\"\"Creates a queue that dequeues elements in a first-in first-out order.\n\n    A `PriorityQueue` has bounded capacity; supports multiple concurrent\n    producers and consumers; and provides exactly-once delivery.\n\n    A `PriorityQueue` holds a list of up to `capacity` elements. Each\n    element is a fixed-length tuple of tensors whose dtypes are\n    described by `types`, and whose shapes are optionally described\n    by the `shapes` argument.\n\n    If the `shapes` argument is specified, each component of a queue\n    element must have the respective fixed shape. If it is\n    unspecified, different queue elements may have different shapes,\n    but the use of `dequeue_many` is disallowed.\n\n    Enqueues and Dequeues to the `PriorityQueue` must include an additional\n    tuple entry at the beginning: the `priority`.  The priority must be\n    an int64 scalar (for `enqueue`) or an int64 vector (for `enqueue_many`).\n\n    Args:\n      capacity: An integer. The upper bound on the number of elements\n        that may be stored in this queue.\n      types:  A list of `DType` objects. The length of `types` must equal\n        the number of tensors in each queue element, except the first priority\n        element.  The first tensor in each element is the priority,\n        which must be type int64.\n      shapes: (Optional.) A list of fully-defined `TensorShape` objects,\n        with the same length as `types`, or `None`.\n      names: (Optional.) A list of strings naming the components in the queue\n        with the same length as `dtypes`, or `None`.  If specified, the dequeue\n        methods return a dictionary with the names as keys.\n      shared_name: (Optional.) If non-empty, this queue will be shared under\n        the given name across multiple sessions.\n      name: Optional name for the queue operation.\n    \"\"\"\n    types = _as_type_list(types)\n    shapes = _as_shape_list(shapes, types)\n\n    queue_ref = gen_data_flow_ops.priority_queue_v2(\n        component_types=types,\n        shapes=shapes,\n        capacity=capacity,\n        shared_name=_shared_name(shared_name),\n        name=name)\n\n    priority_dtypes = [_dtypes.int64] + types\n    priority_shapes = [()] + shapes if shapes else shapes\n\n    super(PriorityQueue, self).__init__(priority_dtypes, priority_shapes, names,\n                                        queue_ref)\n\n\n# TODO(josh11b): class BatchQueue(QueueBase):\n\n\nclass Barrier:\n  \"\"\"Represents a key-value map that persists across graph executions.\"\"\"\n\n  def __init__(self, types, shapes=None, shared_name=None, name=\"barrier\"):\n    \"\"\"Creates a barrier that persists across different graph executions.\n\n    A barrier represents a key-value map, where each key is a string, and\n    each value is a tuple of tensors.\n\n    At runtime, the barrier contains 'complete' and 'incomplete'\n    elements. A complete element has defined tensors for all\n    components of its value tuple, and may be accessed using\n    take_many. An incomplete element has some undefined components in\n    its value tuple, and may be updated using insert_many.\n\n    The barrier call `take_many` outputs values in a particular order.\n    First, it only outputs completed values.  Second, the order in which\n    completed values are returned matches the order in which their very\n    first component was inserted into the barrier.  So, for example, for this\n    sequence of insertions and removals:\n\n      barrier = Barrier((tf.string, tf.int32), shapes=((), ()))\n      barrier.insert_many(0, keys=[\"k1\", \"k2\"], values=[\"a\", \"b\"]).run()\n      barrier.insert_many(1, keys=[\"k1\"], values=[1]).run()\n      barrier.insert_many(0, keys=[\"k3\"], values=[\"c\"]).run()\n      barrier.insert_many(1, keys=[\"k3\"], values=[3]).run()\n      barrier.insert_many(1, keys=[\"k2\"], values=[2]).run()\n\n      (indices, keys, values) = barrier.take_many(2)\n      (indices_val, keys_val, values0_val, values1_val) =\n         session.run([indices, keys, values[0], values[1]])\n\n    The output will be (up to permutation of \"k1\" and \"k2\"):\n\n      indices_val == (-2**63, -2**63)\n      keys_val == (\"k1\", \"k2\")\n      values0_val == (\"a\", \"b\")\n      values1_val == (1, 2)\n\n    Note the key \"k2\" was inserted into the barrier before \"k3\".  Even though\n    \"k3\" was completed first, both are complete by the time\n    take_many is called.  As a result, \"k2\" is prioritized and \"k1\" and \"k2\"\n    are returned first.  \"k3\" remains in the barrier until the next execution\n    of `take_many`.  Since \"k1\" and \"k2\" had their first insertions into\n    the barrier together, their indices are the same (-2**63).  The index\n    of \"k3\" will be -2**63 + 1, because it was the next new inserted key.\n\n    Args:\n      types: A single dtype or a tuple of dtypes, corresponding to the\n        dtypes of the tensor elements that comprise a value in this barrier.\n      shapes: Optional. Constraints on the shapes of tensors in the values:\n        a single tensor shape tuple; a tuple of tensor shape tuples\n        for each barrier-element tuple component; or None if the shape should\n        not be constrained.\n      shared_name: Optional. If non-empty, this barrier will be shared under\n        the given name across multiple sessions.\n      name: Optional name for the barrier op.\n\n    Raises:\n      ValueError: If one of the `shapes` indicate no elements.\n    \"\"\"\n    self._types = _as_type_list(types)\n\n    if shapes is not None:\n      shapes = _as_shape_list(shapes, self._types)\n      self._shapes = [tensor_shape.TensorShape(s) for s in shapes]\n      for i, shape in enumerate(self._shapes):\n        if shape.num_elements() == 0:\n          raise ValueError(\"Empty tensors are not supported, but received \"\n                           f\"shape '{shape}' at index {i}\")\n    else:\n      self._shapes = [tensor_shape.unknown_shape() for _ in self._types]\n\n    self._barrier_ref = gen_data_flow_ops.barrier(\n        component_types=self._types,\n        shapes=self._shapes,\n        shared_name=shared_name,\n        name=name)\n    if context.executing_eagerly():\n      self._name = context.context().scope_name\n    else:\n      self._name = self._barrier_ref.op.name.split(\"/\")[-1]\n\n  @property\n  def barrier_ref(self):\n    \"\"\"Get the underlying barrier reference.\"\"\"\n    return self._barrier_ref\n\n  @property\n  def name(self):\n    \"\"\"The name of the underlying barrier.\"\"\"\n    if context.executing_eagerly():\n      return self._name\n    return self._barrier_ref.op.name\n\n  def insert_many(self, component_index, keys, values, name=None):\n    \"\"\"For each key, assigns the respective value to the specified component.\n\n    This operation updates each element at component_index.\n\n    Args:\n      component_index: The component of the value that is being assigned.\n      keys: A vector of keys, with length n.\n      values: An any-dimensional tensor of values, which are associated with the\n        respective keys. The first dimension must have length n.\n      name: Optional name for the op.\n\n    Returns:\n      The operation that performs the insertion.\n    Raises:\n      InvalidArgumentsError: If inserting keys and values without elements.\n    \"\"\"\n    if name is None:\n      name = \"%s_BarrierInsertMany\" % self._name\n    return gen_data_flow_ops.barrier_insert_many(\n        self._barrier_ref, keys, values, component_index, name=name)\n\n  def take_many(self,\n                num_elements,\n                allow_small_batch=False,\n                timeout=None,\n                name=None):\n    \"\"\"Takes the given number of completed elements from this barrier.\n\n    This operation concatenates completed-element component tensors along\n    the 0th dimension to make a single component tensor.\n\n    If barrier has no completed elements, this operation will block\n    until there are 'num_elements' elements to take.\n\n    TODO(b/25743580): the semantics of `allow_small_batch` are experimental\n    and may be extended to other cases in the future.\n\n    TODO(ebrevdo): If a take_many(allow_small_batch=True) is blocking\n    already when the barrier is closed, it will block for ever. Fix this\n    by using asynchronous operations.\n\n    Args:\n      num_elements: The number of elements to take.\n      allow_small_batch: If the barrier is closed, don't block if there are less\n        completed elements than requested, but instead return all available\n        completed elements.\n      timeout: This specifies the number of milliseconds to block\n        before returning with DEADLINE_EXCEEDED. (This option is not\n        supported yet.)\n      name: A name for the operation (optional).\n\n    Returns:\n      A tuple of (index, key, value_list).\n      \"index\" is a int64 tensor of length num_elements containing the\n        index of the insert_many call for which the very first component of\n        the given element was inserted into the Barrier, starting with\n        the value -2**63.  Note, this value is different from the\n        index of the insert_many call for which the element was completed.\n      \"key\" is a string tensor of length num_elements containing the keys.\n      \"value_list\" is a tuple of tensors, each one with size num_elements\n        in the 0th dimension for each component in the barrier's values.\n\n    \"\"\"\n    if name is None:\n      name = \"%s_BarrierTakeMany\" % self._name\n    ret = gen_data_flow_ops.barrier_take_many(\n        self._barrier_ref,\n        num_elements,\n        self._types,\n        allow_small_batch,\n        timeout,\n        name=name)\n\n    # NOTE(mrry): Not using a shape function because we need access to\n    # the Barrier object.\n    if not context.executing_eagerly():\n      op = ret[0].op\n      if allow_small_batch:\n        batch_dim = None\n      else:\n        batch_dim = tensor_shape.Dimension(\n            tensor_util.constant_value(op.inputs[1]))\n      op.outputs[0].set_shape(tensor_shape.TensorShape([batch_dim]))  # indices\n      op.outputs[1].set_shape(tensor_shape.TensorShape([batch_dim]))  # keys\n      for output, shape in zip(op.outputs[2:], self._shapes):  # value_list\n        output.set_shape(\n            tensor_shape.TensorShape([batch_dim]).concatenate(shape))\n\n    return ret\n\n  def close(self, cancel_pending_enqueues=False, name=None):\n    \"\"\"Closes this barrier.\n\n    This operation signals that no more new key values will be inserted in the\n    given barrier. Subsequent InsertMany operations with new keys will fail.\n    InsertMany operations that just complement already existing keys with other\n    components, will continue to succeed. Subsequent TakeMany operations will\n    continue to succeed if sufficient elements remain in the barrier. Subsequent\n    TakeMany operations that would block will fail immediately.\n\n    If `cancel_pending_enqueues` is `True`, all pending requests to the\n    underlying queue will also be canceled, and completing of already\n    started values is also not acceptable anymore.\n\n    Args:\n      cancel_pending_enqueues: (Optional.) A boolean, defaulting to\n        `False` (described above).\n      name: Optional name for the op.\n\n    Returns:\n      The operation that closes the barrier.\n    \"\"\"\n    if name is None:\n      name = \"%s_BarrierClose\" % self._name\n    return gen_data_flow_ops.barrier_close(\n        self._barrier_ref,\n        cancel_pending_enqueues=cancel_pending_enqueues,\n        name=name)\n\n  def ready_size(self, name=None):\n    \"\"\"Compute the number of complete elements in the given barrier.\n\n    Args:\n      name: A name for the operation (optional).\n\n    Returns:\n      A single-element tensor containing the number of complete elements in the\n      given barrier.\n    \"\"\"\n    if name is None:\n      name = \"%s_BarrierReadySize\" % self._name\n    return gen_data_flow_ops.barrier_ready_size(self._barrier_ref, name=name)\n\n  def incomplete_size(self, name=None):\n    \"\"\"Compute the number of incomplete elements in the given barrier.\n\n    Args:\n      name: A name for the operation (optional).\n\n    Returns:\n      A single-element tensor containing the number of incomplete elements in\n      the given barrier.\n    \"\"\"\n    if name is None:\n      name = \"%s_BarrierIncompleteSize\" % self._name\n    return gen_data_flow_ops.barrier_incomplete_size(\n        self._barrier_ref, name=name)\n\n\n@tf_export(v1=[\"ConditionalAccumulatorBase\"])\nclass ConditionalAccumulatorBase:\n  \"\"\"A conditional accumulator for aggregating gradients.\n\n  Up-to-date gradients (i.e., time step at which gradient was computed is\n  equal to the accumulator's time step) are added to the accumulator.\n\n  Extraction of the average gradient is blocked until the required number of\n  gradients has been accumulated.\n  \"\"\"\n\n  def __init__(self, dtype, shape, accumulator_ref):\n    \"\"\"Creates a new ConditionalAccumulator.\n\n    Args:\n      dtype: Datatype of the accumulated gradients.\n      shape: Shape of the accumulated gradients.\n      accumulator_ref: A handle to the conditional accumulator, created by sub-\n        classes\n    \"\"\"\n    self._dtype = dtype\n    if shape is not None:\n      self._shape = tensor_shape.TensorShape(shape)\n    else:\n      self._shape = tensor_shape.unknown_shape()\n    self._accumulator_ref = accumulator_ref\n    if context.executing_eagerly():\n      self._name = context.context().scope_name\n    else:\n      self._name = self._accumulator_ref.op.name.split(\"/\")[-1]\n\n  @property\n  def accumulator_ref(self):\n    \"\"\"The underlying accumulator reference.\"\"\"\n    return self._accumulator_ref\n\n  @property\n  def name(self):\n    \"\"\"The name of the underlying accumulator.\"\"\"\n    return self._name\n\n  @property\n  def dtype(self):\n    \"\"\"The datatype of the gradients accumulated by this accumulator.\"\"\"\n    return self._dtype\n\n  def num_accumulated(self, name=None):\n    \"\"\"Number of gradients that have currently been aggregated in accumulator.\n\n    Args:\n      name: Optional name for the operation.\n\n    Returns:\n      Number of accumulated gradients currently in accumulator.\n    \"\"\"\n    if name is None:\n      name = \"%s_NumAccumulated\" % self._name\n\n    return gen_data_flow_ops.resource_accumulator_num_accumulated(\n        self._accumulator_ref, name=name)\n\n  def set_global_step(self, new_global_step, name=None):\n    \"\"\"Sets the global time step of the accumulator.\n\n    The operation logs a warning if we attempt to set to a time step that is\n    lower than the accumulator's own time step.\n\n    Args:\n      new_global_step: Value of new time step. Can be a variable or a constant\n      name: Optional name for the operation.\n\n    Returns:\n      Operation that sets the accumulator's time step.\n    \"\"\"\n    return gen_data_flow_ops.resource_accumulator_set_global_step(\n        self._accumulator_ref,\n        math_ops.cast(ops.convert_to_tensor(new_global_step), _dtypes.int64),\n        name=name)\n\n\n@tf_export(v1=[\"ConditionalAccumulator\"])\nclass ConditionalAccumulator(ConditionalAccumulatorBase):\n  \"\"\"A conditional accumulator for aggregating gradients.\n\n  Up-to-date gradients (i.e., time step at which gradient was computed is\n  equal to the accumulator's time step) are added to the accumulator.\n\n  Extraction of the average gradient is blocked until the required number of\n  gradients has been accumulated.\n  \"\"\"\n\n  def __init__(self,\n               dtype,\n               shape=None,\n               shared_name=None,\n               name=\"conditional_accumulator\",\n               reduction_type=\"MEAN\"):\n    \"\"\"Creates a new ConditionalAccumulator.\n\n    Args:\n      dtype: Datatype of the accumulated gradients.\n      shape: Shape of the accumulated gradients.\n      shared_name: Optional. If non-empty, this accumulator will be shared under\n        the given name across multiple sessions.\n      name: Optional name for the accumulator.\n      reduction_type: Reduction type to use when taking the gradient.\n    \"\"\"\n    accumulator_ref = gen_data_flow_ops.resource_conditional_accumulator(\n        dtype=dtype,\n        shape=shape,\n        shared_name=shared_name,\n        name=name,\n        reduction_type=reduction_type)\n    if context.executing_eagerly():\n      self._resource_deleter = resource_variable_ops.EagerResourceDeleter(\n          handle=accumulator_ref, handle_device=context.context().device_name)\n\n    super(ConditionalAccumulator, self).__init__(dtype, shape, accumulator_ref)\n\n  def apply_grad(self, grad, local_step=0, name=None):\n    \"\"\"Attempts to apply a gradient to the accumulator.\n\n    The attempt is silently dropped if the gradient is stale, i.e., local_step\n    is less than the accumulator's global time step.\n\n    Args:\n      grad: The gradient tensor to be applied.\n      local_step: Time step at which the gradient was computed.\n      name: Optional name for the operation.\n\n    Returns:\n      The operation that (conditionally) applies a gradient to the accumulator.\n\n    Raises:\n      ValueError: If grad is of the wrong shape\n    \"\"\"\n    grad = ops.convert_to_tensor(grad, self._dtype)\n    grad.get_shape().assert_is_compatible_with(self._shape)\n    local_step = math_ops.cast(ops.convert_to_tensor(local_step), _dtypes.int64)\n\n    return gen_data_flow_ops.resource_accumulator_apply_gradient(\n        self._accumulator_ref, local_step=local_step, gradient=grad, name=name)\n\n  def take_grad(self, num_required, name=None):\n    \"\"\"Attempts to extract the average gradient from the accumulator.\n\n    The operation blocks until sufficient number of gradients have been\n    successfully applied to the accumulator.\n\n    Once successful, the following actions are also triggered:\n\n    - Counter of accumulated gradients is reset to 0.\n    - Aggregated gradient is reset to 0 tensor.\n    - Accumulator's internal time step is incremented by 1.\n\n    Args:\n      num_required: Number of gradients that needs to have been aggregated\n      name: Optional name for the operation\n\n    Returns:\n      A tensor holding the value of the average gradient.\n\n    Raises:\n      InvalidArgumentError: If num_required < 1\n    \"\"\"\n    out = gen_data_flow_ops.resource_accumulator_take_gradient(\n        self._accumulator_ref, num_required, dtype=self._dtype, name=name)\n    out.set_shape(self._shape)\n    return out\n\n\n@tf_export(\n    v1=[\"sparse.SparseConditionalAccumulator\", \"SparseConditionalAccumulator\"])\nclass SparseConditionalAccumulator(ConditionalAccumulatorBase):\n  \"\"\"A conditional accumulator for aggregating sparse gradients.\n\n  Sparse gradients are represented by `IndexedSlices`.\n\n  Up-to-date gradients (i.e., time step at which gradient was computed is\n  equal to the accumulator's time step) are added to the accumulator.\n\n  Extraction of the average gradient is blocked until the required number of\n  gradients has been accumulated.\n\n  Args:\n    dtype: Datatype of the accumulated gradients.\n    shape: Shape of the accumulated gradients.\n    shared_name: Optional. If non-empty, this accumulator will be shared under\n      the given name across multiple sessions.\n    name: Optional name for the accumulator.\n    reduction_type: Reduction type to use when taking the gradient.\n  \"\"\"\n\n  def __init__(self,\n               dtype,\n               shape=None,\n               shared_name=None,\n               name=\"sparse_conditional_accumulator\",\n               reduction_type=\"MEAN\"):\n    accumulator_ref = gen_data_flow_ops.sparse_conditional_accumulator(\n        dtype=dtype,\n        shape=shape,\n        shared_name=shared_name,\n        name=name,\n        reduction_type=reduction_type)\n    super(SparseConditionalAccumulator, self).__init__(dtype, shape,\n                                                       accumulator_ref)\n\n  def apply_indexed_slices_grad(self, grad, local_step=0, name=None):\n    \"\"\"Attempts to apply a gradient to the accumulator.\n\n    The attempt is silently dropped if the gradient is stale, i.e., `local_step`\n    is less than the accumulator's global time step.\n\n    Args:\n      grad: The gradient `IndexedSlices` to be applied.\n      local_step: Time step at which the gradient was computed.\n      name: Optional name for the operation.\n\n    Returns:\n      The operation that (conditionally) applies a gradient to the accumulator.\n\n    Raises:\n      InvalidArgumentError: If grad is of the wrong shape\n    \"\"\"\n    return self.apply_grad(\n        grad_indices=grad.indices,\n        grad_values=grad.values,\n        grad_shape=grad.dense_shape,\n        local_step=local_step,\n        name=name)\n\n  def apply_grad(self,\n                 grad_indices,\n                 grad_values,\n                 grad_shape=None,\n                 local_step=0,\n                 name=None):\n    \"\"\"Attempts to apply a sparse gradient to the accumulator.\n\n    The attempt is silently dropped if the gradient is stale, i.e., `local_step`\n    is less than the accumulator's global time step.\n\n    A sparse gradient is represented by its indices, values and possibly empty\n    or None shape. Indices must be a vector representing the locations of\n    non-zero entries in the tensor. Values are the non-zero slices of the\n    gradient, and must have the same first dimension as indices, i.e., the nnz\n    represented by indices and values must be consistent. Shape, if not empty or\n    None, must be consistent with the accumulator's shape (if also provided).\n\n    Example:\n      A tensor [[0, 0], [0, 1], [2, 3]] can be represented\n        indices: [1,2]\n        values: [[0,1],[2,3]]\n        shape: [3, 2]\n\n    Args:\n      grad_indices: Indices of the sparse gradient to be applied.\n      grad_values: Values of the sparse gradient to be applied.\n      grad_shape: Shape of the sparse gradient to be applied.\n      local_step: Time step at which the gradient was computed.\n      name: Optional name for the operation.\n\n    Returns:\n      The operation that (conditionally) applies a gradient to the accumulator.\n\n    Raises:\n      InvalidArgumentError: If grad is of the wrong shape\n    \"\"\"\n    local_step = math_ops.cast(ops.convert_to_tensor(local_step), _dtypes.int64)\n    return gen_data_flow_ops.sparse_accumulator_apply_gradient(\n        self._accumulator_ref,\n        local_step=local_step,\n        gradient_indices=math_ops.cast(grad_indices, _dtypes.int64),\n        gradient_values=grad_values,\n        gradient_shape=math_ops.cast(\n            [] if grad_shape is None else grad_shape, _dtypes.int64),\n        has_known_shape=(grad_shape is not None),\n        name=name)\n\n  def take_grad(self, num_required, name=None):\n    \"\"\"Attempts to extract the average gradient from the accumulator.\n\n    The operation blocks until sufficient number of gradients have been\n    successfully applied to the accumulator.\n\n    Once successful, the following actions are also triggered:\n    - Counter of accumulated gradients is reset to 0.\n    - Aggregated gradient is reset to 0 tensor.\n    - Accumulator's internal time step is incremented by 1.\n\n    Args:\n      num_required: Number of gradients that needs to have been aggregated\n      name: Optional name for the operation\n\n    Returns:\n      A tuple of indices, values, and shape representing the average gradient.\n\n    Raises:\n      InvalidArgumentError: If `num_required` < 1\n    \"\"\"\n    return gen_data_flow_ops.sparse_accumulator_take_gradient(\n        self._accumulator_ref, num_required, dtype=self._dtype, name=name)\n\n  def take_indexed_slices_grad(self, num_required, name=None):\n    \"\"\"Attempts to extract the average gradient from the accumulator.\n\n    The operation blocks until sufficient number of gradients have been\n    successfully applied to the accumulator.\n\n    Once successful, the following actions are also triggered:\n    - Counter of accumulated gradients is reset to 0.\n    - Aggregated gradient is reset to 0 tensor.\n    - Accumulator's internal time step is incremented by 1.\n\n    Args:\n      num_required: Number of gradients that needs to have been aggregated\n      name: Optional name for the operation\n\n    Returns:\n      An `IndexedSlices` holding the value of the average gradient.\n\n    Raises:\n      InvalidArgumentError: If `num_required` < 1\n    \"\"\"\n    return_val = gen_data_flow_ops.sparse_accumulator_take_gradient(\n        self._accumulator_ref, num_required, dtype=self._dtype, name=name)\n    return indexed_slices.IndexedSlices(\n        indices=return_val.indices,\n        values=return_val.values,\n        dense_shape=return_val.shape)\n\n  # SparseConditionalAccumulator is not switched to resource. Use old kernels.\n  def num_accumulated(self, name=None):\n    \"\"\"Number of gradients that have currently been aggregated in accumulator.\n\n    Args:\n      name: Optional name for the operation.\n\n    Returns:\n      Number of accumulated gradients currently in accumulator.\n    \"\"\"\n    if name is None:\n      name = \"%s_NumAccumulated\" % self._name\n\n    return gen_data_flow_ops.accumulator_num_accumulated(\n        self._accumulator_ref, name=name)\n\n  def set_global_step(self, new_global_step, name=None):\n    \"\"\"Sets the global time step of the accumulator.\n\n    The operation logs a warning if we attempt to set to a time step that is\n    lower than the accumulator's own time step.\n\n    Args:\n      new_global_step: Value of new time step. Can be a variable or a constant\n      name: Optional name for the operation.\n\n    Returns:\n      Operation that sets the accumulator's time step.\n    \"\"\"\n    return gen_data_flow_ops.accumulator_set_global_step(\n        self._accumulator_ref,\n        math_ops.cast(ops.convert_to_tensor(new_global_step), _dtypes.int64),\n        name=name)\n\n\nclass BaseStagingArea:\n  \"\"\"Base class for Staging Areas.\"\"\"\n  _identifier = 0\n  _lock = threading.Lock()\n\n  def __init__(self,\n               dtypes,\n               shapes=None,\n               names=None,\n               shared_name=None,\n               capacity=0,\n               memory_limit=0):\n    if shared_name is None:\n      self._name = (\n          ops.get_default_graph().unique_name(self.__class__.__name__))\n    elif isinstance(shared_name, str):\n      self._name = shared_name\n    else:\n      raise ValueError(f\"shared_name must be a string, got {shared_name}\")\n\n    self._dtypes = dtypes\n\n    if shapes is not None:\n      if len(shapes) != len(dtypes):\n        raise ValueError(\"StagingArea shapes must be the same length as dtypes\")\n      self._shapes = [tensor_shape.TensorShape(s) for s in shapes]\n    else:\n      self._shapes = [tensor_shape.unknown_shape() for _ in self._dtypes]\n\n    if names is not None:\n      if len(names) != len(dtypes):\n        raise ValueError(\"StagingArea names must be the same length as dtypes\")\n      self._names = names\n    else:\n      self._names = None\n\n    self._capacity = capacity\n    self._memory_limit = memory_limit\n\n    # all get and put ops must colocate with this op\n    with ops.name_scope(\"%s_root\" % self._name):\n      self._coloc_op = control_flow_ops.no_op()\n\n  @property\n  def name(self):\n    \"\"\"The name of the staging area.\"\"\"\n    return self._name\n\n  @property\n  def dtypes(self):\n    \"\"\"The list of dtypes for each component of a staging area element.\"\"\"\n    return self._dtypes\n\n  @property\n  def shapes(self):\n    \"\"\"The list of shapes for each component of a staging area element.\"\"\"\n    return self._shapes\n\n  @property\n  def names(self):\n    \"\"\"The list of names for each component of a staging area element.\"\"\"\n    return self._names\n\n  @property\n  def capacity(self):\n    \"\"\"The maximum number of elements of this staging area.\"\"\"\n    return self._capacity\n\n  @property\n  def memory_limit(self):\n    \"\"\"The maximum number of bytes of this staging area.\"\"\"\n    return self._memory_limit\n\n  def _check_put_dtypes(self, vals, indices=None):\n    \"\"\"Validate and convert `vals` to a list of `Tensor`s.\n\n    The `vals` argument can be a Tensor, a list or tuple of tensors, or a\n    dictionary with tensor values.\n\n    If `vals` is a list, then the appropriate indices associated with the\n    values must be provided.\n\n    If it is a dictionary, the staging area must have been constructed with a\n    `names` attribute and the dictionary keys must match the staging area names.\n    `indices` will be inferred from the dictionary keys.\n    If the staging area was constructed with a `names` attribute, `vals` must\n    be a dictionary.\n\n    Checks that the dtype and shape of each value matches that\n    of the staging area.\n\n    Args:\n      vals: A tensor, a list or tuple of tensors, or a dictionary.\n\n    Returns:\n      A (tensors, indices) tuple where `tensors` is a list of `Tensor` objects\n      and `indices` is a list of indices associated with the tensors.\n\n    Raises:\n      ValueError: If `vals` or `indices` is invalid.\n    \"\"\"\n    if isinstance(vals, dict):\n      if not self._names:\n        raise ValueError(\n            \"Staging areas must have names to enqueue a dictionary\")\n      if not set(vals.keys()).issubset(self._names):\n        raise ValueError(\"Keys in dictionary to put do not match names \"\n                         f\"of staging area. Dictionary: {sorted(vals.keys())}\"\n                         f\"Queue: {sorted(self._names)}\")\n      # The order of values in `self._names` indicates the order in which the\n      # tensors in the dictionary `vals` must be listed.\n      vals, indices, _ = zip(*[(vals[k], i, k)\n                               for i, k in enumerate(self._names)\n                               if k in vals])\n    else:\n      if self._names:\n        raise ValueError(\"You must enqueue a dictionary in a staging area \"\n                         \"with names\")\n\n      if indices is None:\n        raise ValueError(\"Indices must be supplied when inserting a list \"\n                         \"of tensors\")\n\n      if len(indices) != len(vals):\n        raise ValueError(f\"Number of indices {len(indices)} doesn't match \"\n                         f\"number of values {len(vals)}\")\n\n      if not isinstance(vals, (list, tuple)):\n        vals = [vals]\n        indices = [0]\n\n    # Sanity check number of values\n    if not len(vals) <= len(self._dtypes):\n      raise ValueError(f\"Unexpected number of inputs {len(vals)} vs \"\n                       f\"{len(self._dtypes)}\")\n\n    tensors = []\n\n    for val, i in zip(vals, indices):\n      dtype, shape = self._dtypes[i], self._shapes[i]\n      # Check dtype\n      if val.dtype != dtype:\n        raise ValueError(f\"Datatypes do not match. \"\n                         f\"Received val.dtype {str(val.dtype)} and \"\n                         f\"dtype {str(dtype)}\")\n      # Check shape\n      val.get_shape().assert_is_compatible_with(shape)\n\n      tensors.append(\n          ops.convert_to_tensor(val, dtype=dtype, name=\"component_%d\" % i))\n\n    return tensors, indices\n\n  def _create_device_transfers(self, tensors):\n    \"\"\"Encode inter-device transfers if the current device\n    is not the same as the Staging Area's device.\n    \"\"\"\n\n    if not isinstance(tensors, (tuple, list)):\n      tensors = [tensors]\n\n    curr_device_scope = control_flow_ops.no_op().device\n\n    if curr_device_scope != self._coloc_op.device:\n      tensors = [array_ops.identity(t) for t in tensors]\n\n    return tensors\n\n  def _get_return_value(self, tensors, indices):\n    \"\"\"Return the value to return from a get op.\n\n    If the staging area has names, return a dictionary with the\n    names as keys.  Otherwise return either a single tensor\n    or a list of tensors depending on the length of `tensors`.\n\n    Args:\n      tensors: List of tensors from the get op.\n      indices: Indices of associated names and shapes\n\n    Returns:\n      A single tensor, a list of tensors, or a dictionary\n      of tensors.\n    \"\"\"\n\n    tensors = self._create_device_transfers(tensors)\n\n    # Sets shape\n    for output, i in zip(tensors, indices):\n      output.set_shape(self._shapes[i])\n\n    if self._names:\n      # The returned values in `tensors` are in the same order as\n      # the names in `self._names`.\n      return {self._names[i]: t for t, i in zip(tensors, indices)}\n    return tensors\n\n  def _scope_vals(self, vals):\n    \"\"\"Return a list of values to pass to `name_scope()`.\n\n    Args:\n      vals: A tensor, a list or tuple of tensors, or a dictionary.\n\n    Returns:\n      The values in vals as a list.\n    \"\"\"\n    if isinstance(vals, (list, tuple)):\n      return vals\n    elif isinstance(vals, dict):\n      return vals.values()\n    else:\n      return [vals]\n\n\nclass StagingArea(BaseStagingArea):\n  \"\"\"Class for staging inputs. No ordering guarantees.\n\n  A `StagingArea` is a TensorFlow data structure that stores tensors across\n  multiple steps, and exposes operations that can put and get tensors.\n\n  Each `StagingArea` element is a tuple of one or more tensors, where each\n  tuple component has a static dtype, and may have a static shape.\n\n  The capacity of a `StagingArea` may be bounded or unbounded.\n  It supports multiple concurrent producers and consumers; and\n  provides exactly-once delivery.\n\n  Each element of a `StagingArea` is a fixed-length tuple of tensors whose\n  dtypes are described by `dtypes`, and whose shapes are optionally described\n  by the `shapes` argument.\n\n  If the `shapes` argument is specified, each component of a staging area\n  element must have the respective fixed shape. If it is\n  unspecified, different elements may have different shapes,\n\n  It can be configured with a capacity in which case\n  put(values) will block until space becomes available.\n\n  Similarly, it can be configured with a memory limit which\n  will block put(values) until space is available.\n  This is mostly useful for limiting the number of tensors on\n  devices such as GPUs.\n\n  All get() and peek() commands block if the requested data\n  is not present in the Staging Area.\n\n  \"\"\"\n\n  def __init__(self,\n               dtypes,\n               shapes=None,\n               names=None,\n               shared_name=None,\n               capacity=0,\n               memory_limit=0):\n    \"\"\"Constructs a staging area object.\n\n    The two optional lists, `shapes` and `names`, must be of the same length\n    as `dtypes` if provided.  The values at a given index `i` indicate the\n    shape and name to use for the corresponding queue component in `dtypes`.\n\n    The device scope at the time of object creation determines where the\n    storage for the `StagingArea` will reside.  Calls to `put` will incur a copy\n    to this memory space, if necessary.  Tensors returned by `get` will be\n    placed according to the device scope when `get` is called.\n\n    Args:\n      dtypes:  A list of types.  The length of dtypes must equal the number\n        of tensors in each element.\n      shapes: (Optional.) Constraints on the shapes of tensors in an element.\n        A list of shape tuples or None. This list is the same length\n        as dtypes.  If the shape of any tensors in the element are constrained,\n        all must be; shapes can be None if the shapes should not be constrained.\n      names: (Optional.) If provided, the `get()` and\n        `put()` methods will use dictionaries with these names as keys.\n        Must be None or a list or tuple of the same length as `dtypes`.\n      shared_name: (Optional.) A name to be used for the shared object. By\n        passing the same name to two different python objects they will share\n        the underlying staging area. Must be a string.\n      capacity: (Optional.) Maximum number of elements.\n        An integer. If zero, the Staging Area is unbounded\n      memory_limit: (Optional.) Maximum number of bytes of all tensors\n        in the Staging Area.\n        An integer. If zero, the Staging Area is unbounded\n\n    Raises:\n      ValueError: If one of the arguments is invalid.\n    \"\"\"\n\n    super(StagingArea, self).__init__(dtypes, shapes, names, shared_name,\n                                      capacity, memory_limit)\n\n  def put(self, values, name=None):\n    \"\"\"Create an op that places a value into the staging area.\n\n    This operation will block if the `StagingArea` has reached\n    its capacity.\n\n    Args:\n      values: A single tensor, a list or tuple of tensors, or a dictionary with\n        tensor values. The number of elements must match the length of the\n        list provided to the dtypes argument when creating the StagingArea.\n      name: A name for the operation (optional).\n\n    Returns:\n        The created op.\n\n    Raises:\n      ValueError: If the number or type of inputs don't match the staging area.\n    \"\"\"\n    with ops.name_scope(name, \"%s_put\" % self._name,\n                        self._scope_vals(values)) as scope:\n\n      if not isinstance(values, (list, tuple, dict)):\n        values = [values]\n\n      # Hard-code indices for this staging area\n      indices = list(range(len(values)))\n      vals, _ = self._check_put_dtypes(values, indices)\n\n      with ops.colocate_with(self._coloc_op):\n        op = gen_data_flow_ops.stage(\n            values=vals,\n            shared_name=self._name,\n            name=scope,\n            capacity=self._capacity,\n            memory_limit=self._memory_limit)\n\n      return op\n\n  def __internal_get(self, get_fn, name):\n    with ops.colocate_with(self._coloc_op):\n      ret = get_fn()\n\n    indices = list(range(len(self._dtypes)))  # Hard coded\n    return self._get_return_value(ret, indices)\n\n  def get(self, name=None):\n    \"\"\"Gets one element from this staging area.\n\n    If the staging area is empty when this operation executes, it will block\n    until there is an element to dequeue.\n\n    Note that unlike others ops that can block, like the queue Dequeue\n    operations, this can stop other work from happening.  To avoid this, the\n    intended use is for this to be called only when there will be an element\n    already available.  One method for doing this in a training loop would be to\n    run a `put()` call during a warmup session.run call, and then call both\n    `get()` and `put()` in each subsequent step.\n\n    The placement of the returned tensor will be determined by the current\n    device scope when this function is called.\n\n    Args:\n      name: A name for the operation (optional).\n\n    Returns:\n      The tuple of tensors that was gotten.\n    \"\"\"\n    if name is None:\n      name = \"%s_get\" % self._name\n\n    # pylint: disable=bad-continuation\n    fn = lambda: gen_data_flow_ops.unstage(dtypes=self._dtypes,\n                    shared_name=self._name, name=name,\n                    capacity=self._capacity,\n                    memory_limit=self._memory_limit)\n    # pylint: enable=bad-continuation\n\n    return self.__internal_get(fn, name)\n\n  def peek(self, index, name=None):\n    \"\"\"Peeks at an element in the staging area.\n\n    If the staging area is too small to contain the element at\n    the specified index, it will block until enough elements\n    are inserted to complete the operation.\n\n    The placement of the returned tensor will be determined by\n    the current device scope when this function is called.\n\n    Args:\n      index: The index of the tensor within the staging area\n              to look up.\n      name: A name for the operation (optional).\n\n    Returns:\n      The tuple of tensors that was gotten.\n    \"\"\"\n    if name is None:\n      name = \"%s_peek\" % self._name\n\n    # pylint: disable=bad-continuation\n    fn = lambda: gen_data_flow_ops.stage_peek(index,\n                    dtypes=self._dtypes, shared_name=self._name,\n                    name=name, capacity=self._capacity,\n                    memory_limit=self._memory_limit)\n    # pylint: enable=bad-continuation\n\n    return self.__internal_get(fn, name)\n\n  def size(self, name=None):\n    \"\"\"Returns the number of elements in the staging area.\n\n    Args:\n        name: A name for the operation (optional)\n\n    Returns:\n        The created op\n    \"\"\"\n    if name is None:\n      name = \"%s_size\" % self._name\n\n    return gen_data_flow_ops.stage_size(\n        name=name,\n        shared_name=self._name,\n        dtypes=self._dtypes,\n        capacity=self._capacity,\n        memory_limit=self._memory_limit)\n\n  def clear(self, name=None):\n    \"\"\"Clears the staging area.\n\n    Args:\n        name: A name for the operation (optional)\n\n    Returns:\n        The created op\n    \"\"\"\n    if name is None:\n      name = \"%s_clear\" % self._name\n\n    return gen_data_flow_ops.stage_clear(\n        name=name,\n        shared_name=self._name,\n        dtypes=self._dtypes,\n        capacity=self._capacity,\n        memory_limit=self._memory_limit)\n\n\nclass MapStagingArea(BaseStagingArea):\n  \"\"\"A `MapStagingArea` is a TensorFlow data structure that stores tensors\n  across multiple steps, and exposes operations that can put and get tensors.\n\n  Each `MapStagingArea` element is a (key, value) pair.\n  Only int64 keys are supported, other types should be\n  hashed to produce a key.\n  Values are a tuple of one or more tensors.\n  Each tuple component has a static dtype,\n  and may have a static shape.\n\n  The capacity of a `MapStagingArea` may be bounded or unbounded.\n  It supports multiple concurrent producers and consumers; and\n  provides exactly-once delivery.\n\n  Each value tuple of a `MapStagingArea` is a fixed-length tuple of tensors\n  whose\n  dtypes are described by `dtypes`, and whose shapes are optionally described\n  by the `shapes` argument.\n\n  If the `shapes` argument is specified, each component of a staging area\n  element must have the respective fixed shape. If it is\n  unspecified, different elements may have different shapes,\n\n  It behaves like an associative container with support for:\n\n   - put(key, values)\n   - peek(key)         like dict.get(key)\n   - get(key)          like dict.pop(key)\n   - get(key=None)     like dict.popitem()\n   - size()\n   - clear()\n\n  If ordered a tree structure ordered by key will be used and\n  get(key=None) will remove (key, value) pairs in increasing key order.\n  Otherwise a hashtable\n\n  It can be configured with a capacity in which case\n  put(key, values) will block until space becomes available.\n\n  Similarly, it can be configured with a memory limit which\n  will block put(key, values) until space is available.\n  This is mostly useful for limiting the number of tensors on\n  devices such as GPUs.\n\n  All get() and peek() commands block if the requested\n  (key, value) pair is not present in the staging area.\n\n  Partial puts are supported and will be placed in an incomplete\n  map until such time as all values associated with the key have\n  been inserted. Once completed, this (key, value) pair will be\n  inserted into the map. Data in the incomplete map\n  counts towards the memory limit, but not towards capacity limit.\n\n  Partial gets from the map are also supported.\n  This removes the partially requested tensors from the entry,\n  but the entry is only removed from the map once all tensors\n  associated with it are removed.\n  \"\"\"\n\n  def __init__(self,\n               dtypes,\n               shapes=None,\n               names=None,\n               shared_name=None,\n               ordered=False,\n               capacity=0,\n               memory_limit=0):\n    \"\"\"Args:\n\n      dtypes:  A list of types.  The length of dtypes must equal the number\n        of tensors in each element.\n      capacity: (Optional.) Maximum number of elements.\n        An integer. If zero, the Staging Area is unbounded\n      memory_limit: (Optional.) Maximum number of bytes of all tensors\n        in the Staging Area (excluding keys).\n        An integer. If zero, the Staging Area is unbounded\n      ordered: (Optional.) If True the underlying data structure\n        is a tree ordered on key. Otherwise assume a hashtable.\n      shapes: (Optional.) Constraints on the shapes of tensors in an element.\n        A list of shape tuples or None. This list is the same length\n        as dtypes.  If the shape of any tensors in the element are constrained,\n        all must be; shapes can be None if the shapes should not be constrained.\n      names: (Optional.) If provided, the `get()` and\n        `put()` methods will use dictionaries with these names as keys.\n        Must be None or a list or tuple of the same length as `dtypes`.\n      shared_name: (Optional.) A name to be used for the shared object. By\n        passing the same name to two different python objects they will share\n        the underlying staging area. Must be a string.\n\n    Raises:\n      ValueError: If one of the arguments is invalid.\n\n    \"\"\"\n\n    super(MapStagingArea, self).__init__(dtypes, shapes, names, shared_name,\n                                         capacity, memory_limit)\n\n    # Defer to different methods depending if the map is ordered\n    self._ordered = ordered\n\n    if ordered:\n      self._put_fn = gen_data_flow_ops.ordered_map_stage\n      self._pop_fn = gen_data_flow_ops.ordered_map_unstage\n      self._popitem_fn = gen_data_flow_ops.ordered_map_unstage_no_key\n      self._peek_fn = gen_data_flow_ops.ordered_map_peek\n      self._size_fn = gen_data_flow_ops.ordered_map_size\n      self._incomplete_size_fn = gen_data_flow_ops.ordered_map_incomplete_size\n      self._clear_fn = gen_data_flow_ops.ordered_map_clear\n    else:\n      self._put_fn = gen_data_flow_ops.map_stage\n      self._pop_fn = gen_data_flow_ops.map_unstage\n      self._popitem_fn = gen_data_flow_ops.map_unstage_no_key\n      self._peek_fn = gen_data_flow_ops.map_peek\n      self._size_fn = gen_data_flow_ops.map_size\n      self._incomplete_size_fn = gen_data_flow_ops.map_incomplete_size\n      self._clear_fn = gen_data_flow_ops.map_clear\n\n  def put(self, key, vals, indices=None, name=None):\n    \"\"\"Create an op that stores the (key, vals) pair in the staging area.\n\n    Incomplete puts are possible, preferably using a dictionary for vals\n    as the appropriate dtypes and shapes can be inferred from the value names\n    dictionary key values. If vals is a list or tuple, indices must\n    also be specified so that the op knows at which element position\n    to perform the insert.\n\n    This operation will block if the capacity or memory limit of this\n    container is reached.\n\n    Args:\n        key: Key associated with the data\n        vals: Tensor (or a dict/tuple of Tensors) to place\n                into the staging area.\n        indices: (Optional) if vals is a tuple/list, this is required.\n        name: A name for the operation (optional)\n\n    Returns:\n        The created op\n\n    Raises:\n        ValueError: If the number or type of inputs don't match the staging\n        area.\n    \"\"\"\n\n    with ops.name_scope(name, \"%s_put\" % self._name,\n                        self._scope_vals(vals)) as scope:\n\n      vals, indices = self._check_put_dtypes(vals, indices)\n\n      with ops.colocate_with(self._coloc_op):\n        op = self._put_fn(\n            key,\n            indices,\n            vals,\n            dtypes=self._dtypes,\n            shared_name=self._name,\n            name=scope,\n            capacity=self._capacity,\n            memory_limit=self._memory_limit)\n    return op\n\n  def _get_indices_and_dtypes(self, indices=None):\n    if indices is None:\n      indices = list(range(len(self._dtypes)))\n\n    if not isinstance(indices, (tuple, list)):\n      raise TypeError(f\"Invalid indices type {type(indices)}\")\n\n    if len(indices) == 0:\n      raise ValueError(\"Empty indices\")\n\n    if all(isinstance(i, str) for i in indices):\n      if self._names is None:\n        raise ValueError(f\"String indices provided {indices}, but \"\n                         \"this Staging Area was not created with names.\")\n\n      try:\n        indices = [self._names.index(n) for n in indices]\n      except ValueError:\n        raise ValueError(f\"Named index not in \"\n                         f\"Staging Area names {self._names}\")\n    elif all(isinstance(i, int) for i in indices):\n      pass\n    else:\n      raise TypeError(f\"Mixed types in indices {indices}. \"\n                      \"May only be str or int\")\n\n    dtypes = [self._dtypes[i] for i in indices]\n\n    return indices, dtypes\n\n  def peek(self, key, indices=None, name=None):\n    \"\"\"Peeks at staging area data associated with the key.\n\n    If the key is not in the staging area, it will block\n    until the associated (key, value) is inserted.\n\n    Args:\n        key: Key associated with the required data\n        indices: Partial list of tensors to retrieve (optional).\n                A list of integer or string indices.\n                String indices are only valid if the Staging Area\n                has names associated with it.\n        name: A name for the operation (optional)\n\n    Returns:\n        The created op\n    \"\"\"\n\n    if name is None:\n      name = \"%s_pop\" % self._name\n\n    indices, dtypes = self._get_indices_and_dtypes(indices)\n\n    with ops.colocate_with(self._coloc_op):\n      result = self._peek_fn(\n          key,\n          shared_name=self._name,\n          indices=indices,\n          dtypes=dtypes,\n          name=name,\n          capacity=self._capacity,\n          memory_limit=self._memory_limit)\n\n    return self._get_return_value(result, indices)\n\n  def get(self, key=None, indices=None, name=None):\n    \"\"\"If the key is provided, the associated (key, value) is returned from the staging area.\n\n    If the key is not in the staging area, this method will block until\n    the associated (key, value) is inserted.\n    If no key is provided and the staging area is ordered,\n    the (key, value) with the smallest key will be returned.\n    Otherwise, a random (key, value) will be returned.\n\n    If the staging area is empty when this operation executes,\n    it will block until there is an element to dequeue.\n\n    Args:\n        key: Key associated with the required data (Optional)\n        indices: Partial list of tensors to retrieve (optional).\n                A list of integer or string indices.\n                String indices are only valid if the Staging Area\n                has names associated with it.\n        name: A name for the operation (optional)\n\n    Returns:\n        The created op\n    \"\"\"\n    if key is None:\n      return self._popitem(indices=indices, name=name)\n    else:\n      return self._pop(key, indices=indices, name=name)\n\n  def _pop(self, key, indices=None, name=None):\n    \"\"\"Remove and return the associated (key, value) is returned from the staging area.\n\n    If the key is not in the staging area, this method will block until\n    the associated (key, value) is inserted.\n    Args:\n        key: Key associated with the required data\n        indices: Partial list of tensors to retrieve (optional).\n                A list of integer or string indices.\n                String indices are only valid if the Staging Area\n                has names associated with it.\n        name: A name for the operation (optional)\n\n    Returns:\n        The created op\n    \"\"\"\n    if name is None:\n      name = \"%s_get\" % self._name\n\n    indices, dtypes = self._get_indices_and_dtypes(indices)\n\n    with ops.colocate_with(self._coloc_op):\n      result = self._pop_fn(\n          key,\n          shared_name=self._name,\n          indices=indices,\n          dtypes=dtypes,\n          name=name,\n          capacity=self._capacity,\n          memory_limit=self._memory_limit)\n\n    return key, self._get_return_value(result, indices)\n\n  def _popitem(self, indices=None, name=None):\n    \"\"\"If the staging area is ordered, the (key, value) with the smallest key will be returned.\n\n    Otherwise, a random (key, value) will be returned.\n    If the staging area is empty when this operation executes,\n    it will block until there is an element to dequeue.\n\n    Args:\n        key: Key associated with the required data\n        indices: Partial list of tensors to retrieve (optional).\n                A list of integer or string indices.\n                String indices are only valid if the Staging Area\n                has names associated with it.\n        name: A name for the operation (optional)\n\n    Returns:\n        The created op\n    \"\"\"\n    if name is None:\n      name = \"%s_get_nokey\" % self._name\n\n    indices, dtypes = self._get_indices_and_dtypes(indices)\n\n    with ops.colocate_with(self._coloc_op):\n      key, result = self._popitem_fn(\n          shared_name=self._name,\n          indices=indices,\n          dtypes=dtypes,\n          name=name,\n          capacity=self._capacity,\n          memory_limit=self._memory_limit)\n\n    # Separate keys and results out from\n    # underlying namedtuple\n    key = self._create_device_transfers(key)[0]\n    result = self._get_return_value(result, indices)\n\n    return key, result\n\n  def size(self, name=None):\n    \"\"\"Returns the number of elements in the staging area.\n\n    Args:\n        name: A name for the operation (optional)\n\n    Returns:\n        The created op\n    \"\"\"\n    if name is None:\n      name = \"%s_size\" % self._name\n\n    return self._size_fn(\n        shared_name=self._name,\n        name=name,\n        dtypes=self._dtypes,\n        capacity=self._capacity,\n        memory_limit=self._memory_limit)\n\n  def incomplete_size(self, name=None):\n    \"\"\"Returns the number of incomplete elements in the staging area.\n\n    Args:\n        name: A name for the operation (optional)\n\n    Returns:\n        The created op\n    \"\"\"\n    if name is None:\n      name = \"%s_incomplete_size\" % self._name\n\n    return self._incomplete_size_fn(\n        shared_name=self._name,\n        name=name,\n        dtypes=self._dtypes,\n        capacity=self._capacity,\n        memory_limit=self._memory_limit)\n\n  def clear(self, name=None):\n    \"\"\"Clears the staging area.\n\n    Args:\n        name: A name for the operation (optional)\n\n    Returns:\n        The created op\n    \"\"\"\n    if name is None:\n      name = \"%s_clear\" % self._name\n\n    return self._clear_fn(\n        shared_name=self._name,\n        name=name,\n        dtypes=self._dtypes,\n        capacity=self._capacity,\n        memory_limit=self._memory_limit)\n\n\nclass RecordInput:\n  \"\"\"RecordInput asynchronously reads and randomly yields TFRecords.\n\n  A RecordInput Op will continuously read a batch of records asynchronously\n  into a buffer of some fixed capacity. It can also asynchronously yield\n  random records from this buffer.\n\n  It will not start yielding until at least `buffer_size / 2` elements have been\n  placed into the buffer so that sufficient randomization can take place.\n\n  The order the files are read will be shifted each epoch by `shift_amount` so\n  that the data is presented in a different order every epoch.\n  \"\"\"\n\n  def __init__(self,\n               file_pattern,\n               batch_size=1,\n               buffer_size=1,\n               parallelism=1,\n               shift_ratio=0,\n               seed=0,\n               name=None,\n               batches=None,\n               compression_type=None):\n    \"\"\"Constructs a RecordInput Op.\n\n    Args:\n      file_pattern: File path to the dataset, possibly containing wildcards.\n        All matching files will be iterated over each epoch.\n      batch_size: How many records to return at a time.\n      buffer_size: The maximum number of records the buffer will contain.\n      parallelism: How many reader threads to use for reading from files.\n      shift_ratio: What percentage of the total number files to move the start\n        file forward by each epoch.\n      seed: Specify the random number seed used by generator that randomizes\n        records.\n      name: Optional name for the operation.\n      batches: None by default, creating a single batch op. Otherwise specifies\n        how many batches to create, which are returned as a list when\n        `get_yield_op()` is called. An example use case is to split processing\n        between devices on one computer.\n      compression_type: The type of compression for the file. Currently ZLIB and\n        GZIP are supported. Defaults to none.\n\n    Raises:\n      ValueError: If one of the arguments is invalid.\n    \"\"\"\n    self._batch_size = batch_size\n    if batches is not None:\n      self._batch_size *= batches\n    self._batches = batches\n    self._file_pattern = file_pattern\n    self._buffer_size = buffer_size\n    self._parallelism = parallelism\n    self._shift_ratio = shift_ratio\n    self._seed = seed\n    self._name = name\n    self._compression_type = python_io.TFRecordCompressionType.NONE\n    if compression_type is not None:\n      self._compression_type = compression_type\n\n  def get_yield_op(self):\n    \"\"\"Adds a node that yields a group of records every time it is executed.\n    If RecordInput `batches` parameter is not None, it yields a list of\n    record batches with the specified `batch_size`.\n    \"\"\"\n    compression_type = python_io.TFRecordOptions.get_compression_type_string(\n        python_io.TFRecordOptions(self._compression_type))\n    records = gen_data_flow_ops.record_input(\n        file_pattern=self._file_pattern,\n        file_buffer_size=self._buffer_size,\n        file_parallelism=self._parallelism,\n        file_shuffle_shift_ratio=self._shift_ratio,\n        batch_size=self._batch_size,\n        file_random_seed=self._seed,\n        compression_type=compression_type,\n        name=self._name)\n    if self._batches is None:\n      return records\n    else:\n      with ops.name_scope(self._name):\n        batch_list = [[] for _ in range(self._batches)]\n        records = array_ops.split(records, self._batch_size, 0)\n        for index, protobuf in enumerate(records):\n          batch_index = index % self._batches\n          batch_list[batch_index].append(array_ops.reshape(protobuf, []))\n        return batch_list"