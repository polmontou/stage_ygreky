"/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/string_ops.cc.\n\n#include <string>\n#include <utility>\n\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\ntemplate <typename INDICES_TYPE>\ngtl::InlinedVector<INDICES_TYPE, 8> GetFlattenedRelativeOffsets(\n    INDICES_TYPE small_stride, INDICES_TYPE big_stride) {\n  gtl::InlinedVector<INDICES_TYPE, 8> flattened_offsets(small_stride);\n  for (auto i = 0; i < small_stride; i++) {\n    flattened_offsets[i] = i * big_stride;\n  }\n  return flattened_offsets;\n}\n\ntemplate <typename INDICES_TYPE>\nstd::pair<INDICES_TYPE, INDICES_TYPE> GetStrides(\n    const TensorShape& input_shape, const TensorShape& segment_id_shape) {\n  int64_t small_stride = 1;\n  int64_t big_stride = 1;\n  for (auto i = 0; i < input_shape.dims(); i++) {\n    if (i < segment_id_shape.dims()) {\n      small_stride *= segment_id_shape.dim_size(i);\n    } else {\n      big_stride *= input_shape.dim_size(i);\n    }\n  }\n  return std::make_pair(big_stride, small_stride);\n}\n\nTensorShape GetOutputShape(const TensorShape& input_shape,\n                           const TensorShape& segment_id_shape,\n                           const int64_t num_segments) {\n  TensorShape output_shape;\n  output_shape.AddDim(num_segments);\n  for (size_t index = segment_id_shape.dims(); index < input_shape.dims();\n       ++index) {\n    output_shape.AddDim(input_shape.dim_size(index));\n  }\n  return output_shape;\n}\n\n}  // namespace\n\ntemplate <typename INDICES_TYPE, typename NUM_SEGMENTS_TYPE>\nclass UnsortedSegmentJoinOp : public OpKernel {\n public:\n  using OpKernel::OpKernel;\n\n  explicit UnsortedSegmentJoinOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"separator\", &separator_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const int32_t input_dims = input_shape.dims();\n\n    const Tensor& segment_id = context->input(1);\n    const TensorShape& segment_id_shape = segment_id.shape();\n    const int32_t segment_dims = segment_id_shape.dims();\n\n    const Tensor& num_segments_tensor = context->input(2);\n    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,\n                errors::InvalidArgument(\"Number of segments cannot be empty.\"));\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsScalar(num_segments_tensor.shape()),\n                errors::InvalidArgument(\"Number of segments must be a scalar\"));\n    auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();\n\n    OP_REQUIRES(\n        context, num_segments >= 0,\n        errors::InvalidArgument(\n            \"Number of segments must be non-negative but got \", num_segments));\n    OP_REQUIRES(context, segment_dims != 0,\n                errors::InvalidArgument(\"Segment_id cannot have rank 0\"));\n\n    OP_REQUIRES(\n        context, segment_dims <= input_dims,\n        errors::OutOfRange(\"Invalid segment_id rank \", segment_dims,\n                           \" for input with \", input_dims, \" dimension(s)\"));\n    for (auto i = 0; i < segment_dims; i++) {\n      OP_REQUIRES(\n          context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),\n          errors::InvalidArgument(\n              \"Segment dimension is \", segment_id_shape.dim_size(i),\n              \" while input dimension is \", input_dims, \" in rank \", i));\n    }\n\n    // Making output tensor.\n    Tensor* output_tensor = nullptr;\n    TensorShape output_shape =\n        GetOutputShape(input_shape, segment_id_shape, num_segments);\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n\n    // Preparating flat tensors.\n    auto output_flat = output_tensor->flat<tstring>();\n    auto flat_segment_id = segment_id.flat<INDICES_TYPE>();\n    auto flat_input = input.flat<tstring>();\n\n    for (int i = 0; i < flat_segment_id.size(); i++) {\n      OP_REQUIRES(\n          context,\n          ((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),\n          errors::InvalidArgument(\n              \"segment_ids are not allowed to exceed num_segments or\"\n              \" to have negative values.\"));\n    }\n\n    int64_t big_stride;\n    int64_t small_stride;\n    std::tie(big_stride, small_stride) =\n        GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);\n    auto relative_offset_set =\n        GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);\n    for (auto start_offset = 0; start_offset < big_stride; start_offset++) {\n      for (auto i = 0; i < relative_offset_set.size(); i++) {\n        auto output_index = start_offset + flat_segment_id(i) * big_stride;\n        auto offset = start_offset + relative_offset_set[i];\n        if (output_flat(output_index).length() != 0)\n          output_flat(output_index).append(separator_.c_str());\n        output_flat(output_index).append(flat_input(offset));\n      }\n    }\n  }\n\n private:\n  string separator_;\n};\n\n#define REGISTER_CPU_KERNEL(indices_type, num_segments_type)  \\\n  REGISTER_KERNEL_BUILDER(                                    \\\n      Name(\"UnsortedSegmentJoin\")                             \\\n          .Device(DEVICE_CPU)                                 \\\n          .TypeConstraint<indices_type>(\"Tindices\")           \\\n          .TypeConstraint<num_segments_type>(\"Tnumsegments\"), \\\n      UnsortedSegmentJoinOp<indices_type, num_segments_type>);\n\nREGISTER_CPU_KERNEL(int32, int32);\nREGISTER_CPU_KERNEL(int32, int64_t);\nREGISTER_CPU_KERNEL(int64_t, int32);\nREGISTER_CPU_KERNEL(int64_t, int64_t);\n#undef REGISTER_CPU_KERNEL\n\n}  // namespace tensorflow"