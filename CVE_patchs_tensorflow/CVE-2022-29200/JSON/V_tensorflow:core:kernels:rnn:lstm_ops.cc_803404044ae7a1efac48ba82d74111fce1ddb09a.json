"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define EIGEN_USE_THREADS\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define EIGEN_USE_GPU\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#include \"tensorflow/core/kernels/rnn/lstm_ops.h\"\n\n#include <memory>\n#include <vector>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/macros.h\"\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace functor {\n\ntemplate <typename T, GateLayout gate_layout>\nvoid LSTMBlockCellFpropWithEigen(\n    const LSTMBlockCell& cell, OpKernelContext* ctx, const CPUDevice& d,\n    const float forget_bias, const float cell_clip, bool use_peephole,\n    typename TTypes<T>::ConstMatrix x, typename TTypes<T>::ConstMatrix cs_prev,\n    typename TTypes<T>::ConstMatrix h_prev, typename TTypes<T>::ConstMatrix w,\n    typename TTypes<T>::ConstVec wci, typename TTypes<T>::ConstVec wcf,\n    typename TTypes<T>::ConstVec wco, typename TTypes<T>::ConstVec b,\n    typename TTypes<T>::Matrix xh, typename TTypes<T>::Matrix i,\n    typename TTypes<T>::Matrix cs, typename TTypes<T>::Matrix f,\n    typename TTypes<T>::Matrix o, typename TTypes<T>::Matrix ci,\n    typename TTypes<T>::Matrix co, typename TTypes<T>::Matrix gates,\n    typename TTypes<T>::Matrix h) {\n  // Concat xh = [x, h].\n  xh.slice(cell.xh_x_offsets(), cell.xh_x_extents()).device(d) = x;\n  xh.slice(cell.xh_h_offsets(), cell.xh_h_extents()).device(d) = h_prev;\n\n  // states1 = xh * w + b\n  typename TTypes<T>::ConstMatrix const_xh(xh.data(), xh.dimensions());\n  TensorBlasGemm<CPUDevice, T, false /* USE_CUBLAS */>::compute(\n      ctx, d, false, false, typename gemm_compute_type<T>::type(1.f), const_xh,\n      w, typename gemm_compute_type<T>::type(0.f), gates);\n  Eigen::array<Eigen::DenseIndex, 2> b_shape({1, b.dimensions()[0]});\n  Eigen::array<Eigen::DenseIndex, 2> broadcast_shape({cell.batch_size(), 1});\n  gates.device(d) += b.reshape(b_shape).broadcast(broadcast_shape);\n\n  Eigen::array<Eigen::DenseIndex, 2> p_shape({1, cell.cell_size()});\n  Eigen::array<Eigen::DenseIndex, 2> p_broadcast_shape({cell.batch_size(), 1});\n\n  // Input gate.\n  if (use_peephole) {\n    auto i_peep = cs_prev * wci.reshape(p_shape).broadcast(p_broadcast_shape);\n    i.device(d) =\n        (gates.slice(cell.gates_i_offsets(), cell.cell_extents()) + i_peep)\n            .sigmoid();\n  } else {\n    i.device(d) =\n        gates.slice(cell.gates_i_offsets(), cell.cell_extents()).sigmoid();\n  }\n\n  // Cell input.\n  ci.device(d) =\n      gates.slice(cell.gates_c_offsets(gate_layout), cell.cell_extents())\n          .tanh();\n\n  // Forget gate (w/ bias).\n  if (use_peephole) {\n    auto f_peep = cs_prev * wcf.reshape(p_shape).broadcast(p_broadcast_shape);\n    f.device(d) =\n        (gates.slice(cell.gates_f_offsets(gate_layout), cell.cell_extents()) +\n         f.constant(T(forget_bias)) + f_peep)\n            .sigmoid();\n  } else {\n    f.device(d) =\n        (gates.slice(cell.gates_f_offsets(gate_layout), cell.cell_extents()) +\n         f.constant(T(forget_bias)))\n            .sigmoid();\n  }\n\n  // cs = ci .* i + f .* cs_prev\n  cs.device(d) = i * ci + f * cs_prev;\n\n  if (cell_clip > 0.0f) {\n    cs.device(d) =\n        cs.binaryExpr(cs.constant(T(cell_clip)), Eigen::scalar_clip_op<T>());\n  }\n\n  // co = tanh(cs)\n  co.device(d) = cs.tanh();\n\n  // Output gate.\n  if (use_peephole) {\n    auto o_peep = cs * wco.reshape(p_shape).broadcast(p_broadcast_shape);\n    o.device(d) =\n        (gates.slice(cell.gates_o_offsets(), cell.cell_extents()) + o_peep)\n            .sigmoid();\n  } else {\n    o.device(d) =\n        gates.slice(cell.gates_o_offsets(), cell.cell_extents()).sigmoid();\n  }\n\n  // h = o .* co\n  h.device(d) = o * co;\n}\n\ntemplate <typename Device, typename T, GateLayout gate_layout>\nvoid LSTMBlockCellBpropWithEigen(\n    const LSTMBlockCell& cell, OpKernelContext* ctx, const Device& d,\n    bool use_peephole, typename TTypes<T>::ConstMatrix x,\n    typename TTypes<T>::ConstMatrix cs_prev,\n    typename TTypes<T>::ConstMatrix h_prev, typename TTypes<T>::ConstMatrix w,\n    typename TTypes<T>::ConstVec wci, typename TTypes<T>::ConstVec wcf,\n    typename TTypes<T>::ConstVec wco, typename TTypes<T>::ConstVec b,\n    typename TTypes<T>::ConstMatrix i, typename TTypes<T>::ConstMatrix cs,\n    typename TTypes<T>::ConstMatrix f, typename TTypes<T>::ConstMatrix o,\n    typename TTypes<T>::ConstMatrix ci, typename TTypes<T>::ConstMatrix co,\n    typename TTypes<T>::ConstMatrix cs_grad,\n    typename TTypes<T>::ConstMatrix h_grad, typename TTypes<T>::Matrix do_,\n    typename TTypes<T>::Matrix dcs, typename TTypes<T>::Matrix dci,\n    typename TTypes<T>::Matrix df, typename TTypes<T>::Matrix di,\n    typename TTypes<T>::Matrix dgates, typename TTypes<T>::Matrix cs_prev_grad,\n    typename TTypes<T>::Vec wci_grad, typename TTypes<T>::Vec wcf_grad,\n    typename TTypes<T>::Vec wco_grad) {\n  // do[t] = sigm'(o[t]) .* dh[t] .* co[t]\n  do_.device(d) = o * (o.constant(T(1)) - o) * h_grad * co;\n\n  // dcs[t] += tanh'(cs[t]) .* dh[t] .* o[t] + dcs[t + 1] .* f[t + 1]\n  dcs.device(d) = (co.constant(T(1)) - co * co) * h_grad * o + cs_grad;\n\n  Eigen::array<Eigen::DenseIndex, 2> p_shape({1, cell.cell_size()});\n  Eigen::array<Eigen::DenseIndex, 2> p_broadcast_shape({cell.batch_size(), 1});\n  if (use_peephole) {\n    dcs.device(d) =\n        dcs + do_ * wco.reshape(p_shape).broadcast(p_broadcast_shape);\n  }\n\n  // dci[t] = tanh'(ci[t]) dcs[t] i[t]\n  dci.device(d) = (ci.constant(T(1)) - ci * ci) * dcs * i;\n\n  // df[t] = sigm'(f[t]) dcs[t] cs[t - 1]\n  df.device(d) = f * (f.constant(T(1)) - f) * dcs * cs_prev;\n\n  // di[t] = sigm'(i[t]) dcs[t] ci[t]\n  di.device(d) = i * (i.constant(T(1)) - i) * dcs * ci;\n\n  dgates.slice(cell.gates_i_offsets(), cell.cell_extents()).device(d) = di;\n  dgates.slice(cell.gates_c_offsets(gate_layout), cell.cell_extents())\n      .device(d) = dci;\n  dgates.slice(cell.gates_f_offsets(gate_layout), cell.cell_extents())\n      .device(d) = df;\n  dgates.slice(cell.gates_o_offsets(), cell.cell_extents()).device(d) = do_;\n\n  cs_prev_grad.device(d) = dcs * f;\n  if (use_peephole) {\n    cs_prev_grad.device(d) =\n        cs_prev_grad + di * wci.reshape(p_shape).broadcast(p_broadcast_shape) +\n        df * wcf.reshape(p_shape).broadcast(p_broadcast_shape);\n    wci_grad.device(d) = (di * cs_prev).sum(Eigen::array<int, 1>({0}));\n    wcf_grad.device(d) = (df * cs_prev).sum(Eigen::array<int, 1>({0}));\n    wco_grad.device(d) = (do_ * cs).sum(Eigen::array<int, 1>({0}));\n  }\n}\n\n#define DECLARE_CPU_FBPROP(T, GATE_LAYOUT)                                     \\\n  template <>                                                                  \\\n  void LSTMBlockCellFprop<CPUDevice, T, false /* USE_CUBLAS */, GATE_LAYOUT>:: \\\n  operator()(                                                                  \\\n      OpKernelContext* ctx, const CPUDevice& d, const float forget_bias,       \\\n      const float cell_clip, bool use_peephole,                                \\\n      typename TTypes<T>::ConstMatrix x,                                       \\\n      typename TTypes<T>::ConstMatrix cs_prev,                                 \\\n      typename TTypes<T>::ConstMatrix h_prev,                                  \\\n      typename TTypes<T>::ConstMatrix w, typename TTypes<T>::ConstVec wci,     \\\n      typename TTypes<T>::ConstVec wcf, typename TTypes<T>::ConstVec wco,      \\\n      typename TTypes<T>::ConstVec b, typename TTypes<T>::Matrix xh,           \\\n      typename TTypes<T>::Matrix i, typename TTypes<T>::Matrix cs,             \\\n      typename TTypes<T>::Matrix f, typename TTypes<T>::Matrix o,              \\\n      typename TTypes<T>::Matrix ci, typename TTypes<T>::Matrix co,            \\\n      typename TTypes<T>::Matrix gates, typename TTypes<T>::Matrix h) {        \\\n    LSTMBlockCellFpropWithEigen<T, GATE_LAYOUT>(                               \\\n        *this, ctx, d, forget_bias, cell_clip, use_peephole, x, cs_prev,       \\\n        h_prev, w, wci, wcf, wco, b, xh, i, cs, f, o, ci, co, gates, h);       \\\n  }                                                                            \\\n  template <>                                                                  \\\n  void LSTMBlockCellBprop<CPUDevice, T, false /* USE_CUBLAS */, GATE_LAYOUT>:: \\\n  operator()(                                                                  \\\n      OpKernelContext* ctx, const CPUDevice& d, bool use_peephole,             \\\n      typename TTypes<T>::ConstMatrix x,                                       \\\n      typename TTypes<T>::ConstMatrix cs_prev,                                 \\\n      typename TTypes<T>::ConstMatrix h_prev,                                  \\\n      typename TTypes<T>::ConstMatrix w, typename TTypes<T>::ConstVec wci,     \\\n      typename TTypes<T>::ConstVec wcf, typename TTypes<T>::ConstVec wco,      \\\n      typename TTypes<T>::ConstVec b, typename TTypes<T>::ConstMatrix i,       \\\n      typename TTypes<T>::ConstMatrix cs, typename TTypes<T>::ConstMatrix f,   \\\n      typename TTypes<T>::ConstMatrix o, typename TTypes<T>::ConstMatrix ci,   \\\n      typename TTypes<T>::ConstMatrix co,                                      \\\n      typename TTypes<T>::ConstMatrix cs_grad,                                 \\\n      typename TTypes<T>::ConstMatrix h_grad, typename TTypes<T>::Matrix do_,  \\\n      typename TTypes<T>::Matrix dcs, typename TTypes<T>::Matrix dci,          \\\n      typename TTypes<T>::Matrix df, typename TTypes<T>::Matrix di,            \\\n      typename TTypes<T>::Matrix dgates,                                       \\\n      typename TTypes<T>::Matrix cs_prev_grad,                                 \\\n      typename TTypes<T>::Vec wci_grad, typename TTypes<T>::Vec wcf_grad,      \\\n      typename TTypes<T>::Vec wco_grad) {                                      \\\n    LSTMBlockCellBpropWithEigen<CPUDevice, T, GATE_LAYOUT>(                    \\\n        *this, ctx, d, use_peephole, x, cs_prev, h_prev, w, wci, wcf, wco, b,  \\\n        i, cs, f, o, ci, co, cs_grad, h_grad, do_, dcs, dci, df, di, dgates,   \\\n        cs_prev_grad, wci_grad, wcf_grad, wco_grad);                           \\\n  }                                                                            \\\n  template struct LSTMBlockCellFprop<CPUDevice, T, false /* USE_CUBLAS */,     \\\n                                     GATE_LAYOUT>;                             \\\n  template struct LSTMBlockCellBprop<CPUDevice, T, false /* USE_CUBLAS */,     \\\n                                     GATE_LAYOUT>;\n\n#define DECLARE_CPU_SPECS(T)   \\\n  DECLARE_CPU_FBPROP(T, ICFO); \\\n  DECLARE_CPU_FBPROP(T, IFCO);\n\nDECLARE_CPU_SPECS(Eigen::half);\nDECLARE_CPU_SPECS(float);\n#undef DECLARE_CPU_SPECS\n#undef DECLARE_CPU_FBPROP\n\n#if GOOGLE_CUDA\n#define DECLARE_GPU_FBPROP(T, GATE_LAYOUT)                                    \\\n  template <>                                                                 \\\n  void LSTMBlockCellFprop<GPUDevice, T, true, GATE_LAYOUT>::operator()(       \\\n      OpKernelContext* ctx, const GPUDevice& d, const float forget_bias,      \\\n      const float cell_clip, bool use_peephole,                               \\\n      typename TTypes<T>::ConstMatrix x,                                      \\\n      typename TTypes<T>::ConstMatrix cs_prev,                                \\\n      typename TTypes<T>::ConstMatrix h_prev,                                 \\\n      typename TTypes<T>::ConstMatrix w, typename TTypes<T>::ConstVec wci,    \\\n      typename TTypes<T>::ConstVec wcf, typename TTypes<T>::ConstVec wco,     \\\n      typename TTypes<T>::ConstVec b, typename TTypes<T>::Matrix xh,          \\\n      typename TTypes<T>::Matrix i, typename TTypes<T>::Matrix cs,            \\\n      typename TTypes<T>::Matrix f, typename TTypes<T>::Matrix o,             \\\n      typename TTypes<T>::Matrix ci, typename TTypes<T>::Matrix co,           \\\n      typename TTypes<T>::Matrix gates, typename TTypes<T>::Matrix h);        \\\n  template <>                                                                 \\\n  void LSTMBlockCellBprop<GPUDevice, T, true, GATE_LAYOUT>::operator()(       \\\n      OpKernelContext* ctx, const GPUDevice& d, bool use_peephole,            \\\n      typename TTypes<T>::ConstMatrix x,                                      \\\n      typename TTypes<T>::ConstMatrix cs_prev,                                \\\n      typename TTypes<T>::ConstMatrix h_prev,                                 \\\n      typename TTypes<T>::ConstMatrix w, typename TTypes<T>::ConstVec wci,    \\\n      typename TTypes<T>::ConstVec wcf, typename TTypes<T>::ConstVec wco,     \\\n      typename TTypes<T>::ConstVec b, typename TTypes<T>::ConstMatrix i,      \\\n      typename TTypes<T>::ConstMatrix cs, typename TTypes<T>::ConstMatrix f,  \\\n      typename TTypes<T>::ConstMatrix o, typename TTypes<T>::ConstMatrix ci,  \\\n      typename TTypes<T>::ConstMatrix co,                                     \\\n      typename TTypes<T>::ConstMatrix cs_grad,                                \\\n      typename TTypes<T>::ConstMatrix h_grad, typename TTypes<T>::Matrix do_, \\\n      typename TTypes<T>::Matrix dcs, typename TTypes<T>::Matrix dci,         \\\n      typename TTypes<T>::Matrix df, typename TTypes<T>::Matrix di,           \\\n      typename TTypes<T>::Matrix dgates,                                      \\\n      typename TTypes<T>::Matrix cs_prev_grad,                                \\\n      typename TTypes<T>::Vec wci_grad, typename TTypes<T>::Vec wcf_grad,     \\\n      typename TTypes<T>::Vec wco_grad);                                      \\\n                                                                              \\\n  extern template struct LSTMBlockCellBprop<                                  \\\n      GPUDevice, T, true /* USE_CUBLAS */, GATE_LAYOUT>;                      \\\n  extern template struct LSTMBlockCellFprop<GPUDevice, T, true, GATE_LAYOUT>;\n\n#define DECLARE_GPU_SPECS(T) DECLARE_GPU_FBPROP(T, ICFO);\n\nDECLARE_GPU_SPECS(float);\nDECLARE_GPU_SPECS(Eigen::half);\n#undef DECLARE_GPU_SPECS\n#undef DECLARE_GPU_FBROP\n#endif  // GOOGLE_CUDA\n}  // namespace functor\n\ntemplate <typename Device, typename T, bool USE_CUBLAS, GateLayout gate_layout>\nclass LSTMBlockCellOp : public OpKernel {\n public:\n  explicit LSTMBlockCellOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"forget_bias\", &forget_bias_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"cell_clip\", &cell_clip_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"use_peephole\", &use_peephole_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor* x_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x_tensor));\n\n    const Tensor* cs_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n\n    const Tensor* h_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n\n    const Tensor* w_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n\n    const Tensor* wci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n\n    const Tensor* wcf_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n\n    const Tensor* wco_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n\n    const Tensor* b_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n\n    const int64_t batch_size = x_tensor->dim_size(0);\n    const int64_t input_size = x_tensor->dim_size(1);\n    const int64_t cell_size = cs_prev_tensor->dim_size(1);\n\n    // Sanity checks for our input shapes.\n    OP_REQUIRES(ctx, cs_prev_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\"cs_prev.dims(0) != batch_size: \",\n                                        cs_prev_tensor->dim_size(0), \" vs. \",\n                                        batch_size));\n    OP_REQUIRES(ctx, cs_prev_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\"cs_prev.dims(1) != cell_size: \",\n                                        cs_prev_tensor->dim_size(1), \" vs. \",\n                                        cell_size));\n\n    OP_REQUIRES(ctx, h_prev_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\"h_prev.dims(0) != batch_size: \",\n                                        h_prev_tensor->dim_size(0), \" vs. \",\n                                        batch_size));\n    OP_REQUIRES(ctx, h_prev_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\n                    \"h_prev.dims(1) != cell_size: \", h_prev_tensor->dim_size(1),\n                    \" vs. \", cell_size));\n\n    OP_REQUIRES(ctx, w_tensor->dim_size(0) == input_size + cell_size,\n                errors::InvalidArgument(\n                    \"w.dim_size(0) != input_size + cell_size: \",\n                    w_tensor->dim_size(0), \" vs. \", input_size + cell_size));\n    OP_REQUIRES(ctx, w_tensor->dim_size(1) == cell_size * 4,\n                errors::InvalidArgument(\n                    \"w.dim_size(1) != cell_size * 4: \", w_tensor->dim_size(1),\n                    \" vs. \", cell_size * 4));\n\n    OP_REQUIRES(ctx, b_tensor->dim_size(0) == cell_size * 4,\n                errors::InvalidArgument(\n                    \"b.dim_size(0) != cell_size * 4: \", b_tensor->dim_size(0),\n                    \" vs. \", cell_size * 4));\n\n    // Allocate our output tensors.\n    Tensor* i_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                            {\"h_prev\"}, \"i\",\n                            TensorShape({batch_size, cell_size}), &i_tensor));\n\n    Tensor* cs_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"cs\", TensorShape({batch_size, cell_size}),\n                                  &cs_tensor));\n\n    Tensor* f_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"f\", TensorShape({batch_size, cell_size}),\n                                  &f_tensor));\n\n    Tensor* o_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                            {\"cs_prev\"}, \"o\",\n                            TensorShape({batch_size, cell_size}), &o_tensor));\n\n    Tensor* ci_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"ci\", TensorShape({batch_size, cell_size}),\n                                  &ci_tensor));\n\n    Tensor* co_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"co\", TensorShape({batch_size, cell_size}),\n                                  &co_tensor));\n\n    Tensor* h_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"h\", TensorShape({batch_size, cell_size}),\n                                  &h_tensor));\n\n    // Allocate our temp tensors.\n    Tensor xh_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(\n                            DataTypeToEnum<T>::v(),\n                            TensorShape({batch_size, input_size + cell_size}),\n                            &xh_tensor));\n\n    Tensor gates_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                      TensorShape({batch_size, cell_size * 4}),\n                                      &gates_tensor));\n\n    const Device& device = ctx->eigen_device<Device>();\n\n    functor::LSTMBlockCellFprop<Device, T, USE_CUBLAS, gate_layout>(\n        batch_size, input_size, cell_size)(\n        ctx, device, forget_bias_, cell_clip_, use_peephole_,\n        x_tensor->matrix<T>(), cs_prev_tensor->matrix<T>(),\n        h_prev_tensor->matrix<T>(), w_tensor->matrix<T>(), wci_tensor->vec<T>(),\n        wcf_tensor->vec<T>(), wco_tensor->vec<T>(), b_tensor->vec<T>(),\n        xh_tensor.matrix<T>(), i_tensor->matrix<T>(), cs_tensor->matrix<T>(),\n        f_tensor->matrix<T>(), o_tensor->matrix<T>(), ci_tensor->matrix<T>(),\n        co_tensor->matrix<T>(), gates_tensor.matrix<T>(),\n        h_tensor->matrix<T>());\n  }\n\n private:\n  float forget_bias_;\n  float cell_clip_;\n  bool use_peephole_;\n};\n\n#define REGISTER_KERNEL(T)                                             \\\n  REGISTER_KERNEL_BUILDER(                                             \\\n      Name(\"LSTMBlockCell\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      LSTMBlockCellOp<CPUDevice, T, false, ICFO>);\n\nREGISTER_KERNEL(Eigen::half);\nREGISTER_KERNEL(float);\n#undef REGISTER_KERNEL\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define REGISTER_GPU_KERNEL(T)                                         \\\n  REGISTER_KERNEL_BUILDER(                                             \\\n      Name(\"LSTMBlockCell\").Device(DEVICE_GPU).TypeConstraint<T>(\"T\"), \\\n      LSTMBlockCellOp<GPUDevice, T, true, ICFO>);\n\nREGISTER_GPU_KERNEL(Eigen::half);\nREGISTER_GPU_KERNEL(float);\n#undef REGISTER_GPU_KERNEL\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename Device, typename T, bool USE_CUBLAS, GateLayout gate_layout>\nclass LSTMBlockCellGradOp : public OpKernel {\n public:\n  explicit LSTMBlockCellGradOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"use_peephole\", &use_peephole_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor* x_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x_tensor));\n\n    const Tensor* cs_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n\n    const Tensor* h_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n\n    const Tensor* w_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n\n    const Tensor* wci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n\n    const Tensor* wcf_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n\n    const Tensor* wco_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n\n    const Tensor* b_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n\n    const Tensor* i_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"i\", &i_tensor));\n\n    const Tensor* cs_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs\", &cs_tensor));\n\n    const Tensor* f_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"f\", &f_tensor));\n\n    const Tensor* o_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"o\", &o_tensor));\n\n    const Tensor* ci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"ci\", &ci_tensor));\n\n    const Tensor* co_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"co\", &co_tensor));\n\n    const Tensor* cs_grad_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_grad\", &cs_grad_tensor));\n\n    const Tensor* h_grad_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_grad\", &h_grad_tensor));\n\n    const int64_t batch_size = x_tensor->dim_size(0);\n    const int64_t input_size = x_tensor->dim_size(1);\n    const int64_t cell_size = cs_prev_tensor->dim_size(1);\n\n    // Sanity checks for our input shapes.\n    OP_REQUIRES(ctx, cs_prev_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\"cs_prev.dims(0) != batch_size: \",\n                                        cs_prev_tensor->dim_size(0), \" vs. \",\n                                        batch_size));\n    OP_REQUIRES(ctx, cs_prev_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\"cs_prev.dims(1) != cell_size: \",\n                                        cs_prev_tensor->dim_size(1), \" vs. \",\n                                        cell_size));\n\n    OP_REQUIRES(ctx, h_prev_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\"h_prev.dims(0) != batch_size: \",\n                                        h_prev_tensor->dim_size(0), \" vs. \",\n                                        batch_size));\n    OP_REQUIRES(ctx, h_prev_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\n                    \"h_prev.dims(1) != cell_size: \", h_prev_tensor->dim_size(1),\n                    \" vs. \", cell_size));\n\n    OP_REQUIRES(ctx, w_tensor->dim_size(0) == input_size + cell_size,\n                errors::InvalidArgument(\n                    \"w.dim_size(0) != input_size + cell_size: \",\n                    w_tensor->dim_size(0), \" vs. \", input_size + cell_size));\n    OP_REQUIRES(ctx, w_tensor->dim_size(1) == cell_size * 4,\n                errors::InvalidArgument(\n                    \"w.dim_size(1) != cell_size * 4: \", w_tensor->dim_size(1),\n                    \" vs. \", cell_size * 4));\n\n    OP_REQUIRES(ctx, b_tensor->dim_size(0) == cell_size * 4,\n                errors::InvalidArgument(\n                    \"b.dim_size(0) != cell_size * 4: \", b_tensor->dim_size(0),\n                    \" vs. \", cell_size * 4));\n\n    OP_REQUIRES(ctx, i_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\n                    \"i.dim_size(0) != batch_size: \", i_tensor->dim_size(0),\n                    \" vs. \", batch_size));\n    OP_REQUIRES(ctx, i_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\n                    \"i.dim_size(1) != cell_size: \", i_tensor->dim_size(1),\n                    \" vs. \", cell_size));\n\n    OP_REQUIRES(ctx, cs_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\n                    \"cs.dim_size(0) != batch_size: \", cs_tensor->dim_size(0),\n                    \" vs. \", batch_size));\n    OP_REQUIRES(ctx, cs_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\n                    \"cs.dim_size(1) != cell_size: \", cs_tensor->dim_size(1),\n                    \" vs. \", cell_size));\n\n    OP_REQUIRES(ctx, f_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\n                    \"f.dim_size(0) != batch_size: \", f_tensor->dim_size(0),\n                    \" vs. \", batch_size));\n    OP_REQUIRES(ctx, f_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\n                    \"i.dim_size(1) != cell_size: \", f_tensor->dim_size(1),\n                    \" vs. \", cell_size));\n\n    OP_REQUIRES(ctx, o_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\n                    \"o.dim_size(0) != batch_size: \", o_tensor->dim_size(0),\n                    \" vs. \", batch_size));\n    OP_REQUIRES(ctx, o_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\n                    \"o.dim_size(1) != cell_size: \", o_tensor->dim_size(1),\n                    \" vs. \", cell_size));\n\n    OP_REQUIRES(ctx, ci_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\n                    \"ci.dim_size(0) != batch_size: \", ci_tensor->dim_size(0),\n                    \" vs. \", batch_size));\n    OP_REQUIRES(ctx, ci_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\n                    \"ci.dim_size(1) != cell_size: \", ci_tensor->dim_size(1),\n                    \" vs. \", cell_size));\n\n    OP_REQUIRES(ctx, co_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\n                    \"co.dim_size(0) != batch_size: \", co_tensor->dim_size(0),\n                    \" vs. \", batch_size));\n    OP_REQUIRES(ctx, co_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\n                    \"co.dim_size(1) != cell_size: \", co_tensor->dim_size(1),\n                    \" vs. \", cell_size));\n\n    OP_REQUIRES(ctx, cs_grad_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\n                    \"cs_grad_tensor.dims(0) != batch_size: \",\n                    cs_grad_tensor->dim_size(0), \" vs. \", batch_size));\n    OP_REQUIRES(ctx, cs_grad_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\"cs_grad_tensor.dims(1) != cell_size: \",\n                                        cs_grad_tensor->dim_size(1), \" vs. \",\n                                        cell_size));\n\n    OP_REQUIRES(ctx, h_grad_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\"h_grad_tensor.dims(0) != batch_size: \",\n                                        h_grad_tensor->dim_size(0), \" vs. \",\n                                        batch_size));\n    OP_REQUIRES(ctx, h_grad_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\"h_grad_tensor.dims(1) != cell_size: \",\n                                        h_grad_tensor->dim_size(1), \" vs. \",\n                                        cell_size));\n\n    // Allocate our output tensors.\n    Tensor* cs_prev_grad_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->forward_input_or_allocate_output(\n                 {\"cs_grad\"}, \"cs_prev_grad\",\n                 TensorShape({batch_size, cell_size}), &cs_prev_grad_tensor));\n\n    Tensor* dgates_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\n                            \"dicfo\", TensorShape({batch_size, cell_size * 4}),\n                            &dgates_tensor));\n\n    Tensor* wci_grad_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->forward_input_or_allocate_output(\n                 {\"wci\"}, \"wci_grad\", wci_tensor->shape(), &wci_grad_tensor));\n\n    Tensor* wcf_grad_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->forward_input_or_allocate_output(\n                 {\"wcf\"}, \"wcf_grad\", wcf_tensor->shape(), &wcf_grad_tensor));\n\n    Tensor* wco_grad_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->forward_input_or_allocate_output(\n                 {\"wco\"}, \"wco_grad\", wco_tensor->shape(), &wco_grad_tensor));\n\n    // Allocate our temp tensors.\n    Tensor do_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           TensorShape({batch_size, cell_size}),\n                                           &do_tensor));\n\n    Tensor dcs_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           TensorShape({batch_size, cell_size}),\n                                           &dcs_tensor));\n\n    Tensor dci_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           TensorShape({batch_size, cell_size}),\n                                           &dci_tensor));\n\n    Tensor df_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           TensorShape({batch_size, cell_size}),\n                                           &df_tensor));\n\n    Tensor di_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           TensorShape({batch_size, cell_size}),\n                                           &di_tensor));\n\n    const Device& device = ctx->eigen_device<Device>();\n\n    functor::TensorZero<Device, T>()(device, wci_grad_tensor->flat<T>());\n    functor::TensorZero<Device, T>()(device, wcf_grad_tensor->flat<T>());\n    functor::TensorZero<Device, T>()(device, wco_grad_tensor->flat<T>());\n\n    functor::LSTMBlockCellBprop<Device, T, USE_CUBLAS, gate_layout>(\n        batch_size, input_size, cell_size)(\n        ctx, device, use_peephole_, x_tensor->matrix<T>(),\n        cs_prev_tensor->matrix<T>(), h_prev_tensor->matrix<T>(),\n        w_tensor->matrix<T>(), wci_tensor->vec<T>(), wcf_tensor->vec<T>(),\n        wco_tensor->vec<T>(), b_tensor->vec<T>(), i_tensor->matrix<T>(),\n        cs_tensor->matrix<T>(), f_tensor->matrix<T>(), o_tensor->matrix<T>(),\n        ci_tensor->matrix<T>(), co_tensor->matrix<T>(),\n        cs_grad_tensor->matrix<T>(), h_grad_tensor->matrix<T>(),\n        do_tensor.matrix<T>(), dcs_tensor.matrix<T>(), dci_tensor.matrix<T>(),\n        df_tensor.matrix<T>(), di_tensor.matrix<T>(),\n        dgates_tensor->matrix<T>(), cs_prev_grad_tensor->matrix<T>(),\n        wci_grad_tensor->vec<T>(), wcf_grad_tensor->vec<T>(),\n        wco_grad_tensor->vec<T>());\n  }\n\n protected:\n  bool use_peephole_;\n};\n\n#define REGISTER_KERNEL(T)                                                 \\\n  REGISTER_KERNEL_BUILDER(                                                 \\\n      Name(\"LSTMBlockCellGrad\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      LSTMBlockCellGradOp<CPUDevice, T, false, ICFO>);\nREGISTER_KERNEL(float);\nREGISTER_KERNEL(Eigen::half);\n#undef REGISTER_KERNEL\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define REGISTER_GPU_KERNEL(T)                                             \\\n  REGISTER_KERNEL_BUILDER(                                                 \\\n      Name(\"LSTMBlockCellGrad\").Device(DEVICE_GPU).TypeConstraint<T>(\"T\"), \\\n      LSTMBlockCellGradOp<GPUDevice, T, true, ICFO>);\n\nREGISTER_GPU_KERNEL(Eigen::half);\nREGISTER_GPU_KERNEL(float);\n#undef REGISTER_GPU_KERNEL\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace {\n\n// This helper class can be used to access timeslices of a 3D tensor. If a slice\n// happens to be unaligned (usually because both batch size and number of cells\n// are odd - this isn't common) this involves overhead, since data needs to be\n// copied. However, if all slices are aligned, the bits aren't copied. In the\n// cases where copying is needed, the outputs have to be recopied back.\n// At the end of each time step you should call FinishTimeStep which does this,\n// and also allows for reuse of temporary tensors.\ntemplate <typename Device, typename T>\nclass SliceHelper {\n public:\n  explicit SliceHelper(OpKernelContext* ctx)\n      : ctx_(ctx), device_(ctx_->eigen_device<Device>()) {}\n\n  ~SliceHelper() {\n    CHECK(copy_out_.empty());\n    for (const auto& entry : pool_) {\n      CHECK(!entry.second.second);  // nothing is in use\n    }\n  }\n\n  // Slice through an input tensor. This may copy unaligned slices, but no\n  // copying back will be done at the end.\n  const Tensor InputSlice(const Tensor& t, int pos, const string& name) {\n    Tensor res = UnalignedSlice(t, pos);\n    if (res.IsAligned()) {\n      return res;\n    } else {\n      return AlignTensor(res, name);\n    }\n  }\n\n  // Slice through an output tensor. This may copy unaligned slices, and\n  // schedule copying back on destruction.\n  Tensor OutputSlice(Tensor* t, int pos, const string& name) {\n    Tensor res = UnalignedSlice(*t, pos);\n    if (res.IsAligned()) {\n      return res;\n    } else {\n      Tensor aligned = AlignTensor(res, name);\n      copy_out_.emplace_back(res, aligned);\n      return aligned;\n    }\n  }\n\n  void FinishTimeStep() {\n    for (const auto& p : copy_out_) {\n      const Tensor& aligned = p.second;\n      Tensor original = p.first;\n      // Copy from aligned back to original.\n      functor::TensorCopyToUnaligned<Device, T>()(device_, aligned.flat<T>(),\n                                                  original.unaligned_flat<T>());\n    }\n    copy_out_.clear();\n    // Mark all entries as not in use.\n    for (auto& entry : pool_) {\n      entry.second.second = false;\n    }\n  }\n\n private:\n  // Return a slice at position 'pos'. Result may be unaligned. The resulting\n  // tensor always shares data with the source tensor.\n  Tensor UnalignedSlice(const Tensor& t, int pos) const {\n    Tensor res;\n    // CHECK should never fail here, since the number of elements must match\n    CHECK(res.CopyFrom(t.Slice(pos, pos + 1), {t.dim_size(1), t.dim_size(2)}));\n    return res;\n  }\n\n  // Assumes input is not aligned, creates a temporary aligned tensor of the\n  // same shape and copies the original tensor's content into it.\n  Tensor AlignTensor(const Tensor& t, const string& name) {\n    VLOG(1) << \"AlignTensor called for \" << name << \", shape \"\n            << t.shape().DebugString()\n            << \". This is unnecessary copying. Consider using shapes with even \"\n            << \"sizes\";\n    Tensor aligned;\n    auto found = pool_.find(name);\n    if (found != pool_.end()) {  // found in pool\n      CHECK(!found->second.second) << \"Tensor \" << name << \" is in use\";\n      found->second.second = true;  // mark in use\n      aligned = found->second.first;\n      CHECK(aligned.shape().IsSameSize(t.shape()));\n      CHECK_EQ(aligned.dtype(), t.dtype());\n    } else {  // allocate a new temporary tensor\n      TF_CHECK_OK(ctx_->allocate_temp(t.dtype(), t.shape(), &aligned));\n      pool_.emplace(name, std::make_pair(aligned, true));\n    }\n    functor::TensorCopyUnaligned<Device, T>()(device_, t.unaligned_flat<T>(),\n                                              aligned.flat<T>());\n    return aligned;\n  }\n\n  // Tensors to be copied.\n  std::vector<std::pair<Tensor, const Tensor>> copy_out_;\n  // A pool of pre-allocated temporary tensors, with an indicator for whether\n  // it's in use.\n  std::map<string, std::pair<Tensor, bool>> pool_;\n  // Op context\n  OpKernelContext* ctx_ = nullptr;\n  // Device\n  const Device& device_;\n};\n\n}  // namespace\n\ntemplate <typename Device, typename T, bool USE_CUBLAS, GateLayout gate_layout>\nclass BlockLSTMOp : public OpKernel {\n public:\n  explicit BlockLSTMOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    if (ctx->HasAttr(\"forget_bias\")) {\n      OP_REQUIRES_OK(ctx, ctx->GetAttr(\"forget_bias\", &forget_bias_));\n    } else {\n      // V2 version does not have \"forget_bias\" attribute.\n      forget_bias_ = 0.0;\n    }\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"cell_clip\", &cell_clip_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"use_peephole\", &use_peephole_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor* seq_len_max_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"seq_len_max\", &seq_len_max_tensor));\n\n    const Tensor* x;\n    OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x));\n    OP_REQUIRES(ctx, x->dims() == 3, errors::InvalidArgument(\"x must be 3D\"));\n    const int64_t timelen = x->dim_size(0);\n    const int64_t batch_size = x->dim_size(1);\n    const int64_t input_size = x->dim_size(2);\n\n    const Tensor* cs_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n    OP_REQUIRES(ctx, cs_prev_tensor->dims() == 2,\n                errors::InvalidArgument(\"cs_prev must be 2D\"));\n    OP_REQUIRES(ctx, cs_prev_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\"cs_prev.dims(0) != batch_size: \",\n                                        cs_prev_tensor->dim_size(0), \" vs. \",\n                                        batch_size));\n    const int64_t cell_size = cs_prev_tensor->dim_size(1);\n\n    if (batch_size * input_size % 2 == 1) {\n      LOG(WARNING) << \"BlockLSTMOp is inefficient when both batch_size and \"\n                   << \"input_size are odd. You are using: batch_size=\"\n                   << batch_size << \", input_size=\" << input_size;\n    }\n    if (batch_size * cell_size % 2 == 1) {\n      LOG(WARNING) << \"BlockLSTMOp is inefficient when both batch_size and \"\n                   << \"cell_size are odd. You are using: batch_size=\"\n                   << batch_size << \", cell_size=\" << cell_size;\n    }\n\n    const Tensor* h_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n    OP_REQUIRES(ctx, h_prev_tensor->dims() == 2,\n                errors::InvalidArgument(\"h_prev must be 2D\"));\n    OP_REQUIRES(ctx, h_prev_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\"h_prev.dims(0) != batch_size: \",\n                                        h_prev_tensor->dim_size(0), \" vs. \",\n                                        batch_size));\n    OP_REQUIRES(ctx, h_prev_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\n                    \"h_prev.dims(1) != cell_size: \", h_prev_tensor->dim_size(1),\n                    \" vs. \", cell_size));\n\n    const Tensor* w_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n    OP_REQUIRES(ctx, w_tensor->dims() == 2,\n                errors::InvalidArgument(\"w must be 2D\"));\n    OP_REQUIRES(ctx, w_tensor->dim_size(0) == input_size + cell_size,\n                errors::InvalidArgument(\n                    \"w.dim_size(0) != input_size + cell_size: \",\n                    w_tensor->dim_size(0), \" vs. \", input_size + cell_size));\n    OP_REQUIRES(ctx, w_tensor->dim_size(1) == cell_size * 4,\n                errors::InvalidArgument(\n                    \"w.dim_size(1) != cell_size * 4: \", w_tensor->dim_size(1),\n                    \" vs. \", cell_size * 4));\n\n    const Tensor* wci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n    OP_REQUIRES(ctx, wci_tensor->dims() == 1,\n                errors::InvalidArgument(\"wci must be 1D\"));\n    OP_REQUIRES(ctx, wci_tensor->dim_size(0) == cell_size,\n                errors::InvalidArgument(\n                    \"wci.dim_size(0) != cell_size: \", wci_tensor->dim_size(0),\n                    \" vs. \", cell_size));\n\n    const Tensor* wcf_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n    OP_REQUIRES(ctx, wcf_tensor->dims() == 1,\n                errors::InvalidArgument(\"wcf must be 1D\"));\n    OP_REQUIRES(ctx, wcf_tensor->dim_size(0) == cell_size,\n                errors::InvalidArgument(\n                    \"wcf.dim_size(0) != cell_size: \", wcf_tensor->dim_size(0),\n                    \" vs. \", cell_size));\n\n    const Tensor* wco_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n    OP_REQUIRES(ctx, wco_tensor->dims() == 1,\n                errors::InvalidArgument(\"wco must be 1D\"));\n    OP_REQUIRES(ctx, wco_tensor->dim_size(0) == cell_size,\n                errors::InvalidArgument(\n                    \"wco.dim_size(0) != cell_size: \", wco_tensor->dim_size(0),\n                    \" vs. \", cell_size));\n\n    const Tensor* b_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n    OP_REQUIRES(ctx, b_tensor->dims() == 1,\n                errors::InvalidArgument(\"b must be 1D\"));\n    OP_REQUIRES(ctx, b_tensor->dim_size(0) == cell_size * 4,\n                errors::InvalidArgument(\n                    \"b.dim_size(0) != cell_size * 4: \", b_tensor->dim_size(0),\n                    \" vs. \", cell_size * 4));\n\n    TensorShape batch_cell_shape({timelen, batch_size, cell_size});\n    Tensor* i_out;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"i\", batch_cell_shape, &i_out));\n\n    Tensor* cs_out;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"cs\", batch_cell_shape, &cs_out));\n\n    Tensor* f_out;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"f\", batch_cell_shape, &f_out));\n\n    Tensor* o_out;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"o\", batch_cell_shape, &o_out));\n\n    Tensor* ci_out;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"ci\", batch_cell_shape, &ci_out));\n\n    Tensor* co_out;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"co\", batch_cell_shape, &co_out));\n\n    Tensor* h_out;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"h\", batch_cell_shape, &h_out));\n\n    Tensor xh_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(\n                            DataTypeToEnum<T>::v(),\n                            TensorShape({batch_size, input_size + cell_size}),\n                            &xh_tensor));\n\n    Tensor gates_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                      TensorShape({batch_size, cell_size * 4}),\n                                      &gates_tensor));\n\n    const Device& device = ctx->eigen_device<Device>();\n\n    const int64_t seq_len_max = seq_len_max_tensor->scalar<int64_t>()();\n    SliceHelper<Device, T> slicer(ctx);\n    for (int64_t t = 0; t < seq_len_max; ++t) {\n      const Tensor x_tensor = slicer.InputSlice(*x, t, \"x\");\n      const Tensor& cs_prev_tensor2 =\n          t == 0 ? *cs_prev_tensor\n                 : slicer.OutputSlice(cs_out, t - 1, \"cs_prev\");\n      const Tensor& h_prev_tensor2 =\n          t == 0 ? *h_prev_tensor : slicer.OutputSlice(h_out, t - 1, \"h_prev\");\n\n      Tensor i_tensor = slicer.OutputSlice(i_out, t, \"i_out\");\n      Tensor cs_tensor = slicer.OutputSlice(cs_out, t, \"cs_out\");\n      Tensor f_tensor = slicer.OutputSlice(f_out, t, \"f_out\");\n      Tensor o_tensor = slicer.OutputSlice(o_out, t, \"o_out\");\n      Tensor ci_tensor = slicer.OutputSlice(ci_out, t, \"ci_out\");\n      Tensor co_tensor = slicer.OutputSlice(co_out, t, \"co_out\");\n      Tensor h_tensor = slicer.OutputSlice(h_out, t, \"h_out\");\n\n      functor::LSTMBlockCellFprop<Device, T, USE_CUBLAS, gate_layout>(\n          batch_size, input_size, cell_size)(\n          ctx, device, forget_bias_, cell_clip_, use_peephole_,\n          x_tensor.matrix<T>(), cs_prev_tensor2.matrix<T>(),\n          h_prev_tensor2.matrix<T>(), w_tensor->matrix<T>(),\n          wci_tensor->vec<T>(), wcf_tensor->vec<T>(), wco_tensor->vec<T>(),\n          b_tensor->vec<T>(), xh_tensor.matrix<T>(), i_tensor.matrix<T>(),\n          cs_tensor.matrix<T>(), f_tensor.matrix<T>(), o_tensor.matrix<T>(),\n          ci_tensor.matrix<T>(), co_tensor.matrix<T>(),\n          gates_tensor.matrix<T>(), h_tensor.matrix<T>());\n      slicer.FinishTimeStep();\n    }\n\n    if (seq_len_max < timelen) {\n      Tensor cs_tensor = cs_out->Slice(seq_len_max, timelen);\n      Tensor h_tensor = h_out->Slice(seq_len_max, timelen);\n\n      functor::TensorUnalignedZero<Device, T>()(device,\n                                                cs_tensor.unaligned_flat<T>());\n      functor::TensorUnalignedZero<Device, T>()(device,\n                                                h_tensor.unaligned_flat<T>());\n    }\n  }\n\n private:\n  float forget_bias_;\n  float cell_clip_;\n  bool use_peephole_;\n};\n\n#define REGISTER_KERNEL(T)                                           \\\n  REGISTER_KERNEL_BUILDER(                                           \\\n      Name(\"BlockLSTM\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"),   \\\n      BlockLSTMOp<CPUDevice, T, false, ICFO>);                       \\\n  REGISTER_KERNEL_BUILDER(                                           \\\n      Name(\"BlockLSTMV2\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      BlockLSTMOp<CPUDevice, T, false, IFCO>);\n\nREGISTER_KERNEL(Eigen::half);\nREGISTER_KERNEL(float);\n#undef REGISTER_KERNEL\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\nnamespace functor {\n#define DECLARE_GPU_SPECS(T)                                             \\\n  template <>                                                            \\\n  void TensorZero<GPUDevice, T>::operator()(const GPUDevice& d,          \\\n                                            typename TTypes<T>::Flat t); \\\n                                                                         \\\n  extern template struct TensorZero<GPUDevice, T>;                       \\\n                                                                         \\\n  template <>                                                            \\\n  void TensorUnalignedZero<GPUDevice, T>::operator()(                    \\\n      const GPUDevice& d, typename TTypes<T>::UnalignedFlat t);          \\\n                                                                         \\\n  extern template struct TensorUnalignedZero<GPUDevice, T>;\n\nDECLARE_GPU_SPECS(Eigen::half);\nDECLARE_GPU_SPECS(float);\n#undef DECLARE_GPU_SPECS\n}  // end namespace functor\n\n#define REGISTER_GPU_KERNEL(T)                                    \\\n  REGISTER_KERNEL_BUILDER(Name(\"BlockLSTM\")                       \\\n                              .Device(DEVICE_GPU)                 \\\n                              .HostMemory(\"seq_len_max\")          \\\n                              .TypeConstraint<T>(\"T\"),            \\\n                          BlockLSTMOp<GPUDevice, T, true, ICFO>); \\\n  REGISTER_KERNEL_BUILDER(Name(\"BlockLSTMV2\")                     \\\n                              .Device(DEVICE_GPU)                 \\\n                              .HostMemory(\"seq_len_max\")          \\\n                              .TypeConstraint<T>(\"T\"),            \\\n                          BlockLSTMOp<GPUDevice, T, true, IFCO>);\n\nREGISTER_GPU_KERNEL(Eigen::half);\nREGISTER_GPU_KERNEL(float);\n#undef REGISTER_GPU_KERNEL\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename Device, typename T, bool USE_CUBLAS, GateLayout gate_layout>\nclass BlockLSTMGradOp : public OpKernel {\n public:\n  explicit BlockLSTMGradOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"use_peephole\", &use_peephole_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor* seq_len_max_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"seq_len_max\", &seq_len_max_tensor));\n\n    const Tensor* x;\n    OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x));\n    OP_REQUIRES(ctx, x->dims() == 3, errors::InvalidArgument(\"x must be 3D\"));\n    const int64_t timelen = x->dim_size(0);\n    const int64_t batch_size = x->dim_size(1);\n    const int64_t input_size = x->dim_size(2);\n\n    const Tensor* cs_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n\n    const Tensor* h_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n\n    const Tensor* w_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n    const int64_t cell_size = w_tensor->dim_size(1) / 4;\n    OP_REQUIRES(ctx, input_size + cell_size == w_tensor->dim_size(0),\n                errors::InvalidArgument(\n                    \"w matrix rows don't match: \", input_size + cell_size,\n                    \" vs. \", w_tensor->dim_size(0)));\n\n    const Tensor* wci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n\n    const Tensor* wcf_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n\n    const Tensor* wco_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n\n    const Tensor* b_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n    OP_REQUIRES(\n        ctx, cell_size == b_tensor->dim_size(0) / 4,\n        errors::InvalidArgument(\"w and b cell_size don't match: \", cell_size,\n                                \" vs. \", b_tensor->dim_size(0)));\n\n    const Tensor* i_out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"i\", &i_out));\n\n    const Tensor* cs_out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs\", &cs_out));\n\n    const Tensor* f_out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"f\", &f_out));\n\n    const Tensor* o_out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"o\", &o_out));\n\n    const Tensor* ci_out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"ci\", &ci_out));\n\n    const Tensor* co_out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"co\", &co_out));\n\n    const Tensor* h_out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h\", &h_out));\n\n    const Tensor* cs_grad = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_grad\", &cs_grad));\n\n    const Tensor* h_grad = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_grad\", &h_grad));\n\n    TensorShape batch_input_shape({timelen, batch_size, input_size});\n    Tensor* x_grad;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(\"x_grad\", batch_input_shape, &x_grad));\n\n    Tensor* cs_prev_grad_tensor = nullptr;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(\"cs_prev_grad\", cs_prev_tensor->shape(),\n                                        &cs_prev_grad_tensor));\n\n    Tensor* h_prev_grad_tensor = nullptr;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(\"h_prev_grad\", h_prev_tensor->shape(),\n                                        &h_prev_grad_tensor));\n\n    Tensor* w_grad_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"w_grad\", w_tensor->shape(), &w_grad_tensor));\n\n    Tensor* wci_grad_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"wci_grad\", wci_tensor->shape(),\n                                             &wci_grad_tensor));\n\n    Tensor* wcf_grad_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"wcf_grad\", wcf_tensor->shape(),\n                                             &wcf_grad_tensor));\n\n    Tensor* wco_grad_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"wco_grad\", wco_tensor->shape(),\n                                             &wco_grad_tensor));\n\n    Tensor* b_grad_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"b_grad\", b_tensor->shape(), &b_grad_tensor));\n\n    TensorShape batch_cell_shape({batch_size, cell_size});\n\n    Tensor xh_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(\n                            DataTypeToEnum<T>::v(),\n                            TensorShape({batch_size, input_size + cell_size}),\n                            &xh_tensor));\n\n    Tensor xh_grad_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           xh_tensor.shape(), &xh_grad_tensor));\n\n    Tensor do_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           batch_cell_shape, &do_tensor));\n\n    Tensor dcs_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           batch_cell_shape, &dcs_tensor));\n\n    Tensor dci_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           batch_cell_shape, &dci_tensor));\n\n    Tensor df_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           batch_cell_shape, &df_tensor));\n\n    Tensor di_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           batch_cell_shape, &di_tensor));\n\n    Tensor dgates_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                      TensorShape({batch_size, cell_size * 4}),\n                                      &dgates_tensor));\n\n    Tensor cs_grad_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           batch_cell_shape, &cs_grad_tensor));\n\n    Tensor h_grad_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                           batch_cell_shape, &h_grad_tensor));\n\n    const Device& device = ctx->eigen_device<Device>();\n\n    functor::TensorZero<Device, T>()(device, cs_grad_tensor.flat<T>());\n    functor::TensorZero<Device, T>()(device, cs_prev_grad_tensor->flat<T>());\n    functor::TensorZero<Device, T>()(device, h_grad_tensor.flat<T>());\n    functor::TensorZero<Device, T>()(device, h_prev_grad_tensor->flat<T>());\n    functor::TensorZero<Device, T>()(device, w_grad_tensor->flat<T>());\n    functor::TensorZero<Device, T>()(device, wci_grad_tensor->flat<T>());\n    functor::TensorZero<Device, T>()(device, wcf_grad_tensor->flat<T>());\n    functor::TensorZero<Device, T>()(device, wco_grad_tensor->flat<T>());\n    functor::TensorZero<Device, T>()(device, b_grad_tensor->flat<T>());\n\n    const int64_t seq_len_max = seq_len_max_tensor->scalar<int64_t>()();\n    SliceHelper<Device, T> slicer(ctx);\n    for (int64_t t = seq_len_max - 1; t >= 0; --t) {\n      const Tensor& x_tensor = slicer.InputSlice(*x, t, \"x\");\n      const Tensor& cs_prev_tensor2 =\n          t == 0 ? *cs_prev_tensor\n                 : slicer.InputSlice(*cs_out, t - 1, \"cs_prev\");\n      const Tensor& h_prev_tensor2 =\n          t == 0 ? *h_prev_tensor : slicer.InputSlice(*h_out, t - 1, \"h_prev\");\n      const Tensor& i_tensor = slicer.InputSlice(*i_out, t, \"i_out\");\n      const Tensor& cs_tensor = slicer.InputSlice(*cs_out, t, \"cs_out\");\n      const Tensor& f_tensor = slicer.InputSlice(*f_out, t, \"f_out\");\n      const Tensor& o_tensor = slicer.InputSlice(*o_out, t, \"o_out\");\n      const Tensor& ci_tensor = slicer.InputSlice(*ci_out, t, \"ci_out\");\n      const Tensor& co_tensor = slicer.InputSlice(*co_out, t, \"co_out\");\n\n      // Grab previous CS grad.\n      const Tensor& const_cs_prev_grad_tensor = *cs_prev_grad_tensor;\n      const Tensor const_cs_grad_slice =\n          slicer.InputSlice(*cs_grad, t, \"cs_grad\");\n      functor::TensorAdd<Device, T>()(\n          device, const_cs_prev_grad_tensor.flat<T>(),\n          const_cs_grad_slice.flat<T>(), cs_grad_tensor.flat<T>());\n\n      // Combine previous h grad and h grad coming on top.\n      const Tensor& const_h_prev_grad_tensor = *h_prev_grad_tensor;\n      const Tensor const_h_grad_slice = slicer.InputSlice(*h_grad, t, \"h_grad\");\n      functor::TensorAdd<Device, T>()(\n          device, const_h_prev_grad_tensor.flat<T>(),\n          const_h_grad_slice.flat<T>(), h_grad_tensor.flat<T>());\n\n      const Tensor& const_cs_grad_tensor = cs_grad_tensor;\n      const Tensor& const_h_grad_tensor = h_grad_tensor;\n\n      Tensor x_grad_tensor = slicer.OutputSlice(x_grad, t, \"x_grad\");\n      functor::BlockLSTMBprop<Device, T, USE_CUBLAS, gate_layout>(\n          batch_size, input_size, cell_size)(\n          ctx, device, use_peephole_, x_tensor.matrix<T>(),\n          cs_prev_tensor2.matrix<T>(), h_prev_tensor2.matrix<T>(),\n          w_tensor->matrix<T>(), wci_tensor->vec<T>(), wcf_tensor->vec<T>(),\n          wco_tensor->vec<T>(), b_tensor->vec<T>(), xh_tensor.matrix<T>(),\n          i_tensor.matrix<T>(), cs_tensor.matrix<T>(), f_tensor.matrix<T>(),\n          o_tensor.matrix<T>(), ci_tensor.matrix<T>(), co_tensor.matrix<T>(),\n          const_cs_grad_tensor.matrix<T>(), const_h_grad_tensor.matrix<T>(),\n          do_tensor.matrix<T>(), dcs_tensor.matrix<T>(), dci_tensor.matrix<T>(),\n          df_tensor.matrix<T>(), di_tensor.matrix<T>(),\n          dgates_tensor.matrix<T>(), cs_prev_grad_tensor->matrix<T>(),\n          h_prev_grad_tensor->matrix<T>(), xh_grad_tensor.matrix<T>(),\n          x_grad_tensor.matrix<T>(), w_grad_tensor->matrix<T>(),\n          wci_grad_tensor->vec<T>(), wcf_grad_tensor->vec<T>(),\n          wco_grad_tensor->vec<T>(), b_grad_tensor->vec<T>());\n      slicer.FinishTimeStep();\n    }\n\n    if (seq_len_max < timelen) {\n      Tensor x_grad_tensor = x_grad->Slice(seq_len_max, timelen);\n      functor::TensorUnalignedZero<Device, T>()(\n          device, x_grad_tensor.unaligned_flat<T>());\n    }\n  }\n\n private:\n  bool use_peephole_;\n};\n\n#define REGISTER_KERNEL(T)                                               \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"BlockLSTMGrad\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"),   \\\n      BlockLSTMGradOp<CPUDevice, T, false, ICFO>);                       \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"BlockLSTMGradV2\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      BlockLSTMGradOp<CPUDevice, T, false, IFCO>);\n\nREGISTER_KERNEL(Eigen::half);\nREGISTER_KERNEL(float);\n#undef REGISTER_KERNEL\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\nnamespace functor {\n#define DECLARE_GPU_BPROP(T, GATE_LAYOUT)                                     \\\n  template <>                                                                 \\\n  void BlockLSTMBprop<GPUDevice, T, true, GATE_LAYOUT>::operator()(           \\\n      OpKernelContext* ctx, const GPUDevice& d, bool use_peephole,            \\\n      typename TTypes<T>::ConstMatrix x,                                      \\\n      typename TTypes<T>::ConstMatrix cs_prev,                                \\\n      typename TTypes<T>::ConstMatrix h_prev,                                 \\\n      typename TTypes<T>::ConstMatrix w, typename TTypes<T>::ConstVec wci,    \\\n      typename TTypes<T>::ConstVec wcf, typename TTypes<T>::ConstVec wco,     \\\n      typename TTypes<T>::ConstVec b, typename TTypes<T>::Matrix xh,          \\\n      typename TTypes<T>::ConstMatrix i, typename TTypes<T>::ConstMatrix cs,  \\\n      typename TTypes<T>::ConstMatrix f, typename TTypes<T>::ConstMatrix o,   \\\n      typename TTypes<T>::ConstMatrix ci, typename TTypes<T>::ConstMatrix co, \\\n      typename TTypes<T>::ConstMatrix cs_grad,                                \\\n      typename TTypes<T>::ConstMatrix h_grad, typename TTypes<T>::Matrix do_, \\\n      typename TTypes<T>::Matrix dcs, typename TTypes<T>::Matrix dci,         \\\n      typename TTypes<T>::Matrix df, typename TTypes<T>::Matrix di,           \\\n      typename TTypes<T>::Matrix dgates,                                      \\\n      typename TTypes<T>::Matrix cs_prev_grad,                                \\\n      typename TTypes<T>::Matrix h_prev_grad,                                 \\\n      typename TTypes<T>::Matrix xh_grad, typename TTypes<T>::Matrix x_grad,  \\\n      typename TTypes<T>::Matrix w_grad, typename TTypes<T>::Vec wci_grad,    \\\n      typename TTypes<T>::Vec wcf_grad, typename TTypes<T>::Vec wco_grad,     \\\n      typename TTypes<T>::Vec b_grad);                                        \\\n  extern template struct BlockLSTMBprop<GPUDevice, T, true, GATE_LAYOUT>;\n\n#define DECLARE_GPU_SPECS(T)                                                   \\\n  template <>                                                                  \\\n  void TensorCopy<GPUDevice, T>::operator()(const GPUDevice& d,                \\\n                                            typename TTypes<T>::ConstFlat src, \\\n                                            typename TTypes<T>::Flat dst);     \\\n                                                                               \\\n  template <>                                                                  \\\n  void TensorCopyUnaligned<GPUDevice, T>::operator()(                          \\\n      const GPUDevice& d, typename TTypes<T>::UnalignedConstFlat src,          \\\n      typename TTypes<T>::Flat dst);                                           \\\n                                                                               \\\n  template <>                                                                  \\\n  void TensorCopyToUnaligned<GPUDevice, T>::operator()(                        \\\n      const GPUDevice& d, typename TTypes<T>::ConstFlat src,                   \\\n      typename TTypes<T>::UnalignedFlat dst);                                  \\\n                                                                               \\\n  template <>                                                                  \\\n  void TensorAdd<GPUDevice, T>::operator()(                                    \\\n      const GPUDevice& d, typename TTypes<T>::ConstFlat a,                     \\\n      typename TTypes<T>::ConstFlat b, typename TTypes<T>::Flat c);            \\\n                                                                               \\\n  extern template struct TensorCopy<GPUDevice, T>;                             \\\n  extern template struct TensorAdd<GPUDevice, T>;                              \\\n                                                                               \\\n  DECLARE_GPU_BPROP(T, ICFO);                                                  \\\n  DECLARE_GPU_BPROP(T, IFCO);\n\nDECLARE_GPU_SPECS(Eigen::half);\nDECLARE_GPU_SPECS(float);\n#undef DECLARE_GPU_SPECS\n#undef DECLARE_GPU_BPROP\n}  // end namespace functor\n\n#define REGISTER_GPU_KERNEL(T)                                        \\\n  REGISTER_KERNEL_BUILDER(Name(\"BlockLSTMGrad\")                       \\\n                              .Device(DEVICE_GPU)                     \\\n                              .HostMemory(\"seq_len_max\")              \\\n                              .TypeConstraint<T>(\"T\"),                \\\n                          BlockLSTMGradOp<GPUDevice, T, true, ICFO>); \\\n  REGISTER_KERNEL_BUILDER(Name(\"BlockLSTMGradV2\")                     \\\n                              .Device(DEVICE_GPU)                     \\\n                              .HostMemory(\"seq_len_max\")              \\\n                              .TypeConstraint<T>(\"T\"),                \\\n                          BlockLSTMGradOp<GPUDevice, T, true, IFCO>);\n\nREGISTER_GPU_KERNEL(Eigen::half);\nREGISTER_GPU_KERNEL(float);\n#undef REGISTER_GPU_KERNEL\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // end namespace tensorflow"