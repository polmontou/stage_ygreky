"# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functional tests for quantized convolutional operations.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.ops import nn_ops\nfrom tensorflow.python.platform import test\n\n\nclass Conv2DTest(test.TestCase):\n\n  def __init__(self, method_name=\"runTest\"):\n    super(Conv2DTest, self).__init__(method_name)\n\n  def _VerifyValues(self, tensor_in_sizes, filter_in_sizes, stride, padding,\n                    expected):\n    \"\"\"Verifies the output values of the convolution function.\n\n    Args:\n      tensor_in_sizes: Input tensor dimensions in\n        [batch, input_rows, input_cols, input_depth].\n      filter_in_sizes: Filter tensor dimensions in\n        [kernel_rows, kernel_cols, input_depth, output_depth].\n      stride: Stride.\n      padding: Padding type.\n      expected: An array containing the expected operation outputs.\n    \"\"\"\n    total_size_1 = 1\n    total_size_2 = 1\n    for s in tensor_in_sizes:\n      total_size_1 *= s\n    for s in filter_in_sizes:\n      total_size_2 *= s\n    # Initializes the input tensor with array containing incrementing\n    # numbers from 1.\n    x1 = np.array([f for f in range(1, total_size_1 + 1)])\n    x1 = x1.astype(np.uint8).reshape(tensor_in_sizes)\n    x1_min = 0.0\n    x1_max = 255.0\n    x2 = np.array([f for f in range(1, total_size_2 + 1)]).astype(np.uint8)\n    x2 = x2.astype(np.uint8).reshape(filter_in_sizes)\n    x2_min = 0.0\n    x2_max = 255.0\n    with self.cached_session(use_gpu=False) as sess:\n      t1 = constant_op.constant(x1, shape=tensor_in_sizes, dtype=dtypes.quint8)\n      t2 = constant_op.constant(x2, shape=filter_in_sizes, dtype=dtypes.quint8)\n      conv = nn_ops.quantized_conv2d(\n          t1,\n          t2,\n          out_type=dtypes.qint32,\n          strides=[1, stride, stride, 1],\n          padding=padding,\n          min_input=x1_min,\n          max_input=x1_max,\n          min_filter=x2_min,\n          max_filter=x2_max)\n      value = self.evaluate(conv)\n    quantized_output = value[0]\n    output_min = value[1]\n    output_max = value[2]\n    float_output = self._QuantizedOutputToFloat(quantized_output, output_min,\n                                                output_max)\n    self.assertArrayNear(expected, float_output.flatten(), 1.0)\n    self.assertEqual(value[0].shape, conv[0].get_shape())\n\n  def _assertQuantizedArrayEquals(self, iarray1, iarray2):\n    for i1, i2 in zip(iarray1, iarray2):\n      self.assertTrue(i1 == i2)\n\n  def _QuantizedOutputToFloat(self, quantized, quantized_min, quantized_max):\n    number_of_bits = 32\n    number_of_steps = 1 << number_of_bits\n    range_adjust = (number_of_steps / (number_of_steps - 1.0))\n    quantized_range = ((quantized_max - quantized_min) * range_adjust)\n    range_scale = (quantized_range / number_of_steps)\n    lowest_quantized = -(1 << (number_of_bits - 1))\n    result = np.array([(quantized_min +\n                        ((float(x) - lowest_quantized) * range_scale))\n                       for x in quantized.flatten()])\n    return result\n\n  def testConv2D1x1Filter(self):\n    # Our generated input is [batch, rows, cols, depth], and looks like this:\n    # (1,2,3)    (4,5,6)    (7,8,9)\n    # (10,11,12) (13,14,15) (16,17,18)\n    # The filter data is:\n    # (1,4,7) (2,5,8) (3,6,9)\n    # That means the calculations are:\n    # 1*1+2*4+3*7=30\n    # 1*2+2*5+3*8=36\n    # 1*3+2*6+3*9=42\n    # 4*1+5*4+6*7=66\n    # 4*2+5*5+6*8=81\n    # 4*3+5*6+6*9=96\n    # 7*1+5*8+6*9=102\n    # 7*2+8*5+9*8=126\n    # 7*3+8*6+9*9=150\n    # 10*1+11*4+12*7=138\n    # 10*2+11*5+12*8=171\n    # 10*3+11*6+12*9=204\n    # 13*1+14*4+15*7=174\n    # 13*2+14*5+15*8=216\n    # 13*3+14*6+15*9=258, clamped to 255\n    # 16*1+17*4+18*7=210\n    # 16*2+17*5+18*8=261, clamped to 255\n    # 16*3+17*6+18*9=312, clamped to 255\n    # Because the output shift is zero, we call the non-optimized reference\n    # path for the convolution.\n    expected_output = [\n        30, 36, 42, 66, 81, 96, 102, 126, 150, 138, 171, 204, 174, 216, 258,\n        210, 261, 312\n    ]\n    self._VerifyValues(\n        tensor_in_sizes=[1, 2, 3, 3],\n        filter_in_sizes=[1, 1, 3, 3],\n        stride=1,\n        padding=\"VALID\",\n        expected=expected_output)\n\n  def testConv2D2x2Filter(self):\n    # Our generated input is [batch, rows, cols, depth], and looks like this:\n    # (1,2,3)    (4,5,6)    (7,8,9)\n    # (10,11,12) (13,14,15) (16,17,18)\n    # The filter data is [filter_height, filter_width, depth, filter_count]:\n    # ( 1, 4, 7) (10, 13, 16)\n    # (19,22,25) (28, 31, 34)\n    # -\n    # ( 2, 5, 8) (11, 14, 17)\n    # (20,23,26) (29, 32, 35)\n    # -\n    # ( 3, 6, 9) (12, 15, 18)\n    # (21,24,27) (30, 33, 36)\n    # The raw accumulated totals are:\n    # 1*1+2*4+3*7+4*10+5*13+6*16+10*19+11*22+12*25+13*28+14*31+15*34=2271\n    # 1*2+2*5+3*8+4*11+5*14+6*17+10*20+11*23+12*26+13*29+14*32+15*35=2367\n    # 1*3+2*6+3*9+4*12+5*15+6*18+10*21+11*24+12*27+13*30+14*33+15*36=2463\n    # 4*1+5*4+6*7+7*10+8*13+9*16+13*19+14*22+15*25+16*28+17*31+18*34=2901\n    # 4*2+5*5+6*8+7*11+8*14+9*17+13*20+14*23+15*26+16*29+17*32+18*35=3033\n    # 4*3+5*6+6*9+7*12+8*15+9*18+13*21+14*24+15*27+16*30+17*33+18*36=3165\n    # The expected values are taken from the raw totals and rescaled to fit into\n    # eight bits.\n    expected_output = [2271.0, 2367.0, 2463.0, 2901.0, 3033.0, 3165.0]\n    self._VerifyValues(\n        tensor_in_sizes=[1, 2, 3, 3],\n        filter_in_sizes=[2, 2, 3, 3],\n        stride=1,\n        padding=\"VALID\",\n        expected=expected_output)\n\n  def testConv2D1x2Filter(self):\n    # The outputs are computed using third_party/py/IPython/notebook.\n    # With a shift of 21, we should execute the optimized path here.\n    expected_output = [\n        231.0, 252.0, 273.0, 384.0, 423.0, 462.0, 690.0, 765.0, 840.0, 843.0,\n        936.0, 1029.0\n    ]\n    self._VerifyValues(\n        tensor_in_sizes=[1, 2, 3, 3],\n        filter_in_sizes=[1, 2, 3, 3],\n        stride=1,\n        padding=\"VALID\",\n        expected=expected_output)\n\n  def testConv2D2x2FilterStride2(self):\n    # With a shift of 21, we should execute the optimized path here.\n    expected_output = [2271.0, 2367.0, 2463.0]\n    self._VerifyValues(\n        tensor_in_sizes=[1, 2, 3, 3],\n        filter_in_sizes=[2, 2, 3, 3],\n        stride=2,\n        padding=\"VALID\",\n        expected=expected_output)\n\n  def testConv2D2x2FilterStride2Same(self):\n    # With a shift of 21, we should execute the optimized path here.\n    expected_output = [2271.0, 2367.0, 2463.0, 1230.0, 1305.0, 1380.0]\n    self._VerifyValues(\n        tensor_in_sizes=[1, 2, 3, 3],\n        filter_in_sizes=[2, 2, 3, 3],\n        stride=2,\n        padding=\"SAME\",\n        expected=expected_output)\n\n\nif __name__ == \"__main__\":\n  test.main()"