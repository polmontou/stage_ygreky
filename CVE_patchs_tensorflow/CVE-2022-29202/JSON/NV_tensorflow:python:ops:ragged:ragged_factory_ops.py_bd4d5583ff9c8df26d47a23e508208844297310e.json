"# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Operations for constructing RaggedTensors.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import tensor_shape\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops.ragged import ragged_tensor\nfrom tensorflow.python.ops.ragged import ragged_tensor_value\nfrom tensorflow.python.util import dispatch\nfrom tensorflow.python.util.tf_export import tf_export\n\n\n#===============================================================================\n# Op to construct a constant RaggedTensor from a nested Python list.\n#===============================================================================\n@tf_export(\"ragged.constant\")\n@dispatch.add_dispatch_support\ndef constant(pylist, dtype=None, ragged_rank=None, inner_shape=None,\n             name=None, row_splits_dtype=dtypes.int64):\n  \"\"\"Constructs a constant RaggedTensor from a nested Python list.\n\n  Example:\n\n  >>> tf.ragged.constant([[1, 2], [3], [4, 5, 6]])\n  <tf.RaggedTensor [[1, 2], [3], [4, 5, 6]]>\n\n  All scalar values in `pylist` must have the same nesting depth `K`, and the\n  returned `RaggedTensor` will have rank `K`.  If `pylist` contains no scalar\n  values, then `K` is one greater than the maximum depth of empty lists in\n  `pylist`.  All scalar values in `pylist` must be compatible with `dtype`.\n\n  Args:\n    pylist: A nested `list`, `tuple` or `np.ndarray`.  Any nested element that\n      is not a `list`, `tuple` or `np.ndarray` must be a scalar value\n      compatible with `dtype`.\n    dtype: The type of elements for the returned `RaggedTensor`.  If not\n      specified, then a default is chosen based on the scalar values in\n      `pylist`.\n    ragged_rank: An integer specifying the ragged rank of the returned\n      `RaggedTensor`.  Must be nonnegative and less than `K`. Defaults to\n      `max(0, K - 1)` if `inner_shape` is not specified.  Defaults to\n      `max(0, K - 1 - len(inner_shape))` if `inner_shape` is specified.\n    inner_shape: A tuple of integers specifying the shape for individual inner\n      values in the returned `RaggedTensor`.  Defaults to `()` if `ragged_rank`\n      is not specified.  If `ragged_rank` is specified, then a default is chosen\n      based on the contents of `pylist`.\n    name: A name prefix for the returned tensor (optional).\n    row_splits_dtype: data type for the constructed `RaggedTensor`'s row_splits.\n      One of `tf.int32` or `tf.int64`.\n\n  Returns:\n    A potentially ragged tensor with rank `K` and the specified `ragged_rank`,\n    containing the values from `pylist`.\n\n  Raises:\n    ValueError: If the scalar values in `pylist` have inconsistent nesting\n      depth; or if ragged_rank or inner_shape are incompatible with `pylist`.\n  \"\"\"\n  def ragged_factory(values, row_splits):\n    row_splits = constant_op.constant(row_splits, dtype=row_splits_dtype)\n    return ragged_tensor.RaggedTensor.from_row_splits(values, row_splits,\n                                                      validate=False)\n\n  with ops.name_scope(name, \"RaggedConstant\"):\n    return _constant_value(ragged_factory, constant_op.constant, pylist, dtype,\n                           ragged_rank, inner_shape)\n\n\n@tf_export(v1=[\"ragged.constant_value\"])\n@dispatch.add_dispatch_support\ndef constant_value(pylist, dtype=None, ragged_rank=None, inner_shape=None,\n                   row_splits_dtype=\"int64\"):\n  \"\"\"Constructs a RaggedTensorValue from a nested Python list.\n\n  Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.\n  If you wish to construct a constant `RaggedTensor`, use\n  [`ragged.constant(...)`](constant.md) instead.\n\n  Example:\n\n  >>> tf.compat.v1.ragged.constant_value([[1, 2], [3], [4, 5, 6]])\n  tf.RaggedTensorValue(values=array([1, 2, 3, 4, 5, 6]),\n                       row_splits=array([0, 2, 3, 6]))\n\n  All scalar values in `pylist` must have the same nesting depth `K`, and the\n  returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no\n  scalar values, then `K` is one greater than the maximum depth of empty lists\n  in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`.\n\n  Args:\n    pylist: A nested `list`, `tuple` or `np.ndarray`.  Any nested element that\n      is not a `list` or `tuple` must be a scalar value compatible with `dtype`.\n    dtype: `numpy.dtype`.  The type of elements for the returned `RaggedTensor`.\n      If not specified, then a default is chosen based on the scalar values in\n      `pylist`.\n    ragged_rank: An integer specifying the ragged rank of the returned\n      `RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to\n      `max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K\n      - 1 - len(inner_shape))` if `inner_shape` is specified.\n    inner_shape: A tuple of integers specifying the shape for individual inner\n      values in the returned `RaggedTensorValue`.  Defaults to `()` if\n      `ragged_rank` is not specified.  If `ragged_rank` is specified, then a\n      default is chosen based on the contents of `pylist`.\n    row_splits_dtype: data type for the constructed `RaggedTensorValue`'s\n      row_splits.  One of `numpy.int32` or `numpy.int64`.\n\n  Returns:\n    A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified\n    `ragged_rank`, containing the values from `pylist`.\n\n  Raises:\n    ValueError: If the scalar values in `pylist` have inconsistent nesting\n      depth; or if ragged_rank or inner_shape are incompatible with `pylist`.\n  \"\"\"\n  if dtype is not None and isinstance(dtype, dtypes.DType):\n    dtype = dtype.as_numpy_dtype\n  row_splits_dtype = dtypes.as_dtype(row_splits_dtype).as_numpy_dtype\n  def _ragged_factory(values, row_splits):\n    row_splits = np.array(row_splits, dtype=row_splits_dtype)\n    return ragged_tensor_value.RaggedTensorValue(values, row_splits)\n\n  def _inner_factory(pylist, dtype, shape, name=None):  # pylint: disable=unused-argument\n    return np.reshape(np.array(pylist, dtype=dtype), shape)\n\n  return _constant_value(_ragged_factory, _inner_factory, pylist, dtype,\n                         ragged_rank, inner_shape)\n\n\ndef _constant_value(ragged_factory, inner_factory, pylist, dtype, ragged_rank,\n                    inner_shape):\n  \"\"\"Constructs a constant RaggedTensor or RaggedTensorValue.\n\n  Args:\n    ragged_factory: A factory function with the signature:\n      `ragged_factory(values, row_splits)`\n    inner_factory: A factory function with the signature: `inner_factory(pylist,\n      dtype, shape, name)`\n    pylist: A nested `list`, `tuple` or `np.ndarray`.\n    dtype: Data type for returned value.\n    ragged_rank: Ragged rank for returned value.\n    inner_shape: Inner value shape for returned value.\n\n  Returns:\n    A value returned by `ragged_factory` or `inner_factory`.\n\n  Raises:\n    ValueError: If the scalar values in `pylist` have inconsistent nesting\n      depth; or if ragged_rank or inner_shape are incompatible with `pylist`.\n  \"\"\"\n  if ragged_tensor.is_ragged(pylist):\n    raise TypeError(\"pylist may not be a RaggedTensor or RaggedTensorValue.\")\n  # np.ndim builds an array, so we short-circuit lists and tuples.\n  if not isinstance(pylist, (list, tuple)) and np.ndim(pylist) == 0:\n    # Scalar value\n    if ragged_rank is not None and ragged_rank != 0:\n      raise ValueError(\"Invalid pylist=%r: incompatible with ragged_rank=%d\" %\n                       (pylist, ragged_rank))\n    if inner_shape is not None and inner_shape:\n      raise ValueError(\n          \"Invalid pylist=%r: incompatible with dim(inner_shape)=%d\" %\n          (pylist, len(inner_shape)))\n    return inner_factory(pylist, dtype, ())\n\n  if ragged_rank is not None and ragged_rank < 0:\n    raise ValueError(\n        \"Invalid ragged_rank=%r: must be nonnegative\" % ragged_rank)\n\n  # Find the depth of scalar values in `pylist`.\n  scalar_depth, max_depth = _find_scalar_and_max_depth(pylist)\n  if scalar_depth is not None:\n    if max_depth > scalar_depth:\n      raise ValueError(\"Invalid pylist=%r: empty list nesting is greater \"\n                       \"than scalar value nesting\" % pylist)\n    if ragged_rank is not None and max_depth < ragged_rank:\n      raise ValueError(f\"Invalid pylist={pylist}, max depth smaller than \"\n                       f\"ragged_rank={ragged_rank}\")\n\n  # If both inner_shape and ragged_rank were specified, then check that\n  # they are compatible with pylist.\n  if inner_shape is not None and ragged_rank is not None:\n    expected_depth = ragged_rank + len(inner_shape) + 1\n    if ((scalar_depth is not None and expected_depth != scalar_depth) or\n        (scalar_depth is None and expected_depth < max_depth)):\n      raise ValueError(\n          \"Invalid pylist=%r: incompatible with ragged_rank=%d \"\n          \"and dim(inner_shape)=%d\" % (pylist, ragged_rank, len(inner_shape)))\n\n  # Check if the result is a `Tensor`.\n  if (ragged_rank == 0 or\n      (ragged_rank is None and\n       ((max_depth < 2) or\n        (inner_shape is not None and max_depth - len(inner_shape) < 2)))):\n    return inner_factory(pylist, dtype, inner_shape)\n\n  # Compute default value for inner_shape.\n  if inner_shape is None:\n    if ragged_rank is None:\n      inner_shape = ()\n    else:\n      inner_shape = _default_inner_shape_for_pylist(pylist, ragged_rank)\n\n  # Compute default value for ragged_rank.\n  if ragged_rank is None:\n    if scalar_depth is None:\n      ragged_rank = max(1, max_depth - 1)\n    else:\n      ragged_rank = max(1, scalar_depth - 1 - len(inner_shape))\n\n  # Build the splits for each ragged rank, and concatenate the inner values\n  # into a single list.\n  nested_splits = []\n  values = pylist\n  for dim in range(ragged_rank):\n    nested_splits.append([0])\n    concatenated_values = []\n    for row in values:\n      nested_splits[dim].append(nested_splits[dim][-1] + len(row))\n      concatenated_values.extend(row)\n    values = concatenated_values\n\n  values = inner_factory(\n      values, dtype=dtype, shape=(len(values),) + inner_shape, name=\"values\")\n  for row_splits in reversed(nested_splits):\n    values = ragged_factory(values, row_splits)\n  return values\n\n\ndef _find_scalar_and_max_depth(pylist):\n  \"\"\"Finds nesting depth of scalar values in pylist.\n\n  Args:\n    pylist: A nested python `list` or `tuple`.\n\n  Returns:\n    A tuple `(scalar_depth, max_depth)`.  `scalar_depth` is the nesting\n    depth of scalar values in `pylist`, or `None` if `pylist` contains no\n    scalars.  `max_depth` is the maximum depth of `pylist` (including\n    empty lists).\n\n  Raises:\n    ValueError: If pylist has inconsistent nesting depths for scalars.\n  \"\"\"\n  # Check if pylist is not scalar. np.ndim builds an array, so we\n  # short-circuit lists and tuples.\n  if isinstance(pylist, (list, tuple)) or np.ndim(pylist) != 0:\n    scalar_depth = None\n    max_depth = 1\n    for child in pylist:\n      child_scalar_depth, child_max_depth = _find_scalar_and_max_depth(child)\n      if child_scalar_depth is not None:\n        if scalar_depth is not None and scalar_depth != child_scalar_depth + 1:\n          raise ValueError(\"all scalar values must have the same nesting depth\")\n        scalar_depth = child_scalar_depth + 1\n      max_depth = max(max_depth, child_max_depth + 1)\n    return (scalar_depth, max_depth)\n  return (0, 0)\n\n\ndef _default_inner_shape_for_pylist(pylist, ragged_rank):\n  \"\"\"Computes a default inner shape for the given python list.\"\"\"\n\n  def get_inner_shape(item):\n    \"\"\"Returns the inner shape for a python list `item`.\"\"\"\n    if not isinstance(item, (list, tuple)) and np.ndim(item) == 0:\n      return ()\n    # Note that we need this check here in case `item` is not a Python list but\n    # fakes as being one (pylist). For a scenario of this, see test added in\n    # https://github.com/tensorflow/tensorflow/pull/48945\n    elif len(item) > 0:  # pylint: disable=g-explicit-length-test\n      return (len(item),) + get_inner_shape(item[0])\n    return (0,)\n\n  def check_inner_shape(item, shape):\n    \"\"\"Checks that `item` has a consistent shape matching `shape`.\"\"\"\n    is_nested = isinstance(item, (list, tuple)) or np.ndim(item) != 0\n    if is_nested != bool(shape):\n      raise ValueError(\"inner values have inconsistent shape\")\n    if is_nested:\n      if shape[0] != len(item):\n        raise ValueError(\"inner values have inconsistent shape\")\n      for child in item:\n        check_inner_shape(child, shape[1:])\n\n  # Collapse the ragged layers to get the list of inner values.\n  flat_values = pylist\n  for dim in range(ragged_rank):\n    if not all(\n        isinstance(v, (list, tuple)) or np.ndim(v) != 0 for v in flat_values):\n      raise ValueError(\"pylist has scalar values depth %d, but ragged_rank=%d \"\n                       \"requires scalar value depth greater than %d\" %\n                       (dim + 1, ragged_rank, ragged_rank))\n    flat_values = sum((list(v) for v in flat_values), [])\n\n  # Compute the inner shape looking only at the leftmost elements; and then\n  # use check_inner_shape to verify that other elements have the same shape.\n  inner_shape = get_inner_shape(flat_values)\n  check_inner_shape(flat_values, inner_shape)\n  return inner_shape[1:]\n\n\n@tf_export(v1=[\"ragged.placeholder\"])\n@dispatch.add_dispatch_support\ndef placeholder(dtype, ragged_rank, value_shape=None, name=None):\n  \"\"\"Creates a placeholder for a `tf.RaggedTensor` that will always be fed.\n\n  **Important**: This ragged tensor will produce an error if evaluated.\n  Its value must be fed using the `feed_dict` optional argument to\n  `Session.run()`, `Tensor.eval()`, or `Operation.run()`.\n\n  @compatibility{eager} Placeholders are not compatible with eager execution.\n\n  Args:\n    dtype: The data type for the `RaggedTensor`.\n    ragged_rank: The ragged rank for the `RaggedTensor`\n    value_shape: The shape for individual flat values in the `RaggedTensor`.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `RaggedTensor` that may be used as a handle for feeding a value, but\n    not evaluated directly.\n\n  Raises:\n    RuntimeError: if eager execution is enabled\n  \"\"\"\n  if ragged_rank == 0:\n    return array_ops.placeholder(dtype, value_shape, name)\n\n  with ops.name_scope(name, \"RaggedPlaceholder\", []):\n    flat_shape = tensor_shape.TensorShape([None]).concatenate(value_shape)\n    result = array_ops.placeholder(dtype, flat_shape, \"flat_values\")\n    for i in reversed(range(ragged_rank)):\n      row_splits = array_ops.placeholder(dtypes.int64, [None],\n                                         \"row_splits_%d\" % i)\n      result = ragged_tensor.RaggedTensor.from_row_splits(result, row_splits,\n                                                          validate=False)\n    return result"