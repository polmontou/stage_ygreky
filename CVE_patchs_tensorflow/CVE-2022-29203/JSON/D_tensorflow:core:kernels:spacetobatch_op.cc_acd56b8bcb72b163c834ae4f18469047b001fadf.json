"diff --git a/tensorflow/core/kernels/spacetobatch_op.cc b/tensorflow/core/kernels/spacetobatch_op.cc\nindex 009500f7926..e391529d852 100644\n--- a/tensorflow/core/kernels/spacetobatch_op.cc\n+++ b/tensorflow/core/kernels/spacetobatch_op.cc\n@@ -21,8 +21,6 @@ limitations under the License.\n #include <string>\n #include <utility>\n \n-#include \"tensorflow/core/kernels/spacetobatch_functor.h\"\n-\n #include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n #include \"tensorflow/core/framework/op.h\"\n #include \"tensorflow/core/framework/op_kernel.h\"\n@@ -31,8 +29,10 @@ limitations under the License.\n #include \"tensorflow/core/framework/tensor_shape.h\"\n #include \"tensorflow/core/framework/tensor_types.h\"\n #include \"tensorflow/core/framework/types.h\"\n+#include \"tensorflow/core/kernels/spacetobatch_functor.h\"\n #include \"tensorflow/core/platform/logging.h\"\n #include \"tensorflow/core/platform/types.h\"\n+#include \"tensorflow/core/util/overflow.h\"\n \n namespace tensorflow {\n \n@@ -99,7 +99,13 @@ Status SpaceToBatchOpCompute(OpKernelContext* context,\n   // Compute the product of the block_shape values.\n   int64_t block_shape_product = 1;\n   for (int block_dim = 0; block_dim < block_dims; ++block_dim) {\n-    block_shape_product *= block_shape[block_dim];\n+    if (block_shape[block_dim] < 1) {\n+      return errors::InvalidArgument(\n+          \"All values in block_shape must be positive, got value, \",\n+          block_shape[block_dim], \" at index \", block_dim, \".\");\n+    }\n+    block_shape_product =\n+        MultiplyWithoutOverflow(block_shape_product, block_shape[block_dim]);\n   }\n   if (block_shape_product <= 0) {\n     return errors::InvalidArgument(\n@@ -131,8 +137,14 @@ Status SpaceToBatchOpCompute(OpKernelContext* context,\n   // The actual output shape exposed to callers.\n   TensorShape external_output_shape;\n \n-  external_output_shape.AddDim(orig_input_tensor.dim_size(0) *\n-                               block_shape_product);\n+  const int64_t output_shape = MultiplyWithoutOverflow(\n+      orig_input_tensor.dim_size(0), block_shape_product);\n+  if (output_shape < 0) {\n+    return errors::InvalidArgument(\n+        \"Negative output dimension size caused by overflow when multiplying \",\n+        orig_input_tensor.dim_size(0), \" and \", block_shape_product);\n+  }\n+  external_output_shape.AddDim(output_shape);\n \n   int64_t input_batch_size = orig_input_tensor.dim_size(0);\n   for (int block_dim = 0; block_dim < removed_prefix_block_dims; ++block_dim) {"