"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_CORE_KERNELS_STRIDED_SLICE_OP_IMPL_H_\n#define TENSORFLOW_CORE_KERNELS_STRIDED_SLICE_OP_IMPL_H_\n\n// Functor definition for StridedSliceOp, must be compilable by nvcc.\n\n#include \"tensorflow/core/kernels/slice_op.h\"\n#include \"tensorflow/core/kernels/strided_slice_op.h\"\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/register_types_traits.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/variant.h\"\n#include \"tensorflow/core/framework/variant_encode_decode.h\"\n#include \"tensorflow/core/kernels/dense_update_functor.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/gtl/array_slice.h\"\n#include \"tensorflow/core/platform/mem.h\"\n\nnamespace tensorflow {\n\ntemplate <typename Device, typename T, int NDIM>\nvoid HandleStridedSliceCase(OpKernelContext* context,\n                            const gtl::ArraySlice<int64_t>& begin,\n                            const gtl::ArraySlice<int64_t>& end,\n                            const gtl::ArraySlice<int64_t>& strides,\n                            const TensorShape& processing_shape,\n                            bool is_simple_slice, Tensor* result);\n\ntemplate <typename Device, typename T, int NDIM>\nvoid HandleStridedSliceGradCase(OpKernelContext* context,\n                                const gtl::ArraySlice<int64_t>& begin,\n                                const gtl::ArraySlice<int64_t>& end,\n                                const gtl::ArraySlice<int64_t>& strides,\n                                const TensorShape& processing_shape,\n                                bool is_simple_slice, Tensor* result);\n\ntemplate <typename Device, typename T, int NDIM>\nclass HandleStridedSliceAssignCase {\n public:\n  void operator()(OpKernelContext* context,\n                  const gtl::ArraySlice<int64_t>& begin,\n                  const gtl::ArraySlice<int64_t>& end,\n                  const gtl::ArraySlice<int64_t>& strides,\n                  const TensorShape& processing_shape, bool is_simple_slice,\n                  Tensor* result);\n};\n}  // namespace tensorflow\n\n// The actual implementation. This is designed so multiple\n// translation units can include this file in the form\n//\n// #define STRIDED_SLICE_INSTANTIATE_DIM 1\n// #include <thisfile>\n// #undef STRIDED_SLICE_INSTANTIATE_DIM\n//\n#ifdef STRIDED_SLICE_INSTANTIATE_DIM\n\nnamespace tensorflow {\n\ntemplate <typename Device, typename T, int NDIM>\nvoid HandleStridedSliceCase(OpKernelContext* context,\n                            const gtl::ArraySlice<int64_t>& begin,\n                            const gtl::ArraySlice<int64_t>& end,\n                            const gtl::ArraySlice<int64_t>& strides,\n                            const TensorShape& processing_shape,\n                            bool is_simple_slice, Tensor* result) {\n  typedef typename proxy_type<Device, T>::type Proxy;\n\n  gtl::InlinedVector<int64_t, 4> processing_dims = processing_shape.dim_sizes();\n  if (is_simple_slice) {\n    Eigen::DSizes<Eigen::DenseIndex, NDIM> begin_di;\n    Eigen::DSizes<Eigen::DenseIndex, NDIM> sizes_di;\n    for (int i = 0; i < NDIM; ++i) {\n      begin_di[i] = begin[i];\n      sizes_di[i] = end[i] - begin[i];\n    }\n    functor::Slice<Device, Proxy, NDIM>()(\n        context->eigen_device<Device>(),\n        result->bit_casted_shaped<Proxy, NDIM>(processing_dims),\n        context->input(0).bit_casted_tensor<Proxy, NDIM>(), begin_di, sizes_di);\n  } else {\n    Eigen::DSizes<Eigen::DenseIndex, NDIM> begin_di;\n    Eigen::DSizes<Eigen::DenseIndex, NDIM> end_di;\n    Eigen::DSizes<Eigen::DenseIndex, NDIM> strides_di;\n    for (int i = 0; i < NDIM; ++i) {\n      begin_di[i] = begin[i];\n      end_di[i] = end[i];\n      strides_di[i] = strides[i];\n    }\n    functor::StridedSlice<Device, Proxy, NDIM>()(\n        context->eigen_device<Device>(),\n        result->bit_casted_shaped<Proxy, NDIM>(processing_dims),\n        context->input(0).bit_casted_tensor<Proxy, NDIM>(), begin_di, end_di,\n        strides_di);\n  }\n}\n\ntemplate <typename Device, typename T, int NDIM>\nvoid HandleStridedSliceGradCase(OpKernelContext* context,\n                                const gtl::ArraySlice<int64_t>& begin,\n                                const gtl::ArraySlice<int64_t>& end,\n                                const gtl::ArraySlice<int64_t>& strides,\n                                const TensorShape& processing_shape,\n                                bool is_simple_slice, Tensor* result) {\n  gtl::InlinedVector<int64_t, 4> processing_dims = processing_shape.dim_sizes();\n\n  Eigen::DSizes<Eigen::DenseIndex, NDIM> begin_di;\n  Eigen::DSizes<Eigen::DenseIndex, NDIM> end_di;\n  Eigen::DSizes<Eigen::DenseIndex, NDIM> strides_di;\n  for (int i = 0; i < NDIM; ++i) {\n    begin_di[i] = begin[i];\n    end_di[i] = end[i];\n    strides_di[i] = strides[i];\n  }\n\n  typedef typename proxy_type<Device, T>::type Proxy;\n  functor::StridedSliceGrad<Device, Proxy, NDIM>()(\n      context->eigen_device<Device>(), result->bit_casted_tensor<Proxy, NDIM>(),\n      context->input(4).bit_casted_shaped<Proxy, NDIM>(processing_dims),\n      begin_di, end_di, strides_di);\n}\n\ntemplate <typename Device, typename T, int NDIM>\nvoid HandleStridedSliceAssignCase<Device, T, NDIM>::operator()(\n    OpKernelContext* context, const gtl::ArraySlice<int64_t>& begin,\n    const gtl::ArraySlice<int64_t>& end,\n    const gtl::ArraySlice<int64_t>& strides,\n    const TensorShape& processing_shape, bool is_simple_slice, Tensor* result) {\n  gtl::InlinedVector<int64_t, 4> processing_dims = processing_shape.dim_sizes();\n  typedef typename proxy_type<Device, T>::type Proxy;\n  Eigen::DSizes<Eigen::DenseIndex, NDIM> begin_di;\n  Eigen::DSizes<Eigen::DenseIndex, NDIM> end_di;\n  Eigen::DSizes<Eigen::DenseIndex, NDIM> strides_di;\n  for (int i = 0; i < NDIM; ++i) {\n    begin_di[i] = begin[i];\n    end_di[i] = end[i];\n    strides_di[i] = strides[i];\n  }\n  functor::StridedSliceAssign<Device, Proxy, NDIM>()(\n      context->eigen_device<Device>(), result->bit_casted_tensor<Proxy, NDIM>(),\n      context->input(4).bit_casted_shaped<Proxy, NDIM>(processing_dims),\n      begin_di, end_di, strides_di);\n}\n\ntemplate <typename Device, typename T>\nclass HandleStridedSliceAssignCase<Device, T, 0> {\n public:\n  enum { NDIM_PROXY = 1 };\n  void operator()(OpKernelContext* context,\n                  const gtl::ArraySlice<int64_t>& begin,\n                  const gtl::ArraySlice<int64_t>& end,\n                  const gtl::ArraySlice<int64_t>& strides,\n                  const TensorShape& processing_shape, bool is_simple_slice,\n                  Tensor* result) {\n    gtl::InlinedVector<int64_t, 1> processing_dims(1);\n    processing_dims[0] = 1;\n\n    typedef typename proxy_type<Device, T>::type Proxy;\n    functor::StridedSliceAssignScalar<Device, Proxy>()(\n        context->eigen_device<Device>(),\n        result->bit_casted_shaped<Proxy, 1>(processing_dims),\n        context->input(4).bit_casted_shaped<Proxy, 1>(processing_dims));\n  }\n};\n\n// NOTE(aselle): according to bsteiner, we need this because otherwise\n// nvcc instantiates templates that are invalid. strided_slice_op_gpu.cu\n// handles instantiates externally. It is important that this is done\n// before the HandleXXCase's are instantiated to avoid duplicate\n// specialization errors.\n\n#define PREVENT_INSTANTIATE_DIM1_AND_UP(T, NDIM)                   \\\n  namespace functor {                                              \\\n  template <>                                                      \\\n  void StridedSlice<GPUDevice, T, NDIM>::operator()(               \\\n      const GPUDevice& d, typename TTypes<T, NDIM>::Tensor output, \\\n      typename TTypes<T, NDIM>::ConstTensor input,                 \\\n      const Eigen::DSizes<Eigen::DenseIndex, NDIM>& start,         \\\n      const Eigen::DSizes<Eigen::DenseIndex, NDIM>& stop,          \\\n      const Eigen::DSizes<Eigen::DenseIndex, NDIM>& strides);      \\\n  extern template struct StridedSlice<GPUDevice, T, NDIM>;         \\\n  template <>                                                      \\\n  void Slice<GPUDevice, T, NDIM>::operator()(                      \\\n      const GPUDevice& d, typename TTypes<T, NDIM>::Tensor output, \\\n      typename TTypes<T, NDIM>::ConstTensor input,                 \\\n      const Eigen::DSizes<Eigen::DenseIndex, NDIM>& indices,       \\\n      const Eigen::DSizes<Eigen::DenseIndex, NDIM>& sizes);        \\\n  extern template struct Slice<GPUDevice, T, NDIM>;                \\\n  template <>                                                      \\\n  void StridedSliceGrad<GPUDevice, T, NDIM>::operator()(           \\\n      const GPUDevice& d, typename TTypes<T, NDIM>::Tensor output, \\\n      typename TTypes<T, NDIM>::ConstTensor input,                 \\\n      const Eigen::DSizes<Eigen::DenseIndex, NDIM>& start,         \\\n      const Eigen::DSizes<Eigen::DenseIndex, NDIM>& stop,          \\\n      const Eigen::DSizes<Eigen::DenseIndex, NDIM>& strides);      \\\n  extern template struct StridedSliceGrad<GPUDevice, T, NDIM>;     \\\n  template <>                                                      \\\n  void StridedSliceAssign<GPUDevice, T, NDIM>::operator()(         \\\n      const GPUDevice& d, typename TTypes<T, NDIM>::Tensor output, \\\n      typename TTypes<T, NDIM>::ConstTensor input,                 \\\n      const Eigen::DSizes<Eigen::DenseIndex, NDIM>& start,         \\\n      const Eigen::DSizes<Eigen::DenseIndex, NDIM>& stop,          \\\n      const Eigen::DSizes<Eigen::DenseIndex, NDIM>& strides);      \\\n  extern template struct StridedSliceAssign<GPUDevice, T, NDIM>;   \\\n  }  // namespace functor\n#define PREVENT_INSTANTIATE_DIM0_ONLY(T, NDIM)                   \\\n  namespace functor {                                            \\\n  template <>                                                    \\\n  void StridedSliceAssignScalar<GPUDevice, T>::operator()(       \\\n      const GPUDevice& d, typename TTypes<T, 1>::Tensor output,  \\\n      typename TTypes<T, 1>::ConstTensor input);                 \\\n  extern template struct StridedSliceAssignScalar<GPUDevice, T>; \\\n  }  // namespace functor\n\n// Dimension 0 only instantiates some functors. So we only need\n// to prevent ones defined by PREVENT_INSTANTIATE_DIM0_ONLY\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#if STRIDED_SLICE_INSTANTIATE_DIM == 0\n#define PREVENT_INSTANTIATE(T, NDIM) PREVENT_INSTANTIATE_DIM0_ONLY(T, NDIM)\n#else\n#define PREVENT_INSTANTIATE(T, NDIM) PREVENT_INSTANTIATE_DIM1_AND_UP(T, NDIM)\n#endif\n#else\n#define PREVENT_INSTANTIATE(T, NDIM)\n#endif\n\n#define INSTANTIATE_DIM1_AND_UP_HANDLERS(DEVICE, T, DIM)                \\\n  template void HandleStridedSliceCase<DEVICE, T, DIM>(                 \\\n      OpKernelContext * context, const gtl::ArraySlice<int64_t>& begin, \\\n      const gtl::ArraySlice<int64_t>& end,                              \\\n      const gtl::ArraySlice<int64_t>& strides,                          \\\n      const TensorShape& processing_shape, bool is_simple_slice,        \\\n      Tensor* result);                                                  \\\n  template void HandleStridedSliceGradCase<DEVICE, T, DIM>(             \\\n      OpKernelContext * context, const gtl::ArraySlice<int64_t>& begin, \\\n      const gtl::ArraySlice<int64_t>& end,                              \\\n      const gtl::ArraySlice<int64_t>& strides,                          \\\n      const TensorShape& processing_shape, bool is_simple_slice,        \\\n      Tensor* result);\n\n#define INSTANTIATE_DIM0_AND_UP_HANDLERS(DEVICE, T, DIM) \\\n  template class HandleStridedSliceAssignCase<DEVICE, T, DIM>;\n\n// Only some kernels need to be instantiated on dim 0.\n#if STRIDED_SLICE_INSTANTIATE_DIM == 0\n#define INSTANTIATE(DEVICE, T, DIM) \\\n  INSTANTIATE_DIM0_AND_UP_HANDLERS(DEVICE, T, DIM)\n#else\n#define INSTANTIATE(DEVICE, T, DIM)                \\\n  INSTANTIATE_DIM0_AND_UP_HANDLERS(DEVICE, T, DIM) \\\n  INSTANTIATE_DIM1_AND_UP_HANDLERS(DEVICE, T, DIM)\n#endif\n\n#define DECLARE_FOR_N_CPU(T) \\\n  INSTANTIATE(CPUDevice, T, STRIDED_SLICE_INSTANTIATE_DIM)\n\n#define PREVENT_FOR_N_GPU(T) \\\n  PREVENT_INSTANTIATE(T, STRIDED_SLICE_INSTANTIATE_DIM)\n\n#define DECLARE_FOR_N_GPU(T) \\\n  INSTANTIATE(GPUDevice, T, STRIDED_SLICE_INSTANTIATE_DIM)\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\nTF_CALL_GPU_PROXY_TYPES(PREVENT_FOR_N_GPU);\nTF_CALL_COMPLEX_TYPES(PREVENT_FOR_N_GPU);\n\nTF_CALL_uint8(DECLARE_FOR_N_GPU);\nTF_CALL_int8(DECLARE_FOR_N_GPU);\nTF_CALL_int32(DECLARE_FOR_N_GPU);\nTF_CALL_int64(DECLARE_FOR_N_GPU);\nTF_CALL_uint32(DECLARE_FOR_N_GPU);\nTF_CALL_GPU_ALL_TYPES(DECLARE_FOR_N_GPU);\n#endif  // END GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nTF_CALL_ALL_TYPES(DECLARE_FOR_N_CPU);\n\n\n#undef INSTANTIATE\n#undef DECLARE_FOR_N_CPU\n#undef DECLARE_FOR_N_GPU\n\n}  // end namespace tensorflow\n\n#endif  // END STRIDED_SLICE_INSTANTIATE_DIM\n#endif  // TENSORFLOW_CORE_KERNELS_STRIDED_SLICE_OP_IMPL_H_"