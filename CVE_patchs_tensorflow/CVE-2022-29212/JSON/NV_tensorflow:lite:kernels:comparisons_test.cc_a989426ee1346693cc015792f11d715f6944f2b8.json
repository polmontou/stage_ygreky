"/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include <stdint.h>\n\n#include <initializer_list>\n#include <string>\n#include <vector>\n\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n#include \"flatbuffers/flatbuffers.h\"  // from @flatbuffers\n#include \"tensorflow/lite/kernels/test_util.h\"\n#include \"tensorflow/lite/schema/schema_generated.h\"\n#include \"tensorflow/lite/string_type.h\"\n\nnamespace tflite {\nnamespace {\n\nusing ::testing::ElementsAre;\n\nclass ComparisonOpModel : public SingleOpModel {\n public:\n  ComparisonOpModel(std::initializer_list<int> input1_shape,\n                    std::initializer_list<int> input2_shape,\n                    TensorType input_type, BuiltinOperator op) {\n    input1_ = AddInput(input_type);\n    input2_ = AddInput(input_type);\n    output_ = AddOutput(TensorType_BOOL);\n    ConfigureBuiltinOp(op);\n    BuildInterpreter({input1_shape, input2_shape});\n  }\n\n  ComparisonOpModel(const TensorData& input1, const TensorData& input2,\n                    TensorType input_type, BuiltinOperator op) {\n    input1_ = AddInput(input1);\n    input2_ = AddInput(input2);\n    output_ = AddOutput(TensorType_BOOL);\n    ConfigureBuiltinOp(op);\n    BuildInterpreter({GetShape(input1_), GetShape(input2_)});\n  }\n\n  int input1() { return input1_; }\n  int input2() { return input2_; }\n\n  std::vector<bool> GetOutput() { return ExtractVector<bool>(output_); }\n  std::vector<int> GetOutputShape() { return GetTensorShape(output_); }\n\n private:\n  int input1_;\n  int input2_;\n  int output_;\n\n  void ConfigureBuiltinOp(BuiltinOperator op) {\n    switch (op) {\n      case BuiltinOperator_EQUAL: {\n        SetBuiltinOp(op, BuiltinOptions_EqualOptions,\n                     CreateEqualOptions(builder_).Union());\n        break;\n      }\n      case BuiltinOperator_NOT_EQUAL: {\n        SetBuiltinOp(op, BuiltinOptions_NotEqualOptions,\n                     CreateNotEqualOptions(builder_).Union());\n        break;\n      }\n      case BuiltinOperator_GREATER: {\n        SetBuiltinOp(op, BuiltinOptions_GreaterOptions,\n                     CreateGreaterOptions(builder_).Union());\n        break;\n      }\n      case BuiltinOperator_GREATER_EQUAL: {\n        SetBuiltinOp(op, BuiltinOptions_GreaterEqualOptions,\n                     CreateGreaterEqualOptions(builder_).Union());\n        break;\n      }\n      case BuiltinOperator_LESS: {\n        SetBuiltinOp(op, BuiltinOptions_LessOptions,\n                     CreateLessOptions(builder_).Union());\n        break;\n      }\n      case BuiltinOperator_LESS_EQUAL: {\n        SetBuiltinOp(op, BuiltinOptions_LessEqualOptions,\n                     CreateLessEqualOptions(builder_).Union());\n        break;\n      }\n      default: { FAIL() << \"We shouldn't get here.\"; }\n    }\n  }\n};\n\nTEST(ComparisonsTest, EqualBool) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_BOOL,\n                          BuiltinOperator_EQUAL);\n  model.PopulateTensor<bool>(model.input1(), {true, false, true, false});\n  model.PopulateTensor<bool>(model.input2(), {true, true, false, false});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, false, false, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, EqualFloat) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_FLOAT32,\n                          BuiltinOperator_EQUAL);\n  model.PopulateTensor<float>(model.input1(), {0.1, 0.9, 0.7, 0.3});\n  model.PopulateTensor<float>(model.input2(), {0.1, 0.2, 0.6, 0.5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, false, false, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, EqualInt) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {1, 2, 7, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, false, true, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, EqualString) {\n  if (SingleOpModel::GetForceUseNnapi()) {\n    return;\n  }\n  ComparisonOpModel model({1, 1, 1, 4, 1}, {1, 1, 1, 4, 1}, TensorType_STRING,\n                          BuiltinOperator_EQUAL);\n  model.PopulateTensor<std::string>(model.input1(), {\"A\", \"B\", \"C\", \"D\"});\n  model.PopulateTensor<std::string>(model.input2(), {\"A\", \"C\", \"B\", \"D\"});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, false, false, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4, 1));\n}\n\nTEST(ComparisonsTest, EqualBroadcast) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 1}, TensorType_INT32,\n                          BuiltinOperator_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {7});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, false, true, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, EqualBroadcastTwoD) {\n  ComparisonOpModel model({1, 1, 2, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3, 2, 4, 2, 8});\n  model.PopulateTensor<int>(model.input2(), {7, 1, 2, 4});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, false, false, false, false,\n                                             false, true, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 2, 4));\n}\n\nTEST(ComparisonsTest, EqualBroadcastString) {\n  if (SingleOpModel::GetForceUseNnapi()) {\n    return;\n  }\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 1}, TensorType_STRING,\n                          BuiltinOperator_EQUAL);\n  model.PopulateTensor<std::string>(model.input1(), {\"A\", \"B\", \"A\", \"B\"});\n  model.PopulateTensor<std::string>(model.input2(), {\"A\"});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, false, true, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, NotEqualBool) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_BOOL,\n                          BuiltinOperator_NOT_EQUAL);\n  model.PopulateTensor<bool>(model.input1(), {true, false, true, false});\n  model.PopulateTensor<bool>(model.input2(), {true, true, false, false});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, true, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, NotEqualFloat) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_FLOAT32,\n                          BuiltinOperator_NOT_EQUAL);\n  model.PopulateTensor<float>(model.input1(), {0.1, 0.9, 0.7, 0.3});\n  model.PopulateTensor<float>(model.input2(), {0.1, 0.2, 0.6, 0.5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, true, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, NotEqualInt) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_NOT_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {1, 2, 7, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, true, false, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, NotEqualString) {\n  if (SingleOpModel::GetForceUseNnapi()) {\n    return;\n  }\n  ComparisonOpModel model({1, 1, 1, 1, 4}, {1, 1, 1, 1, 4}, TensorType_STRING,\n                          BuiltinOperator_NOT_EQUAL);\n  model.PopulateTensor<std::string>(model.input1(), {\"A\", \"B\", \"C\", \"D\"});\n  model.PopulateTensor<std::string>(model.input2(), {\"A\", \"C\", \"B\", \"D\"});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, true, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, NotEqualBroadcast) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 1}, TensorType_INT32,\n                          BuiltinOperator_NOT_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {7});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, true, false, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, NotEqualBroadcastTwoD) {\n  ComparisonOpModel model({1, 1, 2, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_NOT_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3, 2, 4, 2, 8});\n  model.PopulateTensor<int>(model.input2(), {7, 1, 2, 4});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(),\n              ElementsAre(true, true, true, true, true, true, false, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 2, 4));\n}\n\nTEST(ComparisonsTest, NotEqualBroadcastString) {\n  if (SingleOpModel::GetForceUseNnapi()) {\n    return;\n  }\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 1}, TensorType_STRING,\n                          BuiltinOperator_NOT_EQUAL);\n  model.PopulateTensor<std::string>(model.input1(), {\"A\", \"B\", \"A\", \"B\"});\n  model.PopulateTensor<std::string>(model.input2(), {\"A\"});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, false, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, GreaterFloat) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_FLOAT32,\n                          BuiltinOperator_GREATER);\n  model.PopulateTensor<float>(model.input1(), {0.1, 0.9, 0.7, 0.3});\n  model.PopulateTensor<float>(model.input2(), {0.1, 0.2, 0.6, 0.5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, true, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, GreaterInt) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_GREATER);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {1, 2, 7, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, false, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, GreaterBroadcast) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 1}, TensorType_INT32,\n                          BuiltinOperator_GREATER);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {7});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, false, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, GreaterBroadcastTwoD) {\n  ComparisonOpModel model({1, 1, 2, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_GREATER);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3, 2, 4, 2, 8});\n  model.PopulateTensor<int>(model.input2(), {7, 1, 2, 4});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(),\n              ElementsAre(false, true, true, false, false, true, false, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 2, 4));\n}\n\nTEST(ComparisonsTest, GreaterEqualFloat) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_FLOAT32,\n                          BuiltinOperator_GREATER_EQUAL);\n  model.PopulateTensor<float>(model.input1(), {0.1, 0.9, 0.7, 0.3});\n  model.PopulateTensor<float>(model.input2(), {0.1, 0.2, 0.6, 0.5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, true, true, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, GreaterEqualInt) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_GREATER_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {1, 2, 7, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, true, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, GreaterEqualBroadcast) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 1}, TensorType_INT32,\n                          BuiltinOperator_GREATER_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {7});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, true, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, GreaterEqualBroadcastTwoD) {\n  ComparisonOpModel model({1, 1, 2, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_GREATER_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3, 2, 4, 2, 8});\n  model.PopulateTensor<int>(model.input2(), {7, 1, 2, 4});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(),\n              ElementsAre(false, true, true, false, false, true, true, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 2, 4));\n}\n\n\nTEST(ComparisonsTest, LessFloat) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_FLOAT32,\n                          BuiltinOperator_LESS);\n  model.PopulateTensor<float>(model.input1(), {0.1, 0.9, 0.7, 0.3});\n  model.PopulateTensor<float>(model.input2(), {0.1, 0.2, 0.6, 0.5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, false, false, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, LessInt) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_LESS);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {1, 2, 6, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, false, false, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, LessBroadcast) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 1}, TensorType_INT32,\n                          BuiltinOperator_LESS);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {7});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, false, false, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, LessBroadcastTwoD) {\n  ComparisonOpModel model({1, 1, 2, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_LESS);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3, 2, 4, 6, 8});\n  model.PopulateTensor<int>(model.input2(), {7, 1, 2, 4});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(),\n              ElementsAre(true, false, false, true, true, false, false, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 2, 4));\n}\n\nTEST(ComparisonsTest, LessEqualFloat) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_FLOAT32,\n                          BuiltinOperator_LESS_EQUAL);\n  model.PopulateTensor<float>(model.input1(), {0.1, 0.9, 0.7, 0.3});\n  model.PopulateTensor<float>(model.input2(), {0.1, 0.2, 0.6, 0.5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, false, false, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, LessEqualInt) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_LESS_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {1, 2, 7, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, false, true, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, LessEqualBroadcast) {\n  ComparisonOpModel model({1, 1, 1, 4}, {1, 1, 1, 1}, TensorType_INT32,\n                          BuiltinOperator_LESS_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3});\n  model.PopulateTensor<int>(model.input2(), {7});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, false, true, true));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 1, 4));\n}\n\nTEST(ComparisonsTest, LessEqualBroadcastTwoD) {\n  ComparisonOpModel model({1, 1, 2, 4}, {1, 1, 1, 4}, TensorType_INT32,\n                          BuiltinOperator_LESS_EQUAL);\n  model.PopulateTensor<int>(model.input1(), {-1, 9, 7, 3, 2, 4, 2, 8});\n  model.PopulateTensor<int>(model.input2(), {7, 1, 2, 4});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(),\n              ElementsAre(true, false, false, true, true, false, true, false));\n  EXPECT_THAT(model.GetOutputShape(), ElementsAre(1, 1, 2, 4));\n}\n\nTEST(QuantizedComparisonsTest, EqualUInt8Quantized) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  ComparisonOpModel model({TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          {TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          TensorType_UINT8, BuiltinOperator_EQUAL);\n  model.QuantizeAndPopulate<uint8_t>(model.input1(), {1, 9, 7, 3});\n  model.QuantizeAndPopulate<uint8_t>(model.input2(), {1, 2, 7, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, false, true, false));\n}\n\nTEST(QuantizedComparisonsTest, EqualInt8Quantized) {\n  const float kMin = -127.f;\n  const float kMax = 127.f;\n  ComparisonOpModel model({TensorType_INT8, {1, 2, 2, 1}, kMin, kMax},\n                          {TensorType_INT8, {1, 2, 2, 1}, kMin, kMax},\n                          TensorType_INT8, BuiltinOperator_EQUAL);\n  model.QuantizeAndPopulate<int8_t>(model.input1(), {1, -9, 7, 3});\n  model.QuantizeAndPopulate<int8_t>(model.input2(), {-1, 2, 7, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, false, true, false));\n}\n\nTEST(QuantizedComparisonsTest, NotEqualUInt8Quantized) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  ComparisonOpModel model({TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          {TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          TensorType_UINT8, BuiltinOperator_NOT_EQUAL);\n  model.QuantizeAndPopulate<uint8_t>(model.input1(), {1, 9, 7, 3});\n  model.QuantizeAndPopulate<uint8_t>(model.input2(), {1, 2, 7, 0});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, false, true));\n}\n\nTEST(QuantizedComparisonsTest, NotEqualInt8Quantized) {\n  const float kMin = -127.f;\n  const float kMax = 127.f;\n  ComparisonOpModel model({TensorType_INT8, {1, 2, 2, 1}, kMin, kMax},\n                          {TensorType_INT8, {1, 2, 2, 1}, kMin, kMax},\n                          TensorType_INT8, BuiltinOperator_NOT_EQUAL);\n  model.QuantizeAndPopulate<int8_t>(model.input1(), {1, -9, 7, 3});\n  model.QuantizeAndPopulate<int8_t>(model.input2(), {1, 2, 7, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, false, true));\n}\n\nTEST(ComparisonsTest, GreaterQuantized) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  ComparisonOpModel model({TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          {TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          TensorType_UINT8, BuiltinOperator_GREATER);\n  model.QuantizeAndPopulate<uint8_t>(model.input1(), {1, 9, 7, 3});\n  model.QuantizeAndPopulate<uint8_t>(model.input2(), {1, 2, 6, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, true, false));\n}\n\nTEST(ComparisonsTest, GreaterQuantizedSmallRange) {\n  ComparisonOpModel model({TensorType_UINT8, {1, 2, 2, 1}, 0.0, 1.0},\n                          {TensorType_UINT8, {1, 2, 2, 1}, 0.0, 2.0},\n                          TensorType_UINT8, BuiltinOperator_GREATER);\n  model.QuantizeAndPopulate<uint8_t>(model.input1(), {1.0, 0.5, 0.35, 0.1});\n  model.QuantizeAndPopulate<uint8_t>(model.input2(), {1.01, 0.25, 0.3, 0.4});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, true, true, false));\n}\n\nTEST(ComparisonsTest, GreaterEqualQuantized) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  ComparisonOpModel model({TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          {TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          TensorType_UINT8, BuiltinOperator_GREATER_EQUAL);\n  model.QuantizeAndPopulate<uint8_t>(model.input1(), {1, 9, 7, 3});\n  model.QuantizeAndPopulate<uint8_t>(model.input2(), {1, 2, 6, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, true, true, false));\n}\n\nTEST(ComparisonsTest, LessQuantized) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  ComparisonOpModel model({TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          {TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          TensorType_UINT8, BuiltinOperator_LESS);\n  model.QuantizeAndPopulate<uint8_t>(model.input1(), {1, 9, 7, 3});\n  model.QuantizeAndPopulate<uint8_t>(model.input2(), {1, 2, 6, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(false, false, false, true));\n}\n\nTEST(ComparisonsTest, LessEqualQuantized) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  ComparisonOpModel model({TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          {TensorType_UINT8, {1, 2, 2, 1}, kMin, kMax},\n                          TensorType_UINT8, BuiltinOperator_LESS_EQUAL);\n  model.QuantizeAndPopulate<uint8_t>(model.input1(), {1, 9, 7, 3});\n  model.QuantizeAndPopulate<uint8_t>(model.input2(), {1, 2, 6, 5});\n  model.Invoke();\n\n  EXPECT_THAT(model.GetOutput(), ElementsAre(true, false, false, true));\n}\n\nTEST(ComparisonsTest, QuantizedEqualWithBroadcast) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_UINT8, test_shapes[i], kMin, kMax},\n                            {TensorType_UINT8, {}, kMin, kMax},\n                            TensorType_UINT8, BuiltinOperator_EQUAL);\n    model.QuantizeAndPopulate<uint8_t>(model.input1(), {20, 2, 7, 8, 11, 20});\n    model.QuantizeAndPopulate<uint8_t>(model.input2(), {2});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(false, true, false, false, false, false))\n        << \"With shape number \" << i;\n  }\n}\n\nTEST(ComparisonsTest, QuantizedUInt8NotEqualWithBroadcast) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_UINT8, test_shapes[i], kMin, kMax},\n                            {TensorType_UINT8, {}, kMin, kMax},\n                            TensorType_UINT8, BuiltinOperator_NOT_EQUAL);\n    model.QuantizeAndPopulate<uint8_t>(model.input1(), {20, 2, 7, 8, 11, 20});\n    model.QuantizeAndPopulate<uint8_t>(model.input2(), {2});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(true, false, true, true, true, true))\n        << \"With shape number \" << i;\n  }\n}\n\nTEST(ComparisonsTest, QuantizedInt8NotEqualWithBroadcast) {\n  const float kMin = -127.f;\n  const float kMax = 127.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_INT8, test_shapes[i], kMin, kMax},\n                            {TensorType_INT8, {}, kMin, kMax}, TensorType_INT8,\n                            BuiltinOperator_NOT_EQUAL);\n    model.QuantizeAndPopulate<int8_t>(model.input1(), {-20, 2, 7, -8, 11, 20});\n    model.QuantizeAndPopulate<int8_t>(model.input2(), {2});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(true, false, true, true, true, true))\n        << \"With shape number \" << i;\n  }\n}\n\nTEST(ComparisonsTest, QuantizedUInt8GreaterWithBroadcast) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_UINT8, test_shapes[i], kMin, kMax},\n                            {TensorType_UINT8, {}, kMin, kMax},\n                            TensorType_UINT8, BuiltinOperator_GREATER);\n    model.QuantizeAndPopulate<uint8_t>(model.input1(), {20, 2, 7, 8, 11, 20});\n    model.QuantizeAndPopulate<uint8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(true, false, false, false, true, true))\n        << \"With shape number \" << i;\n  }\n}\n\nTEST(ComparisonsTest, QuantizedInt8GreaterWithBroadcast) {\n  const float kMin = -127.f;\n  const float kMax = 127.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_INT8, test_shapes[i], kMin, kMax},\n                            {TensorType_INT8, {}, kMin, kMax}, TensorType_INT8,\n                            BuiltinOperator_GREATER);\n    model.QuantizeAndPopulate<int8_t>(model.input1(), {20, -2, -71, 8, 11, 20});\n    model.QuantizeAndPopulate<int8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(true, false, false, false, true, true))\n        << \"With shape number \" << i;\n  }\n}\n\nTEST(ComparisonsTest,\n     QuantizedInt8GreaterWithBroadcastMultiplierGreaterThanOne) {\n  const float kMin = -127.f;\n  const float kMax = 127.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_INT8, test_shapes[i], kMin, kMax},\n                            {TensorType_INT8, {}, kMin, kMax}, TensorType_INT8,\n                            BuiltinOperator_GREATER);\n    model.QuantizeAndPopulate<int8_t>(model.input1(),\n                                      {572, -2, -71, 8, 11, 20});\n    model.QuantizeAndPopulate<int8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(true, false, false, false, true, true))\n        << \"With shape number \" << i;\n  }\n}\n\nTEST(ComparisonsTest, QuantizedUInt8GreaterEqualWithBroadcast) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_UINT8, test_shapes[i], kMin, kMax},\n                            {TensorType_UINT8, {}, kMin, kMax},\n                            TensorType_UINT8, BuiltinOperator_GREATER_EQUAL);\n    model.QuantizeAndPopulate<uint8_t>(model.input1(), {20, 2, 7, 8, 11, 20});\n    model.QuantizeAndPopulate<uint8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(true, false, false, true, true, true))\n        << \"With shape number \" << i;\n  }\n}\n\nTEST(ComparisonsTest, QuantizedInt8GreaterEqualWithBroadcast) {\n  const float kMin = -127.f;\n  const float kMax = 127.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_INT8, test_shapes[i], kMin, kMax},\n                            {TensorType_INT8, {}, kMin, kMax}, TensorType_INT8,\n                            BuiltinOperator_GREATER_EQUAL);\n    model.QuantizeAndPopulate<int8_t>(model.input1(), {20, -2, -71, 8, 11, 20});\n    model.QuantizeAndPopulate<int8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(true, false, false, true, true, true))\n        << \"With shape number \" << i;\n  }\n}\n\nTEST(ComparisonsTest, QuantizedUInt8LessWithBroadcast) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_UINT8, test_shapes[i], kMin, kMax},\n                            {TensorType_UINT8, {}, kMin, kMax},\n                            TensorType_UINT8, BuiltinOperator_LESS);\n    model.QuantizeAndPopulate<uint8_t>(model.input1(), {20, 2, 7, 8, 11, 20});\n    model.QuantizeAndPopulate<uint8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(false, true, true, false, false, false))\n        << \"With shape number \" << i;\n  }\n}\n\nTEST(ComparisonsTest, QuantizedInt8LessWithBroadcast) {\n  const float kMin = -127.f;\n  const float kMax = 127.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_INT8, test_shapes[i], kMin, kMax},\n                            {TensorType_INT8, {}, kMin, kMax}, TensorType_INT8,\n                            BuiltinOperator_LESS);\n    model.QuantizeAndPopulate<int8_t>(model.input1(), {20, -2, -71, 8, 11, 20});\n    model.QuantizeAndPopulate<int8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(false, true, true, false, false, false))\n        << \"With shape number \" << i;\n  }\n}\n\nTEST(ComparisonsTest, QuantizedUInt8LessEqualWithBroadcast) {\n  const float kMin = -1.f;\n  const float kMax = 128.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_UINT8, test_shapes[i], kMin, kMax},\n                            {TensorType_UINT8, {}, kMin, kMax},\n                            TensorType_UINT8, BuiltinOperator_LESS_EQUAL);\n    model.QuantizeAndPopulate<uint8_t>(model.input1(), {20, 2, 7, 8, 11, 20});\n    model.QuantizeAndPopulate<uint8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(false, true, true, true, false, false))\n        << \"With shape number \" << i;\n  }\n}\n\nTEST(ComparisonsTest, QuantizedInt8LessEqualWithBroadcast) {\n  const float kMin = -127.f;\n  const float kMax = 127.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_INT8, test_shapes[i], kMin, kMax},\n                            {TensorType_INT8, {}, kMin, kMax}, TensorType_INT8,\n                            BuiltinOperator_LESS_EQUAL);\n    model.QuantizeAndPopulate<int8_t>(model.input1(), {20, -2, -71, 8, 11, 20});\n    model.QuantizeAndPopulate<int8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(false, true, true, true, false, false))\n        << \"With shape number \" << i;\n  }\n}\n}  // namespace\n}  // namespace tflite"