"# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for SavedModelCLI tool.\"\"\"\nimport contextlib\nimport os\nimport pickle\nimport platform\nimport shutil\nimport sys\n\nfrom absl.testing import parameterized\nimport numpy as np\nfrom six import StringIO\n\nfrom tensorflow.core.example import example_pb2\nfrom tensorflow.core.framework import types_pb2\nfrom tensorflow.core.protobuf import meta_graph_pb2\nfrom tensorflow.python.debug.wrappers import local_cli_wrapper\nfrom tensorflow.python.eager import def_function\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import tensor_spec\nfrom tensorflow.python.lib.io import file_io\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\nfrom tensorflow.python.platform import tf_logging as logging\nfrom tensorflow.python.saved_model import save\nfrom tensorflow.python.tools import saved_model_cli\nfrom tensorflow.python.training.tracking import tracking\n\nSAVED_MODEL_PATH = ('cc/saved_model/testdata/half_plus_two/00000123')\n\n\n@contextlib.contextmanager\ndef captured_output():\n  new_out, new_err = StringIO(), StringIO()\n  old_out, old_err = sys.stdout, sys.stderr\n  try:\n    sys.stdout, sys.stderr = new_out, new_err\n    yield sys.stdout, sys.stderr\n  finally:\n    sys.stdout, sys.stderr = old_out, old_err\n\n\nclass SavedModelCLITestCase(test.TestCase, parameterized.TestCase):\n\n  def setUp(self):\n    super(SavedModelCLITestCase, self).setUp()\n    if platform.system() == 'Windows':\n      self.skipTest('Skipping failing tests on Windows.')\n\n  def testShowCommandAll(self):\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    self.parser = saved_model_cli.create_parser()\n    args = self.parser.parse_args(['show', '--dir', base_path, '--all'])\n    with captured_output() as (out, err):\n      saved_model_cli.show(args)\n    output = out.getvalue().strip()\n    # pylint: disable=line-too-long\n    exp_out = \"\"\"MetaGraphDef with tag-set: 'serve' contains the following SignatureDefs:\n\nsignature_def['classify_x2_to_y3']:\n  The given SavedModel SignatureDef contains the following input(s):\n    inputs['inputs'] tensor_info:\n        dtype: DT_FLOAT\n        shape: (-1, 1)\n        name: x2:0\n  The given SavedModel SignatureDef contains the following output(s):\n    outputs['scores'] tensor_info:\n        dtype: DT_FLOAT\n        shape: (-1, 1)\n        name: y3:0\n  Method name is: tensorflow/serving/classify\n\nsignature_def['classify_x_to_y']:\n  The given SavedModel SignatureDef contains the following input(s):\n    inputs['inputs'] tensor_info:\n        dtype: DT_STRING\n        shape: unknown_rank\n        name: tf_example:0\n  The given SavedModel SignatureDef contains the following output(s):\n    outputs['scores'] tensor_info:\n        dtype: DT_FLOAT\n        shape: (-1, 1)\n        name: y:0\n  Method name is: tensorflow/serving/classify\n\nsignature_def['regress_x2_to_y3']:\n  The given SavedModel SignatureDef contains the following input(s):\n    inputs['inputs'] tensor_info:\n        dtype: DT_FLOAT\n        shape: (-1, 1)\n        name: x2:0\n  The given SavedModel SignatureDef contains the following output(s):\n    outputs['outputs'] tensor_info:\n        dtype: DT_FLOAT\n        shape: (-1, 1)\n        name: y3:0\n  Method name is: tensorflow/serving/regress\n\nsignature_def['regress_x_to_y']:\n  The given SavedModel SignatureDef contains the following input(s):\n    inputs['inputs'] tensor_info:\n        dtype: DT_STRING\n        shape: unknown_rank\n        name: tf_example:0\n  The given SavedModel SignatureDef contains the following output(s):\n    outputs['outputs'] tensor_info:\n        dtype: DT_FLOAT\n        shape: (-1, 1)\n        name: y:0\n  Method name is: tensorflow/serving/regress\n\nsignature_def['regress_x_to_y2']:\n  The given SavedModel SignatureDef contains the following input(s):\n    inputs['inputs'] tensor_info:\n        dtype: DT_STRING\n        shape: unknown_rank\n        name: tf_example:0\n  The given SavedModel SignatureDef contains the following output(s):\n    outputs['outputs'] tensor_info:\n        dtype: DT_FLOAT\n        shape: (-1, 1)\n        name: y2:0\n  Method name is: tensorflow/serving/regress\n\nsignature_def['serving_default']:\n  The given SavedModel SignatureDef contains the following input(s):\n    inputs['x'] tensor_info:\n        dtype: DT_FLOAT\n        shape: (-1, 1)\n        name: x:0\n  The given SavedModel SignatureDef contains the following output(s):\n    outputs['y'] tensor_info:\n        dtype: DT_FLOAT\n        shape: (-1, 1)\n        name: y:0\n  Method name is: tensorflow/serving/predict\"\"\"\n    # pylint: enable=line-too-long\n    self.maxDiff = None  # Produce a useful error msg if the comparison fails\n    self.assertMultiLineEqual(output, exp_out)\n    self.assertEqual(err.getvalue().strip(), '')\n\n  def testShowAllWithFunctions(self):\n\n    class DummyModel(tracking.AutoTrackable):\n      \"\"\"Model with callable polymorphic functions specified.\"\"\"\n\n      @def_function.function\n      def func1(self, a, b, c):\n        if c:\n          return a + b\n        else:\n          return a * b\n\n      @def_function.function(input_signature=[\n          tensor_spec.TensorSpec(shape=(2, 2), dtype=dtypes.float32)\n      ])\n      def func2(self, x):\n        return x + 2\n\n      @def_function.function\n      def __call__(self, y, c=7):\n        return y + 2 * c\n\n    saved_model_dir = os.path.join(test.get_temp_dir(), 'dummy_model')\n    dummy_model = DummyModel()\n    # Call with specific values to create new polymorphic function traces.\n    dummy_model.func1(constant_op.constant(5), constant_op.constant(9), True)\n    dummy_model(constant_op.constant(5))\n    save.save(dummy_model, saved_model_dir)\n    self.parser = saved_model_cli.create_parser()\n    args = self.parser.parse_args(['show', '--dir', saved_model_dir, '--all'])\n    with captured_output() as (out, err):\n      saved_model_cli.show(args)\n    output = out.getvalue().strip()\n    exp_out = \"\"\"MetaGraphDef with tag-set: 'serve' contains the following SignatureDefs:\n\nsignature_def['__saved_model_init_op']:\n  The given SavedModel SignatureDef contains the following input(s):\n  The given SavedModel SignatureDef contains the following output(s):\n    outputs['__saved_model_init_op'] tensor_info:\n        dtype: DT_INVALID\n        shape: unknown_rank\n        name: NoOp\n  Method name is: \n\nsignature_def['serving_default']:\n  The given SavedModel SignatureDef contains the following input(s):\n    inputs['x'] tensor_info:\n        dtype: DT_FLOAT\n        shape: (2, 2)\n        name: serving_default_x:0\n  The given SavedModel SignatureDef contains the following output(s):\n    outputs['output_0'] tensor_info:\n        dtype: DT_FLOAT\n        shape: (2, 2)\n        name: PartitionedCall:0\n  Method name is: tensorflow/serving/predict\n\nDefined Functions:\n  Function Name: '__call__'\n    Option #1\n      Callable with:\n        Argument #1\n          y: TensorSpec(shape=(), dtype=tf.int32, name='y')\n        Argument #2\n          DType: int\n          Value: 7\n\n  Function Name: 'func1'\n    Option #1\n      Callable with:\n        Argument #1\n          a: TensorSpec(shape=(), dtype=tf.int32, name='a')\n        Argument #2\n          b: TensorSpec(shape=(), dtype=tf.int32, name='b')\n        Argument #3\n          DType: bool\n          Value: True\n\n  Function Name: 'func2'\n    Option #1\n      Callable with:\n        Argument #1\n          x: TensorSpec(shape=(2, 2), dtype=tf.float32, name='x')\n\"\"\".strip()  # pylint: enable=line-too-long\n    self.maxDiff = None  # Produce a useful error msg if the comparison fails\n    self.assertMultiLineEqual(output, exp_out)\n    self.assertEqual(err.getvalue().strip(), '')\n\n  def testShowAllWithPureConcreteFunction(self):\n\n    class DummyModel(tracking.AutoTrackable):\n      \"\"\"Model with a callable concrete function.\"\"\"\n\n      def __init__(self):\n        function = def_function.function(\n            self.multiply,\n            input_signature=[\n                tensor_spec.TensorSpec(shape=(), dtype=dtypes.float32),\n                tensor_spec.TensorSpec(shape=(), dtype=dtypes.float32)\n            ])\n        self.pure_concrete_function = function.get_concrete_function()\n        super(DummyModel, self).__init__()\n\n      def multiply(self, a, b):\n        return a * b\n\n    saved_model_dir = os.path.join(test.get_temp_dir(), 'dummy_model')\n    dummy_model = DummyModel()\n    save.save(dummy_model, saved_model_dir)\n    self.parser = saved_model_cli.create_parser()\n    args = self.parser.parse_args(['show', '--dir', saved_model_dir, '--all'])\n    with captured_output() as (out, err):\n      saved_model_cli.show(args)\n    output = out.getvalue().strip()\n    exp_out = \"\"\"MetaGraphDef with tag-set: 'serve' contains the following SignatureDefs:\n\nsignature_def['__saved_model_init_op']:\n  The given SavedModel SignatureDef contains the following input(s):\n  The given SavedModel SignatureDef contains the following output(s):\n    outputs['__saved_model_init_op'] tensor_info:\n        dtype: DT_INVALID\n        shape: unknown_rank\n        name: NoOp\n  Method name is: \n\nsignature_def['serving_default']:\n  The given SavedModel SignatureDef contains the following input(s):\n    inputs['a'] tensor_info:\n        dtype: DT_FLOAT\n        shape: ()\n        name: serving_default_a:0\n    inputs['b'] tensor_info:\n        dtype: DT_FLOAT\n        shape: ()\n        name: serving_default_b:0\n  The given SavedModel SignatureDef contains the following output(s):\n    outputs['output_0'] tensor_info:\n        dtype: DT_FLOAT\n        shape: ()\n        name: PartitionedCall:0\n  Method name is: tensorflow/serving/predict\n\nDefined Functions:\n  Function Name: 'pure_concrete_function'\n    Option #1\n      Callable with:\n        Argument #1\n          a: TensorSpec(shape=(), dtype=tf.float32, name='a')\n        Argument #2\n          b: TensorSpec(shape=(), dtype=tf.float32, name='b')\n\"\"\".strip()  # pylint: enable=line-too-long\n    self.maxDiff = None  # Produce a useful error msg if the comparison fails\n    self.assertMultiLineEqual(output, exp_out)\n    self.assertEqual(err.getvalue().strip(), '')\n\n  def testShowCommandTags(self):\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    self.parser = saved_model_cli.create_parser()\n    args = self.parser.parse_args(['show', '--dir', base_path])\n    with captured_output() as (out, err):\n      saved_model_cli.show(args)\n    output = out.getvalue().strip()\n    exp_out = 'The given SavedModel contains the following tag-sets:\\n\\'serve\\''\n    self.assertMultiLineEqual(output, exp_out)\n    self.assertEqual(err.getvalue().strip(), '')\n\n  def testShowCommandSignature(self):\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    self.parser = saved_model_cli.create_parser()\n    args = self.parser.parse_args(\n        ['show', '--dir', base_path, '--tag_set', 'serve'])\n    with captured_output() as (out, err):\n      saved_model_cli.show(args)\n    output = out.getvalue().strip()\n    exp_header = ('The given SavedModel MetaGraphDef contains SignatureDefs '\n                  'with the following keys:')\n    exp_start = 'SignatureDef key: '\n    exp_keys = [\n        '\"classify_x2_to_y3\"', '\"classify_x_to_y\"', '\"regress_x2_to_y3\"',\n        '\"regress_x_to_y\"', '\"regress_x_to_y2\"', '\"serving_default\"'\n    ]\n    # Order of signatures does not matter\n    self.assertMultiLineEqual(\n        output,\n        '\\n'.join([exp_header] + [exp_start + exp_key for exp_key in exp_keys]))\n    self.assertEqual(err.getvalue().strip(), '')\n\n  def testShowCommandErrorNoTagSet(self):\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    self.parser = saved_model_cli.create_parser()\n    args = self.parser.parse_args(\n        ['show', '--dir', base_path, '--tag_set', 'badtagset'])\n    with self.assertRaises(RuntimeError):\n      saved_model_cli.show(args)\n\n  def testShowCommandInputsOutputs(self):\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    self.parser = saved_model_cli.create_parser()\n    args = self.parser.parse_args([\n        'show', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'serving_default'\n    ])\n    with captured_output() as (out, err):\n      saved_model_cli.show(args)\n    output = out.getvalue().strip()\n    expected_output = (\n        'The given SavedModel SignatureDef contains the following input(s):\\n'\n        '  inputs[\\'x\\'] tensor_info:\\n'\n        '      dtype: DT_FLOAT\\n      shape: (-1, 1)\\n      name: x:0\\n'\n        'The given SavedModel SignatureDef contains the following output(s):\\n'\n        '  outputs[\\'y\\'] tensor_info:\\n'\n        '      dtype: DT_FLOAT\\n      shape: (-1, 1)\\n      name: y:0\\n'\n        'Method name is: tensorflow/serving/predict')\n    self.assertEqual(output, expected_output)\n    self.assertEqual(err.getvalue().strip(), '')\n\n  def testPrintREFTypeTensor(self):\n    ref_tensor_info = meta_graph_pb2.TensorInfo()\n    ref_tensor_info.dtype = types_pb2.DT_FLOAT_REF\n    with captured_output() as (out, err):\n      saved_model_cli._print_tensor_info(ref_tensor_info)\n    self.assertTrue('DT_FLOAT_REF' in out.getvalue().strip())\n    self.assertEqual(err.getvalue().strip(), '')\n\n  def testInputPreProcessFormats(self):\n    input_str = 'input1=/path/file.txt[ab3];input2=file2'\n    input_expr_str = 'input3=np.zeros([2,2]);input4=[4,5]'\n    input_dict = saved_model_cli.preprocess_inputs_arg_string(input_str)\n    input_expr_dict = saved_model_cli.preprocess_input_exprs_arg_string(\n        input_expr_str)\n    self.assertTrue(input_dict['input1'] == ('/path/file.txt', 'ab3'))\n    self.assertTrue(input_dict['input2'] == ('file2', None))\n    print(input_expr_dict['input3'])\n    self.assertAllClose(input_expr_dict['input3'], np.zeros([2, 2]))\n    self.assertAllClose(input_expr_dict['input4'], [4, 5])\n    self.assertTrue(len(input_dict) == 2)\n    self.assertTrue(len(input_expr_dict) == 2)\n\n  def testInputPreProcessExamplesWithStrAndBytes(self):\n    input_examples_str = 'inputs=[{\"text\":[\"foo\"], \"bytes\":[b\"bar\"]}]'\n    input_dict = saved_model_cli.preprocess_input_examples_arg_string(\n        input_examples_str)\n    feature = example_pb2.Example.FromString(input_dict['inputs'][0])\n    self.assertProtoEquals(\n        \"\"\"\n          features {\n            feature {\n              key: \"bytes\"\n              value {\n                bytes_list {\n                  value: \"bar\"\n                }\n              }\n            }\n            feature {\n              key: \"text\"\n              value {\n                bytes_list {\n                  value: \"foo\"\n                }\n              }\n            }\n          }\n    \"\"\", feature)\n\n  def testInputPreProcessFileNames(self):\n    input_str = (r'inputx=C:\\Program Files\\data.npz[v:0];'\n                 r'input:0=c:\\PROGRA~1\\data.npy')\n    input_dict = saved_model_cli.preprocess_inputs_arg_string(input_str)\n    self.assertTrue(input_dict['inputx'] == (r'C:\\Program Files\\data.npz',\n                                             'v:0'))\n    self.assertTrue(input_dict['input:0'] == (r'c:\\PROGRA~1\\data.npy', None))\n\n  def testInputPreProcessErrorBadFormat(self):\n    input_str = 'inputx=file[[v1]v2'\n    with self.assertRaises(RuntimeError):\n      saved_model_cli.preprocess_inputs_arg_string(input_str)\n    input_str = 'inputx:file'\n    with self.assertRaises(RuntimeError):\n      saved_model_cli.preprocess_inputs_arg_string(input_str)\n    input_str = 'inputx:np.zeros((5))'\n    with self.assertRaises(RuntimeError):\n      saved_model_cli.preprocess_input_exprs_arg_string(input_str)\n\n  def testInputParserNPY(self):\n    x0 = np.array([[1], [2]])\n    x1 = np.array(range(6)).reshape(2, 3)\n    input0_path = os.path.join(test.get_temp_dir(), 'input0.npy')\n    input1_path = os.path.join(test.get_temp_dir(), 'input1.npy')\n    np.save(input0_path, x0)\n    np.save(input1_path, x1)\n    input_str = 'x0=' + input0_path + '[x0];x1=' + input1_path\n    feed_dict = saved_model_cli.load_inputs_from_input_arg_string(\n        input_str, '', '')\n    self.assertTrue(np.all(feed_dict['x0'] == x0))\n    self.assertTrue(np.all(feed_dict['x1'] == x1))\n\n  def testInputParserNPZ(self):\n    x0 = np.array([[1], [2]])\n    input_path = os.path.join(test.get_temp_dir(), 'input.npz')\n    np.savez(input_path, a=x0)\n    input_str = 'x=' + input_path + '[a];y=' + input_path\n    feed_dict = saved_model_cli.load_inputs_from_input_arg_string(\n        input_str, '', '')\n    self.assertTrue(np.all(feed_dict['x'] == x0))\n    self.assertTrue(np.all(feed_dict['y'] == x0))\n\n  def testInputParserPickle(self):\n    pkl0 = {'a': 5, 'b': np.array(range(4))}\n    pkl1 = np.array([1])\n    pkl2 = np.array([[1], [3]])\n    input_path0 = os.path.join(test.get_temp_dir(), 'pickle0.pkl')\n    input_path1 = os.path.join(test.get_temp_dir(), 'pickle1.pkl')\n    input_path2 = os.path.join(test.get_temp_dir(), 'pickle2.pkl')\n    with open(input_path0, 'wb') as f:\n      pickle.dump(pkl0, f)\n    with open(input_path1, 'wb') as f:\n      pickle.dump(pkl1, f)\n    with open(input_path2, 'wb') as f:\n      pickle.dump(pkl2, f)\n    input_str = 'x=' + input_path0 + '[b];y=' + input_path1 + '[c];'\n    input_str += 'z=' + input_path2\n    feed_dict = saved_model_cli.load_inputs_from_input_arg_string(\n        input_str, '', '')\n    self.assertTrue(np.all(feed_dict['x'] == pkl0['b']))\n    self.assertTrue(np.all(feed_dict['y'] == pkl1))\n    self.assertTrue(np.all(feed_dict['z'] == pkl2))\n\n  def testInputParserPythonExpression(self):\n    x1 = np.ones([2, 10])\n    x2 = np.array([[1], [2], [3]])\n    x3 = np.mgrid[0:5, 0:5]\n    x4 = [[3], [4]]\n    input_expr_str = ('x1=np.ones([2,10]);x2=np.array([[1],[2],[3]]);'\n                      'x3=np.mgrid[0:5,0:5];x4=[[3],[4]]')\n    feed_dict = saved_model_cli.load_inputs_from_input_arg_string(\n        '', input_expr_str, '')\n    self.assertTrue(np.all(feed_dict['x1'] == x1))\n    self.assertTrue(np.all(feed_dict['x2'] == x2))\n    self.assertTrue(np.all(feed_dict['x3'] == x3))\n    self.assertTrue(np.all(feed_dict['x4'] == x4))\n\n  def testInputParserBoth(self):\n    x0 = np.array([[1], [2]])\n    input_path = os.path.join(test.get_temp_dir(), 'input.npz')\n    np.savez(input_path, a=x0)\n    x1 = np.ones([2, 10])\n    input_str = 'x0=' + input_path + '[a]'\n    input_expr_str = 'x1=np.ones([2,10])'\n    feed_dict = saved_model_cli.load_inputs_from_input_arg_string(\n        input_str, input_expr_str, '')\n    self.assertTrue(np.all(feed_dict['x0'] == x0))\n    self.assertTrue(np.all(feed_dict['x1'] == x1))\n\n  def testInputParserBothDuplicate(self):\n    x0 = np.array([[1], [2]])\n    input_path = os.path.join(test.get_temp_dir(), 'input.npz')\n    np.savez(input_path, a=x0)\n    x1 = np.ones([2, 10])\n    input_str = 'x0=' + input_path + '[a]'\n    input_expr_str = 'x0=np.ones([2,10])'\n    feed_dict = saved_model_cli.load_inputs_from_input_arg_string(\n        input_str, input_expr_str, '')\n    self.assertTrue(np.all(feed_dict['x0'] == x1))\n\n  def testInputParserErrorNoName(self):\n    x0 = np.array([[1], [2]])\n    x1 = np.array(range(5))\n    input_path = os.path.join(test.get_temp_dir(), 'input.npz')\n    np.savez(input_path, a=x0, b=x1)\n    input_str = 'x=' + input_path\n    with self.assertRaises(RuntimeError):\n      saved_model_cli.load_inputs_from_input_arg_string(input_str, '', '')\n\n  def testInputParserErrorWrongName(self):\n    x0 = np.array([[1], [2]])\n    x1 = np.array(range(5))\n    input_path = os.path.join(test.get_temp_dir(), 'input.npz')\n    np.savez(input_path, a=x0, b=x1)\n    input_str = 'x=' + input_path + '[c]'\n    with self.assertRaises(RuntimeError):\n      saved_model_cli.load_inputs_from_input_arg_string(input_str, '', '')\n\n  def testRunCommandInputExamples(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    output_dir = os.path.join(test.get_temp_dir(), 'new_dir')\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'regress_x_to_y', '--input_examples',\n        'inputs=[{\"x\":[8.0],\"x2\":[5.0]}, {\"x\":[4.0],\"x2\":[3.0]}]', '--outdir',\n        output_dir\n    ])\n    saved_model_cli.run(args)\n    y_actual = np.load(os.path.join(output_dir, 'outputs.npy'))\n    y_expected = np.array([[6.0], [4.0]])\n    self.assertAllEqual(y_expected, y_actual)\n\n  def testRunCommandExistingOutdir(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    x = np.array([[1], [2]])\n    x_notused = np.zeros((6, 3))\n    input_path = os.path.join(test.get_temp_dir(), 'testRunCommand_inputs.npz')\n    np.savez(input_path, x0=x, x1=x_notused)\n    output_file = os.path.join(test.get_temp_dir(), 'outputs.npy')\n    if os.path.exists(output_file):\n      os.remove(output_file)\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'regress_x2_to_y3', '--inputs', 'inputs=' + input_path + '[x0]',\n        '--outdir',\n        test.get_temp_dir()\n    ])\n    saved_model_cli.run(args)\n    y_actual = np.load(output_file)\n    y_expected = np.array([[3.5], [4.0]])\n    self.assertAllClose(y_expected, y_actual)\n\n  def testRunCommandNewOutdir(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    x = np.array([[1], [2]])\n    x_notused = np.zeros((6, 3))\n    input_path = os.path.join(test.get_temp_dir(),\n                              'testRunCommandNewOutdir_inputs.npz')\n    output_dir = os.path.join(test.get_temp_dir(), 'new_dir')\n    if os.path.isdir(output_dir):\n      shutil.rmtree(output_dir)\n    np.savez(input_path, x0=x, x1=x_notused)\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'serving_default', '--inputs', 'x=' + input_path + '[x0]', '--outdir',\n        output_dir\n    ])\n    saved_model_cli.run(args)\n    y_actual = np.load(os.path.join(output_dir, 'y.npy'))\n    y_expected = np.array([[2.5], [3.0]])\n    self.assertAllClose(y_expected, y_actual)\n\n  def testRunCommandOutOverwrite(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    x = np.array([[1], [2]])\n    x_notused = np.zeros((6, 3))\n    input_path = os.path.join(test.get_temp_dir(),\n                              'testRunCommandOutOverwrite_inputs.npz')\n    np.savez(input_path, x0=x, x1=x_notused)\n    output_file = os.path.join(test.get_temp_dir(), 'y.npy')\n    open(output_file, 'a').close()\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'serving_default', '--inputs', 'x=' + input_path + '[x0]', '--outdir',\n        test.get_temp_dir(), '--overwrite'\n    ])\n    saved_model_cli.run(args)\n    y_actual = np.load(output_file)\n    y_expected = np.array([[2.5], [3.0]])\n    self.assertAllClose(y_expected, y_actual)\n\n  def testRunCommandInvalidInputKeyError(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'regress_x2_to_y3', '--input_exprs', 'x2=np.ones((3,1))'\n    ])\n    with self.assertRaises(ValueError):\n      saved_model_cli.run(args)\n\n  def testRunCommandInvalidSignature(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'INVALID_SIGNATURE', '--input_exprs', 'x2=np.ones((3,1))'\n    ])\n    with self.assertRaisesRegex(ValueError,\n                                'Could not find signature \"INVALID_SIGNATURE\"'):\n      saved_model_cli.run(args)\n\n  def testRunCommandInputExamplesNotListError(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    output_dir = os.path.join(test.get_temp_dir(), 'new_dir')\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'regress_x_to_y', '--input_examples', 'inputs={\"x\":8.0,\"x2\":5.0}',\n        '--outdir', output_dir\n    ])\n    with self.assertRaisesRegex(ValueError, 'must be a list'):\n      saved_model_cli.run(args)\n\n  def testRunCommandInputExamplesFeatureValueNotListError(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    output_dir = os.path.join(test.get_temp_dir(), 'new_dir')\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'regress_x_to_y', '--input_examples', 'inputs=[{\"x\":8.0,\"x2\":5.0}]',\n        '--outdir', output_dir\n    ])\n    with self.assertRaisesRegex(ValueError, 'feature value must be a list'):\n      saved_model_cli.run(args)\n\n  def testRunCommandInputExamplesFeatureBadType(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    output_dir = os.path.join(test.get_temp_dir(), 'new_dir')\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'regress_x_to_y', '--input_examples', 'inputs=[{\"x\":[[1],[2]]}]',\n        '--outdir', output_dir\n    ])\n    with self.assertRaisesRegex(ValueError, 'is not supported'):\n      saved_model_cli.run(args)\n\n  def testRunCommandOutputFileExistError(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    x = np.array([[1], [2]])\n    x_notused = np.zeros((6, 3))\n    input_path = os.path.join(test.get_temp_dir(),\n                              'testRunCommandOutOverwrite_inputs.npz')\n    np.savez(input_path, x0=x, x1=x_notused)\n    output_file = os.path.join(test.get_temp_dir(), 'y.npy')\n    open(output_file, 'a').close()\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'serving_default', '--inputs', 'x=' + input_path + '[x0]', '--outdir',\n        test.get_temp_dir()\n    ])\n    with self.assertRaises(RuntimeError):\n      saved_model_cli.run(args)\n\n  def testRunCommandInputNotGivenError(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'serving_default'\n    ])\n    with self.assertRaises(AttributeError):\n      saved_model_cli.run(args)\n\n  def testRunCommandWithDebuggerEnabled(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    x = np.array([[1], [2]])\n    x_notused = np.zeros((6, 3))\n    input_path = os.path.join(test.get_temp_dir(),\n                              'testRunCommandNewOutdir_inputs.npz')\n    output_dir = os.path.join(test.get_temp_dir(), 'new_dir')\n    if os.path.isdir(output_dir):\n      shutil.rmtree(output_dir)\n    np.savez(input_path, x0=x, x1=x_notused)\n    args = self.parser.parse_args([\n        'run', '--dir', base_path, '--tag_set', 'serve', '--signature_def',\n        'serving_default', '--inputs', 'x=' + input_path + '[x0]', '--outdir',\n        output_dir, '--tf_debug'\n    ])\n\n    def fake_wrapper_session(sess):\n      return sess\n\n    with test.mock.patch.object(\n        local_cli_wrapper,\n        'LocalCLIDebugWrapperSession',\n        side_effect=fake_wrapper_session,\n        autospec=True) as fake:\n      saved_model_cli.run(args)\n      fake.assert_called_with(test.mock.ANY)\n\n    y_actual = np.load(os.path.join(output_dir, 'y.npy'))\n    y_expected = np.array([[2.5], [3.0]])\n    self.assertAllClose(y_expected, y_actual)\n\n  def testScanCommand(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    args = self.parser.parse_args(['scan', '--dir', base_path])\n    with captured_output() as (out, _):\n      saved_model_cli.scan(args)\n    output = out.getvalue().strip()\n    self.assertTrue('does not contain denylisted ops' in output)\n\n  def testScanCommandFoundDenylistedOp(self):\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    args = self.parser.parse_args(\n        ['scan', '--dir', base_path, '--tag_set', 'serve'])\n    op_denylist = saved_model_cli._OP_DENYLIST\n    saved_model_cli._OP_DENYLIST = set(['VariableV2'])\n    with captured_output() as (out, _):\n      saved_model_cli.scan(args)\n    saved_model_cli._OP_DENYLIST = op_denylist\n    output = out.getvalue().strip()\n    self.assertTrue('\\'VariableV2\\'' in output)\n\n  def testAOTCompileCPUWrongSignatureDefKey(self):\n    if not test.is_built_with_xla():\n      self.skipTest('Skipping test because XLA is not compiled in.')\n\n    self.parser = saved_model_cli.create_parser()\n    base_path = test.test_src_dir_path(SAVED_MODEL_PATH)\n    output_dir = os.path.join(test.get_temp_dir(), 'aot_compile_cpu_dir')\n    args = self.parser.parse_args([\n        'aot_compile_cpu', '--dir', base_path, '--tag_set', 'serve',\n        '--output_prefix', output_dir, '--cpp_class', 'Compiled',\n        '--signature_def_key', 'MISSING'\n    ])\n    with self.assertRaisesRegex(ValueError, 'Unable to find signature_def'):\n      saved_model_cli.aot_compile_cpu(args)\n\n  class AOTCompileDummyModel(tracking.AutoTrackable):\n    \"\"\"Model compatible with XLA compilation.\"\"\"\n\n    def __init__(self):\n      self.var = variables.Variable(1.0, name='my_var')\n      self.write_var = variables.Variable(1.0, name='write_var')\n\n    @def_function.function(input_signature=[\n        tensor_spec.TensorSpec(shape=(2, 2), dtype=dtypes.float32),\n        # Test unused inputs.\n        tensor_spec.TensorSpec(shape=(), dtype=dtypes.float32),\n    ])\n    def func2(self, x, y):\n      del y\n      return {'res': x + self.var}\n\n    @def_function.function(input_signature=[\n        # Test large inputs.\n        tensor_spec.TensorSpec(shape=(2048, 16), dtype=dtypes.float32),\n        tensor_spec.TensorSpec(shape=(), dtype=dtypes.float32),\n    ])\n    def func3(self, x, y):\n      del y\n      return {'res': x + self.var}\n\n    @def_function.function(input_signature=[\n        tensor_spec.TensorSpec(shape=(), dtype=dtypes.float32),\n        tensor_spec.TensorSpec(shape=(), dtype=dtypes.float32),\n    ])\n    def func_write(self, x, y):\n      del y\n      self.write_var.assign(x + self.var)\n      return {'res': self.write_var}\n\n  @parameterized.named_parameters(\n      ('VariablesToFeedNone', '', 'func2', None),\n      ('VariablesToFeedNoneTargetAarch64Linux', '', 'func2',\n       'aarch64-none-linux-gnu'),\n      ('VariablesToFeedNoneTargetAarch64Android', '', 'func2',\n       'aarch64-none-android'),\n      ('VariablesToFeedAll', 'all', 'func2', None),\n      ('VariablesToFeedMyVar', 'my_var', 'func2', None),\n      ('VariablesToFeedNoneLargeConstant', '', 'func3', None),\n      ('WriteToWriteVar', 'all', 'func_write', None),\n  )\n  def testAOTCompileCPUFreezesAndCompiles(\n      self, variables_to_feed, func, target_triple):\n    if not test.is_built_with_xla():\n      self.skipTest('Skipping test because XLA is not compiled in.')\n\n    saved_model_dir = os.path.join(test.get_temp_dir(), 'dummy_model')\n    dummy_model = self.AOTCompileDummyModel()\n    func = getattr(dummy_model, func)\n    with self.cached_session():\n      self.evaluate(dummy_model.var.initializer)\n      self.evaluate(dummy_model.write_var.initializer)\n      save.save(dummy_model, saved_model_dir, signatures={'func': func})\n\n    self.parser = saved_model_cli.create_parser()\n    output_prefix = os.path.join(test.get_temp_dir(), 'aot_compile_cpu_dir/out')\n    args = [  # Use the default seving signature_key.\n        'aot_compile_cpu', '--dir', saved_model_dir, '--tag_set', 'serve',\n        '--signature_def_key', 'func', '--output_prefix', output_prefix,\n        '--variables_to_feed', variables_to_feed, '--cpp_class', 'Generated'\n    ]\n    if target_triple:\n      args.extend(['--target_triple', target_triple])\n    args = self.parser.parse_args(args)\n    with test.mock.patch.object(logging, 'warn') as captured_warn:\n      saved_model_cli.aot_compile_cpu(args)\n    self.assertRegex(\n        str(captured_warn.call_args),\n        'Signature input key \\'y\\'.*has been pruned while freezing the graph.')\n    self.assertTrue(file_io.file_exists('{}.o'.format(output_prefix)))\n    self.assertTrue(file_io.file_exists('{}.h'.format(output_prefix)))\n    self.assertTrue(file_io.file_exists('{}_metadata.o'.format(output_prefix)))\n    self.assertTrue(\n        file_io.file_exists('{}_makefile.inc'.format(output_prefix)))\n    header_contents = file_io.read_file_to_string('{}.h'.format(output_prefix))\n    self.assertIn('class Generated', header_contents)\n    self.assertIn('arg_feed_x_data', header_contents)\n    self.assertIn('result_fetch_res_data', header_contents)\n    # arg_y got filtered out as it's not used by the output.\n    self.assertNotIn('arg_feed_y_data', header_contents)\n    if variables_to_feed:\n      # Read-only-variables' setters preserve constness.\n      self.assertIn('set_var_param_my_var_data(const float', header_contents)\n      self.assertNotIn('set_var_param_my_var_data(float', header_contents)\n    if func == dummy_model.func_write:\n      # Writeable variables setters do not preserve constness.\n      self.assertIn('set_var_param_write_var_data(float', header_contents)\n      self.assertNotIn('set_var_param_write_var_data(const float',\n                       header_contents)\n\n    makefile_contents = file_io.read_file_to_string(\n        '{}_makefile.inc'.format(output_prefix))\n    self.assertIn('-D_GLIBCXX_USE_CXX11_ABI=', makefile_contents)\n\n\nif __name__ == '__main__':\n  test.main()"