"/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Based on \"Notes on generating Sobol sequences. August 2008\" by Joe and Kuo.\n// [1] https://web.maths.unsw.edu.au/~fkuo/sobol/joe-kuo-notes.pdf\n#include <algorithm>\n#include <cmath>\n#include <cstdint>\n#include <limits>\n\n#include \"third_party/eigen3/Eigen/Core\"\n#include \"sobol_data.h\"  // from @sobol_data\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/platform/platform_strings.h\"\n\nnamespace tensorflow {\n\n// Embed the platform strings in this binary.\nTF_PLATFORM_STRINGS()\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n\nnamespace {\n\n// Each thread will calculate at least kMinBlockSize points in the sequence.\nconstexpr int kMinBlockSize = 512;\n\n// Returns number of digits in binary representation of n.\n// Example: n=13. Binary representation is 1101. NumBinaryDigits(13) -> 4.\nint NumBinaryDigits(int n) {\n  return static_cast<int>(std::log2(n) + 1);\n}\n\n// Returns position of rightmost zero digit in binary representation of n.\n// Example: n=13. Binary representation is 1101. RightmostZeroBit(13) -> 1.\nint RightmostZeroBit(int n) {\n  int k = 0;\n  while (n & 1) {\n    n >>= 1;\n    ++k;\n  }\n  return k;\n}\n\n// Returns an integer representation of point `i` in the Sobol sequence of\n// dimension `dim` using the given direction numbers.\nEigen::VectorXi GetFirstPoint(int i, int dim,\n                              const Eigen::MatrixXi& direction_numbers) {\n  // Index variables used in this function, consistent with notation in [1].\n  // i - point in the Sobol sequence\n  // j - dimension\n  // k - binary digit\n  Eigen::VectorXi integer_sequence = Eigen::VectorXi::Zero(dim);\n  // go/wiki/Sobol_sequence#A_fast_algorithm_for_the_construction_of_Sobol_sequences\n  int gray_code = i ^ (i >> 1);\n  int num_digits = NumBinaryDigits(i);\n  for (int j = 0; j < dim; ++j) {\n    for (int k = 0; k < num_digits; ++k) {\n      if ((gray_code >> k) & 1) integer_sequence(j) ^= direction_numbers(j, k);\n    }\n  }\n  return integer_sequence;\n}\n\n// Calculates `num_results` Sobol points of dimension `dim` starting at the\n// point `start_point + skip` and writes them into `output` starting at point\n// `start_point`.\ntemplate <typename T>\nvoid CalculateSobolSample(int32_t dim, int32_t num_results, int32_t skip,\n                          int32_t start_point,\n                          typename TTypes<T>::Flat output) {\n  // Index variables used in this function, consistent with notation in [1].\n  // i - point in the Sobol sequence\n  // j - dimension\n  // k - binary digit\n  const int num_digits =\n      NumBinaryDigits(skip + start_point + num_results + 1);\n  Eigen::MatrixXi direction_numbers(dim, num_digits);\n\n  // Shift things so we can use integers everywhere. Before we write to output,\n  // divide by constant to convert back to floats.\n  const T normalizing_constant = 1./(1 << num_digits);\n  for (int j = 0; j < dim; ++j) {\n    for (int k = 0; k < num_digits; ++k) {\n      direction_numbers(j, k) = sobol_data::kDirectionNumbers[j][k]\n                                << (num_digits - k - 1);\n    }\n  }\n\n  // If needed, skip ahead to the appropriate point in the sequence. Otherwise\n  // we start with the first column of direction numbers.\n  Eigen::VectorXi integer_sequence =\n      (skip + start_point > 0)\n          ? GetFirstPoint(skip + start_point + 1, dim, direction_numbers)\n          : direction_numbers.col(0);\n\n  for (int j = 0; j < dim; ++j) {\n    output(start_point * dim + j) = integer_sequence(j) * normalizing_constant;\n  }\n  // go/wiki/Sobol_sequence#A_fast_algorithm_for_the_construction_of_Sobol_sequences\n  for (int i = start_point + 1; i < num_results + start_point; ++i) {\n    // The Gray code for the current point differs from the preceding one by\n    // just a single bit -- the rightmost bit.\n    int k = RightmostZeroBit(i + skip);\n    // Update the current point from the preceding one with a single XOR\n    // operation per dimension.\n    for (int j = 0; j < dim; ++j) {\n      integer_sequence(j) ^= direction_numbers(j, k);\n      output(i * dim + j) = integer_sequence(j) * normalizing_constant;\n    }\n  }\n}\n\n}  // namespace\n\ntemplate <typename Device, typename T>\nclass SobolSampleOp : public OpKernel {\n public:\n  explicit SobolSampleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"dim must be a scalar\"));\n    int32_t dim = context->input(0).scalar<int32_t>()();\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(1).shape()),\n                errors::InvalidArgument(\"num_results must be a scalar\"));\n    int32_t num_results = context->input(1).scalar<int32_t>()();\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(2).shape()),\n                errors::InvalidArgument(\"skip must be a scalar\"));\n    int32_t skip = context->input(2).scalar<int32_t>()();\n\n    OP_REQUIRES(context, dim >= 1,\n                errors::InvalidArgument(\"dim must be at least one\"));\n    OP_REQUIRES(context, dim <= sobol_data::kMaxSobolDim,\n                errors::InvalidArgument(\"dim must be at most \",\n                                        sobol_data::kMaxSobolDim));\n    OP_REQUIRES(context, num_results >= 1,\n                errors::InvalidArgument(\"num_results must be at least one\"));\n    OP_REQUIRES(context, skip >= 0,\n                errors::InvalidArgument(\"skip must be non-negative\"));\n    OP_REQUIRES(context,\n                num_results < std::numeric_limits<int32_t>::max() - skip,\n                errors::InvalidArgument(\"num_results+skip must be less than \",\n                                        std::numeric_limits<int32_t>::max()));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({num_results, dim}), &output));\n    auto output_flat = output->flat<T>();\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    int num_threads = worker_threads.num_threads;\n    int block_size = std::max(\n        kMinBlockSize, static_cast<int>(std::ceil(\n                           static_cast<float>(num_results) / num_threads)));\n    worker_threads.workers->TransformRangeConcurrently(\n        block_size, num_results /* total */,\n        [&dim, &skip, &output_flat](const int start, const int end) {\n          CalculateSobolSample<T>(dim, end - start /* num_results */, skip,\n                                  start, output_flat);\n        });\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"SobolSample\").Device(DEVICE_CPU).TypeConstraint<double>(\"dtype\"),\n    SobolSampleOp<CPUDevice, double>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"SobolSample\").Device(DEVICE_CPU).TypeConstraint<float>(\"dtype\"),\n    SobolSampleOp<CPUDevice, float>);\n\n}  // namespace tensorflow"