"diff --git a/tensorflow/lite/kernels/internal/reference/reference_ops.h b/tensorflow/lite/kernels/internal/reference/reference_ops.h\nindex baf74497b6b..2879212d2fc 100644\n--- a/tensorflow/lite/kernels/internal/reference/reference_ops.h\n+++ b/tensorflow/lite/kernels/internal/reference/reference_ops.h\n@@ -29,6 +29,7 @@ limitations under the License.\n #include \"third_party/eigen3/Eigen/Core\"\n #include \"fixedpoint/fixedpoint.h\"\n #include \"ruy/profiler/instrumentation.h\"  // from @ruy\n+#include \"tensorflow/lite/c/c_api_types.h\"\n #include \"tensorflow/lite/c/common.h\"\n #include \"tensorflow/lite/kernels/internal/common.h\"\n #include \"tensorflow/lite/kernels/internal/quantization_util.h\"\n@@ -595,23 +596,31 @@ inline GatherNdHelperResult GatherNdHelper(const RuntimeShape& params_shape,\n   return ret;\n }\n \n+// Implements GatherNd.\n+// Returns an error if any of the indices_data would cause an out of bounds\n+// memory read.\n template <typename ParamsT, typename IndicesT = int32>\n-inline void GatherNd(const RuntimeShape& params_shape,\n-                     const ParamsT* params_data,\n-                     const RuntimeShape& indices_shape,\n-                     const IndicesT* indices_data,\n-                     const RuntimeShape& output_shape, ParamsT* output_data) {\n+inline TfLiteStatus GatherNd(const RuntimeShape& params_shape,\n+                             const ParamsT* params_data,\n+                             const RuntimeShape& indices_shape,\n+                             const IndicesT* indices_data,\n+                             const RuntimeShape& output_shape,\n+                             ParamsT* output_data) {\n   ruy::profiler::ScopeLabel label(\"GatherNd\");\n \n   const GatherNdHelperResult res = GatherNdHelper(params_shape, indices_shape);\n   for (int i = 0; i < res.n_slices; ++i) {\n-    int from_pos = 0;\n+    int64_t from_pos = 0;\n     for (int j = 0; j < res.indices_nd; ++j) {\n       from_pos += indices_data[i * res.indices_nd + j] * res.dims_to_count[j];\n     }\n+    if (from_pos < 0 || from_pos + res.slice_size > params_shape.FlatSize()) {\n+      return kTfLiteError;\n+    }\n     std::memcpy(output_data + i * res.slice_size, params_data + from_pos,\n                 sizeof(ParamsT) * res.slice_size);\n   }\n+  return kTfLiteOk;\n }\n \n #ifndef TF_LITE_STATIC_MEMORY"