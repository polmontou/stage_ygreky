"/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include <stdint.h>\n\n#include <initializer_list>\n#include <vector>\n\n#include <gtest/gtest.h>\n#include \"flatbuffers/flatbuffers.h\"  // from @flatbuffers\n#include \"tensorflow/lite/kernels/test_util.h\"\n#include \"tensorflow/lite/schema/schema_generated.h\"\n\nnamespace tflite {\nnamespace {\n\nusing ::testing::ElementsAreArray;\n\nclass ScatterNdOpModel : public SingleOpModel {\n public:\n  ScatterNdOpModel(const TensorData& indices, const TensorData& updates,\n                   const TensorData& shape) {\n    indices_ = AddInput(indices);\n    updates_ = AddInput(updates);\n    shape_ = AddInput(shape);\n    output_ = AddOutput(updates.type);\n    SetBuiltinOp(BuiltinOperator_SCATTER_ND, BuiltinOptions_ScatterNdOptions,\n                 CreateScatterNdOptions(builder_).Union());\n    BuildInterpreter(\n        {GetShape(indices_), GetShape(updates_), GetShape(shape_)});\n  }\n\n  template <typename T>\n  void SetIndices(std::initializer_list<T> data) {\n    PopulateTensor<T>(indices_, data);\n  }\n\n  template <typename T>\n  void SetUpdates(std::initializer_list<T> data) {\n    PopulateTensor<T>(updates_, data);\n  }\n\n  template <typename T>\n  void SetShape(std::initializer_list<T> data) {\n    PopulateTensor<T>(shape_, data);\n  }\n\n  template <typename T>\n  std::vector<T> GetOutput() {\n    return ExtractVector<T>(output_);\n  }\n\n  std::vector<int> GetOutputShape() { return GetTensorShape(output_); }\n\n protected:\n  int indices_;\n  int updates_;\n  int shape_;\n  int output_;\n};\n\nTEST(ScatterNdOpTest, ScatterElementIntoVector) {\n  ScatterNdOpModel m({TensorType_INT32, {4, 1}}, {TensorType_FLOAT32, {4}},\n                     {TensorType_INT32, {1}});\n  m.SetIndices<int32_t>({4, 3, 1, 7});\n  m.SetUpdates<float>({9, 10, 11, 12});\n  m.SetShape<int32_t>({8});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({8}));\n  EXPECT_THAT(m.GetOutput<float>(),\n              ElementsAreArray({0, 11, 0, 10, 9, 0, 0, 12}));\n}\n\nTEST(ScatterNdOpTest, ScatterMatrixIntoRank3Tensor) {\n  ScatterNdOpModel m({TensorType_INT32, {2, 1}},\n                     {TensorType_FLOAT32, {2, 4, 4}}, {TensorType_INT32, {3}});\n  m.SetIndices<int32_t>({0, 2});\n  m.SetUpdates<float>({5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8,\n                       5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8});\n  m.SetShape<int32_t>({4, 4, 4});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({4, 4, 4}));\n  EXPECT_THAT(\n      m.GetOutput<float>(),\n      ElementsAreArray({5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8,\n                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                        5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8,\n                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}));\n}\n\nTEST(ScatterNdOpTest, ScatterVectorIntoMatrix) {\n  ScatterNdOpModel m({TensorType_INT32, {4, 1}}, {TensorType_FLOAT32, {4, 4}},\n                     {TensorType_INT32, {2}});\n  m.SetIndices<int32_t>({/*0*/ 9, /*1*/ 8, /*2*/ 0, /*3*/ 1});\n  m.SetUpdates<float>({/*0*/ 1, 2, 3, 4,\n                       /*1*/ 5, 6, 7, 8,\n                       /*2*/ 9, 10, 11, 12,\n                       /*3*/ 13, 14, 15, 16});\n  m.SetShape<int32_t>({10, 4});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({10, 4}));\n  EXPECT_THAT(m.GetOutput<float>(),\n              ElementsAreArray({/*0*/ 9,  10, 11, 12,\n                                /*1*/ 13, 14, 15, 16,\n                                /*2*/ 0,  0,  0,  0,\n                                /*3*/ 0,  0,  0,  0,\n                                /*4*/ 0,  0,  0,  0,\n                                /*5*/ 0,  0,  0,  0,\n                                /*6*/ 0,  0,  0,  0,\n                                /*7*/ 0,  0,  0,  0,\n                                /*8*/ 5,  6,  7,  8,\n                                /*9*/ 1,  2,  3,  4}));\n}\n\nTEST(ScatterNdOpTest, ScatterMatricesIntoRank4Tensor) {\n  ScatterNdOpModel m({TensorType_INT32, {2, 2, 2}},\n                     {TensorType_FLOAT32, {2, 2, 2, 2}},\n                     {TensorType_INT32, {4}});\n  m.SetIndices<int32_t>(\n      {/*0,0*/ 1, 1, /*0,1*/ 0, 1, /*1,0*/ 0, 0, /*1,1*/ 1, 0});\n  m.SetUpdates<float>({/*0,0*/ 1, 2, 3, 4, /*0,1*/ 5, 6, 7, 8,\n                       /*1,0*/ 9, 10, 11, 12, /*1,1*/ 13, 14, 15, 16});\n  m.SetShape<int32_t>({2, 2, 2, 2});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({2, 2, 2, 2}));\n  EXPECT_THAT(m.GetOutput<float>(), ElementsAreArray({/*0, 0*/ 9, 10, 11, 12,\n                                                      /*0, 1*/ 5, 6, 7, 8,\n                                                      /*1, 0*/ 13, 14, 15, 16,\n                                                      /*1, 1*/ 1, 2, 3, 4}));\n}\n\nTEST(ScatterNdOpTest, ScatterVectorIntoRank4Tensor) {\n  ScatterNdOpModel m({TensorType_INT32, {2, 2, 3}},\n                     {TensorType_FLOAT32, {2, 2, 5}}, {TensorType_INT32, {4}});\n  m.SetIndices<int32_t>(\n      {/*0,0*/ 2, 2, 2, /*0,1*/ 1, 0, 1, /*1,0*/ 0, 2, 0, /*1,0*/ 2, 2, 0});\n  m.SetUpdates<float>(\n      {/*0,0*/ 1,  2,  3,  4,  5,  /*0,1*/ 6,  7,  8,  9,  10,\n       /*1,0*/ 11, 12, 13, 14, 15, /*1,1*/ 16, 17, 18, 19, 20});\n  m.SetShape<int32_t>({3, 3, 3, 5});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({3, 3, 3, 5}));\n  EXPECT_THAT(m.GetOutput<float>(),\n              ElementsAreArray({\n                  /*0, 0, 0*/ 0,  0,  0,  0,  0,\n                  /*0, 0, 1*/ 0,  0,  0,  0,  0,\n                  /*0, 0, 2*/ 0,  0,  0,  0,  0,\n                  /*0, 1, 0*/ 0,  0,  0,  0,  0,\n                  /*0, 1, 1*/ 0,  0,  0,  0,  0,\n                  /*0, 1, 2*/ 0,  0,  0,  0,  0,\n                  /*0, 2, 0*/ 11, 12, 13, 14, 15,\n                  /*0, 2, 1*/ 0,  0,  0,  0,  0,\n                  /*0, 2, 2*/ 0,  0,  0,  0,  0,\n                  /*1, 0, 0*/ 0,  0,  0,  0,  0,\n                  /*1, 0, 1*/ 6,  7,  8,  9,  10,\n                  /*1, 0, 2*/ 0,  0,  0,  0,  0,\n                  /*1, 1, 0*/ 0,  0,  0,  0,  0,\n                  /*1, 1, 1*/ 0,  0,  0,  0,  0,\n                  /*1, 1, 2*/ 0,  0,  0,  0,  0,\n                  /*1, 2, 0*/ 0,  0,  0,  0,  0,\n                  /*1, 2, 1*/ 0,  0,  0,  0,  0,\n                  /*1, 2, 2*/ 0,  0,  0,  0,  0,\n                  /*2, 0, 0*/ 0,  0,  0,  0,  0,\n                  /*2, 0, 1*/ 0,  0,  0,  0,  0,\n                  /*2, 0, 2*/ 0,  0,  0,  0,  0,\n                  /*2, 1, 0*/ 0,  0,  0,  0,  0,\n                  /*2, 1, 1*/ 0,  0,  0,  0,  0,\n                  /*2, 1, 2*/ 0,  0,  0,  0,  0,\n                  /*2, 2, 0*/ 16, 17, 18, 19, 20,\n                  /*2, 2, 1*/ 0,  0,  0,  0,  0,\n                  /*2, 2, 2*/ 1,  2,  3,  4,  5,\n              }));\n}\n\nTEST(ScatterNdOpTest, ScatterVectorIntoRank3Tensor) {\n  ScatterNdOpModel m({TensorType_INT32, {4, 2}}, {TensorType_FLOAT32, {4, 5}},\n                     {TensorType_INT32, {3}});\n  m.SetIndices<int32_t>({/*0*/ 0, 0, /*1*/ 1, 0, /*2*/ 0, 2, /*3*/ 1, 2});\n  m.SetUpdates<float>(\n      {/*0*/ 1,  2,  3,  4,  5,  /*1*/ 6,  7,  8,  9,  10,\n       /*2*/ 11, 12, 13, 14, 15, /*3*/ 16, 17, 18, 19, 20});\n  m.SetShape<int32_t>({2, 3, 5});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({2, 3, 5}));\n  EXPECT_THAT(m.GetOutput<float>(),\n              ElementsAreArray({/*0, 0*/ 1,  2,  3,  4,  5,\n                                /*0, 1*/ 0,  0,  0,  0,  0,\n                                /*0, 2*/ 11, 12, 13, 14, 15,\n                                /*1, 0*/ 6,  7,  8,  9,  10,\n                                /*1, 1*/ 0,  0,  0,  0,  0,\n                                /*1, 2*/ 16, 17, 18, 19, 20}));\n}\n\nTEST(ScatterNdOpTest, OverlappedIndicesSummed) {\n  ScatterNdOpModel m({TensorType_INT32, {4, 2}}, {TensorType_FLOAT32, {4, 5}},\n                     {TensorType_INT32, {3}});\n  m.SetIndices<int32_t>({/*0*/ 1, 0, /*1*/ 0, 2, /*2*/ 0, 2, /*3*/ 1, 0});\n  m.SetUpdates<float>(\n      {/*0*/ 1,  2,  3,  4,  5,  /*1*/ 6,  7,  8,  9,  10,\n       /*2*/ 11, 12, 13, 14, 15, /*3*/ 16, 17, 18, 19, 20});\n  m.SetShape<int32_t>({2, 3, 5});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({2, 3, 5}));\n  EXPECT_THAT(m.GetOutput<float>(),\n              ElementsAreArray({/*0, 0*/ 0,  0,  0,  0,  0,\n                                /*0, 1*/ 0,  0,  0,  0,  0,\n                                /*0, 2*/ 17, 19, 21, 23, 25,\n                                /*1, 0*/ 17, 19, 21, 23, 25,\n                                /*1, 1*/ 0,  0,  0,  0,  0,\n                                /*1, 2*/ 0,  0,  0,  0,  0}));\n}\n\nTEST(ScatterNdOpTest, Int32IndicesUint8Updates) {\n  ScatterNdOpModel m({TensorType_INT32, {4, 2}}, {TensorType_UINT8, {4, 5}},\n                     {TensorType_INT32, {3}});\n  m.SetIndices<int32_t>({/*0*/ 0, 0, /*1*/ 1, 0, /*2*/ 0, 2, /*3*/ 1, 2});\n  m.SetUpdates<uint8_t>(\n      {/*0*/ 1,  2,  3,  4,  5,  /*1*/ 6,  7,  8,  9,  10,\n       /*2*/ 11, 12, 13, 14, 15, /*3*/ 16, 17, 18, 19, 20});\n  m.SetShape<int32_t>({2, 3, 5});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({2, 3, 5}));\n  EXPECT_THAT(m.GetOutput<uint8_t>(),\n              ElementsAreArray({/*0, 0*/ 1,  2,  3,  4,  5,\n                                /*0, 1*/ 0,  0,  0,  0,  0,\n                                /*0, 2*/ 11, 12, 13, 14, 15,\n                                /*1, 0*/ 6,  7,  8,  9,  10,\n                                /*1, 1*/ 0,  0,  0,  0,  0,\n                                /*1, 2*/ 16, 17, 18, 19, 20}));\n}\n\nTEST(ScatterNdOpTest, Int32IndicesInt8Updates) {\n  ScatterNdOpModel m({TensorType_INT32, {4, 2}}, {TensorType_INT8, {4, 5}},\n                     {TensorType_INT32, {3}});\n  m.SetIndices<int32_t>({/*0*/ 0, 0, /*1*/ 1, 0, /*2*/ 0, 2, /*3*/ 1, 2});\n  m.SetUpdates<int8_t>(\n      {/*0*/ 1,  2,  3,  4,  5,  /*1*/ 6,  7,  8,  9,  10,\n       /*2*/ 11, 12, 13, 14, 15, /*3*/ 16, 17, 18, 19, 20});\n  m.SetShape<int32_t>({2, 3, 5});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({2, 3, 5}));\n  EXPECT_THAT(m.GetOutput<int8_t>(),\n              ElementsAreArray({/*0, 0*/ 1,  2,  3,  4,  5,\n                                /*0, 1*/ 0,  0,  0,  0,  0,\n                                /*0, 2*/ 11, 12, 13, 14, 15,\n                                /*1, 0*/ 6,  7,  8,  9,  10,\n                                /*1, 1*/ 0,  0,  0,  0,  0,\n                                /*1, 2*/ 16, 17, 18, 19, 20}));\n}\n\nTEST(ScatterNdOpTest, Int32IndicesInt32Updates) {\n  ScatterNdOpModel m({TensorType_INT32, {4, 2}}, {TensorType_INT32, {4, 5}},\n                     {TensorType_INT32, {3}});\n  m.SetIndices<int32_t>({/*0*/ 0, 0, /*1*/ 1, 0, /*2*/ 0, 2, /*3*/ 1, 2});\n  m.SetUpdates<int32_t>(\n      {/*0*/ 1,  2,  3,  4,  5,  /*1*/ 6,  7,  8,  9,  10,\n       /*2*/ 11, 12, 13, 14, 15, /*3*/ 16, 17, 18, 19, 20});\n  m.SetShape<int32_t>({2, 3, 5});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({2, 3, 5}));\n  EXPECT_THAT(m.GetOutput<int32_t>(),\n              ElementsAreArray({/*0, 0*/ 1,  2,  3,  4,  5,\n                                /*0, 1*/ 0,  0,  0,  0,  0,\n                                /*0, 2*/ 11, 12, 13, 14, 15,\n                                /*1, 0*/ 6,  7,  8,  9,  10,\n                                /*1, 1*/ 0,  0,  0,  0,  0,\n                                /*1, 2*/ 16, 17, 18, 19, 20}));\n}\n\nTEST(ScatterNdOpTest, Int32IndicesInt64Updates) {\n  ScatterNdOpModel m({TensorType_INT32, {4, 2}}, {TensorType_INT64, {4, 5}},\n                     {TensorType_INT32, {3}});\n  m.SetIndices<int32_t>({/*0*/ 0, 0, /*1*/ 1, 0, /*2*/ 0, 2, /*3*/ 1, 2});\n  m.SetUpdates<int64_t>(\n      {/*0*/ 1,  2,  3,  4,  5,  /*1*/ 6,  7,  8,  9,  10,\n       /*2*/ 11, 12, 13, 14, 15, /*3*/ 16, 17, 18, 19, 20});\n  m.SetShape<int32_t>({2, 3, 5});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({2, 3, 5}));\n  EXPECT_THAT(m.GetOutput<int64_t>(),\n              ElementsAreArray({/*0, 0*/ 1,  2,  3,  4,  5,\n                                /*0, 1*/ 0,  0,  0,  0,  0,\n                                /*0, 2*/ 11, 12, 13, 14, 15,\n                                /*1, 0*/ 6,  7,  8,  9,  10,\n                                /*1, 1*/ 0,  0,  0,  0,  0,\n                                /*1, 2*/ 16, 17, 18, 19, 20}));\n}\n\nTEST(ScatterNdOpTest, Int32IndicesBoolUpdates) {\n  ScatterNdOpModel m({TensorType_INT32, {4, 1}}, {TensorType_BOOL, {4}},\n                     {TensorType_INT32, {1}});\n  m.SetIndices<int32_t>({4, 3, 1, 7});\n  m.SetUpdates<bool>({true, false, true, false});\n  m.SetShape<int32_t>({8});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({8}));\n  EXPECT_THAT(\n      m.GetOutput<bool>(),\n      ElementsAreArray({false, true, false, false, true, false, false, false}));\n}\n\nTEST(ScatterNdOpTest, DynamicShape) {\n  ScatterNdOpModel m({TensorType_INT32, {4, 2}}, {TensorType_INT64, {4, 5}},\n                     {TensorType_INT32, {3}});\n  m.SetIndices<int32_t>({/*0*/ 0, 0, /*1*/ 1, 0, /*2*/ 0, 2, /*3*/ 1, 2});\n  m.SetUpdates<int64_t>(\n      {/*0*/ 1,  2,  3,  4,  5,  /*1*/ 6,  7,  8,  9,  10,\n       /*2*/ 11, 12, 13, 14, 15, /*3*/ 16, 17, 18, 19, 20});\n  m.SetShape<int32_t>({2, 3, 5});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({2, 3, 5}));\n  EXPECT_THAT(m.GetOutput<int64_t>(),\n              ElementsAreArray({/*0, 0*/ 1,  2,  3,  4,  5,\n                                /*0, 1*/ 0,  0,  0,  0,  0,\n                                /*0, 2*/ 11, 12, 13, 14, 15,\n                                /*1, 0*/ 6,  7,  8,  9,  10,\n                                /*1, 1*/ 0,  0,  0,  0,  0,\n                                /*1, 2*/ 16, 17, 18, 19, 20}));\n\n  m.SetIndices<int32_t>({/*0*/ 2, 3, /*1*/ 1, 0, /*2*/ 2, 0, /*3*/ 1, 2});\n  m.SetShape<int32_t>({3, 4, 5});\n  ASSERT_EQ(m.Invoke(), kTfLiteOk);\n\n  EXPECT_THAT(m.GetOutputShape(), ElementsAreArray({3, 4, 5}));\n  EXPECT_THAT(m.GetOutput<int64_t>(),\n              ElementsAreArray({/*0, 0*/ 0,  0,  0,  0,  0,\n                                /*0, 1*/ 0,  0,  0,  0,  0,\n                                /*0, 2*/ 0,  0,  0,  0,  0,\n                                /*0, 3*/ 0,  0,  0,  0,  0,\n                                /*1, 0*/ 6,  7,  8,  9,  10,\n                                /*1, 1*/ 0,  0,  0,  0,  0,\n                                /*1, 2*/ 16, 17, 18, 19, 20,\n                                /*1, 3*/ 0,  0,  0,  0,  0,\n                                /*2, 0*/ 11, 12, 13, 14, 15,\n                                /*2, 1*/ 0,  0,  0,  0,  0,\n                                /*2, 2*/ 0,  0,  0,  0,  0,\n                                /*2, 3*/ 1,  2,  3,  4,  5}));\n}\n\n}  // namespace\n}  // namespace tflite"