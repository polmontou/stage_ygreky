"/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <gtest/gtest.h>\n#include \"tensorflow/core/framework/fake_input.h\"\n#include \"tensorflow/core/framework/node_def_builder.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n#include \"tensorflow/core/framework/shape_inference_testutil.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_testutil.h\"\n#include \"tensorflow/core/kernels/ops_testutil.h\"\n#include \"tensorflow/core/lib/core/status_test_util.h\"\n#include \"tensorflow/core/platform/test.h\"\n\nnamespace tensorflow {\nnamespace {\n\nclass RaggedRangeOpTest : public ::tensorflow::OpsTestBase {\n protected:\n  // Indices of output tensors.\n  static constexpr int kSplitsOutput = 0;\n  static constexpr int kValuesOutput = 1;\n\n  // Builds the tensorflow test graph for the RaggedRange op.\n  template <typename T>\n  void BuildRaggedRangeGraph() {\n    const auto& dtype = DataTypeToEnum<T>::v();\n    TF_ASSERT_OK(NodeDefBuilder(\"tested_op\", \"RaggedRange\")\n                     .Input(FakeInput(dtype))  // starts\n                     .Input(FakeInput(dtype))  // limits\n                     .Input(FakeInput(dtype))  // deltas\n                     .Attr(\"T\", dtype)\n                     .Finalize(node_def()));\n    TF_ASSERT_OK(InitOp());\n  }\n};\n\nTEST_F(RaggedRangeOpTest, IntValues) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({4}), {0, 5, 8, 5});   // starts\n  AddInputFromArray<int>(TensorShape({4}), {8, 7, 8, 1});   // limits\n  AddInputFromArray<int>(TensorShape({4}), {2, 1, 1, -1});  // deltas\n  TF_ASSERT_OK(RunOpKernel());\n\n  // Expected: [[0, 2, 4, 6], [5, 6], [], [5, 4, 3, 2]]\n  test::ExpectTensorEqual<int64_t>(*GetOutput(kSplitsOutput),\n                                   test::AsTensor<int64_t>({0, 4, 6, 6, 10}));\n  test::ExpectTensorEqual<int>(\n      *GetOutput(kValuesOutput),\n      test::AsTensor<int>({0, 2, 4, 6, 5, 6, 5, 4, 3, 2}));\n}\n\nTEST_F(RaggedRangeOpTest, FloatValues) {\n  BuildRaggedRangeGraph<float>();\n  AddInputFromArray<float>(TensorShape({4}), {0, 5, 8, 5});   // starts\n  AddInputFromArray<float>(TensorShape({4}), {8, 7, 8, 1});   // limits\n  AddInputFromArray<float>(TensorShape({4}), {2, 1, 1, -1});  // deltas\n  TF_ASSERT_OK(RunOpKernel());\n\n  // Expected: [[0, 2, 4, 6], [5, 6], [], [5, 4, 3, 2]]\n  test::ExpectTensorEqual<int64_t>(*GetOutput(kSplitsOutput),\n                                   test::AsTensor<int64_t>({0, 4, 6, 6, 10}));\n  test::ExpectTensorNear<float>(\n      *GetOutput(kValuesOutput),\n      test::AsTensor<float>({0, 2, 4, 6, 5, 6, 5, 4, 3, 2}), 0.1);\n}\n\nTEST_F(RaggedRangeOpTest, RangeSizeOverflow) {\n  BuildRaggedRangeGraph<float>();\n  AddInputFromArray<float>(TensorShape({2}), {1.1, 0.1});    // starts\n  AddInputFromArray<float>(TensorShape({2}), {10.0, 1e10});  // limits\n  AddInputFromArray<float>(TensorShape({2}), {1, 1e-10});    // deltas\n\n  EXPECT_EQ(absl::StrCat(\"Requires ((limit - start) / delta) <= \",\n                         std::numeric_limits<int64_t>::max()),\n            RunOpKernel().error_message());\n}\n\nTEST_F(RaggedRangeOpTest, BroadcastDeltas) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({3}), {0, 5, 8});  // starts\n  AddInputFromArray<int>(TensorShape({3}), {8, 7, 8});  // limits\n  AddInputFromArray<int>(TensorShape({}), {1});         // deltas\n  TF_ASSERT_OK(RunOpKernel());\n\n  // Expected: [[0, 1, 2, 3, 4, 5, 6, 7], [5, 6], []]\n  test::ExpectTensorEqual<int64_t>(*GetOutput(kSplitsOutput),\n                                   test::AsTensor<int64_t>({0, 8, 10, 10}));\n  test::ExpectTensorEqual<int>(\n      *GetOutput(kValuesOutput),\n      test::AsTensor<int>({0, 1, 2, 3, 4, 5, 6, 7, 5, 6}));\n}\n\nTEST_F(RaggedRangeOpTest, BroadcastLimitsAndDeltas) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({}), {0});         // starts\n  AddInputFromArray<int>(TensorShape({3}), {3, 0, 2});  // limits\n  AddInputFromArray<int>(TensorShape({}), {1});         // deltas\n  TF_ASSERT_OK(RunOpKernel());\n\n  // Expected: [[0, 1, 2], [], [0, 1]]\n  test::ExpectTensorEqual<int64_t>(*GetOutput(kSplitsOutput),\n                                   test::AsTensor<int64_t>({0, 3, 3, 5}));\n  test::ExpectTensorEqual<int>(*GetOutput(kValuesOutput),\n                               test::AsTensor<int>({0, 1, 2, 0, 1}));\n}\n\nTEST_F(RaggedRangeOpTest, BroadcastStartsAndLimits) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({}), {0});         // starts\n  AddInputFromArray<int>(TensorShape({}), {12});        // limits\n  AddInputFromArray<int>(TensorShape({3}), {3, 4, 5});  // deltas\n  TF_ASSERT_OK(RunOpKernel());\n\n  // Expected: [[0, 3, 6, 9], [0, 4, 8], [0, 5, 10]]]\n  test::ExpectTensorEqual<int64_t>(*GetOutput(kSplitsOutput),\n                                   test::AsTensor<int64_t>({0, 4, 7, 10}));\n  test::ExpectTensorEqual<int>(\n      *GetOutput(kValuesOutput),\n      test::AsTensor<int>({0, 3, 6, 9, 0, 4, 8, 0, 5, 10}));\n}\n\nTEST_F(RaggedRangeOpTest, AllScalarInputs) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({}), {0});  // starts\n  AddInputFromArray<int>(TensorShape({}), {5});  // limits\n  AddInputFromArray<int>(TensorShape({}), {1});  // deltas\n  TF_ASSERT_OK(RunOpKernel());\n\n  // Expected: [[0, 1, 2, 3, 4]\n  test::ExpectTensorEqual<int64_t>(*GetOutput(kSplitsOutput),\n                                   test::AsTensor<int64_t>({0, 5}));\n  test::ExpectTensorEqual<int>(*GetOutput(kValuesOutput),\n                               test::AsTensor<int>({0, 1, 2, 3, 4}));\n}\n\nTEST_F(RaggedRangeOpTest, InvalidArgsStarts) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({4, 1}), {0, 5, 8, 5});  // starts\n  AddInputFromArray<int>(TensorShape({4}), {8, 7, 8, 1});     // limits\n  AddInputFromArray<int>(TensorShape({4}), {2, 1, 1, -1});    // deltas\n  EXPECT_EQ(\"starts must be a scalar or vector\", RunOpKernel().error_message());\n}\n\nTEST_F(RaggedRangeOpTest, InvalidArgsLimits) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({4}), {0, 5, 8, 5});     // starts\n  AddInputFromArray<int>(TensorShape({4, 1}), {8, 7, 8, 1});  // limits\n  AddInputFromArray<int>(TensorShape({4}), {2, 1, 1, -1});    // deltas\n  EXPECT_EQ(\"limits must be a scalar or vector\", RunOpKernel().error_message());\n}\n\nTEST_F(RaggedRangeOpTest, InvalidArgsDeltas) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({4}), {0, 5, 8, 5});      // starts\n  AddInputFromArray<int>(TensorShape({4}), {8, 7, 8, 1});      // limits\n  AddInputFromArray<int>(TensorShape({4, 1}), {2, 1, 1, -1});  // deltas\n  EXPECT_EQ(\"deltas must be a scalar or vector\", RunOpKernel().error_message());\n}\n\nTEST_F(RaggedRangeOpTest, InvalidArgsShapeMismatch) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({4}), {0, 5, 8, 5});   // starts\n  AddInputFromArray<int>(TensorShape({3}), {7, 8, 1});      // limits\n  AddInputFromArray<int>(TensorShape({4}), {2, 1, 1, -1});  // deltas\n  EXPECT_EQ(\"starts, limits, and deltas must have the same shape\",\n            RunOpKernel().error_message());\n}\n\nTEST_F(RaggedRangeOpTest, InvalidArgsZeroDelta) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({4}), {0, 5, 8, 5});   // starts\n  AddInputFromArray<int>(TensorShape({4}), {7, 8, 8, 1});   // limits\n  AddInputFromArray<int>(TensorShape({4}), {2, 1, 0, -1});  // deltas\n  EXPECT_EQ(\"Requires delta != 0\", RunOpKernel().error_message());\n}\n\nTEST_F(RaggedRangeOpTest, EmptyRangePositiveDelta) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({2}), {0, 5});  // starts\n  AddInputFromArray<int>(TensorShape({2}), {5, 0});  // limits\n  AddInputFromArray<int>(TensorShape({}), {2});      // deltas\n  TF_ASSERT_OK(RunOpKernel());\n\n  // Expected: [[0, 2, 4], []]\n  test::ExpectTensorEqual<int64_t>(*GetOutput(kSplitsOutput),\n                                   test::AsTensor<int64_t>({0, 3, 3}));\n  test::ExpectTensorEqual<int>(*GetOutput(kValuesOutput),\n                               test::AsTensor<int>({0, 2, 4}));\n}\n\nTEST_F(RaggedRangeOpTest, EmptyRangeNegativeDelta) {\n  BuildRaggedRangeGraph<int>();\n  AddInputFromArray<int>(TensorShape({2}), {0, 5});  // starts\n  AddInputFromArray<int>(TensorShape({2}), {5, 0});  // limits\n  AddInputFromArray<int>(TensorShape({}), {-2});     // deltas\n  TF_ASSERT_OK(RunOpKernel());\n\n  // Expected: [[], [5, 3, 1]]\n  test::ExpectTensorEqual<int64_t>(*GetOutput(kSplitsOutput),\n                                   test::AsTensor<int64_t>({0, 0, 3}));\n  test::ExpectTensorEqual<int>(*GetOutput(kValuesOutput),\n                               test::AsTensor<int>({5, 3, 1}));\n}\n\nTEST_F(RaggedRangeOpTest, ShapeFn) {\n  // RaggedRange(starts, limits, deltas) -> [splits, values]\n  ShapeInferenceTestOp op(\"RaggedRange\");\n  INFER_OK(op, \"?;?;?\", \"[?];[?]\");\n  INFER_OK(op, \"[3];[3];[3]\", \"[4];[?]\");\n  INFER_OK(op, \"[3];[3];[]\", \"[4];[?]\");  // broadcast deltas\n  INFER_OK(op, \"[3];[];[3]\", \"[4];[?]\");  // broadcast limits\n  INFER_OK(op, \"[];[3];[3]\", \"[4];[?]\");  // broadcast starts\n  INFER_OK(op, \"[];[];[]\", \"[2];[?]\");    // degenerate case: all scalar inputs\n  INFER_ERROR(\"Shape must be at most rank 1 but is rank 2\", op,\n              \"[5,5];[5];[5]\");\n  INFER_ERROR(\"Shape must be at most rank 1 but is rank 2\", op,\n              \"[5];[5,5];[5]\");\n  INFER_ERROR(\"Shape must be at most rank 1 but is rank 2\", op,\n              \"[5];[5];[5,5]\");\n  INFER_ERROR(\"Dimensions must be equal, but are 4 and 3\", op, \"[3];[4];[3]\");\n}\n\n}  // namespace\n}  // namespace tensorflow"