"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/nn_ops.cc.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/kernels/avgpooling_op.h\"\n\n#include <vector>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/kernel_shape_util.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_slice.h\"\n#include \"tensorflow/core/kernels/eigen_pooling.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/kernels/pooling_ops_common.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/array_slice.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/util/padding.h\"\n#include \"tensorflow/core/util/tensor_format.h\"\n\n#if GOOGLE_CUDA\n#include \"third_party/gpus/cudnn/cudnn.h\"\n#endif  // GOOGLE_CUDA\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/maxpooling_op_gpu.h\"\n#include \"tensorflow/core/kernels/pooling_ops_common_gpu.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\ntemplate <typename Device, typename T>\nclass AvgPoolingOp : public UnaryOp<T> {\n public:\n  explicit AvgPoolingOp(OpKernelConstruction* context) : UnaryOp<T>(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES(\n        context, data_format_ == FORMAT_NHWC,\n        errors::InvalidArgument(\"Default AvgPoolingOp only supports NHWC \",\n                                \"on device type \",\n                                DeviceTypeString(context->device_type())));\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n\n    for (int i = 0; i < ksize_.size(); ++i) {\n      OP_REQUIRES(context, ksize_[i] != 0,\n                  errors::InvalidArgument(\"ksize cannot be zero\"));\n    }\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          data_format_,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    OP_REQUIRES(context, params.depth_window == 1,\n                errors::Unimplemented(\"Non-spatial pooling is not \"\n                                      \"yet supported. Volunteers? :)\"));\n\n    // For avgpooling, tensor_in should have 4 dimensions.\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, params.forward_output_shape(), &output));\n\n    SpatialAvgPool<Device, T>(context, output, tensor_in, params, padding_);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"AvgPool\").Device(DEVICE_CPU).TypeConstraint<double>(\"T\"),\n    AvgPoolingOp<CPUDevice, double>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"AvgPool\").Device(DEVICE_CPU).TypeConstraint<float>(\"T\"),\n    AvgPoolingOp<CPUDevice, float>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"AvgPool\").Device(DEVICE_CPU).TypeConstraint<Eigen::half>(\"T\"),\n    AvgPoolingOp<CPUDevice, Eigen::half>);\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\ntemplate <typename T>\nclass AvgPoolingOp<GPUDevice, T> : public UnaryOp<T> {\n public:\n  typedef GPUDevice Device;\n  explicit AvgPoolingOp(OpKernelConstruction* context) : UnaryOp<T>(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    const int32_t ksize_n = GetTensorDim(ksize_, data_format_, 'N');\n    const int32_t stride_n = GetTensorDim(stride_, data_format_, 'N');\n    OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n\n    for (int i = 0; i < ksize_.size(); ++i) {\n      OP_REQUIRES(context, ksize_[i] != 0,\n                  errors::InvalidArgument(\"ksize cannot be zero\"));\n    }\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          data_format_,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    OP_REQUIRES(context, params.depth_window == 1,\n                errors::Unimplemented(\"Non-spatial pooling is not \"\n                                      \"yet supported. Volunteers? :)\"));\n\n    // For avgpooling, tensor_in should have 4 dimensions.\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n\n    TensorShape output_shape = params.forward_output_shape();\n    if (output_shape.num_elements() == 0) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, output_shape, &output));\n      return;\n    }\n\n#if CUDNN_VERSION >= 7300\n    DnnPoolingOp<T>::Compute(context, se::dnn::PoolingMode::kAverage, ksize_,\n                             stride_, padding_, /*explicit_paddings=*/{},\n                             data_format_, tensor_in, output_shape,\n                             /*propagate_nans=*/false);\n#else\n    if (data_format_ == FORMAT_NCHW) {\n      DnnPoolingOp<T>::Compute(context, se::dnn::PoolingMode::kAverage, ksize_,\n                               stride_, padding_, /*explicit_paddings=*/{},\n                               data_format_, tensor_in, output_shape,\n                               /*propagate_nans=*/false);\n    } else {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, output_shape, &output));\n      Eigen::PaddingType pt = BrainPadding2EigenPadding(padding_);\n      functor::SpatialAvgPooling<Device, T>()(\n          context->eigen_device<Device>(), output->tensor<T, 4>(),\n          tensor_in.tensor<T, 4>(), params.window_rows, params.window_cols,\n          params.row_stride, params.col_stride, pt);\n    }\n#endif  // CUDNN_VERSION >= 7300\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n};\n\n// Forward declarations of the functor specializations for GPU.\nnamespace functor {\n#define DECLARE_GPU_SPEC(T)                                      \\\n  template <>                                                    \\\n  void SpatialAvgPooling<GPUDevice, T>::operator()(              \\\n      const GPUDevice& d, typename TTypes<T, 4>::Tensor output,  \\\n      typename TTypes<T, 4>::ConstTensor input, int window_rows, \\\n      int window_cols, int row_stride, int col_stride,           \\\n      const Eigen::PaddingType& padding);                        \\\n  extern template struct SpatialAvgPooling<GPUDevice, T>;\n\nDECLARE_GPU_SPEC(Eigen::half);\nDECLARE_GPU_SPEC(float);\nDECLARE_GPU_SPEC(double);\n#undef DECLARE_GPU_SPEC\n}  // namespace functor\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"AvgPool\").Device(DEVICE_GPU).TypeConstraint<Eigen::half>(\"T\"),\n    AvgPoolingOp<GPUDevice, Eigen::half>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"AvgPool\").Device(DEVICE_GPU).TypeConstraint<float>(\"T\"),\n    AvgPoolingOp<GPUDevice, float>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"AvgPool\").Device(DEVICE_GPU).TypeConstraint<double>(\"T\"),\n    AvgPoolingOp<GPUDevice, double>);\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// The operation to compute AvgPool gradients.\n// It takes two inputs:\n//   - The original input tensor shape\n//   - Backprop tensor for output\n// It produces one output: backprop tensor for input.\ntemplate <typename Device, class T>\nclass AvgPoolingGradOp : public OpKernel {\n public:\n  explicit AvgPoolingGradOp(OpKernelConstruction* context) : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES(\n        context, data_format_ == FORMAT_NHWC,\n        errors::InvalidArgument(\"Default AvgPoolingGradOp only supports NHWC \",\n                                \"on device type \",\n                                DeviceTypeString(context->device_type())));\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in_shape = context->input(0);\n    const Tensor& out_backprop = context->input(1);\n    // For avgpooling, tensor_in_shape should have 1 dimension, and 4 elements.\n    OP_REQUIRES(\n        context,\n        tensor_in_shape.dims() == 1 && tensor_in_shape.NumElements() == 4,\n        errors::InvalidArgument(\"out_backprop must be 1-dimensional and 4 \"\n                                \"elements\"));\n    // For avgpooling, out_backprop should have 4 dimensions.\n    OP_REQUIRES(context, out_backprop.dims() == 4,\n                errors::InvalidArgument(\"out_backprop must be 4-dimensional\"));\n    const int64_t out_backprop_batch = out_backprop.dim_size(0);\n    const int64_t out_backprop_rows = out_backprop.dim_size(1);\n    const int64_t out_backprop_cols = out_backprop.dim_size(2);\n    const int64_t out_backprop_depth = out_backprop.dim_size(3);\n\n    TensorShape output_shape;\n    auto shape_vec = tensor_in_shape.vec<int32>();\n    for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) {\n      OP_REQUIRES_OK(context, output_shape.AddDimWithStatus(shape_vec(i)));\n    }\n    const int64_t in_rows = output_shape.dim_size(1);\n    const int64_t in_cols = output_shape.dim_size(2);\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    output->flat<T>().setZero();\n\n    if (output_shape.num_elements() == 0) {\n      return;\n    }\n    const int window_rows = ksize_[1];\n    const int window_cols = ksize_[2];\n    const int depth_window = ksize_[3];\n\n    const int row_stride = stride_[1];\n    const int col_stride = stride_[2];\n\n    // We (will) use different code for spatial pooling and\n    // non-spatial pooling.\n    //\n    // Spatial pooling is when depth_window = 1\n    OP_REQUIRES(context, depth_window == 1,\n                errors::Unimplemented(\"Non-spatial pooling is not \"\n                                      \"yet supported. Volunteers? :)\"));\n\n    int64_t out_height, out_width, pad_rows, pad_cols;\n    OP_REQUIRES_OK(context,\n                   GetWindowedOutputSize(in_rows, window_rows, row_stride,\n                                         padding_, &out_height, &pad_rows));\n    OP_REQUIRES_OK(context,\n                   GetWindowedOutputSize(in_cols, window_cols, col_stride,\n                                         padding_, &out_width, &pad_cols));\n\n    const T* out_backprop_ptr = out_backprop.flat<T>().data();\n    T* input_backprop_ptr = output->flat<T>().data();\n\n    auto shard = [context, out_backprop_ptr, input_backprop_ptr,\n                  out_backprop_rows, out_backprop_cols, out_backprop_depth,\n                  in_rows, in_cols, window_rows, window_cols, row_stride,\n                  col_stride, pad_rows,\n                  pad_cols](int64_t start, int64_t limit) {\n      for (int64_t b = start; b < limit; ++b) {\n        for (int64_t r = 0; r < out_backprop_rows; ++r) {\n          // Calculates row broadcast size.  For SAME padding, current\n          // index could be in the padding area, and r*row_stride +\n          // window_rows could be beyond the input tensor's boundary. In\n          // such cases, change the starting index and reduce the\n          // broadcast size.\n          int rindex, rsize;\n          OP_REQUIRES_OK(context,\n                         GetBroadcastSize(r, in_rows, window_rows, row_stride,\n                                          pad_rows, &rindex, &rsize));\n          for (int64_t c = 0; c < out_backprop_cols; ++c) {\n            // Calculates col broadcast size.  For SAME padding, current\n            // index could be in the padding area, and c*col_stride +\n            // window_cols could be beyond the input tensor's boundary. In\n            // such cases, change the starting index and reduce the\n            // broadcast size.\n            int cindex, csize;\n            OP_REQUIRES_OK(context,\n                           GetBroadcastSize(c, in_cols, window_cols, col_stride,\n                                            pad_cols, &cindex, &csize));\n\n            T divide_coeff(1.0 / (rsize * csize));\n            int64_t output_index =\n                (b * out_backprop_rows + r) * out_backprop_cols + c;\n            for (int64_t r_dst = rindex; r_dst < rindex + rsize; ++r_dst) {\n              for (int64_t c_dst = cindex; c_dst < cindex + csize; ++c_dst) {\n                int64_t input_index = (b * in_rows + r_dst) * in_cols + c_dst;\n                const T* output_offset =\n                    out_backprop_ptr + output_index * out_backprop_depth;\n                T* input_offset =\n                    input_backprop_ptr + input_index * out_backprop_depth;\n                for (int64_t d = 0; d < out_backprop_depth; ++d) {\n                  *input_offset += *output_offset * divide_coeff;\n                  ++output_offset;\n                  ++input_offset;\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    const int64_t shard_cost =\n        window_rows * window_cols * depth_window * in_rows * in_rows * in_cols;\n    Shard(worker_threads.num_threads, worker_threads.workers,\n          out_backprop_batch, shard_cost, shard);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n};\n\n#define REGISTER_CPU_KERNEL(T)                                 \\\n  REGISTER_KERNEL_BUILDER(Name(\"AvgPoolGrad\")                  \\\n                              .Device(DEVICE_CPU)              \\\n                              .TypeConstraint<T>(\"T\")          \\\n                              .HostMemory(\"orig_input_shape\"), \\\n                          AvgPoolingGradOp<CPUDevice, T>);\n\nTF_CALL_float(REGISTER_CPU_KERNEL);\nTF_CALL_double(REGISTER_CPU_KERNEL);\nTF_CALL_half(REGISTER_CPU_KERNEL);\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// A CUDNN based AvgPoolingGrad implementation. It includes the padding as the\n// candidates for the pooling operation.\ntemplate <class T>\nclass AvgPoolingGradOp<GPUDevice, T> : public OpKernel {\n public:\n  typedef GPUDevice Device;\n\n  explicit AvgPoolingGradOp(OpKernelConstruction* context) : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    const int32_t ksize_n = GetTensorDim(ksize_, data_format_, 'N');\n    const int32_t stride_n = GetTensorDim(stride_, data_format_, 'N');\n    OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in_shape = context->input(0);\n    const Tensor& out_backprop = context->input(1);\n    // For avgpooling, tensor_in_shape should have 1 dimension, and 4 elements.\n    OP_REQUIRES(\n        context,\n        tensor_in_shape.dims() == 1 && tensor_in_shape.NumElements() == 4,\n        errors::InvalidArgument(\"out_backprop must be 1-dimensional and 4 \"\n                                \"elements\"));\n    // For avgpooling, out_backprop should have 4 dimensions.\n    OP_REQUIRES(context, out_backprop.dims() == 4,\n                errors::InvalidArgument(\"out_backprop must be 4-dimensional\"));\n\n    TensorShape output_shape;\n    auto shape_vec = tensor_in_shape.vec<int32>();\n    for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) {\n      OP_REQUIRES_OK(context, output_shape.AddDimWithStatus(shape_vec(i)));\n    }\n\n    if (output_shape.num_elements() == 0) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, output_shape, &output));\n      return;\n    }\n\n    DnnPoolingGradOp<T>::Compute(\n        context, se::dnn::PoolingMode::kAverage, ksize_, stride_, padding_,\n        /*explicit_paddings=*/{}, data_format_, nullptr, nullptr, out_backprop,\n        output_shape, /*propagate_nans=*/false);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"AvgPoolGrad\")\n                            .Device(DEVICE_GPU)\n                            .TypeConstraint<double>(\"T\")\n                            .HostMemory(\"orig_input_shape\")\n                            .Label(\"cudnn\"),\n                        AvgPoolingGradOp<GPUDevice, double>);\nREGISTER_KERNEL_BUILDER(Name(\"AvgPoolGrad\")\n                            .Device(DEVICE_GPU)\n                            .TypeConstraint<float>(\"T\")\n                            .HostMemory(\"orig_input_shape\")\n                            .Label(\"cudnn\"),\n                        AvgPoolingGradOp<GPUDevice, float>);\nREGISTER_KERNEL_BUILDER(Name(\"AvgPoolGrad\")\n                            .Device(DEVICE_GPU)\n                            .TypeConstraint<Eigen::half>(\"T\")\n                            .HostMemory(\"orig_input_shape\")\n                            .Label(\"cudnn\"),\n                        AvgPoolingGradOp<GPUDevice, Eigen::half>);\n\n// A custom GPU kernel based AvgPoolingGrad implementation. It includes the\n// padding as the candidates for the pooling operation.\ntemplate <class T>\nclass AvgPoolingGradOpCustomGPUKernel : public OpKernel {\n public:\n  typedef GPUDevice Device;\n\n  explicit AvgPoolingGradOpCustomGPUKernel(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    const int32_t ksize_n = GetTensorDim(ksize_, data_format_, 'N');\n    const int32_t stride_n = GetTensorDim(stride_, data_format_, 'N');\n    OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in_shape = context->input(0);\n    const Tensor& out_backprop = context->input(1);\n    // For avgpooling, tensor_in_shape should have 1 dimension, and 4 elements.\n    OP_REQUIRES(\n        context,\n        tensor_in_shape.dims() == 1 && tensor_in_shape.NumElements() == 4,\n        errors::InvalidArgument(\"out_backprop must be 1-dimensional and 4 \"\n                                \"elements\"));\n    // For avgpooling, out_backprop should have 4 dimensions.\n    OP_REQUIRES(context, out_backprop.dims() == 4,\n                errors::InvalidArgument(\"out_backprop must be 4-dimensional\"));\n    TensorShape output_shape;\n    auto shape_vec = tensor_in_shape.vec<int32>();\n    for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) {\n      OP_REQUIRES_OK(context, output_shape.AddDimWithStatus(shape_vec(i)));\n    }\n    if (output_shape.num_elements() == 0) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, output_shape, &output));\n      return;\n    }\n\n#if CUDNN_VERSION >= 7300\n    DnnPoolingGradOp<T>::Compute(context, se::dnn::PoolingMode::kAverage,\n                                 ksize_, stride_, padding_,\n                                 /*explicit_paddings=*/{}, data_format_,\n                                 nullptr, nullptr, out_backprop, output_shape,\n                                 /*propagate_nans=*/false);\n#else\n    if (data_format_ == FORMAT_NHWC) {\n      const int64 out_backprop_batch = out_backprop.dim_size(0);\n      const int64 out_backprop_rows = out_backprop.dim_size(1);\n      const int64 out_backprop_cols = out_backprop.dim_size(2);\n      const int64 out_backprop_depth = out_backprop.dim_size(3);\n\n      const int64 in_rows = output_shape.dim_size(1);\n      const int64 in_cols = output_shape.dim_size(2);\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, output_shape, &output));\n\n      const int window_rows = ksize_[1];\n      const int window_cols = ksize_[2];\n      const int depth_window = ksize_[3];\n\n      const int row_stride = stride_[1];\n      const int col_stride = stride_[2];\n\n      // We (will) use different code for spatial pooling and\n      // non-spatial pooling.\n      //\n      // Spatial pooling is when depth_window = 1\n      OP_REQUIRES(context, depth_window == 1,\n                  errors::Unimplemented(\"Non-spatial pooling is not \"\n                                        \"yet supported. Volunteers? :)\"));\n\n      int64 out_height, out_width, pad_rows, pad_cols;\n      OP_REQUIRES_OK(context,\n                     GetWindowedOutputSize(in_rows, window_rows, row_stride,\n                                           padding_, &out_height, &pad_rows));\n      OP_REQUIRES_OK(context,\n                     GetWindowedOutputSize(in_cols, window_cols, col_stride,\n                                           padding_, &out_width, &pad_cols));\n\n      RunAvePoolBackwardNHWC<T>(out_backprop.flat<T>().data(),  // top_diff\n                                out_backprop_batch,             // num\n                                in_rows,                        // height\n                                in_cols,                        // width\n                                out_backprop_depth,             // channels\n                                out_backprop_rows,              // pooled_height\n                                out_backprop_cols,              // pooled_width\n                                window_rows,                    // kernel_h\n                                window_cols,                    // kernel_w\n                                row_stride,                     // stride_h\n                                col_stride,                     // stride_w\n                                pad_rows,                       // pad_t\n                                pad_cols,                       // pad_l\n                                output->flat<T>().data(),       // bottom_diff\n                                context->eigen_gpu_device());   // d\n    } else {\n      DnnPoolingGradOp<T>::Compute(context, se::dnn::PoolingMode::kAverage,\n                                   ksize_, stride_, padding_,\n                                   /*explicit_paddings=*/{}, data_format_,\n                                   nullptr, nullptr, out_backprop, output_shape,\n                                   /*propagate_nans=*/false);\n    }\n#endif  // CUDNN_VERSION >= 7300\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"AvgPoolGrad\")\n                            .Device(DEVICE_GPU)\n                            .TypeConstraint<float>(\"T\")\n                            .HostMemory(\"orig_input_shape\"),\n                        AvgPoolingGradOpCustomGPUKernel<float>);\nREGISTER_KERNEL_BUILDER(Name(\"AvgPoolGrad\")\n                            .Device(DEVICE_GPU)\n                            .TypeConstraint<double>(\"T\")\n                            .HostMemory(\"orig_input_shape\"),\n                        AvgPoolingGradOpCustomGPUKernel<double>);\nREGISTER_KERNEL_BUILDER(Name(\"AvgPoolGrad\")\n                            .Device(DEVICE_GPU)\n                            .TypeConstraint<Eigen::half>(\"T\")\n                            .HostMemory(\"orig_input_shape\"),\n                        AvgPoolingGradOpCustomGPUKernel<Eigen::half>);\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace tensorflow"