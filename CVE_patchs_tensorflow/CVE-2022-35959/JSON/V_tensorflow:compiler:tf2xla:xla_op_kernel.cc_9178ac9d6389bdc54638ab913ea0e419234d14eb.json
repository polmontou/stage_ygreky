"/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/compiler/tf2xla/xla_op_kernel.h\"\n\n#include <numeric>\n\n#include \"absl/memory/memory.h\"\n#include \"tensorflow/compiler/tf2xla/literal_util.h\"\n#include \"tensorflow/compiler/tf2xla/shape_util.h\"\n#include \"tensorflow/compiler/tf2xla/type_util.h\"\n#include \"tensorflow/compiler/tf2xla/xla_compilation_device.h\"\n#include \"tensorflow/compiler/tf2xla/xla_context.h\"\n#include \"tensorflow/compiler/tf2xla/xla_helpers.h\"\n#include \"tensorflow/compiler/xla/client/value_inference.h\"\n#include \"tensorflow/compiler/xla/client/xla_builder.h\"\n#include \"tensorflow/compiler/xla/client/xla_computation.h\"\n#include \"tensorflow/compiler/xla/status_macros.h\"\n#include \"tensorflow/core/common_runtime/dma_helper.h\"\n#include \"tensorflow/core/platform/errors.h\"\n\nnamespace tensorflow {\n\nXlaOpKernelContext::XlaOpKernelContext(OpKernelContext* context)\n    : context_(context),\n      dynamic_dimension_is_minus_one_(false),\n      value_inference_(xla_context()->builder()) {}\n\nbool XlaOpKernelContext::ValidateInputsAreSameShape(OpKernel* op) {\n  return context_->ValidateInputsAreSameShape(op);\n}\n\nXlaContext* XlaOpKernelContext::xla_context() const {\n  return &XlaContext::Get(context_);\n}\n\nxla::XlaBuilder* XlaOpKernelContext::builder() const {\n  return xla_context()->builder();\n}\n\nxla::ValueInference& XlaOpKernelContext::value_inference() {\n  return value_inference_;\n}\n\nXlaCompiler* XlaOpKernelContext::compiler() const {\n  return xla_context()->compiler();\n}\n\nconst XlaExpression& XlaOpKernelContext::InputExpression(int index) {\n  return *XlaExpression::CastExpressionFromTensor(context_->input(index));\n}\n\nconst XlaExpression& XlaOpKernelContext::InputExpression(\n    absl::string_view name) {\n  return *XlaExpression::CastExpressionFromTensor(GetInputTensorByName(name));\n}\n\nxla::XlaOp XlaOpKernelContext::Input(int index) {\n  return InputExpression(index).AsXlaOp(builder());\n}\n\nxla::XlaOp XlaOpKernelContext::Input(absl::string_view name) {\n  return InputExpression(name).AsXlaOp(builder());\n}\n\nTensorShape XlaOpKernelContext::InputShape(int index) {\n  return context_->input(index).shape();\n}\n\nTensorShape XlaOpKernelContext::InputShape(absl::string_view name) {\n  return GetInputTensorByName(name).shape();\n}\n\nStatusOr<xla::Shape> XlaOpKernelContext::InputXlaShape(int index) {\n  return builder()->GetShape(Input(index));\n}\n\nStatusOr<xla::Shape> XlaOpKernelContext::InputXlaShape(absl::string_view name) {\n  return builder()->GetShape(Input(name));\n}\n\nDataType XlaOpKernelContext::input_type(int index) const {\n  DataType type = context_->input_dtype(index);\n  if (type == DT_UINT8) {\n    // Masqueraded XlaExpression could have different type. See\n    // XlaOpKernelContext::SetOutputExpression for details.\n    auto expression =\n        XlaExpression::CastExpressionFromTensor(context_->input(index));\n    type = expression->dtype();\n  }\n  return type;\n}\n\nDataType XlaOpKernelContext::InputType(absl::string_view name) {\n  const Tensor& tensor = GetInputTensorByName(name);\n  DataType type = tensor.dtype();\n  if (type == DT_UINT8) {\n    // Masqueraded XlaExpression could have different type. See\n    // XlaOpKernelContext::SetOutputExpression for details.\n    auto expression = XlaExpression::CastExpressionFromTensor(tensor);\n    type = expression->dtype();\n  }\n  return type;\n}\n\nxla::PrimitiveType XlaOpKernelContext::input_xla_type(int index) {\n  xla::PrimitiveType type;\n  Status status = DataTypeToPrimitiveType(input_type(index), &type);\n  if (!status.ok()) {\n    SetStatus(status);\n    return xla::PRIMITIVE_TYPE_INVALID;\n  }\n  return type;\n}\n\nxla::PrimitiveType XlaOpKernelContext::InputXlaType(absl::string_view name) {\n  xla::PrimitiveType type;\n  Status status = DataTypeToPrimitiveType(InputType(name), &type);\n  if (!status.ok()) {\n    SetStatus(status);\n    return xla::PRIMITIVE_TYPE_INVALID;\n  }\n  return type;\n}\n\nStatus XlaOpKernelContext::ConstantInput(int index,\n                                         xla::Literal* constant_literal,\n                                         xla::ValueInferenceMode mode) {\n  if (this->InputXlaShape(index)->is_dynamic()) {\n    return errors::InvalidArgument(\n        \"Reading input as constant from a dynamic tensor is not yet supported. \"\n        \"Xla shape: \",\n        this->InputXlaShape(index)->ToString());\n  }\n  return ConstantInputReshaped(index,\n                               context_->input(index).shape().dim_sizes(),\n                               constant_literal, mode);\n}\n\nstatic StatusOr<int> InputIndex(XlaOpKernelContext* context,\n                                absl::string_view name) {\n  int start, stop;\n  TF_RETURN_IF_ERROR(context->op_kernel().InputRange(name, &start, &stop));\n  if (stop != start + 1) {\n    return errors::InvalidArgument(\"OpKernel used list-valued input name '\",\n                                   name,\n                                   \"' when single-valued input was \"\n                                   \"expected\");\n  }\n  return start;\n}\n\nStatus XlaOpKernelContext::ResolveInputDynamism(\n    int index, xla::Literal* dynamism_literal) {\n  return ResolveInputDynamismReshaped(\n      index, context_->input(index).shape().dim_sizes(), dynamism_literal);\n}\n\nStatus XlaOpKernelContext::ResolveInputDynamism(\n    absl::string_view name, xla::Literal* dynamism_literal) {\n  TF_ASSIGN_OR_RETURN(int index, InputIndex(this, name));\n  return ResolveInputDynamism(index, dynamism_literal);\n}\n\nStatus XlaOpKernelContext::ConstantInput(absl::string_view name,\n                                         xla::Literal* constant_literal,\n                                         xla::ValueInferenceMode mode) {\n  TF_ASSIGN_OR_RETURN(int index, InputIndex(this, name));\n  return ConstantInput(index, constant_literal, mode);\n}\n\nStatus XlaOpKernelContext::ConstantInputReshaped(\n    int index, absl::Span<const int64_t> new_dims,\n    xla::Literal* constant_literal, xla::ValueInferenceMode mode) {\n  TF_ASSIGN_OR_RETURN(Tensor constant, ConstantInputTensor(index, mode));\n  Tensor temp(constant.dtype());\n  if (!temp.CopyFrom(constant, TensorShape(new_dims))) {\n    return errors::InvalidArgument(\n        context_->op_kernel().name(), \" input \", index, \" has shape \",\n        constant.shape().DebugString(),\n        \" but was asked to be reshaped to incompatible shape \",\n        TensorShape(new_dims).DebugString());\n  }\n\n  TF_ASSIGN_OR_RETURN(*constant_literal, HostTensorToLiteral(temp));\n  return OkStatus();\n}\n\n// Converts an int32 or int64 scalar literal to an int64.\nstatic Status LiteralToInt64Scalar(const xla::LiteralSlice& literal,\n                                   int64_t* out) {\n  if (literal.shape().rank() != 0) {\n    return errors::InvalidArgument(\"value is not a scalar\");\n  }\n  if (literal.shape().element_type() == xla::S32) {\n    *out = literal.Get<int32>({});\n  } else if (literal.shape().element_type() == xla::S64) {\n    *out = literal.Get<int64_t>({});\n  } else {\n    return errors::InvalidArgument(\"value must be either int32 or int64\");\n  }\n  return OkStatus();\n}\n\n// Converts an float32 or float64 scalar literal to a float64.\nstatic Status LiteralToFloat64Scalar(const xla::LiteralSlice& literal,\n                                     double* out) {\n  if (literal.shape().rank() != 0) {\n    return errors::InvalidArgument(\"value is not a scalar\");\n  }\n  if (literal.shape().element_type() == xla::F32) {\n    *out = literal.Get<float>({});\n  } else if (literal.shape().element_type() == xla::F64) {\n    *out = literal.Get<double>({});\n  } else {\n    return errors::InvalidArgument(\"value must be either float32 or float64\");\n  }\n  return OkStatus();\n}\n\nStatus XlaOpKernelContext::ConstantInputAsIntScalar(\n    int index, int64_t* out, xla::ValueInferenceMode mode) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInput(index, &literal, mode));\n  return LiteralToInt64Scalar(literal, out);\n}\n\nStatus XlaOpKernelContext::ConstantInputAsIntScalar(\n    absl::string_view name, int64_t* out, xla::ValueInferenceMode mode) {\n  TF_ASSIGN_OR_RETURN(int index, InputIndex(this, name));\n  return ConstantInputAsIntScalar(index, out, mode);\n}\n\nStatus XlaOpKernelContext::ConstantInputAsFloatScalar(\n    int index, double* out, xla::ValueInferenceMode mode) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInput(index, &literal, mode));\n  return LiteralToFloat64Scalar(literal, out);\n}\n\nstatic Status LiteralToPredVector(const xla::LiteralSlice& literal,\n                                  std::vector<bool>* out) {\n  if (literal.shape().rank() != 1) {\n    return errors::InvalidArgument(\"output_shape must be rank 1, got shape \",\n                                   literal.shape().DebugString());\n  }\n  int64_t size = xla::ShapeUtil::ElementsIn(literal.shape());\n  if (literal.shape().element_type() != xla::PRED) {\n    return errors::InvalidArgument(\"value is not PRED\");\n  }\n  for (int64_t i = 0; i < size; ++i) {\n    out->push_back(literal.Get<bool>({i}));\n  }\n  return OkStatus();\n}\n\nStatus XlaOpKernelContext::ResolveInputDynamismIntoPred(int index, bool* out) {\n  xla::Literal literal;\n  XlaExpression e = InputExpression(index);\n  auto* client = compiler() ? compiler()->client() : nullptr;\n  StatusOr<Tensor> dynamism_or_status = e.ResolveDynamism(client);\n  if (!dynamism_or_status.ok()) {\n    // When failed to resolve dynamism, conservatively consider the value\n    // dynamic. This could happen if the input depends on some ops like\n    // custom-call that is not supported generally for dynamism computation.\n    //\n    // TODO(b/176993339): Support resolving dynamism across computations so\n    // resolving dynamism will not fail in those cases.\n    *out = true;\n    return OkStatus();\n  }\n  Tensor dynamism = dynamism_or_status.ValueOrDie();\n\n  Tensor temp(dynamism.dtype());\n  TensorShape tensor_shape({});\n  if (!temp.CopyFrom(dynamism, tensor_shape)) {\n    return errors::InvalidArgument(\n        context_->op_kernel().name(), \" input \", index, \" has shape \",\n        dynamism.shape().DebugString(), \" which is not a R0 \", tensor_shape);\n  }\n\n  TF_ASSIGN_OR_RETURN(literal, HostTensorToLiteral(temp));\n  *out = literal.Get<bool>({});\n  return OkStatus();\n}\n\nStatus XlaOpKernelContext::ResolveInputDynamismIntoPredVector(\n    absl::string_view name, std::vector<bool>* out) {\n  TF_ASSIGN_OR_RETURN(int index, InputIndex(this, name));\n  return ResolveInputDynamismIntoPredVector(index, out);\n}\n\nStatus XlaOpKernelContext::ResolveInputDynamismIntoPred(absl::string_view name,\n                                                        bool* out) {\n  TF_ASSIGN_OR_RETURN(int index, InputIndex(this, name));\n  return ResolveInputDynamismIntoPred(index, out);\n}\n\nStatus XlaOpKernelContext::ResolveInputDynamismReshaped(\n    int index, absl::Span<const int64_t> new_dims,\n    xla::Literal* dynamism_literal) {\n  XlaExpression e = InputExpression(index);\n  auto* client = compiler() ? compiler()->client() : nullptr;\n  StatusOr<Tensor> dynamism_or_status = e.ResolveDynamism(client);\n  if (!dynamism_or_status.ok()) {\n    xla::Literal true_literal = xla::LiteralUtil::CreateR0<bool>(true);\n    // When failed to resolve dynamism, conservatively consider the value\n    // dynamic. This could happen if the input depends on some ops like\n    // custom-call that is not supported generally for dynamism computation.\n    *dynamism_literal =\n        true_literal\n            .Broadcast(xla::ShapeUtil::MakeShape(xla::PRED, new_dims), {})\n            .ValueOrDie();\n\n    return OkStatus();\n  }\n  Tensor dynamism = dynamism_or_status.ValueOrDie();\n\n  Tensor temp(dynamism.dtype());\n  if (!temp.CopyFrom(dynamism, TensorShape(new_dims))) {\n    return errors::InvalidArgument(\n        context_->op_kernel().name(), \" input \", index, \" has shape \",\n        dynamism.shape().DebugString(),\n        \" but was asked to be reshaped to incompatible shape \",\n        TensorShape(new_dims).DebugString());\n  }\n\n  TF_ASSIGN_OR_RETURN(*dynamism_literal, HostTensorToLiteral(temp));\n  return OkStatus();\n}\n\nStatus XlaOpKernelContext::ResolveInputDynamismIntoPredVector(\n    int index, std::vector<bool>* out) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ResolveInputDynamismReshaped(\n      index, {InputShape(index).num_elements()}, &literal));\n\n  return LiteralToPredVector(literal, out);\n}\n\n// Converts an int32 or int64 1D literal to an int64 vector.\nstatic Status LiteralToInt64Vector(const xla::LiteralSlice& literal,\n                                   std::vector<int64_t>* out) {\n  if (literal.shape().rank() != 1) {\n    return errors::InvalidArgument(\"output_shape must be rank 1, got shape \",\n                                   literal.shape().DebugString());\n  }\n  int64_t size = xla::ShapeUtil::ElementsIn(literal.shape());\n  if (literal.shape().element_type() == xla::S32) {\n    for (int64_t i = 0; i < size; ++i) {\n      out->push_back(literal.Get<int32>({i}));\n    }\n  } else if (literal.shape().element_type() == xla::S64) {\n    for (int64_t i = 0; i < size; ++i) {\n      out->push_back(literal.Get<int64_t>({i}));\n    }\n  } else {\n    return errors::InvalidArgument(\"value must be either int32 or int64\");\n  }\n  return OkStatus();\n}\n\nStatus XlaOpKernelContext::ConstantInputAsIntVector(\n    int index, std::vector<int64_t>* out, xla::ValueInferenceMode mode) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInput(index, &literal, mode));\n  return LiteralToInt64Vector(literal, out);\n}\n\nStatus XlaOpKernelContext::ConstantInputAsIntVector(\n    absl::string_view name, std::vector<int64_t>* out,\n    xla::ValueInferenceMode mode) {\n  TF_ASSIGN_OR_RETURN(int index, InputIndex(this, name));\n  return ConstantInputAsIntVector(index, out, mode);\n}\n\nStatus XlaOpKernelContext::ConstantInputReshapedToIntVector(\n    int index, std::vector<int64_t>* out, xla::ValueInferenceMode mode) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInputReshaped(\n      index, {InputShape(index).num_elements()}, &literal, mode));\n  return LiteralToInt64Vector(literal, out);\n}\n\nStatus XlaOpKernelContext::ConstantInputReshapedToIntVector(\n    absl::string_view name, std::vector<int64_t>* out,\n    xla::ValueInferenceMode mode) {\n  TF_ASSIGN_OR_RETURN(int index, InputIndex(this, name));\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInputReshaped(\n      index, {InputShape(index).num_elements()}, &literal, mode));\n  return LiteralToInt64Vector(literal, out);\n}\n\nStatus XlaOpKernelContext::ConstantInputAsInt64Literal(\n    int index, xla::Literal* out, xla::ValueInferenceMode mode) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInput(index, &literal, mode));\n  switch (literal.shape().element_type()) {\n    case xla::S32: {\n      *out = xla::Literal(\n          xla::ShapeUtil::ChangeElementType(literal.shape(), xla::S64));\n      auto src_data = literal.data<int32>();\n      for (int64_t i = 0; i < src_data.size(); ++i) {\n        out->data<int64_t>()[i] = src_data[i];\n      }\n      return OkStatus();\n    }\n    case xla::S64:\n      *out = std::move(literal);\n      return OkStatus();\n\n    default:\n      return errors::InvalidArgument(\n          \"Invalid argument to ConstantInputAsInt64Literal: \",\n          xla::ShapeUtil::HumanString(literal.shape()));\n  }\n}\n\nStatus XlaOpKernelContext::ConstantInputAsInt64Literal(\n    absl::string_view name, xla::Literal* out, xla::ValueInferenceMode mode) {\n  TF_ASSIGN_OR_RETURN(int index, InputIndex(this, name));\n  return ConstantInputAsInt64Literal(index, out, mode);\n}\n\n// TODO(phawkins): validate that the dimensions form a valid shape, fail\n// gracefully if they do not.\nStatus XlaOpKernelContext::ConstantInputAsShape(int index, TensorShape* shape,\n                                                xla::ValueInferenceMode mode) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInput(index, &literal, mode));\n  std::vector<int64_t> dims;\n  TF_RETURN_IF_ERROR(LiteralToInt64Vector(literal, &dims));\n  *shape = TensorShape(dims);\n  return OkStatus();\n}\n\nStatus XlaOpKernelContext::ConstantInputAsPartialShape(\n    int index, PartialTensorShape* shape) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInput(index, &literal));\n  // If `literal` is a scalar it's value must be -1.\n  if (literal.shape().rank() == 0) {\n    int64_t shape_val;\n    TF_RETURN_IF_ERROR(LiteralToInt64Scalar(literal, &shape_val));\n    if (shape_val != -1) {\n      return errors::InvalidArgument(\n          \"Cannot convert value to PartialTensorShape: \", shape_val);\n    }\n    *shape = PartialTensorShape();  // Shape with unknown rank.\n    return OkStatus();\n  }\n  std::vector<int64_t> dims;\n  TF_RETURN_IF_ERROR(LiteralToInt64Vector(literal, &dims));\n  *shape = PartialTensorShape(dims);\n  return OkStatus();\n}\n\nStatus XlaOpKernelContext::InputList(absl::string_view name,\n                                     std::vector<xla::XlaOp>* handles,\n                                     std::vector<TensorShape>* shapes) {\n  OpInputList inputs;\n  TF_RETURN_IF_ERROR(context_->input_list(name, &inputs));\n  handles->clear();\n  shapes->clear();\n  for (const Tensor& input : inputs) {\n    handles->push_back(\n        XlaExpression::CastExpressionFromTensor(input)->AsXlaOp(builder()));\n    shapes->push_back(input.shape());\n  }\n  return OkStatus();\n}\n\nStatus XlaOpKernelContext::ConstantInputList(absl::string_view name,\n                                             std::vector<xla::Literal>* outputs,\n                                             xla::ValueInferenceMode mode) {\n  int start, stop;\n  TF_RETURN_IF_ERROR(op_kernel().InputRange(name, &start, &stop));\n  outputs->resize(stop - start);\n  for (int i = start; i < stop; ++i) {\n    TF_RETURN_IF_ERROR(ConstantInput(i, &(*outputs)[i], mode));\n  }\n  return OkStatus();\n}\n\nStatusOr<Tensor> XlaOpKernelContext::ConstantInputTensor(\n    int index, xla::ValueInferenceMode mode) {\n  XlaExpression e = InputExpression(index);\n  auto* client = compiler() ? compiler()->client() : nullptr;\n  StatusOr<std::optional<Tensor>> constant_or_status =\n      e.ResolveConstant(client, dynamic_dimension_is_minus_one_, mode);\n  if (!constant_or_status.ok()) {\n    Status status = constant_or_status.status();\n    errors::AppendToMessage(&status, \"while evaluating input \", index, \" of \",\n                            context_->op_kernel().type_string(),\n                            \" operator as a compile-time constant.\");\n    return status;\n  }\n  std::optional<Tensor> constant = constant_or_status.ValueOrDie();\n  if (!constant.has_value()) {\n    return errors::InvalidArgument(\n        \"Input \", index, \" to node `\", context_->op_kernel().name(),\n        \"` with op \", context_->op_kernel().type_string(),\n        \" must be a compile-time constant.\\n\\n\"\n        \"XLA compilation requires that operator arguments that represent \"\n        \"shapes or dimensions be evaluated to concrete values at compile time. \"\n        \"This error means that a shape or dimension argument could not be \"\n        \"evaluated at compile time, usually because the value of the argument \"\n        \"depends on a parameter to the computation, on a variable, or on a \"\n        \"stateful operation such as a random number generator.\");\n  }\n  return *constant;\n}\n\nnamespace {\n\nStatus ReadVariableInputTensor(const Tensor& tensor, DataType type,\n                               const XlaOpKernelContext* ctx,\n                               TensorShape* shape, xla::XlaOp* value) {\n  const XlaExpression* expression =\n      XlaExpression::CastExpressionFromTensor(tensor);\n  XlaResource* variable = expression->resource();\n  TF_RET_CHECK(variable != nullptr);\n  TF_RET_CHECK(variable->kind() == XlaResource::kVariable);\n  if (!variable->initialized()) {\n    return errors::FailedPrecondition(\n        \"Read variable failure \", variable->name(),\n        \". It could mean the variable is uninitialized or the variable is on \"\n        \"another device \");\n  }\n  if (variable->type() != type) {\n    return errors::InvalidArgument(\n        \"Trying to read variable with wrong dtype. Expected \",\n        DataTypeString(type), \" got \", DataTypeString(variable->type()));\n  }\n  if (shape) {\n    *shape = variable->shape();\n  }\n\n  if (!variable->IsOverwritten() && expression->constant_value()) {\n    TF_ASSIGN_OR_RETURN(xla::Literal literal,\n                        HostTensorToLiteral(*expression->constant_value()));\n    *value = xla::ConstantLiteral(ctx->builder(), literal);\n    return OkStatus();\n  }\n  auto shape_determination_fns =\n      ctx->compiler()->options().shape_determination_fns;\n  XlaLayoutPreference layout_preference =\n      shape_determination_fns.layout_preference_fn(\n          variable->shape(), variable->type(), std::nullopt);\n  TF_ASSIGN_OR_RETURN(xla::Shape representation_shape,\n                      shape_determination_fns.shape_representation_fn(\n                          variable->shape(), variable->type(),\n                          /*use_fast_memory=*/false, layout_preference));\n  xla::Shape xla_shape;\n  TF_RETURN_IF_ERROR(\n      TensorShapeToXLAShape(variable->type(), variable->shape(), &xla_shape));\n  if (xla::ShapeUtil::Compatible(xla_shape, representation_shape)) {\n    *value = variable->value();\n  } else {\n    *value = xla::Reshape(variable->value(), variable->shape().dim_sizes());\n  }\n  return OkStatus();\n}\n\n}  // namespace\n\nStatus XlaOpKernelContext::ReadVariableInput(int index, DataType type,\n                                             TensorShape* shape,\n                                             xla::XlaOp* value) {\n  return ReadVariableInputTensor(context_->input(index), type, this, shape,\n                                 value);\n}\n\nStatus XlaOpKernelContext::ReadVariableInput(absl::string_view name,\n                                             DataType type, TensorShape* shape,\n                                             xla::XlaOp* value) {\n  return ReadVariableInputTensor(GetInputTensorByName(name), type, this, shape,\n                                 value);\n}\n\nStatus XlaOpKernelContext::GetVariableTypeAndShape(int index, DataType* type,\n                                                   TensorShape* shape) const {\n  const Tensor& tensor = context_->input(index);\n  const XlaExpression* expression =\n      XlaExpression::CastExpressionFromTensor(tensor);\n  XlaResource* variable = expression->resource();\n  TF_RET_CHECK(variable != nullptr);\n  TF_RET_CHECK(variable->kind() == XlaResource::kVariable);\n  if (!variable->initialized()) {\n    return errors::InvalidArgument(\n        \"Read variable failure \", variable->name(),\n        \". It could mean the variable is uninitialized or the variable is on \"\n        \"another device \");\n  }\n  *type = variable->type();\n  *shape = variable->shape();\n  return OkStatus();\n}\n\nvoid XlaOpKernelContext::SetOutputExpression(int index,\n                                             const XlaExpression& expression) {\n  Status status = [&] {\n    // The step's default allocator is the dummy XlaCompilationAllocator which\n    // simply allocates a metadata buffer to hold the expression to which it\n    // corresponds.\n    // Provides a special behavior for DT_VARIANT and other types that are not\n    // trivially copyable. In those cases, allocate a tensor of type DT_UINT8.\n    if (!DataTypeCanUseMemcpy(expression.dtype())) {\n      // tensor_data() is not supported for tensors that cannot be copied via\n      // memcpy, as the copy logic might try to inspect the stored data (e.g.\n      // a std::string). This is likely to fail, as the data is invalid given\n      // that it actually encodes an XlaExpression. Using a uint8 tensor is\n      // always safe, so simply do that.\n      // TODO(jpienaar): This should be refactored to stop masquerading\n      // XlaExpressions as Tensors.\n      Tensor output;\n      TensorShape tensor_shape;\n      TF_RETURN_IF_ERROR(\n          context_->allocate_temp(DT_UINT8, tensor_shape, &output));\n      context_->set_output(index, output);\n    } else {\n      Tensor* output = nullptr;\n      TF_ASSIGN_OR_RETURN(TensorShape shape, expression.GetShape());\n      TF_RETURN_IF_ERROR(context_->allocate_output(index, shape, &output));\n    }\n    XlaExpression::AssignExpressionToTensor(expression,\n                                            context_->mutable_output(index));\n    return OkStatus();\n  }();\n  if (!status.ok()) {\n    SetStatus(status);\n  }\n}\n\nxla::PrimitiveType XlaOpKernelContext::output_xla_type(int index) {\n  xla::PrimitiveType type;\n  Status status = DataTypeToPrimitiveType(expected_output_dtype(index), &type);\n  if (!status.ok()) {\n    SetStatus(status);\n    return xla::PRIMITIVE_TYPE_INVALID;\n  }\n  return type;\n}\n\nvoid XlaOpKernelContext::SetOutput(int index, const xla::XlaOp& handle) {\n  SetOutputExpression(\n      index,\n      XlaExpression::XlaOp(handle, context_->expected_output_dtype(index)));\n}\n\nvoid XlaOpKernelContext::SetConstantOutput(int index, const Tensor& constant) {\n  SetOutputExpression(index, XlaExpression::Constant(constant));\n}\n\nvoid XlaOpKernelContext::SetTensorListOutput(int index,\n                                             const xla::XlaOp& handle) {\n  SetOutputExpression(index, XlaExpression::TensorList(handle));\n}\n\nvoid XlaOpKernelContext::SetResourceOutput(int index, XlaResource* resource) {\n  SetOutputExpression(index, XlaExpression::Resource(resource));\n}\n\nStatus XlaOpKernelContext::GetResourceInput(int index, XlaResource** resource) {\n  const XlaExpression* expression =\n      XlaExpression::CastExpressionFromTensor(context_->input(index));\n  TF_RET_CHECK(expression->resource() != nullptr);\n  *resource = expression->resource();\n  return OkStatus();\n}\n\nnamespace {\n\nStatus AssignVariableTensor(const Tensor& tensor, DataType type,\n                            const XlaOpKernelContext* ctx, xla::XlaOp handle,\n                            xla::XlaBuilder* builder) {\n  const XlaExpression* expression =\n      XlaExpression::CastExpressionFromTensor(tensor);\n  XlaResource* variable = expression->resource();\n  TF_RET_CHECK(variable != nullptr);\n  TF_RET_CHECK(variable->kind() == XlaResource::kVariable);\n\n  auto shape_or_status = builder->GetShape(handle);\n  if (!shape_or_status.ok()) {\n    return shape_or_status.status();\n  }\n  TensorShape shape;\n  TF_RETURN_IF_ERROR(\n      XLAShapeToTensorShape(shape_or_status.ValueOrDie(), &shape));\n\n  TF_RETURN_IF_ERROR(variable->SetTypeAndShape(type, shape));\n\n  auto shape_determination_fns =\n      ctx->compiler()->options().shape_determination_fns;\n  XlaLayoutPreference layout_preference =\n      shape_determination_fns.layout_preference_fn(shape, type, std::nullopt);\n  TF_ASSIGN_OR_RETURN(xla::Shape representation_shape,\n                      shape_determination_fns.shape_representation_fn(\n                          shape, type,\n                          /*use_fast_memory=*/false, layout_preference));\n  xla::Shape xla_shape;\n  TF_RETURN_IF_ERROR(TensorShapeToXLAShape(type, shape, &xla_shape));\n  if (!xla::ShapeUtil::Compatible(xla_shape, representation_shape)) {\n    handle = xla::Reshape(handle, representation_shape.dimensions());\n  }\n  variable->SetRepresentationShape(representation_shape);\n  return variable->SetValue(handle);\n}\n\n}  // namespace\n\nStatus XlaOpKernelContext::AssignVariable(int input_index, DataType type,\n                                          xla::XlaOp handle) {\n  TF_RET_CHECK(handle.valid());\n  return AssignVariableTensor(context_->input(input_index), type, this, handle,\n                              builder());\n}\n\nStatus XlaOpKernelContext::AssignVariable(absl::string_view name, DataType type,\n                                          xla::XlaOp handle) {\n  TF_RET_CHECK(handle.valid());\n  return AssignVariableTensor(GetInputTensorByName(name), type, this, handle,\n                              builder());\n}\n\nstatic Status GetStatusWithStackTrace(const Status& s,\n                                      const XlaOpKernelContext* ctx) {\n  if (s.code() == error::INVALID_ARGUMENT) {\n    return Status{s.code(),\n                  absl::StrCat(s.error_message(), \"\\n\", ctx->StackTrace())};\n  }\n  return s;\n}\n\nvoid XlaOpKernelContext::CtxFailure(const Status& s) {\n  context_->CtxFailure(GetStatusWithStackTrace(s, this));\n}\nvoid XlaOpKernelContext::CtxFailureWithWarning(const Status& s) {\n  context_->CtxFailureWithWarning(GetStatusWithStackTrace(s, this));\n}\n\nvoid XlaOpKernelContext::CtxFailure(const char* file, int line,\n                                    const Status& s) {\n  context_->CtxFailure(file, line, GetStatusWithStackTrace(s, this));\n}\nvoid XlaOpKernelContext::CtxFailureWithWarning(const char* file, int line,\n                                               const Status& s) {\n  context_->CtxFailureWithWarning(file, line, GetStatusWithStackTrace(s, this));\n}\n\nconst xla::XlaComputation* XlaOpKernelContext::GetOrCreateMax(\n    const DataType type) {\n  return xla_context()->GetOrCreateMax(type);\n}\n\nconst xla::XlaComputation* XlaOpKernelContext::GetOrCreateMin(\n    const DataType type) {\n  return xla_context()->GetOrCreateMin(type);\n}\n\nconst xla::XlaComputation* XlaOpKernelContext::GetOrCreateAdd(\n    const DataType type) {\n  return xla_context()->GetOrCreateAdd(type);\n}\n\nconst xla::XlaComputation* XlaOpKernelContext::GetOrCreateMul(\n    const DataType type) {\n  return xla_context()->GetOrCreateMul(type);\n}\n\nconst Tensor& XlaOpKernelContext::GetInputTensorByName(absl::string_view name) {\n  const Tensor* tensor;\n  CHECK(context_->input(name, &tensor).ok());\n  return *tensor;\n}\n\nXlaOpKernel::XlaOpKernel(OpKernelConstruction* context) : OpKernel(context) {}\n\nvoid XlaOpKernel::Compute(OpKernelContext* context) {\n  XlaOpKernelContext xla_context(context);\n  Compile(&xla_context);\n}\n\nstd::string XlaOpKernelContext::StackTrace() const {\n  if (const AbstractStackTrace* stack_trace =\n          xla_context()->StackTraceForNodeName(op_kernel().name())) {\n    AbstractStackTrace::TracePrintingOptions opts;\n    opts.show_line_contents = true;\n    opts.filter_common_prefix = true;\n    opts.drop_internal_frames = true;\n    return absl::StrCat(\"\\nStack trace for op definition: \\n\",\n                        stack_trace->ToString(opts), \"\\n\");\n  } else {\n    return \"\";\n  }\n}\n\n}  // namespace tensorflow"