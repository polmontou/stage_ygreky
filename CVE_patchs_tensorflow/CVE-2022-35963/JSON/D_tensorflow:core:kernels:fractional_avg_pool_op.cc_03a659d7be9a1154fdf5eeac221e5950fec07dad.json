"diff --git a/tensorflow/core/kernels/fractional_avg_pool_op.cc b/tensorflow/core/kernels/fractional_avg_pool_op.cc\nindex b3e65aeaee2..e1c536af706 100644\n--- a/tensorflow/core/kernels/fractional_avg_pool_op.cc\n+++ b/tensorflow/core/kernels/fractional_avg_pool_op.cc\n@@ -12,6 +12,7 @@ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n+\n #define EIGEN_USE_THREADS\n \n #include <algorithm>\n@@ -19,15 +20,15 @@ limitations under the License.\n #include <random>\n #include <vector>\n \n-#include \"tensorflow/core/kernels/fractional_pool_common.h\"\n-\n #include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n #include \"tensorflow/core/framework/numeric_op.h\"\n #include \"tensorflow/core/framework/op_kernel.h\"\n+#include \"tensorflow/core/kernels/fractional_pool_common.h\"\n #include \"tensorflow/core/lib/random/random.h\"\n #include \"tensorflow/core/platform/logging.h\"\n #include \"tensorflow/core/platform/mutex.h\"\n #include \"tensorflow/core/util/guarded_philox_random.h\"\n+#include \"tensorflow/core/util/overflow.h\"\n \n namespace tensorflow {\n typedef Eigen::ThreadPoolDevice CPUDevice;\n@@ -241,7 +242,32 @@ class FractionalAvgPoolGradOp : public OpKernel {\n                     orig_input_tensor_shape.NumElements() == 4,\n                 errors::InvalidArgument(\"original input tensor shape must be\"\n                                         \"1-dimensional and 4 elements\"));\n+    int64_t num_elements = 1;\n+    for (int i = 0; i < orig_input_tensor_shape.dims(); i++) {\n+      OP_REQUIRES(context, orig_input_tensor_shape.dim_size(i) > 0,\n+                  errors::InvalidArgument(\n+                      \"orig_input_tensor_shape must be positive, got: \",\n+                      orig_input_tensor_shape.dim_size(i)));\n+      num_elements = MultiplyWithoutOverflow(\n+          num_elements, orig_input_tensor_shape.dim_size(i));\n+      OP_REQUIRES(\n+          context, num_elements > 0,\n+          errors::InvalidArgument(\n+              \"The total elements specified by orig_input_tensor_shape\",\n+              \" is too large. Encountered overflow after multiplying \",\n+              orig_input_tensor_shape.dim_size(i), \", result: \", num_elements));\n+    }\n+\n     const Tensor& out_backprop = context->input(1);\n+    OP_REQUIRES(context, out_backprop.dims() == 4,\n+                errors::InvalidArgument(\"out_backprop must be 4-dimensional\"));\n+    for (int i = 0; i < out_backprop.dims(); i++) {\n+      OP_REQUIRES(context, out_backprop.dim_size(i) > 0,\n+                  errors::InvalidArgument(\n+                      \"out_backprop must be positive for all dimension, got:\",\n+                      out_backprop.dim_size(i)));\n+    }\n+\n     const Tensor& row_seq_tensor = context->input(2);\n     const Tensor& col_seq_tensor = context->input(3);\n "