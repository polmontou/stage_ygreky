"diff --git a/tensorflow/core/kernels/bincount_op.cc b/tensorflow/core/kernels/bincount_op.cc\nindex 24d9c5b19d5..4bef8c5be22 100644\n--- a/tensorflow/core/kernels/bincount_op.cc\n+++ b/tensorflow/core/kernels/bincount_op.cc\n@@ -23,6 +23,7 @@ limitations under the License.\n #include \"tensorflow/core/framework/types.h\"\n #include \"tensorflow/core/kernels/bincount_op.h\"\n #include \"tensorflow/core/kernels/fill_functor.h\"\n+#include \"tensorflow/core/kernels/sparse_utils.h\"\n #include \"tensorflow/core/lib/core/threadpool.h\"\n #include \"tensorflow/core/platform/types.h\"\n #include \"tensorflow/core/util/determinism.h\"\n@@ -369,7 +370,8 @@ class SparseBincountOp : public OpKernel {\n \n   void Compute(OpKernelContext* ctx) override {\n     const Tensor& indices = ctx->input(0);\n-    const auto values = ctx->input(1).flat<Tidx>();\n+    const Tensor& values = ctx->input(1);\n+    const auto values_flat = values.flat<Tidx>();\n     const Tensor& dense_shape = ctx->input(2);\n     const Tensor& size_t = ctx->input(3);\n     const auto weights = ctx->input(4).flat<T>();\n@@ -382,6 +384,9 @@ class SparseBincountOp : public OpKernel {\n     OP_REQUIRES(\n         ctx, size >= 0,\n         errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n+    OP_REQUIRES_OK(\n+        ctx, sparse_utils::ValidateSparseTensor<int64_t>(\n+                 indices, values, dense_shape, /*validate_indices=*/true));\n \n     bool is_1d = dense_shape.NumElements() == 1;\n \n@@ -394,11 +399,11 @@ class SparseBincountOp : public OpKernel {\n       if (binary_output_) {\n         OP_REQUIRES_OK(ctx,\n                        functor::BincountFunctor<Device, Tidx, T, true>::Compute(\n-                           ctx, values, weights, out, size));\n+                           ctx, values_flat, weights, out, size));\n       } else {\n         OP_REQUIRES_OK(\n             ctx, functor::BincountFunctor<Device, Tidx, T, false>::Compute(\n-                     ctx, values, weights, out, size));\n+                     ctx, values_flat, weights, out, size));\n       }\n     } else {\n       const auto shape = dense_shape.flat<int64_t>();\n@@ -410,7 +415,7 @@ class SparseBincountOp : public OpKernel {\n       const auto indices_mat = indices.matrix<int64_t>();\n       for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {\n         const int64_t batch = indices_mat(i, 0);\n-        const Tidx bin = values(i);\n+        const Tidx bin = values_flat(i);\n         OP_REQUIRES(\n             ctx, batch < out.dimension(0),\n             errors::InvalidArgument(\"Index out of bound. `batch` (\", batch,"