"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/util/tensor_slice_writer.h\"\n\n#include <utility>\n\n#include \"tensorflow/core/framework/versions.pb.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/io/table_builder.h\"\n#include \"tensorflow/core/lib/random/random.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/public/version.h\"\n#include \"tensorflow/core/util/saved_tensor_slice_util.h\"\n\nnamespace tensorflow {\n\nnamespace checkpoint {\n\nnamespace {\n\nclass TableBuilder : public TensorSliceWriter::Builder {\n public:\n  TableBuilder(const string& name, WritableFile* f) : name_(name), file_(f) {\n    table::Options option;\n    option.compression = table::kNoCompression;\n    builder_.reset(new table::TableBuilder(option, f));\n  }\n  void Add(StringPiece key, StringPiece val) override {\n    builder_->Add(key, val);\n  }\n  Status Finish(int64_t* file_size) override {\n    *file_size = -1;\n    Status s = builder_->Finish();\n    if (s.ok()) {\n      s = file_->Close();\n      if (s.ok()) {\n        *file_size = builder_->FileSize();\n      }\n    }\n    if (!s.ok()) {\n      s = errors::Internal(\"Error writing (tmp) checkpoint file: \", name_, \": \",\n                           s.error_message());\n    }\n    builder_.reset();\n    file_.reset();\n    return s;\n  }\n\n private:\n  string name_;\n  std::unique_ptr<WritableFile> file_;\n  std::unique_ptr<table::TableBuilder> builder_;\n};\n}  // anonymous namespace\n\nStatus CreateTableTensorSliceBuilder(const string& name,\n                                     TensorSliceWriter::Builder** builder) {\n  *builder = nullptr;\n  std::unique_ptr<WritableFile> f;\n  Status s = Env::Default()->NewWritableFile(name, &f);\n  if (s.ok()) {\n    *builder = new TableBuilder(name, f.release());\n    return OkStatus();\n  } else {\n    return s;\n  }\n}\n\nTensorSliceWriter::TensorSliceWriter(const string& filename,\n                                     CreateBuilderFunction create_builder)\n    : filename_(filename),\n      create_builder_(std::move(create_builder)),\n      tmpname_(strings::StrCat(filename, \".tempstate\", random::New64())),\n      slices_(0) {\n  VersionDef* versions = sts_.mutable_meta()->mutable_versions();\n  versions->set_producer(TF_CHECKPOINT_VERSION);\n  versions->set_min_consumer(TF_CHECKPOINT_VERSION_MIN_CONSUMER);\n}\n\nStatus TensorSliceWriter::Finish() {\n  Builder* b;\n  Status s = create_builder_(tmpname_, &b);\n  if (!s.ok()) {\n    delete b;\n    return s;\n  }\n  std::unique_ptr<Builder> builder(b);\n\n  // We save the saved tensor slice metadata as the first element.\n  string meta;\n  sts_.AppendToString(&meta);\n  builder->Add(kSavedTensorSlicesKey, meta);\n\n  // Go through all the data and add them\n  for (const auto& x : data_) {\n    builder->Add(x.first, x.second);\n  }\n\n  int64_t file_size;\n  s = builder->Finish(&file_size);\n  // We need to rename the file to the proper name\n  if (s.ok()) {\n    s = Env::Default()->RenameFile(tmpname_, filename_);\n    if (s.ok()) {\n      VLOG(1) << \"Written \" << slices_ << \" slices for \"\n              << sts_.meta().tensor_size() << \" tensors (\" << file_size\n              << \" bytes) to \" << filename_;\n    } else {\n      LOG(ERROR) << \"Failed to rename file \" << tmpname_ << \" to \" << filename_;\n    }\n  } else {\n    Env::Default()->DeleteFile(tmpname_).IgnoreError();\n  }\n  return s;\n}\n\n/* static */\nsize_t TensorSliceWriter::MaxBytesPerElement(DataType dt) {\n  size_t max_bytes_per_element =\n      TensorSliceWriter::MaxBytesPerElementOrZero(dt);\n  if (max_bytes_per_element == 0) {\n    LOG(FATAL) << \"MaxBytesPerElement not implemented for dtype: \" << dt;\n  }\n  return max_bytes_per_element;\n}\n\n/* static */\nsize_t TensorSliceWriter::MaxBytesPerElementOrZero(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      return 0;\n  }\n}\n\ntemplate <>\nStatus TensorSliceWriter::SaveData(const tstring* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t size_bound = ss->ByteSize() + kTensorProtoHeaderBytes +\n                      (num_elements * MaxBytesPerElement(DT_INT32));\n  for (int64_t i = 0; i < num_elements; ++i) {\n    size_bound += data[i].size();\n  }\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }\n  Fill(data, num_elements, ss->mutable_data());\n  DCHECK_GE(ss->ByteSize(), 0);\n  DCHECK_LE(ss->ByteSize(), size_bound);\n  return OkStatus();\n}\n\n}  // namespace checkpoint\n\n}  // namespace tensorflow"