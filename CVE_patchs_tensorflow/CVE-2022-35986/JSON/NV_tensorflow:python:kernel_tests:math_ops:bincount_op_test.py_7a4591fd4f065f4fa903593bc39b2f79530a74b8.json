"# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for bincount_ops.bincount.\"\"\"\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import errors_impl\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import bincount_ops\nfrom tensorflow.python.ops import gen_math_ops\nfrom tensorflow.python.ops import random_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.ops.ragged import ragged_factory_ops\nfrom tensorflow.python.ops.ragged import ragged_tensor\nfrom tensorflow.python.platform import googletest\n\n\nclass BincountTest(test_util.TensorFlowTestCase):\n\n  def test_empty(self):\n    with self.session():\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount([], minlength=5)),\n          [0, 0, 0, 0, 0])\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount([], minlength=1)), [0])\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount([], minlength=0)), [])\n      self.assertEqual(\n          self.evaluate(\n              bincount_ops.bincount([], minlength=0, dtype=np.float32)).dtype,\n          np.float32)\n      self.assertEqual(\n          self.evaluate(\n              bincount_ops.bincount([], minlength=3, dtype=np.float64)).dtype,\n          np.float64)\n\n  def test_values(self):\n    with self.session():\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount([1, 1, 1, 2, 2, 3])),\n          [0, 3, 2, 1])\n      arr = [1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5]\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount(arr)), [0, 5, 4, 3, 2, 1])\n      arr += [0, 0, 0, 0, 0, 0]\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount(arr)), [6, 5, 4, 3, 2, 1])\n\n      self.assertAllEqual(self.evaluate(bincount_ops.bincount([])), [])\n      self.assertAllEqual(self.evaluate(bincount_ops.bincount([0, 0, 0])), [3])\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount([5])), [0, 0, 0, 0, 0, 1])\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount(np.arange(10000))),\n          np.ones(10000))\n\n  def test_maxlength(self):\n    with self.session():\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount([5], maxlength=3)), [0, 0, 0])\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount([1], maxlength=3)), [0, 1])\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount([], maxlength=3)), [])\n\n  def test_random_with_weights(self):\n    num_samples = 10000\n    with self.session():\n      np.random.seed(42)\n      for dtype in [dtypes.int32, dtypes.int64, dtypes.float32, dtypes.float64]:\n        arr = np.random.randint(0, 1000, num_samples)\n        if dtype == dtypes.int32 or dtype == dtypes.int64:\n          weights = np.random.randint(-100, 100, num_samples)\n        else:\n          weights = np.random.random(num_samples)\n        self.assertAllClose(\n            self.evaluate(bincount_ops.bincount(arr, weights)),\n            np.bincount(arr, weights))\n\n  def test_random_without_weights(self):\n    num_samples = 10000\n    with self.session():\n      np.random.seed(42)\n      for dtype in [np.int32, np.float32]:\n        arr = np.random.randint(0, 1000, num_samples)\n        weights = np.ones(num_samples).astype(dtype)\n        self.assertAllClose(\n            self.evaluate(bincount_ops.bincount(arr, None)),\n            np.bincount(arr, weights))\n\n  @test_util.run_gpu_only\n  @test_util.disable_xla(\"XLA uses scatter and could be non-deterministic\")\n  def test_bincount_determinism_error(self):\n    arr = np.random.randint(0, 1000, size=1000)\n    with test_util.deterministic_ops(), self.assertRaisesRegex(\n        errors_impl.UnimplementedError,\n        \"Determinism is not yet supported in GPU implementation of Bincount.\"):\n      self.evaluate(bincount_ops.bincount(arr, None, axis=None))\n    arr = np.random.randint(0, 1000, size=(100, 100))\n    with test_util.deterministic_ops(), self.assertRaisesRegex(\n        errors_impl.UnimplementedError,\n        \"Determinism is not yet supported in GPU implementation of \"\n        \"DenseBincount.\"):\n      self.evaluate(bincount_ops.bincount(arr, None, axis=-1))\n\n  def test_zero_weights(self):\n    with self.session():\n      self.assertAllEqual(\n          self.evaluate(bincount_ops.bincount(np.arange(1000), np.zeros(1000))),\n          np.zeros(1000))\n\n  @test_util.disable_xla(\"This is not raised on XLA CPU\")\n  def test_negative(self):\n    # unsorted_segment_sum will only report InvalidArgumentError on CPU\n    with self.cached_session(), ops.device(\"/CPU:0\"):\n      with self.assertRaises(errors.InvalidArgumentError):\n        self.evaluate(bincount_ops.bincount([1, 2, 3, -1, 6, 8]))\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_shape_function(self):\n    # size must be scalar.\n    with self.assertRaisesRegex(\n        (ValueError, errors.InvalidArgumentError),\n        \"Shape must be rank 0 but is rank 1(?s).*Bincount\"):\n      gen_math_ops.bincount([1, 2, 3, 1, 6, 8], [1], [])\n    # size must be positive.\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be non-negative\"):\n      gen_math_ops.bincount([1, 2, 3, 1, 6, 8], -5, [])\n    # if size is a constant then the shape is known.\n    v1 = gen_math_ops.bincount([1, 2, 3, 1, 6, 8], 5, [])\n    self.assertAllEqual(v1.get_shape().as_list(), [5])\n    # if size is a placeholder then the shape is unknown.\n    with ops.Graph().as_default():\n      s = array_ops.placeholder(dtype=dtypes.int32)\n      v2 = gen_math_ops.bincount([1, 2, 3, 1, 6, 8], s, [])\n      self.assertAllEqual(v2.get_shape().as_list(), [None])\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    binary_output = True\n    inp = random_ops.random_uniform(\n        shape=[10, 10],\n        minval=-10000,\n        maxval=10000,\n        dtype=dtypes.int32,\n        seed=-2460)\n    size = random_ops.random_uniform(\n        shape=[], minval=-10000, maxval=10000, dtype=dtypes.int32, seed=-10000)\n    weights = random_ops.random_uniform(\n        shape=[],\n        minval=-10000,\n        maxval=10000,\n        dtype=dtypes.float32,\n        seed=-10000)\n    with self.assertRaises(errors.InvalidArgumentError):\n      self.evaluate(\n          gen_math_ops.dense_bincount(\n              input=inp,\n              size=size,\n              weights=weights,\n              binary_output=binary_output))\n\n\nclass BincountOpTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_bincount_all_count(self, dtype):\n    np.random.seed(42)\n    size = 1000\n    inp = np.random.randint(0, size, (4096), dtype=dtype)\n    np_out = np.bincount(inp, minlength=size)\n    with test_util.use_gpu():\n      self.assertAllEqual(\n          np_out,\n          self.evaluate(\n              gen_math_ops.dense_bincount(input=inp, weights=[], size=size)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_bincount_all_count_with_weights(self, dtype):\n    np.random.seed(42)\n    size = 1000\n    inp = np.random.randint(0, size, (4096,), dtype=dtype)\n    np_weight = np.random.random((4096,))\n    np_out = np.bincount(inp, minlength=size, weights=np_weight)\n    with test_util.use_gpu():\n      self.assertAllEqual(\n          np_out,\n          self.evaluate(\n              gen_math_ops.dense_bincount(\n                  input=inp, weights=np_weight, size=size)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_bincount_all_binary(self, dtype):\n    np.random.seed(42)\n    size = 10\n    inp = np.random.randint(0, size, (4096), dtype=dtype)\n    np_out = np.ones((size,))\n    with test_util.use_gpu():\n      self.assertAllEqual(\n          np_out,\n          self.evaluate(\n              gen_math_ops.dense_bincount(\n                  input=inp, weights=[], size=size, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_bincount_all_binary_with_weights(self, dtype):\n    np.random.seed(42)\n    size = 10\n    inp = np.random.randint(0, size, (4096,), dtype=dtype)\n    np_weight = np.random.random((4096,))\n    np_out = np.ones((size,))\n    with test_util.use_gpu():\n      self.assertAllEqual(\n          np_out,\n          self.evaluate(\n              gen_math_ops.dense_bincount(\n                  input=inp, weights=np_weight, size=size, binary_output=True)))\n\n  def _test_bincount_col_count(self, num_rows, num_cols, size, dtype):\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    with test_util.use_gpu():\n      self.assertAllEqual(\n          np_out,\n          self.evaluate(\n              gen_math_ops.dense_bincount(input=inp, weights=[], size=size)))\n\n  def _test_bincount_col_binary(self, num_rows, num_cols, size, dtype):\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate([\n            np.where(np.bincount(inp[j, :], minlength=size) > 0, 1, 0)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    with test_util.use_gpu():\n      self.assertAllEqual(\n          np_out,\n          self.evaluate(\n              gen_math_ops.dense_bincount(\n                  input=inp, weights=[], size=size, binary_output=True)))\n\n  def _test_bincount_col_count_with_weights(self, num_rows, num_cols, size,\n                                            dtype):\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_weight = np.random.random((num_rows, num_cols))\n    np_out = np.reshape(\n        np.concatenate([\n            np.bincount(inp[j, :], weights=np_weight[j, :], minlength=size)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    with test_util.use_gpu():\n      evaluated = self.evaluate(\n          gen_math_ops.dense_bincount(input=inp, weights=np_weight, size=size))\n      if np_out.dtype in (np.float32, np.float64):\n        self.assertAllClose(np_out, evaluated)\n      else:\n        self.assertAllEqual(np_out, evaluated)\n\n  def test_col_reduce_basic(self):\n    with test_util.use_gpu():\n      v = self.evaluate(\n          gen_math_ops.dense_bincount(\n              input=[[1, 2, 3], [0, 3, 2]], weights=[], size=4))\n    expected_out = [[0., 1., 1., 1.], [1., 0., 1., 1.]]\n    self.assertAllEqual(expected_out, v)\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_col_reduce_shared_memory(self, dtype):\n    # num_rows * num_bins less than half of max shared memory.\n    num_rows = 128\n    num_cols = 27\n    size = 10\n    self._test_bincount_col_count(num_rows, num_cols, size, dtype)\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_col_reduce_global_memory(self, dtype):\n    # num_rows * num_bins more than half of max shared memory.\n    num_rows = 128\n    num_cols = 27\n    size = 1024\n    self._test_bincount_col_count(num_rows, num_cols, size, dtype)\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_col_reduce_shared_memory_with_weights(self, dtype):\n    # num_rows * num_bins less than half of max shared memory.\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    self._test_bincount_col_count_with_weights(num_rows, num_cols, size, dtype)\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_col_reduce_global_memory_with_weights(self, dtype):\n    # num_rows * num_bins more than half of max shared memory.\n    num_rows = 128\n    num_cols = 27\n    size = 1024\n    self._test_bincount_col_count_with_weights(num_rows, num_cols, size, dtype)\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_col_reduce_binary(self, dtype):\n    num_rows = 128\n    num_cols = 7\n    size = 10\n    self._test_bincount_col_binary(num_rows, num_cols, size, dtype)\n\n  def test_invalid_rank(self):\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"at most rank 2\"):\n      with test_util.use_gpu():\n        self.evaluate(\n            gen_math_ops.dense_bincount(\n                input=[[[1, 2, 3], [0, 3, 2]]], weights=[], size=10))\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_size_is_not_scalar(self):  # b/206619828\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Shape must be rank 0 but is rank 1\"):\n      self.evaluate(\n          gen_math_ops.dense_bincount(\n              input=[0], size=[1, 1], weights=[3], binary_output=False))\n\n\nclass SparseBincountOpTest(test_util.TensorFlowTestCase,\n                           parameterized.TestCase):\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_bincount_all_count(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n\n    np_out = np.bincount(inp_vals, minlength=size)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            gen_math_ops.sparse_bincount(\n                indices=inp_indices,\n                values=inp_vals,\n                dense_shape=[num_rows],\n                size=size,\n                weights=[])))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_bincount_all_count_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    inp_weight = np.random.random((n_elems,))\n\n    np_out = np.bincount(inp_vals, minlength=size, weights=inp_weight)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            gen_math_ops.sparse_bincount(\n                indices=inp_indices,\n                values=inp_vals,\n                dense_shape=[num_rows],\n                size=size,\n                weights=inp_weight)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_bincount_all_binary(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 10\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n\n    np_out = np.ones((size,))\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            gen_math_ops.sparse_bincount(\n                indices=inp_indices,\n                values=inp_vals,\n                dense_shape=[num_rows],\n                size=size,\n                weights=[],\n                binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_bincount_all_binary_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 10\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    inp_weight = np.random.random((n_elems,))\n\n    np_out = np.ones((size,))\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            gen_math_ops.sparse_bincount(\n                indices=inp_indices,\n                values=inp_vals,\n                dense_shape=[num_rows],\n                size=size,\n                weights=inp_weight,\n                binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_bincount_col_reduce_count(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            gen_math_ops.sparse_bincount(\n                indices=inp_sparse.indices,\n                values=inp_sparse.values - 1,\n                dense_shape=inp_sparse.dense_shape,\n                size=size,\n                weights=[])))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_bincount_col_reduce_binary(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate([\n            np.where(np.bincount(inp[j, :], minlength=size) > 0, 1, 0)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            gen_math_ops.sparse_bincount(\n                indices=inp_sparse.indices,\n                values=inp_sparse.values - 1,\n                dense_shape=inp_sparse.dense_shape,\n                size=size,\n                weights=[],\n                binary_output=True)))\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_size_is_not_scalar(self):  # b/206619828\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Shape must be rank 0 but is rank 1\"):\n      self.evaluate(\n          gen_math_ops.sparse_bincount(\n              indices=[[0], [1]],\n              values=[0, 0],\n              dense_shape=[1, 1],\n              size=[1, 1],\n              weights=[0, 0],\n              binary_output=False))\n\n  def test_sparse_bincount_input_validation(self):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_vals = np.random.randint(0, size, (n_elems,))\n\n    # Insert negative index.\n    inp_indices[10, 0] = -2\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"out of bounds\"):\n      self.evaluate(\n          gen_math_ops.sparse_bincount(\n              indices=inp_indices,\n              values=inp_vals,\n              dense_shape=[num_rows],\n              size=size,\n              weights=[]))\n\n\nclass RaggedBincountOpTest(test_util.TensorFlowTestCase,\n                           parameterized.TestCase):\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_bincount_count(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    expected_output = [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0,\n                                            0], [1, 1, 0, 1, 0, 0],\n                       [0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 2, 1]]\n    self.assertAllEqual(\n        expected_output,\n        self.evaluate(\n            gen_math_ops.ragged_bincount(\n                splits=x.row_splits, values=x.values, weights=[], size=6)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_bincount_binary(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    expected_output = [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0,\n                                            0], [1, 1, 0, 1, 0, 0],\n                       [0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1]]\n    self.assertAllEqual(\n        expected_output,\n        self.evaluate(\n            gen_math_ops.ragged_bincount(\n                splits=x.row_splits,\n                values=x.values,\n                weights=[],\n                size=6,\n                binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_bincount_count_with_weights(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    weights = ragged_factory_ops.constant([[], [], [.1, .2, .3], [],\n                                           [.2, .5, .6, .3]])\n    expected_output = [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0],\n                       [.2, .3, 0, .1, 0, 0], [0, 0, 0, 0, 0, 0],\n                       [.5, 0, 0, 0, .9, .2]]\n    self.assertAllClose(\n        expected_output,\n        self.evaluate(\n            gen_math_ops.ragged_bincount(\n                splits=x.row_splits,\n                values=x.values,\n                weights=weights.values,\n                size=6)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_bincount_count_np(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            gen_math_ops.ragged_bincount(\n                splits=x.row_splits, values=x.values, weights=[], size=size)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_bincount_count_np_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_weight = np.random.random((num_rows, num_cols))\n    np_out = np.reshape(\n        np.concatenate([\n            np.bincount(inp[j, :], weights=np_weight[j, :], minlength=size)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            gen_math_ops.ragged_bincount(\n                splits=x.row_splits,\n                values=x.values,\n                weights=np_weight,\n                size=size)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_bincount_binary_np_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate([\n            np.where(np.bincount(inp[j, :], minlength=size) > 0, 1, 0)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            gen_math_ops.ragged_bincount(\n                splits=x.row_splits,\n                values=x.values,\n                weights=[],\n                size=size,\n                binary_output=True)))\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_size_is_not_scalar(self):  # b/206619828\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Shape must be rank 0 but is rank 1\"):\n      self.evaluate(\n          gen_math_ops.ragged_bincount(\n              splits=[0, 0, 1],\n              values=[1],\n              size=[1, 1],\n              weights=[0, 0, 0],\n              binary_output=False,\n              name=None))\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_splits_empty(self):  # b/238450914\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Splits must be non-empty\"):\n      self.evaluate(\n          gen_math_ops.ragged_bincount(\n              splits=[],  # Invalid splits\n              values=[1],\n              size=1,\n              weights=[1],\n              binary_output=False,\n              name=None))\n\nif __name__ == \"__main__\":\n  googletest.main()"