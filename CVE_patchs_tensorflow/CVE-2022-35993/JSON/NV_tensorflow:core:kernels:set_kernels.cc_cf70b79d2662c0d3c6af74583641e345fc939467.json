"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Ops for operating with sets. They are not checked in\n// to TensorFlow because we would first like to demonstrate successful\n// end-to-end use of these ops in eval and polish the api a bit like taking two\n// SparseTensor rather than on edense and one sparse.\n\n#define EIGEN_USE_THREADS\n\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"absl/container/btree_set.h\"\n#include \"absl/container/flat_hash_set.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\nnamespace tensorflow {\n\nusing ShapeArray = sparse::SparseTensor::ShapeArray;\nusing VarDimArray = sparse::SparseTensor::VarDimArray;\n\n// Validate rank >= 2.\nvoid CheckRankAtLeast2(OpKernelContext* ctx, const TensorShape& shape) {\n  const auto rank = shape.dims();\n  OP_REQUIRES(ctx, rank >= 2,\n              errors::InvalidArgument(\"Invalid rank \", rank, \".\"));\n}\n\n// Return group shape, which is the 1st n-1 dimensions of shape.\nStatus GroupShape(const VarDimArray& input_shape, ShapeArray* grouped_shape) {\n  if (input_shape.size() < 2) {\n    // TODO(irving): Why can't 2 be 1 here?\n    return errors::InvalidArgument(\"Shape [\", absl::StrJoin(input_shape, \",\"),\n                                   \"] has rank \", input_shape.size(), \" < 2\");\n  }\n  // grouped_shape is input_shape[:-1]\n  *grouped_shape = ShapeArray(input_shape.begin(), input_shape.end() - 1);\n  return OkStatus();\n}\n\n// Build `SparseTensor` from indices, values, and shape in inputs\n// [base_index, base_index + 3), and validate its rank and indices.\nStatus SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index,\n                               const bool validate_indices,\n                               sparse::SparseTensor* tensor) {\n  // Assume row-major order.\n  TensorShape shape;\n  const Tensor& shape_tensor = ctx->input(base_index + 2);\n  if (shape_tensor.dims() != 1) {\n    return errors::InvalidArgument(\"Shape must be a 1D tensor.\");\n  }\n  TF_RETURN_IF_ERROR(\n      TensorShape::BuildTensorShape(shape_tensor.vec<int64_t>(), &shape));\n  CheckRankAtLeast2(ctx, shape);\n  std::vector<int64_t> order(shape.dims());\n  std::iota(order.begin(), order.end(), 0);\n\n  Status status = sparse::SparseTensor::Create(\n      ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor);\n\n  if (!validate_indices || !status.ok()) return status;\n  return tensor->IndicesValid();\n}\n\n// TODO(ptucker): CheckGroup is just a sanity check on the result of\n// SparseTensor.group, consider removing.\n// `sparse_tensor_shape` is the shape of the `SparseTensor` from which group\n// was created, and is used to sanity check the indices in `group'.\ntemplate <typename T>\nvoid CheckGroup(OpKernelContext* ctx, const sparse::Group& group,\n                const VarDimArray& sparse_tensor_shape) {\n  const auto& indices = group.indices();\n  const auto& values = group.values<T>();\n\n  // Sanity check: group is non-empty, and indices and values are same size.\n  const auto num_values = values.dimension(0);\n  OP_REQUIRES(ctx, indices.size() > 0, errors::Internal(\"Empty group.\"));\n  OP_REQUIRES(\n      ctx, indices.dimension(0) == num_values,\n      errors::Internal(\"shape[0] of group indices \", indices.dimension(0),\n                       \" != values \", num_values, \".\"));\n\n  // Sanity check: valid indices.\n  const auto group_rank = indices.dimension(1);\n  const auto expected_rank = sparse_tensor_shape.size();\n  OP_REQUIRES(ctx, expected_rank == group_rank,\n              errors::Internal(\"Rank expected \", expected_rank, \", got \",\n                               group_rank, \".\"));\n  for (int32_t j = 0; j < expected_rank; ++j) {\n    const auto dim_size = sparse_tensor_shape[j];\n    OP_REQUIRES(\n        ctx, dim_size > 0,\n        errors::Internal(\"Invalid dim_size[\", j, \"] = \", dim_size, \".\"));\n    for (int64_t i = 0; i < num_values; ++i) {\n      const auto index = indices(i, j);\n      OP_REQUIRES(ctx, dim_size > index,\n                  errors::Internal(\"indices[\", i, \", \", j, \"] expected < \",\n                                   dim_size, \", got \", index, \".\"));\n    }\n  }\n}\n\n// This lets us calculate the row-major index into flattened output.\nconst ShapeArray Strides(const VarDimArray& shape) {\n  ShapeArray result(shape.size());\n  int64_t product = 1;\n  for (int i = shape.size() - 1; i >= 0; --i) {\n    result[i] = product;\n    product *= shape[i];\n  }\n  return result;\n}\n\n// TODO(ptucker): If memory becomes an issue, consider a 2-pass approach to\n// eliminate the intermediate `values` data structure - iterate once to\n// determine `num_values`, allocate output tensors, then write results directly\n// to output tensors.\n\n// TODO(ptucker): Consider sharding work across multiple threads. See\n// SparseCrossOp for an example.\n\n// Output `SparseTensor` of shape `output_shape`. `sets` contains pairs of\n// group indices (i.e., values for all but the last dimension of `output_shape`)\n// and set values, each of which will occupy the last dimension of\n// `output_shape`. `sets` should be sorted in ascending order by group indices.\ntemplate <typename T>\nvoid OutputSparseTensor(\n    OpKernelContext* ctx, const TensorShape& output_shape,\n    const int64_t num_values,\n    const std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>>&\n        sets) {\n  // Allocate 3 output tensors for sparse data.\n  Tensor *out_indices_t, *out_values_t, *out_shape_t;\n  OP_REQUIRES_OK(ctx, ctx->allocate_output(\n                          0, TensorShape({num_values, output_shape.dims()}),\n                          &out_indices_t));\n  OP_REQUIRES_OK(\n      ctx, ctx->allocate_output(1, TensorShape({num_values}), &out_values_t));\n  OP_REQUIRES_OK(ctx, ctx->allocate_output(\n                          2, TensorShape({output_shape.dims()}), &out_shape_t));\n  auto out_indices_mat = out_indices_t->matrix<int64_t>();\n  auto out_values_flat = out_values_t->vec<T>();\n\n  // For each set, write its indices and values to output tensors.\n  int64_t value_index = 0;\n  for (auto it = sets.begin(); it != sets.end(); ++it) {\n    const auto& group_indices = it->first;\n    OP_REQUIRES(\n        ctx, group_indices.size() == output_shape.dims() - 1,\n        errors::Internal(\"Invalid number of indices \", group_indices.size(),\n                         \", expected \", output_shape.dims() - 1, \".\"));\n    const auto& set = it->second;\n\n    // For each set item, write its indices and value to output tensors.\n    int64_t group_value_index = 0;\n    for (auto value = set.begin(); value != set.end();\n         ++value, ++value_index, ++group_value_index) {\n      // First n-1 dimensions are the group, last dimension is the position in\n      // the set.\n      for (int32_t i = 0; i < group_indices.size(); ++i) {\n        out_indices_mat(value_index, i) = group_indices[i];\n      }\n      out_indices_mat(value_index, group_indices.size()) = group_value_index;\n\n      out_values_flat(value_index) = *value;\n    }\n  }\n\n  // Write output shape.\n  auto out_shape_flat = out_shape_t->vec<int64_t>();\n  for (int32_t i = 0; i < output_shape.dims(); ++i) {\n    out_shape_flat(i) = output_shape.dim_size(i);\n  }\n}\n\nbool ValidateIndicesFromContext(OpKernelConstruction* ctx) {\n  bool result;\n  if (ctx->GetAttr(\"validate_indices\", &result).ok()) {\n    return result;\n  }\n  return true;\n}\n\n// Populate `result` set from group in `tensor`. \"Group\" is defined by\n// `group_indices`, which are values for the first n-1 dimensions of\n// `input_tensor`. `input_strides` is provided to avoid recalculating it\n// multiple times, and is used to calculate the flat index into `input_tensor`\n// values.\ntemplate <typename T>\nvoid PopulateFromDenseGroup(OpKernelContext* ctx, const Tensor& input_tensor,\n                            const VarDimArray& input_strides,\n                            const std::vector<int64_t>& group_indices,\n                            absl::flat_hash_set<T>* result) {\n  OP_REQUIRES(ctx, group_indices.size() == input_strides.size() - 1,\n              errors::Internal(\"group_indices.size \", group_indices.size(),\n                               \", !=  input_strides.size-1 \",\n                               input_strides.size() - 1, \".\"));\n  result->clear();\n  auto input_flat = input_tensor.flat<T>();\n  const auto start = std::inner_product(\n      group_indices.begin(), group_indices.end(), input_strides.begin(), 0LL);\n  const TensorShape& input_shape = input_tensor.shape();\n  const auto end = start + input_shape.dim_size(input_shape.dims() - 1);\n  for (int64_t i = start; i < end; ++i) {\n    result->insert(input_flat(i));\n  }\n}\n\n// Populate `result` set from `group`. `sparse_tensor_shape` is the shape of the\n// `SparseTensor` from which group was created, and is used to sanity check the\n// indices in `group'.\ntemplate <typename T>\nvoid PopulateFromSparseGroup(OpKernelContext* ctx, const sparse::Group& group,\n                             const VarDimArray& sparse_tensor_shape,\n                             absl::flat_hash_set<T>* result) {\n  CheckGroup<T>(ctx, group, sparse_tensor_shape);\n  result->clear();\n  const auto& group_values = group.values<T>();\n  for (int64_t i = 0; i < group_values.size(); ++i) {\n    result->insert(group_values(i));\n  }\n}\n\ntemplate <typename T>\nclass SetSizeOp : public OpKernel {\n public:\n  explicit SetSizeOp(OpKernelConstruction* ctx)\n      : OpKernel(ctx), validate_indices_(ValidateIndicesFromContext(ctx)) {}\n\n  void Compute(OpKernelContext* ctx) override;\n\n private:\n  const bool validate_indices_;\n};\n\ntemplate <typename T>\nvoid SetSizeOp<T>::Compute(OpKernelContext* ctx) {\n  sparse::SparseTensor set_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 0, validate_indices_, &set_st));\n\n  // Output shape is same as input except for last dimension, which reduces\n  // to the set size of values along that dimension.\n  ShapeArray output_shape;\n  OP_REQUIRES_OK(ctx, GroupShape(set_st.shape(), &output_shape));\n  const auto output_strides = Strides(output_shape);\n\n  TensorShape output_shape_ts;\n  OP_REQUIRES_OK(ctx,\n                 TensorShapeUtils::MakeShape(output_shape, &output_shape_ts));\n  Tensor* out_t;\n  OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape_ts, &out_t));\n  auto out = out_t->flat<int32>();\n  out.device(ctx->eigen_cpu_device()) = out.constant(static_cast<int32>(0.0));\n\n  // Group by all but last dimension, create a set of group values, and add set\n  // size to output.\n  VarDimArray group_ix = set_st.order().subspan(0, set_st.order().size() - 1);\n  absl::flat_hash_set<T> group_set;\n  for (const auto& group : set_st.group(group_ix)) {\n    PopulateFromSparseGroup<T>(ctx, group, set_st.shape(), &group_set);\n\n    const auto group_key = group.group();\n    const auto output_index = std::inner_product(\n        group_key.begin(), group_key.end(), output_strides.begin(), 0LL);\n    out(output_index) = group_set.size();\n  }\n}\n\n#define _SET_SIZE_REGISTER_KERNEL_BUILDER(T)                     \\\n  REGISTER_KERNEL_BUILDER(                                       \\\n      Name(\"SetSize\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SetSizeOp<T>);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int8);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int16);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int32);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(int64_t);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(uint8);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(uint16);\n_SET_SIZE_REGISTER_KERNEL_BUILDER(tstring);\n#undef _SET_SIZE_REGISTER_KERNEL_BUILDER\n\nenum InputTypes {\n  DENSE_DENSE = 0,\n  DENSE_SPARSE = 1,\n  SPARSE_SPARSE = 2,\n};\n\nenum SetOperation { A_MINUS_B = 0, B_MINUS_A = 1, INTERSECTION = 2, UNION = 3 };\n\nSetOperation SetOperationFromContext(OpKernelConstruction* ctx) {\n  string set_operation_str;\n  if (!ctx->GetAttr(\"set_operation\", &set_operation_str).ok()) {\n    ctx->CtxFailure(errors::InvalidArgument(\"Missing set_operation.\"));\n  } else {\n    std::transform(set_operation_str.begin(), set_operation_str.end(),\n                   set_operation_str.begin(), ::tolower);\n    if (\"a-b\" == set_operation_str) {\n      return A_MINUS_B;\n    }\n    if (\"b-a\" == set_operation_str) {\n      return B_MINUS_A;\n    }\n    if (\"intersection\" == set_operation_str) {\n      return INTERSECTION;\n    }\n    if (\"union\" != set_operation_str) {\n      ctx->CtxFailure(errors::InvalidArgument(\"Invalid set_operation \",\n                                              set_operation_str, \".\"));\n    }\n  }\n  // NOTE: This is not the default, this function fails if no 'set_operation'\n  // attribute is provided.\n  return UNION;\n}\n\n// Abstract base class for performing set operations across the last dimension\n// of 2 input tensors.\ntemplate <typename T>\nclass SetOperationOp : public OpKernel {\n public:\n  SetOperationOp(OpKernelConstruction* ctx, InputTypes input_types)\n      : OpKernel(ctx),\n        set_operation_(SetOperationFromContext(ctx)),\n        validate_indices_(ValidateIndicesFromContext(ctx)),\n        input_types_(input_types) {}\n\n  void Compute(OpKernelContext* ctx) override;\n\n private:\n  void ApplySetOperation(const absl::flat_hash_set<T>& set1,\n                         const absl::flat_hash_set<T>& set2,\n                         absl::btree_set<T>* result) const;\n  void ComputeDenseToDense(OpKernelContext* ctx) const;\n  void ComputeDenseToSparse(OpKernelContext* ctx) const;\n  void ComputeSparseToSparse(OpKernelContext* ctx) const;\n  const SetOperation set_operation_;\n  const bool validate_indices_;\n  const InputTypes input_types_;\n};\n\ntemplate <typename T>\nvoid SetDifference(const absl::flat_hash_set<T>& set1,\n                   const absl::flat_hash_set<T>& set2,\n                   absl::btree_set<T>* result) {\n  for (const T& elem : set1) {\n    if (!set2.contains(elem)) result->insert(elem);\n  }\n}\n\ntemplate <typename T>\nvoid SetIntersection(const absl::flat_hash_set<T>& set1,\n                     const absl::flat_hash_set<T>& set2,\n                     absl::btree_set<T>* result) {\n  if (set1.size() <= set2.size()) {\n    for (const T& elem : set1) {\n      if (set2.contains(elem)) result->insert(elem);\n    }\n  } else {\n    for (const T& elem : set2) {\n      if (set1.contains(elem)) result->insert(elem);\n    }\n  }\n}\n\ntemplate <typename T>\nvoid SetUnion(const absl::flat_hash_set<T>& set1,\n              const absl::flat_hash_set<T>& set2, absl::btree_set<T>* result) {\n  result->insert(set1.begin(), set1.end());\n  result->insert(set2.begin(), set2.end());\n}\n\ntemplate <typename T>\nvoid SetOperationOp<T>::ApplySetOperation(const absl::flat_hash_set<T>& set1,\n                                          const absl::flat_hash_set<T>& set2,\n                                          absl::btree_set<T>* result) const {\n  switch (set_operation_) {\n    case A_MINUS_B:\n      SetDifference<T>(set1, set2, result);\n      break;\n    case B_MINUS_A:\n      SetDifference<T>(set2, set1, result);\n      break;\n    case INTERSECTION:\n      SetIntersection<T>(set1, set2, result);\n      break;\n    case UNION:\n      SetUnion<T>(set1, set2, result);\n      break;\n  }\n}\n\n// Validate shapes have the same dimensions.\nStatus CheckShapesMatch(VarDimArray shape1, VarDimArray shape2) {\n  if (shape1 != shape2) {\n    return errors::InvalidArgument(\"Mismatched shapes [\",\n                                   absl::StrJoin(shape1, \",\"), \"] vs [\",\n                                   absl::StrJoin(shape2, \",\"), \"]\");\n  }\n  return OkStatus();\n}\n\n// Validate ranks are the same, and all but last dimension are the same.\n// Return GroupShape.\nStatus GroupShapeFromInputs(VarDimArray shape1, VarDimArray shape2,\n                            ShapeArray* group_shape) {\n  ShapeArray group_shape_1;\n  TF_RETURN_IF_ERROR(GroupShape(shape1, &group_shape_1));\n  ShapeArray group_shape_2;\n  TF_RETURN_IF_ERROR(GroupShape(shape2, &group_shape_2));\n  TF_RETURN_IF_ERROR(CheckShapesMatch(group_shape_1, group_shape_2));\n  *group_shape = group_shape_1;\n  return OkStatus();\n}\n\n// Split `flat_group_index` into separate dimensions based on `group_shape`.\nvoid PopulateGroupIndices(const int64_t flat_group_index,\n                          VarDimArray group_shape,\n                          std::vector<int64_t>* group_indices) {\n  group_indices->clear();\n  int64_t running_flat_group_index = flat_group_index;\n  for (int group_dim_index = group_shape.size() - 1; group_dim_index >= 0;\n       --group_dim_index) {\n    const auto group_dim = group_shape[group_dim_index];\n    group_indices->insert(group_indices->begin(),\n                          running_flat_group_index % group_dim);\n    running_flat_group_index /= group_dim;\n  }\n}\n\nShapeArray TensorShapeToArray(const TensorShape& t) {\n  ShapeArray vec(t.dims());\n  for (int i = 0; i < t.dims(); ++i) vec[i] = t.dim_size(i);\n  return vec;\n}\n\n// `ctx` contains set1 and set2 dense tensors.\n// Iterate over groups in set1 and set2, applying `ApplySetOperation` to each,\n// and outputting the result `SparseTensor`. A \"group\" is a collection of values\n// with the same first n-1 dimensions in set1 and set2.\ntemplate <typename T>\nvoid SetOperationOp<T>::ComputeDenseToDense(OpKernelContext* ctx) const {\n  const Tensor& set1_t = ctx->input(0);\n  const Tensor& set2_t = ctx->input(1);\n  // The following should stay in sync with `_dense_to_dense_shape` shape\n  // assertions in python/ops/set_ops.py, and `SetShapeFn` for\n  // `DenseToDenseSetOperation` in ops/set_ops.cc.\n  ShapeArray group_shape;\n  const auto shape1 = TensorShapeToArray(set1_t.shape());\n  const auto shape2 = TensorShapeToArray(set2_t.shape());\n  OP_REQUIRES_OK(ctx, GroupShapeFromInputs(shape1, shape2, &group_shape));\n\n  const auto set1_strides = Strides(shape1);\n  const auto set2_strides = Strides(shape2);\n\n  std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>> group_sets;\n  int64_t num_result_values = 0;\n  int64_t max_set_size = 0;\n\n  absl::flat_hash_set<T> set1_group_set;\n  absl::flat_hash_set<T> set2_group_set;\n  std::vector<int64_t> group_indices;\n  int64_t num_elements;\n  OP_REQUIRES_OK(ctx,\n                 TensorShapeUtils::NumElements(group_shape, &num_elements));\n  for (int64_t flat_group_index = 0; flat_group_index < num_elements;\n       ++flat_group_index) {\n    PopulateGroupIndices(flat_group_index, group_shape, &group_indices);\n    PopulateFromDenseGroup<T>(ctx, set1_t, set1_strides, group_indices,\n                              &set1_group_set);\n    PopulateFromDenseGroup<T>(ctx, set2_t, set2_strides, group_indices,\n                              &set2_group_set);\n\n    absl::btree_set<T> group_set;\n    ApplySetOperation(set1_group_set, set2_group_set, &group_set);\n    if (!group_set.empty()) {\n      const auto set_size = group_set.size();\n      if (set_size > max_set_size) {\n        max_set_size = set_size;\n      }\n      num_result_values += set_size;\n      group_sets.push_back({group_indices, std::move(group_set)});\n    }\n  }\n\n  TensorShape output_shape;\n  OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(group_shape, &output_shape));\n  output_shape.AddDim(max_set_size);\n  OutputSparseTensor<T>(ctx, output_shape, num_result_values, group_sets);\n}\n\n// `ctx` contains dense set1 and sparse set2 tensors.\n// Iterate over groups in set1 and set2, applying `ApplySetOperation` to each,\n// and outputing the result `SparseTensor`. A \"group\" is a collection of values\n// with the same first n-1 dimensions in set1 and set2.\ntemplate <typename T>\nvoid SetOperationOp<T>::ComputeDenseToSparse(OpKernelContext* ctx) const {\n  const Tensor& set1_t = ctx->input(0);\n  sparse::SparseTensor set2_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 1, validate_indices_, &set2_st));\n  // The following should stay in sync with `_dense_to_sparse_shape` shape\n  // assertions in python/ops/set_ops.py, and `SetShapeFn` for\n  // `DenseToSparseSetOperation` in ops/set_ops.cc.\n  ShapeArray group_shape;\n  OP_REQUIRES_OK(ctx, GroupShapeFromInputs(TensorShapeToArray(set1_t.shape()),\n                                           set2_st.shape(), &group_shape));\n\n  const ShapeArray set1_strides = Strides(TensorShapeToArray(set1_t.shape()));\n\n  std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>> group_sets;\n  int64_t num_result_values = 0;\n  int64_t max_set_size = 0;\n\n  absl::flat_hash_set<T> set1_group_set;\n  absl::flat_hash_set<T> set2_group_set;\n  auto set2_grouper =\n      set2_st.group(set2_st.order().subspan(0, set2_st.order().size() - 1));\n  auto set2_group_it = set2_grouper.begin();\n  std::vector<int64_t> group_indices;\n  int64_t num_elements;\n  OP_REQUIRES_OK(ctx,\n                 TensorShapeUtils::NumElements(group_shape, &num_elements));\n  for (int64_t flat_group_index = 0; flat_group_index < num_elements;\n       ++flat_group_index) {\n    PopulateGroupIndices(flat_group_index, group_shape, &group_indices);\n\n    // Get values from set1.\n    PopulateFromDenseGroup<T>(ctx, set1_t, set1_strides, group_indices,\n                              &set1_group_set);\n\n    // Get values from set2, if applicable.\n    set2_group_set.clear();\n    if (set2_group_it != set2_grouper.end()) {\n      const auto& group = *set2_group_it;\n      const auto set2_group_indices = group.group();\n      OP_REQUIRES(\n          ctx, set2_group_indices.size() == group_indices.size(),\n          errors::InvalidArgument(\"Invalid number of group indices \",\n                                  set2_group_indices.size(), \", expected \",\n                                  group_indices.size(), \".\"));\n      bool group_match = true;\n      for (int32_t i = 0; group_match && (i < set2_group_indices.size()); ++i) {\n        if (set2_group_indices[i] != group_indices[i]) {\n          group_match = false;\n        }\n      }\n      if (group_match) {\n        PopulateFromSparseGroup<T>(ctx, group, set2_st.shape(),\n                                   &set2_group_set);\n        ++set2_group_it;\n      }\n    }\n\n    absl::btree_set<T> group_set;\n    ApplySetOperation(set1_group_set, set2_group_set, &group_set);\n    if (!group_set.empty()) {\n      const auto set_size = group_set.size();\n      if (set_size > max_set_size) {\n        max_set_size = set_size;\n      }\n      num_result_values += set_size;\n      group_sets.push_back({group_indices, std::move(group_set)});\n    }\n  }\n\n  TensorShape output_shape;\n  OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(group_shape, &output_shape));\n  output_shape.AddDim(max_set_size);\n  OutputSparseTensor<T>(ctx, output_shape, num_result_values, group_sets);\n}\n\n// This is used to determine which group iterator is less than the other, based\n// on row-major ordering of indices.\n// An empty index list indicates end of iteration, which is interpreted as \"max\"\n// for the purposes of comparison; i.e., non-empty < empty.\n// Return 0 if both groups are empty, or both non-empty with the same values.\n// Return <0 if set1 <= set2, or set2 is empty.\n// Return >0 if set2 <= set1, or set1 is empty.\nvoid CompareGroups(OpKernelContext* ctx,\n                   const std::vector<int64_t>& set1_group_indices,\n                   const std::vector<int64_t>& set2_group_indices,\n                   int64_t* result) {\n  if (set1_group_indices.empty()) {\n    *result = set2_group_indices.empty() ? 0 : 1;\n    return;\n  }\n  if (set2_group_indices.empty()) {\n    *result = set1_group_indices.empty() ? 0 : -1;\n    return;\n  }\n  OP_REQUIRES(ctx, set1_group_indices.size() == set2_group_indices.size(),\n              errors::InvalidArgument(\"Mismatched group dims \",\n                                      set1_group_indices.size(), \" vs \",\n                                      set2_group_indices.size(), \".\"));\n  for (int32_t i = 0; i < set1_group_indices.size(); ++i) {\n    *result = set1_group_indices[i] - set2_group_indices[i];\n    if (*result != 0) {\n      return;\n    }\n  }\n}\n\n// `ctx` contains set1 and set2 sparse tensors.\n// Iterate over groups in set1 and set2, applying `ApplySetOperation` to each,\n// and outputing the result `SparseTensor`. A \"group\" is a collection of values\n// with the same first n-1 dimensions in set1 and set2.\ntemplate <typename T>\nvoid SetOperationOp<T>::ComputeSparseToSparse(OpKernelContext* ctx) const {\n  sparse::SparseTensor set1_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 0, validate_indices_, &set1_st));\n\n  sparse::SparseTensor set2_st;\n  OP_REQUIRES_OK(ctx,\n                 SparseTensorFromContext(ctx, 3, validate_indices_, &set2_st));\n\n  // The following should stay in sync with `_sparse_to_sparse_shape` shape\n  // assertions in python/ops/set_ops.py, and `SetShapeFn` for\n  // `SparseToSparseSetOperation` in ops/set_ops.cc.\n  ShapeArray group_shape;\n  OP_REQUIRES_OK(ctx, GroupShapeFromInputs(set1_st.shape(), set2_st.shape(),\n                                           &group_shape));\n\n  std::vector<std::pair<std::vector<int64_t>, absl::btree_set<T>>> group_sets;\n  int64_t num_result_values = 0;\n  int64_t max_set_size = 0;\n\n  absl::flat_hash_set<T> set1_group_set;\n  absl::flat_hash_set<T> set2_group_set;\n  auto set1_grouper =\n      set1_st.group(set1_st.order().subspan(0, set1_st.order().size() - 1));\n  auto set1_group_it = set1_grouper.begin();\n  auto set2_grouper =\n      set2_st.group(set2_st.order().subspan(0, set2_st.order().size() - 1));\n  auto set2_group_it = set2_grouper.begin();\n\n  // Empty indices vector represents iteration end in `CompareGroups`.\n  const std::vector<int64_t> group_iter_end;\n  // Group by rows, and iterate over rows of both sets in parallel, creating a\n  // set for each row.\n  while ((set1_group_it != set1_grouper.end()) ||\n         (set2_group_it != set2_grouper.end())) {\n    const std::vector<int64_t>& set1_group_indices =\n        (set1_group_it == set1_grouper.end()) ? group_iter_end\n                                              : (*set1_group_it).group();\n    const std::vector<int64_t>& set2_group_indices =\n        (set2_group_it == set2_grouper.end()) ? group_iter_end\n                                              : (*set2_group_it).group();\n\n    int64_t compare_groups;\n    CompareGroups(ctx, set1_group_indices, set2_group_indices, &compare_groups);\n    const std::vector<int64_t>* group_indices = nullptr;\n\n    // Get values from set1, if applicable.\n    set1_group_set.clear();\n    if (compare_groups <= 0) {\n      PopulateFromSparseGroup<T>(ctx, *set1_group_it, set1_st.shape(),\n                                 &set1_group_set);\n      ++set1_group_it;\n      group_indices = &set1_group_indices;\n    }\n\n    // Get values from set2, if applicable.\n    set2_group_set.clear();\n    if (compare_groups >= 0) {\n      PopulateFromSparseGroup<T>(ctx, *set2_group_it, set2_st.shape(),\n                                 &set2_group_set);\n      ++set2_group_it;\n      group_indices = &set2_group_indices;\n    }\n\n    absl::btree_set<T> group_set;\n    ApplySetOperation(set1_group_set, set2_group_set, &group_set);\n    if (!group_set.empty()) {\n      const auto set_size = group_set.size();\n      if (set_size > max_set_size) {\n        max_set_size = set_size;\n      }\n      num_result_values += set_size;\n      group_sets.push_back({*group_indices, std::move(group_set)});\n    }\n  }\n\n  TensorShape output_shape;\n  OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(group_shape, &output_shape));\n  output_shape.AddDim(max_set_size);\n  OutputSparseTensor<T>(ctx, output_shape, num_result_values, group_sets);\n}\n\n// Given set1 of shape [b, n1] and data_2 of shape [b, n2], populate result\n// sparse tensor with [b, n3] values, where each row `i` contains the result of\n// the set operation on elements from set1[i] and set2[i]. `n3` is the number\n// of elements in that result row.\ntemplate <typename T>\nvoid SetOperationOp<T>::Compute(OpKernelContext* ctx) {\n  switch (input_types_) {\n    case DENSE_DENSE:\n      ComputeDenseToDense(ctx);\n      break;\n    case DENSE_SPARSE:\n      ComputeDenseToSparse(ctx);\n      break;\n    case SPARSE_SPARSE:\n      ComputeSparseToSparse(ctx);\n      break;\n  }\n}\n\ntemplate <typename T>\nclass DenseToDenseSetOperationOp : public SetOperationOp<T> {\n public:\n  explicit DenseToDenseSetOperationOp(OpKernelConstruction* ctx)\n      : SetOperationOp<T>(ctx, DENSE_DENSE) {}\n};\n\n#define _DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(T) \\\n  REGISTER_KERNEL_BUILDER(Name(\"DenseToDenseSetOperation\")       \\\n                              .Device(DEVICE_CPU)                \\\n                              .TypeConstraint<T>(\"T\"),           \\\n                          DenseToDenseSetOperationOp<T>);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int8);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int16);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int32);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int64_t);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint8);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint16);\n_DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(tstring);\n#undef _DENSE_TO_DENSE_SET_OPERATION_REGISTER_KERNEL_BUILDER\n\ntemplate <typename T>\nclass DenseToSparseSetOperationOp : public SetOperationOp<T> {\n public:\n  explicit DenseToSparseSetOperationOp(OpKernelConstruction* ctx)\n      : SetOperationOp<T>(ctx, DENSE_SPARSE) {}\n};\n\n#define _DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(T) \\\n  REGISTER_KERNEL_BUILDER(Name(\"DenseToSparseSetOperation\")       \\\n                              .Device(DEVICE_CPU)                 \\\n                              .TypeConstraint<T>(\"T\"),            \\\n                          DenseToSparseSetOperationOp<T>);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int8);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int16);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int32);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int64_t);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint8);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint16);\n_DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(tstring);\n#undef _DENSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER\n\ntemplate <typename T>\nclass SparseToSparseSetOperationOp : public SetOperationOp<T> {\n public:\n  explicit SparseToSparseSetOperationOp(OpKernelConstruction* ctx)\n      : SetOperationOp<T>(ctx, SPARSE_SPARSE) {}\n};\n\n#define _SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(T) \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseToSparseSetOperation\")       \\\n                              .Device(DEVICE_CPU)                  \\\n                              .TypeConstraint<T>(\"T\"),             \\\n                          SparseToSparseSetOperationOp<T>);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int8);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int16);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int32);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(int64_t);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint8);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(uint16);\n_SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER(tstring);\n#undef _SPARSE_TO_SPARSE_SET_OPERATION_REGISTER_KERNEL_BUILDER\n\n}  // namespace tensorflow"