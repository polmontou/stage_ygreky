"# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for set_ops.\"\"\"\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors_impl\nfrom tensorflow.python.framework import sparse_tensor as sparse_tensor_lib\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import sets\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import googletest\n\n_DTYPES = set([\n    dtypes.int8, dtypes.int16, dtypes.int32, dtypes.int64, dtypes.uint8,\n    dtypes.uint16, dtypes.string\n])\n\n\ndef _values(values, dtype):\n  return np.array(\n      values,\n      dtype=(np.str_ if (dtype == dtypes.string) else dtype.as_numpy_dtype))\n\n\ndef _constant(values, dtype):\n  return constant_op.constant(_values(values, dtype), dtype=dtype)\n\n\ndef _dense_to_sparse(dense, dtype):\n  indices = []\n  values = []\n  max_row_len = 0\n  for row in dense:\n    max_row_len = max(max_row_len, len(row))\n  shape = [len(dense), max_row_len]\n  row_ix = 0\n  for row in dense:\n    col_ix = 0\n    for cell in row:\n      indices.append([row_ix, col_ix])\n      values.append(str(cell) if dtype == dtypes.string else cell)\n      col_ix += 1\n    row_ix += 1\n  return sparse_tensor_lib.SparseTensor(\n      constant_op.constant(indices, dtypes.int64),\n      constant_op.constant(values, dtype),\n      constant_op.constant(shape, dtypes.int64))\n\n\nclass SetOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  @test_util.run_deprecated_v1\n  def test_set_size_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_size_2d(dtype)\n\n  def _test_set_size_2d(self, dtype):\n    self.assertAllEqual([1], self._set_size(_dense_to_sparse([[1]], dtype)))\n    self.assertAllEqual([2, 1],\n                        self._set_size(_dense_to_sparse([[1, 9], [1]], dtype)))\n    self.assertAllEqual(\n        [3, 0], self._set_size(_dense_to_sparse([[1, 9, 2], []], dtype)))\n    self.assertAllEqual(\n        [0, 3], self._set_size(_dense_to_sparse([[], [1, 9, 2]], dtype)))\n\n  @test_util.run_deprecated_v1\n  def test_set_size_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_size_duplicates_2d(dtype)\n\n  def _test_set_size_duplicates_2d(self, dtype):\n    self.assertAllEqual(\n        [1], self._set_size(_dense_to_sparse([[1, 1, 1, 1, 1, 1]], dtype)))\n    self.assertAllEqual([2, 7, 3, 0, 1],\n                        self._set_size(\n                            _dense_to_sparse([[1, 9], [\n                                6, 7, 8, 8, 6, 7, 5, 3, 3, 0, 6, 6, 9, 0, 0, 0\n                            ], [999, 1, -1000], [], [-1]], dtype)))\n\n  @test_util.run_deprecated_v1\n  def test_set_size_3d(self):\n    for dtype in _DTYPES:\n      self._test_set_size_3d(dtype)\n\n  def test_set_size_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_set_size_3d(dtype, invalid_indices=True)\n\n  def _test_set_size_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant([\n          [0, 1, 0], [0, 1, 1],             # 0,1\n          [1, 0, 0],                        # 1,0\n          [1, 1, 0], [1, 1, 1], [1, 1, 2],  # 1,1\n          [0, 0, 0], [0, 0, 2],             # 0,0\n                                            # 2,0\n          [2, 1, 1]                         # 2,1\n      ], dtypes.int64)\n    else:\n      indices = constant_op.constant([\n          [0, 0, 0], [0, 0, 2],             # 0,0\n          [0, 1, 0], [0, 1, 1],             # 0,1\n          [1, 0, 0],                        # 1,0\n          [1, 1, 0], [1, 1, 1], [1, 1, 2],  # 1,1\n                                            # 2,0\n          [2, 1, 1]                         # 2,1\n      ], dtypes.int64)\n\n    sp = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant([\n            1, 9,     # 0,0\n            3, 3,     # 0,1\n            1,        # 1,0\n            9, 7, 8,  # 1,1\n                      # 2,0\n            5         # 2,1\n        ], dtype),\n        constant_op.constant([3, 2, 3], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_size(sp)\n    else:\n      self.assertAllEqual([\n          [2,   # 0,0\n           1],  # 0,1\n          [1,   # 1,0\n           3],  # 1,1\n          [0,   # 2,0\n           1]   # 2,1\n      ], self._set_size(sp))\n\n  def _set_size(self, sparse_data):\n    # Validate that we get the same results with or without `validate_indices`.\n    ops = [\n        sets.set_size(sparse_data, validate_indices=True),\n        sets.set_size(sparse_data, validate_indices=False)\n    ]\n    for op in ops:\n      self.assertEqual(None, op.get_shape().dims)\n      self.assertEqual(dtypes.int32, op.dtype)\n    with self.cached_session() as sess:\n      results = self.evaluate(ops)\n    self.assertAllEqual(results[0], results[1])\n    return results[0]\n\n  @test_util.run_deprecated_v1\n  def test_set_intersection_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_multirow_2d(dtype)\n\n  def _test_set_intersection_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1]]\n    expected_indices = [[0, 0], [0, 1]]\n    expected_values = _values([1, 9], dtype)\n    expected_shape = [2, 2]\n    expected_counts = [2, 0]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    intersection = self._set_intersection(a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    intersection = self._set_intersection(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_intersection_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_dense_set_intersection_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_dense_set_intersection_multirow_2d(dtype)\n\n  def _test_dense_set_intersection_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1, 5]]\n    expected_indices = [[0, 0], [0, 1]]\n    expected_values = _values([1, 9], dtype)\n    expected_shape = [2, 2]\n    expected_counts = [2, 0]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype)\n    b = _constant(b_values, dtype)\n    intersection = self._set_intersection(a, b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, b))\n\n  @test_util.run_deprecated_v1\n  def test_set_intersection_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_duplicates_2d(dtype)\n\n  def _test_set_intersection_duplicates_2d(self, dtype):\n    a_values = [[1, 1, 3]]\n    b_values = [[1]]\n    expected_indices = [[0, 0]]\n    expected_values = _values([1], dtype)\n    expected_shape = [1, 1]\n    expected_counts = [1]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype=dtype)\n    b = _constant(b_values, dtype=dtype)\n    intersection = self._set_intersection(a, b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, b))\n\n    # Dense to sparse.\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    intersection = self._set_intersection(a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_intersection_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    intersection = self._set_intersection(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        intersection,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_intersection_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_set_intersection_3d(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_3d(dtype=dtype)\n\n  def test_set_intersection_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_set_intersection_3d(dtype=dtype, invalid_indices=True)\n\n  def _test_set_intersection_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant(\n          [\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    else:\n      indices = constant_op.constant(\n          [\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant(\n            [\n                1,\n                9,  # 0,0\n                3,\n                3,  # 0,1\n                1,  # 1,0\n                9,\n                7,\n                8,  # 1,1\n                # 2,0\n                5  # 2,1\n                # 3,*\n            ],\n            dtype),\n        constant_op.constant([4, 2, 3], dtypes.int64))\n    sp_b = sparse_tensor_lib.SparseTensor(\n        constant_op.constant(\n            [\n                [0, 0, 0],\n                [0, 0, 3],  # 0,0\n                # 0,1\n                [1, 0, 0],  # 1,0\n                [1, 1, 0],\n                [1, 1, 1],  # 1,1\n                [2, 0, 1],  # 2,0\n                [2, 1, 1],  # 2,1\n                [3, 0, 0],  # 3,0\n                [3, 1, 0]  # 3,1\n            ],\n            dtypes.int64),\n        _constant(\n            [\n                1,\n                3,  # 0,0\n                # 0,1\n                3,  # 1,0\n                7,\n                8,  # 1,1\n                2,  # 2,0\n                5,  # 2,1\n                4,  # 3,0\n                4  # 3,1\n            ],\n            dtype),\n        constant_op.constant([4, 2, 4], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_intersection(sp_a, sp_b)\n    else:\n      expected_indices = [\n          [0, 0, 0],  # 0,0\n          # 0,1\n          # 1,0\n          [1, 1, 0],\n          [1, 1, 1],  # 1,1\n          # 2,0\n          [2, 1, 0],  # 2,1\n          # 3,*\n      ]\n      expected_values = _values(\n          [\n              1,  # 0,0\n              # 0,1\n              # 1,0\n              7,\n              8,  # 1,1\n              # 2,0\n              5,  # 2,1\n              # 3,*\n          ],\n          dtype)\n      expected_shape = [4, 2, 2]\n      expected_counts = [\n          [\n              1,  # 0,0\n              0  # 0,1\n          ],\n          [\n              0,  # 1,0\n              2  # 1,1\n          ],\n          [\n              0,  # 2,0\n              1  # 2,1\n          ],\n          [\n              0,  # 3,0\n              0  # 3,1\n          ]\n      ]\n\n      # Sparse to sparse.\n      intersection = self._set_intersection(sp_a, sp_b)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          intersection,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts,\n                          self._set_intersection_count(sp_a, sp_b))\n\n      # NOTE: sparse_to_dense doesn't support uint8 and uint16.\n      if dtype not in [dtypes.uint8, dtypes.uint16]:\n        # Dense to sparse.\n        a = math_ops.cast(\n            sparse_ops.sparse_to_dense(\n                sp_a.indices,\n                sp_a.dense_shape,\n                sp_a.values,\n                default_value=\"-1\" if dtype == dtypes.string else -1),\n            dtype=dtype)\n        intersection = self._set_intersection(a, sp_b)\n        self._assert_set_operation(\n            expected_indices,\n            expected_values,\n            expected_shape,\n            intersection,\n            dtype=dtype)\n        self.assertAllEqual(expected_counts,\n                            self._set_intersection_count(a, sp_b))\n\n        # Dense to dense.\n        b = math_ops.cast(\n            sparse_ops.sparse_to_dense(\n                sp_b.indices,\n                sp_b.dense_shape,\n                sp_b.values,\n                default_value=\"-2\" if dtype == dtypes.string else -2),\n            dtype=dtype)\n        intersection = self._set_intersection(a, b)\n        self._assert_set_operation(\n            expected_indices,\n            expected_values,\n            expected_shape,\n            intersection,\n            dtype=dtype)\n        self.assertAllEqual(expected_counts, self._set_intersection_count(a, b))\n\n  def _assert_static_shapes(self, input_tensor, result_sparse_tensor):\n    if isinstance(input_tensor, sparse_tensor_lib.SparseTensor):\n      sparse_shape_dims = input_tensor.dense_shape.get_shape().dims\n      if sparse_shape_dims is None:\n        expected_rank = None\n      else:\n        expected_rank = sparse_shape_dims[0].value\n    else:\n      expected_rank = input_tensor.get_shape().ndims\n    self.assertAllEqual((None, expected_rank),\n                        result_sparse_tensor.indices.get_shape().as_list())\n    self.assertAllEqual((None,),\n                        result_sparse_tensor.values.get_shape().as_list())\n    self.assertAllEqual((expected_rank,),\n                        result_sparse_tensor.dense_shape.get_shape().as_list())\n\n  def _run_equivalent_set_ops(self, ops):\n    \"\"\"Assert all ops return the same shapes, and return 1st result.\"\"\"\n    # Collect shapes and results for all ops, and assert static shapes match.\n    dynamic_indices_shape_ops = []\n    dynamic_values_shape_ops = []\n    static_indices_shape = None\n    static_values_shape = None\n    with self.cached_session() as sess:\n      for op in ops:\n        if static_indices_shape is None:\n          static_indices_shape = op.indices.get_shape()\n        else:\n          self.assertAllEqual(\n              static_indices_shape.as_list(), op.indices.get_shape().as_list())\n        if static_values_shape is None:\n          static_values_shape = op.values.get_shape()\n        else:\n          self.assertAllEqual(\n              static_values_shape.as_list(), op.values.get_shape().as_list())\n        dynamic_indices_shape_ops.append(array_ops.shape(op.indices))\n        dynamic_values_shape_ops.append(array_ops.shape(op.values))\n      results = sess.run(\n          list(ops) + dynamic_indices_shape_ops + dynamic_values_shape_ops)\n      op_count = len(ops)\n      op_results = results[0:op_count]\n      dynamic_indices_shapes = results[op_count:2 * op_count]\n      dynamic_values_shapes = results[2 * op_count:3 * op_count]\n\n    # Assert static and dynamic tensor shapes, and result shapes, are all\n    # consistent.\n    static_indices_shape.assert_is_compatible_with(dynamic_indices_shapes[0])\n    static_values_shape.assert_is_compatible_with(dynamic_values_shapes[0])\n    self.assertAllEqual(dynamic_indices_shapes[0], op_results[0].indices.shape)\n    self.assertAllEqual(dynamic_values_shapes[0], op_results[0].values.shape)\n\n    # Assert dynamic shapes and values are the same for all ops.\n    for i in range(1, len(ops)):\n      self.assertAllEqual(dynamic_indices_shapes[0], dynamic_indices_shapes[i])\n      self.assertAllEqual(dynamic_values_shapes[0], dynamic_values_shapes[i])\n      self.assertAllEqual(op_results[0].indices, op_results[i].indices)\n      self.assertAllEqual(op_results[0].values, op_results[i].values)\n      self.assertAllEqual(op_results[0].dense_shape, op_results[i].dense_shape)\n\n    return op_results[0]\n\n  def _set_intersection(self, a, b):\n    # Validate that we get the same results with or without `validate_indices`,\n    # and with a & b swapped.\n    ops = (\n        sets.set_intersection(\n            a, b, validate_indices=True),\n        sets.set_intersection(\n            a, b, validate_indices=False),\n        sets.set_intersection(\n            b, a, validate_indices=True),\n        sets.set_intersection(\n            b, a, validate_indices=False),)\n    for op in ops:\n      self._assert_static_shapes(a, op)\n    return self._run_equivalent_set_ops(ops)\n\n  def _set_intersection_count(self, a, b):\n    op = sets.set_size(sets.set_intersection(a, b))\n    with self.cached_session() as sess:\n      return self.evaluate(op)\n\n  @test_util.run_deprecated_v1\n  def test_set_difference_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_difference_multirow_2d(dtype)\n\n  def _test_set_difference_multirow_2d(self, dtype):\n    a_values = [[1, 1, 1], [1, 5, 9], [4, 5, 3], [5, 5, 1]]\n    b_values = [[], [1, 2], [1, 2, 2], []]\n\n    # a - b.\n    expected_indices = [[0, 0], [1, 0], [1, 1], [2, 0], [2, 1], [2, 2], [3, 0],\n                        [3, 1]]\n    expected_values = _values([1, 5, 9, 3, 4, 5, 1, 5], dtype)\n    expected_shape = [4, 3]\n    expected_counts = [1, 2, 3, 2]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    difference = self._set_difference(a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, True))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    difference = self._set_difference(sp_a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, True))\n\n    # b - a.\n    expected_indices = [[1, 0], [2, 0], [2, 1]]\n    expected_values = _values([2, 1, 2], dtype)\n    expected_shape = [4, 2]\n    expected_counts = [0, 1, 2, 0]\n\n    # Dense to sparse.\n    difference = self._set_difference(a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, False))\n\n    # Sparse to sparse.\n    difference = self._set_difference(sp_a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, False))\n\n  @test_util.run_deprecated_v1\n  def test_dense_set_difference_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_dense_set_difference_multirow_2d(dtype)\n\n  def _test_dense_set_difference_multirow_2d(self, dtype):\n    a_values = [[1, 5, 9], [4, 5, 3]]\n    b_values = [[1, 2, 6], [1, 2, 2]]\n\n    # a - b.\n    expected_indices = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]]\n    expected_values = _values([5, 9, 3, 4, 5], dtype)\n    expected_shape = [2, 3]\n    expected_counts = [2, 3]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype=dtype)\n    b = _constant(b_values, dtype=dtype)\n    difference = self._set_difference(a, b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_difference_count(a, b, True))\n\n    # b - a.\n    expected_indices = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    expected_values = _values([2, 6, 1, 2], dtype)\n    expected_shape = [2, 2]\n    expected_counts = [2, 2]\n\n    # Dense to dense.\n    difference = self._set_difference(a, b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, b, False))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_set_difference_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_difference_multirow_2d(dtype)\n\n  def _test_sparse_set_difference_multirow_2d(self, dtype):\n    sp_a = _dense_to_sparse(\n        [[], [1, 5, 9], [4, 5, 3, 3, 4, 5], [5, 1]], dtype=dtype)\n    sp_b = _dense_to_sparse([[], [1, 2], [1, 2, 2], []], dtype=dtype)\n\n    # a - b.\n    expected_indices = [[1, 0], [1, 1], [2, 0], [2, 1], [2, 2], [3, 0], [3, 1]]\n    expected_values = _values([5, 9, 3, 4, 5, 1, 5], dtype)\n    expected_shape = [4, 3]\n    expected_counts = [0, 2, 3, 2]\n\n    difference = self._set_difference(sp_a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, True))\n\n    # b - a.\n    expected_indices = [[1, 0], [2, 0], [2, 1]]\n    expected_values = _values([2, 1, 2], dtype)\n    expected_shape = [4, 2]\n    expected_counts = [0, 1, 2, 0]\n\n    difference = self._set_difference(sp_a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(sp_a, sp_b, False))\n\n  @test_util.run_deprecated_v1\n  def test_set_difference_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_difference_duplicates_2d(dtype)\n\n  def _test_set_difference_duplicates_2d(self, dtype):\n    a_values = [[1, 1, 3]]\n    b_values = [[1, 2, 2]]\n\n    # a - b.\n    expected_indices = [[0, 0]]\n    expected_values = _values([3], dtype)\n    expected_shape = [1, 1]\n    expected_counts = [1]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    difference = self._set_difference(a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, True))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    difference = self._set_difference(sp_a, sp_b, True)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, True))\n\n    # b - a.\n    expected_indices = [[0, 0]]\n    expected_values = _values([2], dtype)\n    expected_shape = [1, 1]\n    expected_counts = [1]\n\n    # Dense to sparse.\n    difference = self._set_difference(a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, False))\n\n    # Sparse to sparse.\n    difference = self._set_difference(sp_a, sp_b, False)\n    self._assert_set_operation(\n        expected_indices,\n        expected_values,\n        expected_shape,\n        difference,\n        dtype=dtype)\n    self.assertAllEqual(expected_counts,\n                        self._set_difference_count(a, sp_b, False))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_set_difference_3d(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_difference_3d(dtype)\n\n  def test_sparse_set_difference_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_difference_3d(dtype, invalid_indices=True)\n\n  def _test_sparse_set_difference_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant(\n          [\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    else:\n      indices = constant_op.constant(\n          [\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant(\n            [\n                1,\n                9,  # 0,0\n                3,\n                3,  # 0,1\n                1,  # 1,0\n                9,\n                7,\n                8,  # 1,1\n                # 2,0\n                5  # 2,1\n                # 3,*\n            ],\n            dtype),\n        constant_op.constant([4, 2, 3], dtypes.int64))\n    sp_b = sparse_tensor_lib.SparseTensor(\n        constant_op.constant(\n            [\n                [0, 0, 0],\n                [0, 0, 3],  # 0,0\n                # 0,1\n                [1, 0, 0],  # 1,0\n                [1, 1, 0],\n                [1, 1, 1],  # 1,1\n                [2, 0, 1],  # 2,0\n                [2, 1, 1],  # 2,1\n                [3, 0, 0],  # 3,0\n                [3, 1, 0]  # 3,1\n            ],\n            dtypes.int64),\n        _constant(\n            [\n                1,\n                3,  # 0,0\n                # 0,1\n                3,  # 1,0\n                7,\n                8,  # 1,1\n                2,  # 2,0\n                5,  # 2,1\n                4,  # 3,0\n                4  # 3,1\n            ],\n            dtype),\n        constant_op.constant([4, 2, 4], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_difference(sp_a, sp_b, False)\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_difference(sp_a, sp_b, True)\n    else:\n      # a-b\n      expected_indices = [\n          [0, 0, 0],  # 0,0\n          [0, 1, 0],  # 0,1\n          [1, 0, 0],  # 1,0\n          [1, 1, 0],  # 1,1\n          # 2,*\n          # 3,*\n      ]\n      expected_values = _values(\n          [\n              9,  # 0,0\n              3,  # 0,1\n              1,  # 1,0\n              9,  # 1,1\n              # 2,*\n              # 3,*\n          ],\n          dtype)\n      expected_shape = [4, 2, 1]\n      expected_counts = [\n          [\n              1,  # 0,0\n              1  # 0,1\n          ],\n          [\n              1,  # 1,0\n              1  # 1,1\n          ],\n          [\n              0,  # 2,0\n              0  # 2,1\n          ],\n          [\n              0,  # 3,0\n              0  # 3,1\n          ]\n      ]\n\n      difference = self._set_difference(sp_a, sp_b, True)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          difference,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts,\n                          self._set_difference_count(sp_a, sp_b))\n\n      # b-a\n      expected_indices = [\n          [0, 0, 0],  # 0,0\n          # 0,1\n          [1, 0, 0],  # 1,0\n          # 1,1\n          [2, 0, 0],  # 2,0\n          # 2,1\n          [3, 0, 0],  # 3,0\n          [3, 1, 0]  # 3,1\n      ]\n      expected_values = _values(\n          [\n              3,  # 0,0\n              # 0,1\n              3,  # 1,0\n              # 1,1\n              2,  # 2,0\n              # 2,1\n              4,  # 3,0\n              4,  # 3,1\n          ],\n          dtype)\n      expected_shape = [4, 2, 1]\n      expected_counts = [\n          [\n              1,  # 0,0\n              0  # 0,1\n          ],\n          [\n              1,  # 1,0\n              0  # 1,1\n          ],\n          [\n              1,  # 2,0\n              0  # 2,1\n          ],\n          [\n              1,  # 3,0\n              1  # 3,1\n          ]\n      ]\n\n      difference = self._set_difference(sp_a, sp_b, False)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          difference,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts,\n                          self._set_difference_count(sp_a, sp_b, False))\n\n  def _set_difference(self, a, b, aminusb=True):\n    # Validate that we get the same results with or without `validate_indices`,\n    # and with a & b swapped.\n    ops = (\n        sets.set_difference(\n            a, b, aminusb=aminusb, validate_indices=True),\n        sets.set_difference(\n            a, b, aminusb=aminusb, validate_indices=False),\n        sets.set_difference(\n            b, a, aminusb=not aminusb, validate_indices=True),\n        sets.set_difference(\n            b, a, aminusb=not aminusb, validate_indices=False),)\n    for op in ops:\n      self._assert_static_shapes(a, op)\n    return self._run_equivalent_set_ops(ops)\n\n  def _set_difference_count(self, a, b, aminusb=True):\n    op = sets.set_size(sets.set_difference(a, b, aminusb))\n    with self.cached_session() as sess:\n      return self.evaluate(op)\n\n  @test_util.run_deprecated_v1\n  def test_set_union_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_union_multirow_2d(dtype)\n\n  def _test_set_union_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1]]\n    expected_indices = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [1, 3]]\n    expected_values = _values([1, 5, 9, 1, 2, 3, 4], dtype)\n    expected_shape = [2, 4]\n    expected_counts = [3, 4]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    union = self._set_union(a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_union_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    union = self._set_union(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_union_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_dense_set_union_multirow_2d(self):\n    for dtype in _DTYPES:\n      self._test_dense_set_union_multirow_2d(dtype)\n\n  def _test_dense_set_union_multirow_2d(self, dtype):\n    a_values = [[9, 1, 5], [2, 4, 3]]\n    b_values = [[1, 9], [1, 2]]\n    expected_indices = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [1, 3]]\n    expected_values = _values([1, 5, 9, 1, 2, 3, 4], dtype)\n    expected_shape = [2, 4]\n    expected_counts = [3, 4]\n\n    # Dense to dense.\n    a = _constant(a_values, dtype=dtype)\n    b = _constant(b_values, dtype=dtype)\n    union = self._set_union(a, b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual(expected_counts, self._set_union_count(a, b))\n\n  @test_util.run_deprecated_v1\n  def test_set_union_duplicates_2d(self):\n    for dtype in _DTYPES:\n      self._test_set_union_duplicates_2d(dtype)\n\n  def _test_set_union_duplicates_2d(self, dtype):\n    a_values = [[1, 1, 3]]\n    b_values = [[1]]\n    expected_indices = [[0, 0], [0, 1]]\n    expected_values = _values([1, 3], dtype)\n    expected_shape = [1, 2]\n\n    # Dense to sparse.\n    a = _constant(a_values, dtype=dtype)\n    sp_b = _dense_to_sparse(b_values, dtype=dtype)\n    union = self._set_union(a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual([2], self._set_union_count(a, sp_b))\n\n    # Sparse to sparse.\n    sp_a = _dense_to_sparse(a_values, dtype=dtype)\n    union = self._set_union(sp_a, sp_b)\n    self._assert_set_operation(\n        expected_indices, expected_values, expected_shape, union, dtype=dtype)\n    self.assertAllEqual([2], self._set_union_count(sp_a, sp_b))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_set_union_3d(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_union_3d(dtype)\n\n  def test_sparse_set_union_3d_invalid_indices(self):\n    for dtype in _DTYPES:\n      self._test_sparse_set_union_3d(dtype, invalid_indices=True)\n\n  def _test_sparse_set_union_3d(self, dtype, invalid_indices=False):\n    if invalid_indices:\n      indices = constant_op.constant(\n          [\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    else:\n      indices = constant_op.constant(\n          [\n              [0, 0, 0],\n              [0, 0, 2],  # 0,0\n              [0, 1, 0],\n              [0, 1, 1],  # 0,1\n              [1, 0, 0],  # 1,0\n              [1, 1, 0],\n              [1, 1, 1],\n              [1, 1, 2],  # 1,1\n              # 2,0\n              [2, 1, 1]  # 2,1\n              # 3,*\n          ],\n          dtypes.int64)\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices,\n        _constant(\n            [\n                1,\n                9,  # 0,0\n                3,\n                3,  # 0,1\n                1,  # 1,0\n                9,\n                7,\n                8,  # 1,1\n                # 2,0\n                5  # 2,1\n                # 3,*\n            ],\n            dtype),\n        constant_op.constant([4, 2, 3], dtypes.int64))\n    sp_b = sparse_tensor_lib.SparseTensor(\n        constant_op.constant(\n            [\n                [0, 0, 0],\n                [0, 0, 3],  # 0,0\n                # 0,1\n                [1, 0, 0],  # 1,0\n                [1, 1, 0],\n                [1, 1, 1],  # 1,1\n                [2, 0, 1],  # 2,0\n                [2, 1, 1],  # 2,1\n                [3, 0, 0],  # 3,0\n                [3, 1, 0]  # 3,1\n            ],\n            dtypes.int64),\n        _constant(\n            [\n                1,\n                3,  # 0,0\n                # 0,1\n                3,  # 1,0\n                7,\n                8,  # 1,1\n                2,  # 2,0\n                5,  # 2,1\n                4,  # 3,0\n                4  # 3,1\n            ],\n            dtype),\n        constant_op.constant([4, 2, 4], dtypes.int64))\n\n    if invalid_indices:\n      with self.assertRaisesRegex(errors_impl.OpError, \"out of order\"):\n        self._set_union(sp_a, sp_b)\n    else:\n      expected_indices = [\n          [0, 0, 0],\n          [0, 0, 1],\n          [0, 0, 2],  # 0,0\n          [0, 1, 0],  # 0,1\n          [1, 0, 0],\n          [1, 0, 1],  # 1,0\n          [1, 1, 0],\n          [1, 1, 1],\n          [1, 1, 2],  # 1,1\n          [2, 0, 0],  # 2,0\n          [2, 1, 0],  # 2,1\n          [3, 0, 0],  # 3,0\n          [3, 1, 0],  # 3,1\n      ]\n      expected_values = _values(\n          [\n              1,\n              3,\n              9,  # 0,0\n              3,  # 0,1\n              1,\n              3,  # 1,0\n              7,\n              8,\n              9,  # 1,1\n              2,  # 2,0\n              5,  # 2,1\n              4,  # 3,0\n              4,  # 3,1\n          ],\n          dtype)\n      expected_shape = [4, 2, 3]\n      expected_counts = [\n          [\n              3,  # 0,0\n              1  # 0,1\n          ],\n          [\n              2,  # 1,0\n              3  # 1,1\n          ],\n          [\n              1,  # 2,0\n              1  # 2,1\n          ],\n          [\n              1,  # 3,0\n              1  # 3,1\n          ]\n      ]\n\n      intersection = self._set_union(sp_a, sp_b)\n      self._assert_set_operation(\n          expected_indices,\n          expected_values,\n          expected_shape,\n          intersection,\n          dtype=dtype)\n      self.assertAllEqual(expected_counts, self._set_union_count(sp_a, sp_b))\n\n  def _set_union(self, a, b):\n    # Validate that we get the same results with or without `validate_indices`,\n    # and with a & b swapped.\n    ops = (\n        sets.set_union(\n            a, b, validate_indices=True),\n        sets.set_union(\n            a, b, validate_indices=False),\n        sets.set_union(\n            b, a, validate_indices=True),\n        sets.set_union(\n            b, a, validate_indices=False),)\n    for op in ops:\n      self._assert_static_shapes(a, op)\n    return self._run_equivalent_set_ops(ops)\n\n  def _set_union_count(self, a, b):\n    op = sets.set_size(sets.set_union(a, b))\n    with self.cached_session() as sess:\n      return self.evaluate(op)\n\n  def _assert_set_operation(self, expected_indices, expected_values,\n                            expected_shape, sparse_tensor_value, dtype):\n    self.assertAllEqual(expected_indices, sparse_tensor_value.indices)\n    self.assertAllEqual(len(expected_indices), len(expected_values))\n    self.assertAllEqual(len(expected_values), len(sparse_tensor_value.values))\n    expected_set = set()\n    actual_set = set()\n    last_indices = None\n    for indices, expected_value, actual_value in zip(\n        expected_indices, expected_values, sparse_tensor_value.values):\n      if dtype == dtypes.string:\n        actual_value = actual_value.decode(\"utf-8\")\n      if last_indices and (last_indices[:-1] != indices[:-1]):\n        self.assertEqual(\n            expected_set, actual_set,\n            \"Expected %s, got %s, at %s.\" % (expected_set, actual_set, indices))\n        expected_set.clear()\n        actual_set.clear()\n      expected_set.add(expected_value)\n      actual_set.add(actual_value)\n      last_indices = indices\n    self.assertEqual(\n        expected_set, actual_set, \"Expected %s, got %s, at %s.\" %\n        (expected_set, actual_set, last_indices))\n    self.assertAllEqual(expected_shape, sparse_tensor_value.dense_shape)\n\n  @parameterized.parameters(*_DTYPES)\n  def test_set_union_output_is_sorted(self, dtype):\n    # We don't use any numbers >= 10 so that lexicographical order agrees with\n    # numeric order in this test, for the type dtype == tf.string.\n\n    # [3 7 5 3 1]\n    # [2 6 5 4]\n    # []\n    # [9 8]\n    sp_a = sparse_tensor_lib.SparseTensor(\n        indices=constant_op.constant(\n            [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1], [1, 2],\n             [1, 3], [3, 0], [3, 1]],\n            dtype=dtypes.int64),\n        values=_constant([3, 7, 5, 3, 1, 2, 6, 5, 4, 9, 8], dtype),\n        dense_shape=constant_op.constant([4, 5], dtype=dtypes.int64))\n\n    # [9 7]\n    # [5 2 0]\n    # [6]\n    # []\n    sp_b = sparse_tensor_lib.SparseTensor(\n        indices=constant_op.constant(\n            [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2], [2, 0]],\n            dtype=dtypes.int64),\n        values=_constant([9, 7, 5, 2, 0, 6], dtype),\n        dense_shape=constant_op.constant([4, 3], dtype=dtypes.int64))\n    # The union should be\n    # [1 3 5 7 9]\n    # [0 2 4 5 6]\n    # [6]\n    # [8 9]\n    result = sets.set_union(sp_a, sp_b)\n    self.assertAllEqual(result.dense_shape, [4, 5])\n    self.assertAllEqual(result.indices,\n                        [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1],\n                         [1, 2], [1, 3], [1, 4], [2, 0], [3, 0], [3, 1]])\n    self.assertAllEqual(\n        result.values,\n        _constant([1, 3, 5, 7, 9, 0, 2, 4, 5, 6, 6, 8, 9], dtype))\n\n\nif __name__ == \"__main__\":\n  googletest.main()"