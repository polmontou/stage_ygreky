"# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for sparse_cross_op.\"\"\"\n\nimport numpy\n\nfrom tensorflow.python.client import session\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_sparse_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import test\n\n\nclass BaseSparseCrossOpTest(test.TestCase):\n\n  def _sparse_tensor(self, data, batch_size=-1):\n    \"\"\"Generates a SparseTensor.\n\n    Args:\n      data: Should be a list of list of strings or int64. Each item of the outer\n        list represents a batch. Each item of the batch is a feature of a\n        specific feature column.\n      batch_size: optional batch size, especially for cases when data has no\n        entry for some batches.\n\n    Returns:\n     A SparseTensor.\n    \"\"\"\n    indices = []\n    values = []\n    max_col_count = 0\n    for batch, batch_ix in zip(data, range(len(data))):\n      for column, column_ix in zip(batch, range(len(batch))):\n        indices.append([batch_ix, column_ix])\n        values.append(column)\n        max_col_count = max(max_col_count, column_ix + 1)\n    shape = [batch_size if batch_size != -1 else len(data), max_col_count]\n    value_type = (\n        dtypes.string\n        if not values or isinstance(values[0], str) else dtypes.int64)\n    return sparse_tensor.SparseTensor(\n        constant_op.constant(indices, dtypes.int64, [len(indices), 2]),\n        constant_op.constant(values, value_type, [len(indices)]),\n        constant_op.constant(shape, dtypes.int64))\n\n  def _assert_sparse_tensor_equals(self, sp1, sp2):\n    self.assertAllEqual(sp1.indices, sp2.indices)\n    self.assertAllEqual(sp1.values, sp2.values)\n    self.assertAllEqual(sp1.dense_shape, sp2.dense_shape)\n\n  def _assert_sparse_tensor_empty(self, sp):\n    self.assertEqual(0, sp.indices.size)\n    self.assertEqual(0, sp.values.size)\n    # TODO(zakaria): check if we can ignore the first dim of the shape.\n    self.assertEqual(0, sp.dense_shape[1])\n\n\nclass SparseCrossOpTest(test.TestCase):\n\n  @test_util.run_deprecated_v1\n  def test_simple(self):\n    \"\"\"Tests a simple scenario.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1'],\n                             ['batch2-FC1-F1', 'batch2-FC1-F2']]),\n        self._sparse_tensor([['batch1-FC2-F1'],\n                             ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    ])\n    expected_out = self._sparse_tensor([['batch1-FC1-F1_X_batch1-FC2-F1'], [\n        'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n        'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_dense(self):\n    \"\"\"Tests only dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        constant_op.constant([['batch1-FC1-F1', 'batch1-FC1-F2'],\n                              ['batch2-FC1-F1', 'batch2-FC1-F2']],\n                             dtypes.string),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1', 'batch1-FC1-F2_X_batch1-FC2-F2'\n    ], [\n        'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n        'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_sparse(self):\n    \"\"\"Tests mixed type.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([[11], [333, 55555]]),\n        self._sparse_tensor([['batch1-FC2-F1'],\n                             ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    ])\n    expected_out = self._sparse_tensor([['11_X_batch1-FC2-F1'], [\n        '333_X_batch2-FC2-F1', '333_X_batch2-FC2-F2', '55555_X_batch2-FC2-F1',\n        '55555_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_dense(self):\n    \"\"\"Tests mixed dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        constant_op.constant([[11, 333], [55555, 999999]], dtypes.int64),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor([[\n        '11_X_batch1-FC2-F1', '11_X_batch1-FC2-F2', '333_X_batch1-FC2-F1',\n        '333_X_batch1-FC2-F2'\n    ], [\n        '55555_X_batch2-FC2-F1', '55555_X_batch2-FC2-F2',\n        '999999_X_batch2-FC2-F1', '999999_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_cross_dense(self):\n    \"\"\"Tests sparse and dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1'],\n                             ['batch2-FC1-F1', 'batch2-FC1-F2']]),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor(\n        [['batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2'], [\n            'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n            'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n        ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_integer_sparse_input(self):\n    \"\"\"Tests mixed type sparse and dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([[11], [333, 5555]]),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor(\n        [['11_X_batch1-FC2-F1', '11_X_batch1-FC2-F2'], [\n            '333_X_batch2-FC2-F1', '333_X_batch2-FC2-F2',\n            '5555_X_batch2-FC2-F1', '5555_X_batch2-FC2-F2'\n        ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x3x3(self):\n    \"\"\"Tests 3x3x3 permutation.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor(\n            [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']]),\n        self._sparse_tensor(\n            [['batch1-FC2-F1', 'batch1-FC2-F2', 'batch1-FC2-F3']]),\n        self._sparse_tensor(\n            [['batch1-FC3-F1', 'batch1-FC3-F2', 'batch1-FC3-F3']])\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F3'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor(\n            [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']]),\n        self._sparse_tensor([['batch1-FC2-F1']]),\n        self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_large_batch(self):\n    \"\"\"Tests with large batch size to force multithreading.\"\"\"\n    batch_size = 5000\n    col1 = []\n    col2 = []\n    col3 = []\n    for b in range(batch_size):\n      col1.append(\n          ['batch%d-FC1-F1' % b, 'batch%d-FC1-F2' % b, 'batch%d-FC1-F3' % b])\n      col2.append(['batch%d-FC2-F1' % b])\n      col3.append(['batch%d-FC3-F1' % b, 'batch%d-FC3-F2' % b])\n\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor(col1),\n        self._sparse_tensor(col2),\n        self._sparse_tensor(col3)\n    ])\n\n    col_out = []\n    for b in range(batch_size):\n      col_out.append([\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b)\n      ])\n\n    expected_out = self._sparse_tensor(col_out)\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_one_column_empty(self):\n    \"\"\"Tests when one column is empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']]),\n        self._sparse_tensor([], 1),\n        self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    ])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_empty(self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_some_columns_empty(self):\n    \"\"\"Tests when more than one columns are empty.\n\n    Cross for the corresponding batch should be empty.\n    \"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']], 2),\n        self._sparse_tensor([['batch1-FC2-F1'], ['batch2-FC2-F1']], 2),\n        self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']], 2)\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]], 2)\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_all_columns_empty(self):\n    \"\"\"Tests when all columns are empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([]),\n        self._sparse_tensor([]),\n        self._sparse_tensor([])\n    ])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_empty(self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_zero_bucket_no_hash_key(self):\n    op = sparse_ops.sparse_cross_hashed([\n        self._sparse_tensor([['batch1-FC1-F1']]),\n        self._sparse_tensor([['batch1-FC2-F1']]),\n        self._sparse_tensor([['batch1-FC3-F1']])\n    ])\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[1971693436396284976]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_zero_bucket(self):\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor([['batch1-FC1-F1']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1']])\n        ],\n        hash_key=sparse_ops._DEFAULT_HASH_KEY + 1)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[4847552627144134031]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  # TODO(sibyl-Aix6ihai): Add benchmark to compare Hashed vs Non-hashed.\n  @test_util.run_deprecated_v1\n  def test_hashed_no_hash_key(self):\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor([['batch1-FC1-F1']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1']])\n        ],\n        num_buckets=100)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[83]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_output(self):\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor([['batch1-FC1-F1']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1']])\n        ],\n        num_buckets=100,\n        hash_key=sparse_ops._DEFAULT_HASH_KEY + 1)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[31]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed__has_no_collision(self):\n    \"\"\"Tests that fingerprint concatenation has no collisions.\"\"\"\n    # Although the last 10 bits of 359 and 1024+359 are identical.\n    # As a result, all the crosses shouldn't collide.\n    t1 = constant_op.constant([[359], [359 + 1024]])\n    t2 = constant_op.constant([list(range(10)), list(range(10))])\n    cross = sparse_ops.sparse_cross_hashed(\n        [t2, t1], num_buckets=1024, hash_key=sparse_ops._DEFAULT_HASH_KEY + 1)\n    cross_dense = sparse_ops.sparse_tensor_to_dense(cross)\n    with session.Session():\n      values = self.evaluate(cross_dense)\n      self.assertTrue(numpy.not_equal(values[0], values[1]).all())\n\n  def test_hashed_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation with hashed output.\"\"\"\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor(\n                [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n        ],\n        num_buckets=1000)\n    with self.cached_session() as sess:\n      out = self.evaluate(op)\n      self.assertEqual(6, len(out.values))\n      self.assertAllEqual([[0, i] for i in range(6)], out.indices)\n      self.assertTrue(all(x < 1000 and x >= 0 for x in out.values))\n      all_values_are_different = len(out.values) == len(set(out.values))\n      self.assertTrue(all_values_are_different)\n\n  def _assert_sparse_tensor_empty(self, sp):\n    self.assertEqual(0, sp.indices.size)\n    self.assertEqual(0, sp.values.size)\n    # TODO(zakaria): check if we can ignore the first dim of the shape.\n    self.assertEqual(0, sp.dense_shape[1])\n\n  def _assert_sparse_tensor_equals(self, sp1, sp2):\n    self.assertAllEqual(sp1.indices, sp2.indices)\n    self.assertAllEqual(sp1.values, sp2.values)\n    self.assertAllEqual(sp1.dense_shape, sp2.dense_shape)\n\n  def _sparse_tensor(self, data, batch_size=-1):\n    \"\"\"Generates a SparseTensor.\n\n    Args:\n      data: Should be a list of list of strings or int64. Each item of the outer\n          list represents a batch. Each item of the batch is a feature of a\n          specific feature column.\n      batch_size: optional batch size, especially for cases when data has no\n          entry for some batches.\n\n    Returns:\n     A SparseTensor.\n    \"\"\"\n    indices = []\n    values = []\n    max_col_count = 0\n    for batch, batch_ix in zip(data, range(len(data))):\n      for column, column_ix in zip(batch, range(len(batch))):\n        indices.append([batch_ix, column_ix])\n        values.append(column)\n        max_col_count = max(max_col_count, column_ix + 1)\n    shape = [batch_size if batch_size != -1 else len(data), max_col_count]\n    value_type = (dtypes.string if not values or isinstance(values[0], str) else\n                  dtypes.int64)\n    return sparse_tensor.SparseTensor(\n        constant_op.constant(indices, dtypes.int64, [len(indices), 2]),\n        constant_op.constant(values, value_type, [len(indices)]),\n        constant_op.constant(shape, dtypes.int64))\n\n  def test_invalid_sparse_tensors(self):\n    # Test validation of invalid SparseTensors.  The SparseTensor constructor\n    # prevents us from creating invalid SparseTensors (eps. in eager mode),\n    # so we create valid SparseTensors and then modify them to be invalid.\n\n    st1 = sparse_tensor.SparseTensor([[0, 0]], [0], [2, 2])\n    st1._indices = array_ops.zeros([], dtypes.int64)\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Input indices should be a matrix'):\n      self.evaluate(sparse_ops.sparse_cross([st1]))\n\n    st2 = sparse_tensor.SparseTensor([[0, 0]], [0], [2, 2])\n    st2._values = array_ops.zeros([], dtypes.int64)\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Input values should be a vector'):\n      self.evaluate(sparse_ops.sparse_cross([st2]))\n\n    st3 = sparse_tensor.SparseTensor([[0, 0]], [0], [2, 2])\n    st3._dense_shape = array_ops.zeros([], dtypes.int64)\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Input shapes should be a vector'):\n      self.evaluate(sparse_ops.sparse_cross([st3]))\n\n  def test_bad_tensor_shapes(self):\n    # All inputs must be 2D.\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Expected D2 of index to be 2'):\n      st = sparse_tensor.SparseTensor([[0]], [0], [10])  # 1D SparseTensor\n      self.evaluate(sparse_ops.sparse_cross([st]))\n\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Dense inputs should be a matrix'):\n      dt = array_ops.zeros([0])  # 1D DenseTensor.\n      self.evaluate(sparse_ops.sparse_cross([dt]))\n\n  def test_batch_size_mismatch(self):\n    st1 = sparse_tensor.SparseTensor([[0, 0]], [0], [10, 10])  # batch size 10\n    st2 = sparse_tensor.SparseTensor([[0, 0]], [0], [7, 10])  # batch size 7\n    dt = array_ops.zeros([5, 0])  # batch size 5\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Expected batch size'):\n      self.evaluate(sparse_ops.sparse_cross([st1, dt]))\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Expected batch size'):\n      self.evaluate(sparse_ops.sparse_cross([st1, st2]))\n\n\nclass SparseCrossV2OpTest(BaseSparseCrossOpTest):\n\n  @test_util.run_deprecated_v1\n  def test_sparse(self):\n    \"\"\"Tests a simple scenario.\"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1'],\n                                    ['batch2-FC1-F1', 'batch2-FC1-F2']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],\n                                    ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices],\n        values=[sp_inp_1.values, sp_inp_2.values],\n        shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_X_batch1-FC2-F1'],\n        ['batch2-FC1-F1_X_batch2-FC2-F1',\n         'batch2-FC1-F1_X_batch2-FC2-F2',\n         'batch2-FC1-F2_X_batch2-FC2-F1',\n         'batch2-FC1-F2_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_sep(self):\n    \"\"\"Tests a simple scenario.\"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1'],\n                                    ['batch2-FC1-F1', 'batch2-FC1-F2']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],\n                                    ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices],\n        values=[sp_inp_1.values, sp_inp_2.values],\n        shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],\n        dense_inputs=[],\n        sep='_Y_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_Y_batch1-FC2-F1'],\n        ['batch2-FC1-F1_Y_batch2-FC2-F1',\n         'batch2-FC1-F1_Y_batch2-FC2-F2',\n         'batch2-FC1-F2_Y_batch2-FC2-F1',\n         'batch2-FC1-F2_Y_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_dense(self):\n    \"\"\"Tests only dense inputs.\"\"\"\n    dense_inp_1 = constant_op.constant([['batch1-FC1-F1', 'batch1-FC1-F2'],\n                                        ['batch2-FC1-F1', 'batch2-FC1-F2']],\n                                       dtypes.string)\n    dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                        ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                       dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[dense_inp_1, dense_inp_2],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2',\n         'batch1-FC1-F2_X_batch1-FC2-F1', 'batch1-FC1-F2_X_batch1-FC2-F2'\n        ],\n        ['batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n         'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_dense_sep(self):\n    \"\"\"Tests only dense inputs.\"\"\"\n    dense_inp_1 = constant_op.constant([['batch1-FC1-F1', 'batch1-FC1-F2'],\n                                        ['batch2-FC1-F1', 'batch2-FC1-F2']],\n                                       dtypes.string)\n    dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                        ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                       dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[dense_inp_1, dense_inp_2],\n        sep='_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_batch1-FC2-F1', 'batch1-FC1-F1_batch1-FC2-F2',\n         'batch1-FC1-F2_batch1-FC2-F1', 'batch1-FC1-F2_batch1-FC2-F2'\n        ],\n        ['batch2-FC1-F1_batch2-FC2-F1', 'batch2-FC1-F1_batch2-FC2-F2',\n         'batch2-FC1-F2_batch2-FC2-F1', 'batch2-FC1-F2_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_sparse(self):\n    \"\"\"Tests mixed type.\"\"\"\n    sp_inp_1 = self._sparse_tensor([[11], [333, 55555]])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],\n                                    ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices],\n        values=[sp_inp_1.values, sp_inp_2.values],\n        shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['11_X_batch1-FC2-F1'],\n        ['333_X_batch2-FC2-F1', '333_X_batch2-FC2-F2',\n         '55555_X_batch2-FC2-F1', '55555_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_dense(self):\n    \"\"\"Tests mixed dense inputs.\"\"\"\n    dense_inp_1 = constant_op.constant([[11, 333], [55555, 999999]],\n                                       dtypes.int64)\n    dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                        ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                       dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[dense_inp_1, dense_inp_2],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['11_X_batch1-FC2-F1', '11_X_batch1-FC2-F2',\n         '333_X_batch1-FC2-F1', '333_X_batch1-FC2-F2'\n        ],\n        ['55555_X_batch2-FC2-F1', '55555_X_batch2-FC2-F2',\n         '999999_X_batch2-FC2-F1', '999999_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_cross_dense(self):\n    \"\"\"Tests sparse and dense inputs.\"\"\"\n    sp_inp = self._sparse_tensor([['batch1-FC1-F1'],\n                                  ['batch2-FC1-F1', 'batch2-FC1-F2']])\n    dense_inp = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                      ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                     dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp.indices],\n        values=[sp_inp.values],\n        shapes=[sp_inp.dense_shape],\n        dense_inputs=[dense_inp],\n        sep='_X_')\n    expected_out = self._sparse_tensor(\n        [['batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2'],\n         [\n             'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n             'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n         ]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x3x3(self):\n    \"\"\"Tests 3x3x3 permutation.\"\"\"\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor(\n        [['batch1-FC2-F1', 'batch1-FC2-F2', 'batch1-FC2-F3']])\n    sp_inp_3 = self._sparse_tensor(\n        [['batch1-FC3-F1', 'batch1-FC3-F2', 'batch1-FC3-F3']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F3'\n    ]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation.\"\"\"\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_large_batch(self):\n    \"\"\"Tests with large batch size to force multithreading.\"\"\"\n    batch_size = 5000\n    col1 = []\n    col2 = []\n    col3 = []\n    for b in range(batch_size):\n      col1.append(\n          ['batch%d-FC1-F1' % b,\n           'batch%d-FC1-F2' % b,\n           'batch%d-FC1-F3' % b])\n      col2.append(['batch%d-FC2-F1' % b])\n      col3.append(['batch%d-FC3-F1' % b, 'batch%d-FC3-F2' % b])\n    sp_inp_1 = self._sparse_tensor(col1)\n    sp_inp_2 = self._sparse_tensor(col2)\n    sp_inp_3 = self._sparse_tensor(col3)\n\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n\n    col_out = []\n    for b in range(batch_size):\n      col_out.append([\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b)\n      ])\n\n    expected_out = self._sparse_tensor(col_out)\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_one_column_empty(self):\n    \"\"\"Tests when one column is empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']])\n    sp_inp_2 = self._sparse_tensor([], 1)\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_empty(self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_some_columns_empty(self):\n    \"\"\"Tests when more than one columns are empty.\n\n    Cross for the corresponding batch should be empty.\n    \"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']], 2)\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'], ['batch2-FC2-F1']], 2)\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']], 2)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]], 2)\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_all_columns_empty(self):\n    \"\"\"Tests when all columns are empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    sp_inp_1 = self._sparse_tensor([])\n    sp_inp_2 = self._sparse_tensor([])\n    sp_inp_3 = self._sparse_tensor([])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_empty(self.evaluate(out))\n\n\nclass SparseCrossHashedOpTest(BaseSparseCrossOpTest):\n\n  @test_util.run_deprecated_v1\n  def test_hashed_zero_bucket_no_hash_key(self):\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=0,\n        salt=[1, 1],\n        strong_hash=False)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[9186962005966787372]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n    # salt is not being used when `strong_hash` is False.\n    inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=0,\n        salt=[137, 173],\n        strong_hash=False)\n    out_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out_2))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_output(self):\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=100,\n        salt=[137, 173],\n        strong_hash=False)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[79]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_has_no_collision(self):\n    \"\"\"Tests that fingerprint concatenation has no collisions.\"\"\"\n    # Although the last 10 bits of 359 and 1024+359 are identical.\n    # As a result, all the crosses shouldn't collide.\n    t1 = constant_op.constant([[359], [359 + 1024]], dtype=dtypes.int64)\n    t2 = constant_op.constant(\n        [list(range(10)), list(range(10))], dtype=dtypes.int64)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[t2, t1],\n        num_buckets=1024,\n        salt=[137, 173],\n        strong_hash=False)\n    cross = sparse_tensor.SparseTensor(inds, vals, shapes)\n    cross_dense = sparse_ops.sparse_tensor_to_dense(cross)\n    with session.Session():\n      values = self.evaluate(cross_dense)\n      self.assertTrue(numpy.not_equal(values[0], values[1]).all())\n\n  def test_hashed_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation with hashed output.\"\"\"\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=1000,\n        salt=[137, 173],\n        strong_hash=False)\n    output = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      out = self.evaluate(output)\n      self.assertEqual(6, len(out.values))\n      self.assertAllEqual([[0, i] for i in range(6)], out.indices)\n      self.assertTrue(all(x < 1000 and x >= 0 for x in out.values))\n      all_values_are_different = len(out.values) == len(set(out.values))\n      self.assertTrue(all_values_are_different)\n\n  def test_hashed_different_salt(self):\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=False,\n        num_buckets=1000,\n        salt=[137, 173])\n    output = sparse_tensor.SparseTensor(inds, vals, shapes)\n    inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=True,\n        num_buckets=1000,\n        salt=[137, 1])\n    output_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)\n    with self.cached_session():\n      out = self.evaluate(output)\n      out_2 = self.evaluate(output_2)\n      self.assertAllEqual(out.indices, out_2.indices)\n      self.assertNotAllEqual(out.values, out_2.values)\n\n  def test_sep_ignored_in_hashed_out(self):\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=True,\n        num_buckets=1000,\n        salt=[137, 173])\n    output = sparse_tensor.SparseTensor(inds, vals, shapes)\n    inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=True,\n        num_buckets=1000,\n        salt=[137, 173])\n    output_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)\n    with self.cached_session():\n      out = self.evaluate(output)\n      out_2 = self.evaluate(output_2)\n      self.assertAllEqual(out.indices, out_2.indices)\n      self.assertAllEqual(out.values, out_2.values)\n\n\nif __name__ == '__main__':\n  test.main()"