"# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for tensorflow.ops.random_ops.random_gamma.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import random_seed\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.kernel_tests.random import util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import random_ops\nfrom tensorflow.python.platform import test\nfrom tensorflow.python.platform import tf_logging\n\n\nclass RandomGammaTest(test.TestCase):\n  \"\"\"This is a medium test due to the moments computation taking some time.\"\"\"\n\n  def setUp(self):\n    np.random.seed(137)\n    random_seed.set_random_seed(137)\n\n  def _Sampler(self, num, alpha, beta, dtype, use_gpu=True, seed=None):\n\n    def func():\n      with self.session(use_gpu=use_gpu, graph=ops.Graph()) as sess:\n        rng = random_ops.random_gamma(\n            [num], alpha, beta=beta, dtype=dtype, seed=seed)\n        ret = np.empty([10, num])\n        for i in range(10):\n          ret[i, :] = self.evaluate(rng)\n      return ret\n\n    return func\n\n  def testNpDtypes(self):\n    self.evaluate(random_ops.random_gamma(\n        [5], alpha=np.ones([2, 1, 3]), beta=np.ones([3]), dtype=np.float32))\n\n  def testEmptySamplingNoError(self):\n    self.evaluate(random_ops.random_gamma(\n        [5], alpha=np.ones([2, 0, 3]), beta=np.ones([3]), dtype=dtypes.float32))\n\n  @test_util.run_deprecated_v1\n  def testMomentsFloat32(self):\n    self._testMoments(dtypes.float32)\n\n  @test_util.run_deprecated_v1\n  def testMomentsFloat64(self):\n    self._testMoments(dtypes.float64)\n\n  def _testMoments(self, dt):\n    try:\n      from scipy import stats  # pylint: disable=g-import-not-at-top\n    except ImportError as e:\n      tf_logging.warn(\"Cannot test moments: %s\" % e)\n      return\n\n    # The moments test is a z-value test.  This is the largest z-value\n    # we want to tolerate. Since the z-test approximates a unit normal\n    # distribution, it should almost definitely never exceed 6.\n    z_limit = 6.0\n\n    for stride in 0, 1, 4, 17:\n      alphas = [0.2, 1.0, 3.0]\n      if dt == dtypes.float64:\n        alphas = [0.01] + alphas\n      for alpha in alphas:\n        for scale in 9, 17:\n          # Gamma moments only defined for values less than the scale param.\n          max_moment = min(6, scale // 2)\n          sampler = self._Sampler(20000, alpha, 1 / scale, dt, seed=12345)\n          z_scores = util.test_moment_matching(\n              sampler(),\n              max_moment,\n              stats.gamma(alpha, scale=scale),\n              stride=stride,\n          )\n          self.assertAllLess(z_scores, z_limit)\n\n  def _testZeroDensity(self, alpha):\n    \"\"\"Zero isn't in the support of the gamma distribution.\n\n    But quantized floating point math has its limits.\n    TODO(bjp): Implement log-gamma sampler for small-shape distributions.\n\n    Args:\n      alpha: float shape value to test\n    \"\"\"\n    try:\n      from scipy import stats  # pylint: disable=g-import-not-at-top\n    except ImportError as e:\n      tf_logging.warn(\"Cannot test zero density proportions: %s\" % e)\n      return\n    allowable_zeros = {\n        dtypes.float16: stats.gamma(alpha).cdf(np.finfo(np.float16).tiny),\n        dtypes.float32: stats.gamma(alpha).cdf(np.finfo(np.float32).tiny),\n        dtypes.float64: stats.gamma(alpha).cdf(np.finfo(np.float64).tiny)\n    }\n    failures = []\n    for dt in dtypes.float16, dtypes.float32, dtypes.float64:\n      sampler = self._Sampler(10000, alpha, 1.0, dt, seed=12345)\n      x = sampler()\n      allowable = allowable_zeros[dt] * x.size\n      allowable = allowable * 2 if allowable < 10 else allowable * 1.05\n      if np.sum(x <= 0) > allowable:\n        failures += [dt]\n    self.assertEqual([], failures)\n\n  def testNonZeroSmallShape(self):\n    self._testZeroDensity(0.01)\n\n  def testNonZeroSmallishShape(self):\n    self._testZeroDensity(0.35)\n\n  # Asserts that different trials (1000 samples per trial) is unlikely\n  # to see the same sequence of values. Will catch buggy\n  # implementations which uses the same random number seed.\n  def testDistinct(self):\n    for dt in dtypes.float16, dtypes.float32, dtypes.float64:\n      sampler = self._Sampler(1000, 2.0, 1.0, dt)\n      x = sampler()\n      y = sampler()\n      # Number of different samples.\n      count = (x == y).sum()\n      count_limit = 20 if dt == dtypes.float16 else 10\n      self.assertLess(count, count_limit)\n\n  # Checks that the CPU and GPU implementation returns the same results,\n  # given the same random seed\n  @test_util.run_deprecated_v1\n  def testCPUGPUMatch(self):\n    for dt in dtypes.float16, dtypes.float32, dtypes.float64:\n      results = {}\n      for use_gpu in [False, True]:\n        sampler = self._Sampler(1000, 0.0, 1.0, dt, use_gpu=use_gpu, seed=12345)\n        results[use_gpu] = sampler()\n      if dt == dtypes.float16:\n        self.assertAllClose(results[False], results[True], rtol=1e-3, atol=1e-3)\n      else:\n        self.assertAllClose(results[False], results[True], rtol=1e-6, atol=1e-6)\n\n  def testSeed(self):\n    for dt in dtypes.float16, dtypes.float32, dtypes.float64:\n      sx = self._Sampler(1000, 0.0, 1.0, dt, seed=345)\n      sy = self._Sampler(1000, 0.0, 1.0, dt, seed=345)\n      self.assertAllEqual(sx(), sy())\n\n  @test_util.run_deprecated_v1\n  def testNoCSE(self):\n    \"\"\"CSE = constant subexpression eliminator.\n\n    SetIsStateful() should prevent two identical random ops from getting\n    merged.\n    \"\"\"\n    for dtype in dtypes.float16, dtypes.float32, dtypes.float64:\n      with self.cached_session():\n        rnd1 = random_ops.random_gamma([24], 2.0, dtype=dtype)\n        rnd2 = random_ops.random_gamma([24], 2.0, dtype=dtype)\n        diff = rnd2 - rnd1\n        self.assertGreater(np.linalg.norm(diff.eval()), 0.1)\n\n  @test_util.run_deprecated_v1\n  def testShape(self):\n    # Fully known shape.\n    rnd = random_ops.random_gamma([150], 2.0)\n    self.assertEqual([150], rnd.get_shape().as_list())\n    rnd = random_ops.random_gamma([150], 2.0, beta=[3.0, 4.0])\n    self.assertEqual([150, 2], rnd.get_shape().as_list())\n    rnd = random_ops.random_gamma([150], array_ops.ones([1, 2, 3]))\n    self.assertEqual([150, 1, 2, 3], rnd.get_shape().as_list())\n    rnd = random_ops.random_gamma([20, 30], array_ops.ones([1, 2, 3]))\n    self.assertEqual([20, 30, 1, 2, 3], rnd.get_shape().as_list())\n    rnd = random_ops.random_gamma(\n        [123], array_ops.placeholder(\n            dtypes.float32, shape=(2,)))\n    self.assertEqual([123, 2], rnd.get_shape().as_list())\n    # Partially known shape.\n    rnd = random_ops.random_gamma(\n        array_ops.placeholder(\n            dtypes.int32, shape=(1,)), array_ops.ones([7, 3]))\n    self.assertEqual([None, 7, 3], rnd.get_shape().as_list())\n    rnd = random_ops.random_gamma(\n        array_ops.placeholder(\n            dtypes.int32, shape=(3,)), array_ops.ones([9, 6]))\n    self.assertEqual([None, None, None, 9, 6], rnd.get_shape().as_list())\n    # Unknown shape.\n    rnd = random_ops.random_gamma(\n        array_ops.placeholder(dtypes.int32),\n        array_ops.placeholder(dtypes.float32))\n    self.assertIs(None, rnd.get_shape().ndims)\n    rnd = random_ops.random_gamma([50], array_ops.placeholder(dtypes.float32))\n    self.assertIs(None, rnd.get_shape().ndims)\n\n  @test_util.run_deprecated_v1\n  def testPositive(self):\n    n = int(10e3)\n    for dt in [dtypes.float16, dtypes.float32, dtypes.float64]:\n      with self.cached_session():\n        x = random_ops.random_gamma(shape=[n], alpha=0.001, dtype=dt, seed=0)\n        self.assertEqual(0, math_ops.reduce_sum(math_ops.cast(\n            math_ops.less_equal(x, 0.), dtype=dtypes.int64)).eval())\n\n\nif __name__ == \"__main__\":\n  test.main()"