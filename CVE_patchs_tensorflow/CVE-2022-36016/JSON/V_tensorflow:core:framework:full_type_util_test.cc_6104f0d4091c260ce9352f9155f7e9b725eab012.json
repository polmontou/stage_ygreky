"/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/attr_value.pb.h\"\n#include \"tensorflow/core/framework/full_type.pb.h\"\n#include \"tensorflow/core/framework/node_def.pb.h\"\n#include \"tensorflow/core/framework/node_def_util.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/lib/core/status_test_util.h\"\n#include \"tensorflow/core/platform/test.h\"\n\nnamespace tensorflow {\n\nnamespace full_type {\n\nnamespace {\n\n// TODO(mdan): Use ParseTextProto, ProtoEquals when available in a clean lib.\n\nTEST(Nullary, Basic) {\n  OpTypeConstructor ctor = Nullary(TFT_TENSOR);\n\n  OpDef op;\n  op.add_output_arg();\n\n  TF_ASSERT_OK(ctor(&op));\n\n  const FullTypeDef& t = op.output_arg(0).experimental_full_type();\n  EXPECT_EQ(t.type_id(), TFT_TENSOR);\n  EXPECT_EQ(t.args_size(), 0);\n}\n\nTEST(Unary, Basic) {\n  OpTypeConstructor ctor = Unary(TFT_TENSOR, \"T\");\n\n  OpDef op;\n  op.add_output_arg();\n\n  TF_ASSERT_OK(ctor(&op));\n\n  const FullTypeDef& t = op.output_arg(0).experimental_full_type();\n  EXPECT_EQ(t.type_id(), TFT_TENSOR);\n  EXPECT_EQ(t.args_size(), 1);\n  EXPECT_EQ(t.args(0).type_id(), TFT_VAR);\n  EXPECT_EQ(t.args(0).args_size(), 0);\n  EXPECT_EQ(t.args(0).s(), \"T\");\n}\n\nTEST(UnaryGeneric, Basic) {\n  OpTypeConstructor ctor = UnaryGeneric(TFT_TENSOR);\n\n  OpDef op;\n  op.add_output_arg();\n\n  TF_ASSERT_OK(ctor(&op));\n\n  const FullTypeDef& t = op.output_arg(0).experimental_full_type();\n  EXPECT_EQ(t.type_id(), TFT_TENSOR);\n  EXPECT_EQ(t.args_size(), 1);\n  EXPECT_EQ(t.args(0).type_id(), TFT_ANY);\n  EXPECT_EQ(t.args(0).args_size(), 0);\n}\n\nTEST(UnaryTensorContainer, Fixed) {\n  OpTypeConstructor ctor = UnaryTensorContainer(TFT_ARRAY, TFT_INT32);\n\n  OpDef op;\n  op.add_output_arg();\n\n  TF_ASSERT_OK(ctor(&op));\n\n  const FullTypeDef& t = op.output_arg(0).experimental_full_type();\n  EXPECT_EQ(t.type_id(), TFT_ARRAY);\n  EXPECT_EQ(t.args_size(), 1);\n  EXPECT_EQ(t.args(0).type_id(), TFT_TENSOR);\n  EXPECT_EQ(t.args(0).args_size(), 1);\n  EXPECT_EQ(t.args(0).args(0).type_id(), TFT_INT32);\n  EXPECT_EQ(t.args(0).args(0).args_size(), 0);\n}\n\nTEST(UnaryTensorContainer, Dependent) {\n  OpTypeConstructor ctor = UnaryTensorContainer(TFT_ARRAY, \"T\");\n\n  OpDef op;\n  op.add_output_arg();\n\n  TF_ASSERT_OK(ctor(&op));\n\n  const FullTypeDef& t = op.output_arg(0).experimental_full_type();\n  EXPECT_EQ(t.type_id(), TFT_ARRAY);\n  EXPECT_EQ(t.args_size(), 1);\n  EXPECT_EQ(t.args(0).type_id(), TFT_TENSOR);\n  EXPECT_EQ(t.args(0).args_size(), 1);\n  EXPECT_EQ(t.args(0).args(0).type_id(), TFT_VAR);\n  EXPECT_EQ(t.args(0).args(0).args_size(), 0);\n  EXPECT_EQ(t.args(0).args(0).s(), \"T\");\n}\n\nTEST(VariadicTensorContainer, Basic) {\n  OpTypeConstructor ctor = VariadicTensorContainer(TFT_ARRAY, \"T\");\n\n  OpDef op;\n  op.add_output_arg();\n\n  TF_ASSERT_OK(ctor(&op));\n\n  const FullTypeDef& t = op.output_arg(0).experimental_full_type();\n  EXPECT_EQ(t.type_id(), TFT_ARRAY);\n  EXPECT_EQ(t.args_size(), 1);\n  EXPECT_EQ(t.args(0).type_id(), TFT_FOR_EACH);\n  EXPECT_EQ(t.args(0).args_size(), 3);\n  EXPECT_EQ(t.args(0).args(0).type_id(), TFT_PRODUCT);\n  EXPECT_EQ(t.args(0).args(0).args_size(), 0);\n  EXPECT_EQ(t.args(0).args(1).type_id(), TFT_TENSOR);\n  EXPECT_EQ(t.args(0).args(1).args_size(), 1);\n  EXPECT_EQ(t.args(0).args(1).args(0).type_id(), TFT_VAR);\n  EXPECT_EQ(t.args(0).args(1).args(0).args_size(), 0);\n  EXPECT_EQ(t.args(0).args(1).args(0).s(), \"T\");\n  EXPECT_EQ(t.args(0).args(2).type_id(), TFT_VAR);\n  EXPECT_EQ(t.args(0).args(2).args_size(), 0);\n  EXPECT_EQ(t.args(0).args(2).s(), \"T\");\n}\n\nTEST(SpecializeType, Fixed) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_ARRAY);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(0)->add_args()->set_type_id(TFT_INT32);\n  t->add_args()->set_type_id(TFT_DATASET);\n  t->mutable_args(1)->add_args()->set_type_id(TFT_FLOAT);\n\n  AttrSlice empty;\n\n  FullTypeDef ft;\n  TF_ASSERT_OK(SpecializeType(empty, op, ft));\n\n  EXPECT_EQ(ft.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(ft.args_size(), 1);\n\n  const FullTypeDef& t_actual = ft.args(0);\n  EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);\n  EXPECT_EQ(t_actual.args_size(), 2);\n  EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);\n  EXPECT_EQ(t_actual.args(0).args_size(), 1);\n  EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);\n  EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);\n  EXPECT_EQ(t_actual.args(1).type_id(), TFT_DATASET);\n  EXPECT_EQ(t_actual.args(1).args_size(), 1);\n  EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_FLOAT);\n  EXPECT_EQ(t_actual.args(1).args(0).args_size(), 0);\n}\n\nTEST(SpecializeType, Idempotence) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_ARRAY);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(0)->add_args()->set_type_id(TFT_INT32);\n  t->add_args()->set_type_id(TFT_DATASET);\n  t->mutable_args(1)->add_args()->set_type_id(TFT_FLOAT);\n\n  AttrSlice empty;\n\n  FullTypeDef ft;\n  TF_ASSERT_OK(SpecializeType(empty, op, ft));\n  TF_ASSERT_OK(SpecializeType(empty, op, ft));\n\n  EXPECT_EQ(ft.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(ft.args_size(), 1);\n}\n\nTEST(SpecializeType, VarExpandsFromSingleAttribute) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_ARRAY);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(0)->mutable_args(0)->set_s(\"T\");\n\n  AttrValue attr;\n  attr.set_type(DT_INT32);\n  NodeDef ndef;\n  (*ndef.mutable_attr())[\"T\"] = attr;\n\n  AttrSlice attrs(ndef);\n\n  FullTypeDef ft;\n  TF_ASSERT_OK(SpecializeType(attrs, op, ft));\n\n  EXPECT_EQ(ft.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(ft.args_size(), 1);\n\n  const FullTypeDef& t_actual = ft.args(0);\n  EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);\n  EXPECT_EQ(t_actual.args_size(), 1);\n  EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);\n  EXPECT_EQ(t_actual.args(0).args_size(), 1);\n  EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);\n  EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);\n}\n\nTEST(SpecializeType, VarExpandsFromSingleElementTypeListAttribute) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_ARRAY);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(0)->mutable_args(0)->set_s(\"T\");\n\n  AttrValue attr;\n  attr.mutable_list()->add_type(DT_INT32);\n  NodeDef ndef;\n  (*ndef.mutable_attr())[\"T\"] = attr;\n\n  AttrSlice attrs(ndef);\n\n  FullTypeDef ft;\n  TF_ASSERT_OK(SpecializeType(attrs, op, ft));\n\n  EXPECT_EQ(ft.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(ft.args_size(), 1);\n\n  const FullTypeDef& t_actual = ft.args(0);\n  EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);\n  EXPECT_EQ(t_actual.args_size(), 1);\n  EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);\n  EXPECT_EQ(t_actual.args(0).args_size(), 1);\n  EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);\n  EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);\n}\n\nTEST(SpecializeType, VarRejectsMultipleElementTypeListAttribute) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_ARRAY);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(0)->mutable_args(0)->set_s(\"T\");\n\n  AttrValue attr;\n  attr.mutable_list()->add_type(DT_INT32);\n  attr.mutable_list()->add_type(DT_FLOAT);\n  NodeDef ndef;\n  (*ndef.mutable_attr())[\"T\"] = attr;\n\n  AttrSlice attrs(ndef);\n\n  FullTypeDef ft;\n  EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());\n}\n\nTEST(SpecializeType, VarRejectsEmptyTypeListAttribute) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_ARRAY);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(0)->mutable_args(0)->set_s(\"T\");\n\n  AttrValue attr;\n  attr.mutable_list();\n  NodeDef ndef;\n  (*ndef.mutable_attr())[\"T\"] = attr;\n\n  AttrSlice attrs(ndef);\n\n  FullTypeDef ft;\n  EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());\n}\n\nTEST(SpecializeType, ForEachExpandsFromSingleAttribute) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_FOR_EACH);\n  t->add_args()->set_type_id(TFT_PRODUCT);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(1)->mutable_args(0)->set_s(\"T\");\n  t->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(2)->set_s(\"T\");\n\n  AttrValue attr;\n  attr.set_type(DT_INT32);\n  NodeDef ndef;\n  (*ndef.mutable_attr())[\"T\"] = attr;\n\n  AttrSlice attrs(ndef);\n\n  FullTypeDef ft;\n  TF_ASSERT_OK(SpecializeType(attrs, op, ft));\n\n  EXPECT_EQ(ft.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(ft.args_size(), 1);\n\n  const FullTypeDef& t_actual = ft.args(0);\n  EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(t_actual.args_size(), 1);\n  EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);\n  EXPECT_EQ(t_actual.args(0).args_size(), 1);\n  EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);\n  EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);\n}\n\nTEST(SpecializeType, ForEachExpandsFromListAttribute) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_FOR_EACH);\n  t->add_args()->set_type_id(TFT_PRODUCT);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(1)->mutable_args(0)->set_s(\"T\");\n  t->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(2)->set_s(\"T\");\n\n  AttrValue attr;\n  attr.mutable_list()->add_type(DT_INT32);\n  attr.mutable_list()->add_type(DT_FLOAT);\n  NodeDef ndef;\n  (*ndef.mutable_attr())[\"T\"] = attr;\n\n  AttrSlice attrs(ndef);\n\n  FullTypeDef ft;\n  TF_ASSERT_OK(SpecializeType(attrs, op, ft));\n\n  EXPECT_EQ(ft.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(ft.args_size(), 1);\n\n  const FullTypeDef& t_actual = ft.args(0);\n  EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(t_actual.args_size(), 2);\n  EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);\n  EXPECT_EQ(t_actual.args(0).args_size(), 1);\n  EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);\n  EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);\n  EXPECT_EQ(t_actual.args(1).type_id(), TFT_TENSOR);\n  EXPECT_EQ(t_actual.args(1).args_size(), 1);\n  EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_FLOAT);\n  EXPECT_EQ(t_actual.args(1).args(0).args_size(), 0);\n}\n\nTEST(SpecializeType, ForEachDistributesNestedVar) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_FOR_EACH);\n  t->add_args()->set_type_id(TFT_PRODUCT);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(1)->mutable_args(0)->set_s(\"ForEachTarget\");\n  t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(1)->mutable_args(1)->set_s(\"GlobalVar\");\n  t->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(2)->set_s(\"ForEachTarget\");\n\n  NodeDef ndef;\n  AttrValue attr;\n\n  attr.mutable_list()->add_type(DT_INT32);\n  attr.mutable_list()->add_type(DT_INT64);\n  (*ndef.mutable_attr())[\"ForEachTarget\"] = attr;\n\n  attr.set_type(DT_FLOAT);\n  (*ndef.mutable_attr())[\"GlobalVar\"] = attr;\n\n  AttrSlice attrs(ndef);\n\n  FullTypeDef ft;\n  TF_ASSERT_OK(SpecializeType(attrs, op, ft));\n\n  EXPECT_EQ(ft.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(ft.args_size(), 1);\n\n  const FullTypeDef& t_actual = ft.args(0);\n  EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(t_actual.args_size(), 2);\n  EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);\n  EXPECT_EQ(t_actual.args(0).args_size(), 2);\n  EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);\n  EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);\n  EXPECT_EQ(t_actual.args(0).args(1).type_id(), TFT_FLOAT);\n  EXPECT_EQ(t_actual.args(0).args(1).args_size(), 0);\n  EXPECT_EQ(t_actual.args(1).type_id(), TFT_TENSOR);\n  EXPECT_EQ(t_actual.args(1).args_size(), 2);\n  EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_INT64);\n  EXPECT_EQ(t_actual.args(1).args(0).args_size(), 0);\n  EXPECT_EQ(t_actual.args(1).args(1).type_id(), TFT_FLOAT);\n  EXPECT_EQ(t_actual.args(1).args(1).args_size(), 0);\n}\n\nTEST(SpecializeType, ForEachDistributesNestedForEach) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_FOR_EACH);\n  t->add_args()->set_type_id(TFT_PRODUCT);\n\n  FullTypeDef* inner = t->add_args();\n  inner->set_type_id(TFT_FOR_EACH);\n  inner->add_args()->set_type_id(TFT_PRODUCT);\n  inner->add_args()->set_type_id(TFT_ARRAY);\n  inner->mutable_args(1)->add_args()->set_type_id(TFT_VAR);\n  inner->mutable_args(1)->mutable_args(0)->set_s(\"InnerForEach\");\n  inner->mutable_args(1)->add_args()->set_type_id(TFT_VAR);\n  inner->mutable_args(1)->mutable_args(1)->set_s(\"OuterForEach\");\n  inner->add_args()->set_type_id(TFT_VAR);\n  inner->mutable_args(2)->set_s(\"InnerForEach\");\n\n  t->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(2)->set_s(\"OuterForEach\");\n\n  NodeDef ndef;\n  AttrValue attr;\n\n  attr.mutable_list()->add_type(DT_INT32);\n  attr.mutable_list()->add_type(DT_INT64);\n  (*ndef.mutable_attr())[\"OuterForEach\"] = attr;\n\n  attr.set_type(DT_FLOAT);\n  (*ndef.mutable_attr())[\"InnerForEach\"] = attr;\n\n  AttrSlice attrs(ndef);\n\n  FullTypeDef ft;\n  TF_ASSERT_OK(SpecializeType(attrs, op, ft));\n\n  EXPECT_EQ(ft.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(ft.args_size(), 1);\n\n  const FullTypeDef& t_actual = ft.args(0);\n  EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(t_actual.args_size(), 2);\n  EXPECT_EQ(t_actual.args(0).type_id(), TFT_PRODUCT);\n  EXPECT_EQ(t_actual.args(0).args_size(), 1);\n  EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_ARRAY);\n  EXPECT_EQ(t_actual.args(0).args(0).args_size(), 2);\n  EXPECT_EQ(t_actual.args(0).args(0).args(0).type_id(), TFT_FLOAT);\n  EXPECT_EQ(t_actual.args(0).args(0).args(0).args_size(), 0);\n  EXPECT_EQ(t_actual.args(0).args(0).args(1).type_id(), TFT_INT32);\n  EXPECT_EQ(t_actual.args(0).args(0).args(1).args_size(), 0);\n  EXPECT_EQ(t_actual.args(1).type_id(), TFT_PRODUCT);\n  EXPECT_EQ(t_actual.args(1).args_size(), 1);\n  EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_ARRAY);\n  EXPECT_EQ(t_actual.args(1).args(0).args_size(), 2);\n  EXPECT_EQ(t_actual.args(1).args(0).args(0).type_id(), TFT_FLOAT);\n  EXPECT_EQ(t_actual.args(1).args(0).args(0).args_size(), 0);\n  EXPECT_EQ(t_actual.args(1).args(0).args(1).type_id(), TFT_INT64);\n  EXPECT_EQ(t_actual.args(1).args(0).args(1).args_size(), 0);\n}\n\nTEST(SpecializeType, ForEachOverridesTargetOfNestedForEach) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_FOR_EACH);\n  t->add_args()->set_type_id(TFT_PRODUCT);\n\n  FullTypeDef* inner = t->add_args();\n  inner->set_type_id(TFT_FOR_EACH);\n  inner->add_args()->set_type_id(TFT_PRODUCT);\n  inner->add_args()->set_type_id(TFT_ARRAY);\n  inner->mutable_args(1)->add_args()->set_type_id(TFT_VAR);\n  inner->mutable_args(1)->mutable_args(0)->set_s(\"T\");\n  inner->add_args()->set_type_id(TFT_VAR);\n  inner->mutable_args(2)->set_s(\"T\");\n\n  t->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(2)->set_s(\"T\");\n\n  NodeDef ndef;\n  AttrValue attr;\n\n  attr.mutable_list()->add_type(DT_FLOAT);\n  attr.mutable_list()->add_type(DT_DOUBLE);\n  (*ndef.mutable_attr())[\"T\"] = attr;\n\n  AttrSlice attrs(ndef);\n\n  FullTypeDef ft;\n  TF_ASSERT_OK(SpecializeType(attrs, op, ft));\n\n  EXPECT_EQ(ft.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(ft.args_size(), 1);\n\n  const FullTypeDef& t_actual = ft.args(0);\n  EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(t_actual.args_size(), 2);\n  EXPECT_EQ(t_actual.args(0).type_id(), TFT_PRODUCT);\n  EXPECT_EQ(t_actual.args(0).args_size(), 1);\n  EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_ARRAY);\n  EXPECT_EQ(t_actual.args(0).args(0).args_size(), 1);\n  EXPECT_EQ(t_actual.args(0).args(0).args(0).type_id(), TFT_FLOAT);\n  EXPECT_EQ(t_actual.args(0).args(0).args(0).args_size(), 0);\n  EXPECT_EQ(t_actual.args(1).type_id(), TFT_PRODUCT);\n  EXPECT_EQ(t_actual.args(1).args_size(), 1);\n  EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_ARRAY);\n  EXPECT_EQ(t_actual.args(1).args(0).args_size(), 1);\n  EXPECT_EQ(t_actual.args(1).args(0).args(0).type_id(), TFT_DOUBLE);\n  EXPECT_EQ(t_actual.args(1).args(0).args(0).args_size(), 0);\n}\n\nTEST(SpecializeType, RemovesLegacyVariant) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_ARRAY);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(0)->add_args()->set_type_id(TFT_LEGACY_VARIANT);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(1)->add_args()->set_type_id(TFT_FLOAT);\n\n  AttrSlice empty;\n\n  FullTypeDef ft;\n  TF_ASSERT_OK(SpecializeType(empty, op, ft));\n\n  EXPECT_EQ(ft.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(ft.args_size(), 1);\n\n  const FullTypeDef& t_actual = ft.args(0);\n  EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);\n  EXPECT_EQ(t_actual.args_size(), 0);\n}\n\nTEST(SpecializeType, RemovesLegacyVariantAfterExpansion) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_ARRAY);\n  t->add_args()->set_type_id(TFT_TENSOR);\n  t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);\n  t->mutable_args(0)->mutable_args(0)->set_s(\"T\");\n\n  AttrValue attr;\n  attr.set_type(DT_VARIANT);\n  NodeDef ndef;\n  (*ndef.mutable_attr())[\"T\"] = attr;\n\n  AttrSlice attrs(ndef);\n\n  FullTypeDef ft;\n  TF_ASSERT_OK(SpecializeType(attrs, op, ft));\n\n  EXPECT_EQ(ft.type_id(), TFT_PRODUCT);\n  EXPECT_EQ(ft.args_size(), 1);\n\n  const FullTypeDef& t_actual = ft.args(0);\n  EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);\n  EXPECT_EQ(t_actual.args_size(), 0);\n}\n\nTEST(GetArgDefaults, DefaultUnsetFromNoArgs) {\n  FullTypeDef t;\n\n  const auto& d = GetArgDefaultUnset(t, 0);\n\n  EXPECT_EQ(d.type_id(), TFT_UNSET);\n}\n\nTEST(GetArgDefaults, DefaultUnsetFromOutOfBounds) {\n  FullTypeDef t;\n  t.add_args()->set_type_id(TFT_TENSOR);\n\n  const auto& d = GetArgDefaultUnset(t, 1);\n\n  EXPECT_EQ(d.type_id(), TFT_UNSET);\n}\n\nTEST(GetArgDefaults, NoDefaultUnsetFromArg) {\n  FullTypeDef t;\n  t.add_args()->set_type_id(TFT_TENSOR);\n  t.mutable_args(0)->add_args();\n\n  const auto& d = GetArgDefaultUnset(t, 0);\n\n  EXPECT_EQ(d.type_id(), TFT_TENSOR);\n  EXPECT_EQ(d.args_size(), 1);\n}\n\nTEST(GetArgDefaults, DefaultAnyFromNoArgs) {\n  FullTypeDef t;\n\n  const auto& d = GetArgDefaultAny(t, 0);\n\n  EXPECT_EQ(d.type_id(), TFT_ANY);\n}\n\nTEST(GetArgDefaults, DefaultAnyFromOutOfBounds) {\n  FullTypeDef t;\n  t.add_args()->set_type_id(TFT_TENSOR);\n\n  const auto& d = GetArgDefaultAny(t, 1);\n\n  EXPECT_EQ(d.type_id(), TFT_ANY);\n}\n\nTEST(GetArgDefaults, DefaultAnyFromUnset) {\n  FullTypeDef t;\n  t.add_args();\n\n  const auto& d = GetArgDefaultAny(t, 0);\n\n  EXPECT_EQ(d.type_id(), TFT_ANY);\n}\n\nTEST(GetArgDefaults, NoDefaultAnyFromArg) {\n  FullTypeDef t;\n  t.add_args()->set_type_id(TFT_TENSOR);\n  t.mutable_args(0)->add_args();\n\n  const auto& d = GetArgDefaultAny(t, 0);\n\n  EXPECT_EQ(d.type_id(), TFT_TENSOR);\n  EXPECT_EQ(d.args_size(), 1);\n}\n\nTEST(IsEqual, Reflexivity) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  EXPECT_TRUE(IsEqual(t, t));\n}\n\nTEST(IsEqual, Copy) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  FullTypeDef u;\n  u = t;\n  EXPECT_TRUE(IsEqual(t, u));\n  EXPECT_TRUE(IsEqual(u, t));\n}\n\nTEST(IsEqual, DifferentTypesNotEqual) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  FullTypeDef u;\n  u = t;\n  u.set_type_id(TFT_ARRAY);\n\n  EXPECT_FALSE(IsEqual(t, u));\n  EXPECT_FALSE(IsEqual(u, t));\n}\n\nTEST(IsEqual, DifferentAritiesNotEqual) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  FullTypeDef u;\n  u = t;\n  u.add_args()->set_type_id(TFT_FLOAT);\n\n  EXPECT_FALSE(IsEqual(t, u));\n  EXPECT_FALSE(IsEqual(u, t));\n}\n\nTEST(IsEqual, MissingArgsEquivalentToAny) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n\n  FullTypeDef u;\n  u = t;\n  u.add_args()->set_type_id(TFT_ANY);\n\n  EXPECT_TRUE(IsEqual(t, u));\n  EXPECT_TRUE(IsEqual(u, t));\n}\n\nTEST(IsEqual, DifferentArgsNotEqual) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  FullTypeDef u;\n  u = t;\n  u.mutable_args(1)->set_type_id(TFT_FLOAT);\n\n  EXPECT_FALSE(IsEqual(t, u));\n  EXPECT_FALSE(IsEqual(u, t));\n}\n\nTEST(IsEqual, DifferentStringValuesNotEqual) {\n  FullTypeDef t;\n  t.set_type_id(TFT_VAR);\n  t.set_s(\"T\");\n\n  FullTypeDef u;\n  u = t;\n  u.set_type_id(TFT_VAR);\n  u.set_s(\"U\");\n\n  EXPECT_FALSE(IsEqual(t, u));\n  EXPECT_FALSE(IsEqual(u, t));\n}\n\nTEST(IsSubtype, Reflexivity) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  EXPECT_TRUE(IsSubtype(t, t));\n}\n\nTEST(IsSubtype, Copy) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  FullTypeDef u;\n  u = t;\n  EXPECT_TRUE(IsSubtype(t, u));\n}\n\nTEST(IsSubtype, Any) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  FullTypeDef u;\n  u.set_type_id(TFT_ANY);\n\n  EXPECT_TRUE(IsSubtype(t, u));\n  EXPECT_FALSE(IsSubtype(u, t));\n}\n\nTEST(IsSubtype, Unset) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  FullTypeDef u;\n  u.set_type_id(TFT_UNSET);\n\n  EXPECT_TRUE(IsSubtype(t, u));\n  EXPECT_FALSE(IsSubtype(u, t));\n}\n\nTEST(IsSubtype, Covariance) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_ARRAY);\n  t.mutable_args(0)->add_args()->set_type_id(TFT_INT32);\n\n  FullTypeDef u;\n  u.set_type_id(TFT_TENSOR);\n  u.add_args()->set_type_id(TFT_ANY);\n\n  EXPECT_TRUE(IsSubtype(t, u, /*covariant=*/true));\n  EXPECT_FALSE(IsSubtype(u, t, /*covariant=*/true));\n\n  EXPECT_FALSE(IsSubtype(t, u, /*covariant=*/false));\n  EXPECT_TRUE(IsSubtype(u, t, /*covariant=*/false));\n}\n\nTEST(IsSubtype, DifferentTypesNotSubtype) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  FullTypeDef u;\n  u = t;\n  u.set_type_id(TFT_ARRAY);\n\n  EXPECT_FALSE(IsSubtype(t, u));\n  EXPECT_FALSE(IsSubtype(u, t));\n}\n\nTEST(IsSubtype, DifferentAritiesDefaultToAny) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  FullTypeDef u;\n  u = t;\n  u.add_args()->set_type_id(TFT_FLOAT);\n\n  EXPECT_FALSE(IsSubtype(t, u));\n  EXPECT_TRUE(IsSubtype(u, t));\n}\n\nTEST(IsSubtype, DifferentArgsNotSubtype) {\n  FullTypeDef t;\n  t.set_type_id(TFT_TENSOR);\n  t.add_args()->set_type_id(TFT_INT32);\n  t.add_args()->set_type_id(TFT_INT64);\n\n  FullTypeDef u;\n  u = t;\n  u.mutable_args(1)->set_type_id(TFT_FLOAT);\n\n  EXPECT_FALSE(IsSubtype(t, u));\n  EXPECT_FALSE(IsSubtype(u, t));\n}\n\n}  // namespace\n\n}  // namespace full_type\n\n}  // namespace tensorflow"