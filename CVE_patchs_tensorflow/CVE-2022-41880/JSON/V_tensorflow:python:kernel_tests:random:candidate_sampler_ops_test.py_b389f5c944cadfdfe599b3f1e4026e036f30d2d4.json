"# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for CandidateSamplerOp.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import candidate_sampling_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.platform import test\n\n\nclass RangeSamplerOpsTest(test.TestCase):\n\n  BATCH_SIZE = 3\n  NUM_TRUE = 2\n  RANGE = 5\n  NUM_SAMPLED = RANGE\n\n  TRUE_LABELS = [[1, 2], [0, 4], [3, 3]]\n\n  @test_util.run_deprecated_v1\n  def testTrueCandidates(self):\n    with self.cached_session() as sess:\n      indices = constant_op.constant([0, 0, 1, 1, 2, 2])\n      true_candidates_vec = constant_op.constant([1, 2, 0, 4, 3, 3])\n      true_candidates_matrix = array_ops.reshape(\n          true_candidates_vec, [self.BATCH_SIZE, self.NUM_TRUE])\n      indices_val, true_candidates_val = sess.run(\n          [indices, true_candidates_matrix])\n\n    self.assertAllEqual(indices_val, [0, 0, 1, 1, 2, 2])\n    self.assertAllEqual(true_candidates_val, self.TRUE_LABELS)\n\n  def testSampledCandidates(self):\n    with self.cached_session():\n      true_classes = constant_op.constant(\n          [[1, 2], [0, 4], [3, 3]], dtype=dtypes.int64)\n      sampled_candidates, _, _ = candidate_sampling_ops.all_candidate_sampler(\n          true_classes, self.NUM_TRUE, self.NUM_SAMPLED, True)\n      result = self.evaluate(sampled_candidates)\n\n    expected_ids = [0, 1, 2, 3, 4]\n    self.assertAllEqual(result, expected_ids)\n    self.assertEqual(sampled_candidates.get_shape(), [self.NUM_SAMPLED])\n\n  def testTrueLogExpectedCount(self):\n    with self.cached_session():\n      true_classes = constant_op.constant(\n          [[1, 2], [0, 4], [3, 3]], dtype=dtypes.int64)\n      _, true_expected_count, _ = candidate_sampling_ops.all_candidate_sampler(\n          true_classes, self.NUM_TRUE, self.NUM_SAMPLED, True)\n      true_log_expected_count = math_ops.log(true_expected_count)\n      result = self.evaluate(true_log_expected_count)\n\n    self.assertAllEqual(result, [[0.0] * self.NUM_TRUE] * self.BATCH_SIZE)\n    self.assertEqual(true_expected_count.get_shape(),\n                     [self.BATCH_SIZE, self.NUM_TRUE])\n    self.assertEqual(true_log_expected_count.get_shape(),\n                     [self.BATCH_SIZE, self.NUM_TRUE])\n\n  def testSampledLogExpectedCount(self):\n    with self.cached_session():\n      true_classes = constant_op.constant(\n          [[1, 2], [0, 4], [3, 3]], dtype=dtypes.int64)\n      _, _, sampled_expected_count = candidate_sampling_ops.all_candidate_sampler(  # pylint: disable=line-too-long\n          true_classes, self.NUM_TRUE, self.NUM_SAMPLED, True)\n      sampled_log_expected_count = math_ops.log(sampled_expected_count)\n      result = self.evaluate(sampled_log_expected_count)\n\n    self.assertAllEqual(result, [0.0] * self.NUM_SAMPLED)\n    self.assertEqual(sampled_expected_count.get_shape(), [self.NUM_SAMPLED])\n    self.assertEqual(sampled_log_expected_count.get_shape(), [self.NUM_SAMPLED])\n\n  def testAccidentalHits(self):\n    with self.cached_session() as sess:\n      true_classes = constant_op.constant(\n          [[1, 2], [0, 4], [3, 3]], dtype=dtypes.int64)\n      sampled_candidates, _, _ = candidate_sampling_ops.all_candidate_sampler(\n          true_classes, self.NUM_TRUE, self.NUM_SAMPLED, True)\n      accidental_hits = candidate_sampling_ops.compute_accidental_hits(\n          true_classes, sampled_candidates, self.NUM_TRUE)\n      indices, ids, weights = self.evaluate(accidental_hits)\n\n    self.assertEqual(1, accidental_hits[0].get_shape().ndims)\n    self.assertEqual(1, accidental_hits[1].get_shape().ndims)\n    self.assertEqual(1, accidental_hits[2].get_shape().ndims)\n    for index, id_, weight in zip(indices, ids, weights):\n      self.assertTrue(id_ in self.TRUE_LABELS[index])\n      self.assertLess(weight, -1.0e37)\n\n  @test_util.run_deprecated_v1\n  def testSeed(self):\n\n    def draw(seed):\n      with self.cached_session():\n        true_classes = constant_op.constant(\n            [[1, 2], [0, 4], [3, 3]], dtype=dtypes.int64)\n        sampled, _, _ = candidate_sampling_ops.log_uniform_candidate_sampler(\n            true_classes, self.NUM_TRUE, self.NUM_SAMPLED, True, 5, seed=seed)\n        return self.evaluate(sampled)\n\n    # Non-zero seed. Repeatable.\n    for seed in [1, 12, 123, 1234]:\n      self.assertAllEqual(draw(seed), draw(seed))\n    # Seed=0 means random seeds.\n    num_same = 0\n    for _ in range(10):\n      if np.allclose(draw(None), draw(None)):\n        num_same += 1\n    # Accounts for the fact that the same random seed may be picked\n    # twice very rarely.\n    self.assertLessEqual(num_same, 2)\n\n\nif __name__ == \"__main__\":\n  test.main()"