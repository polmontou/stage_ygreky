"/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define EIGEN_USE_GPU\n\n#include <algorithm>\n#include <vector>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/numeric_types.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/kernels/gpu_prim.h\"\n#include \"tensorflow/core/kernels/image/non_max_suppression_op.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/stream_executor.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/gpu_kernel_helper.h\"\n#include \"tensorflow/core/util/gpu_launch_config.h\"\n\nnamespace tensorflow {\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace {\n\n// Decode d_bbox_deltas with respect to anchors into absolute coordinates,\n// clipping if necessary.\n// prenms_nboxes maximum number of boxes per image to decode.\n// d_boxes_keep_flags mask for boxes to consider in NMS.\n// min_size is the lower bound of the shortest edge for the boxes to consider.\n// bbox_xform_clip is the upper bound of encoded width and height.\n__global__ void GeneratePreNMSUprightBoxesKernel(\n    const Gpu2DLaunchConfig config, const int* d_sorted_scores_keys,\n    const float4* d_bbox_deltas, const float4* d_anchors, const int height,\n    const int width, const int num_anchors, const float min_size,\n    const float* d_img_info_vec,  // Input \"image_info\" to the op [N,5]\n    const float bbox_xform_clip, float4* d_out_boxes,\n    const int prenms_nboxes,  // leading dimension of out_boxes\n    char* d_boxes_keep_flags) {\n  // constants to calculate offsets in to the input and output arrays.\n  const int anchor_stride = height * width;              // Stride of Anchor\n  const int height_stride = width * num_anchors;         // Stride of height\n  const int image_stride = anchor_stride * num_anchors;  // Stride of image\n  CUDA_AXIS_KERNEL_LOOP(image_index, config.virtual_thread_count.y, Y) {\n    CUDA_AXIS_KERNEL_LOOP(ibox, config.virtual_thread_count.x, X) {\n      // box_conv_index : # of the same box, but indexed in the\n      // scores from the conv layer, of shape (height,width,num_anchors) the\n      // num_images dimension was already removed box_conv_index =\n      // a*image_stride + h*width + w\n      const int box_conv_index =\n          d_sorted_scores_keys[image_index * image_stride + ibox];\n\n      // We want to decompose box_conv_index in (h,w,a)\n      // such as box_conv_index = h*width*num_anchors + width*num_anchors + a\n      // (avoiding modulos in the process)\n      int remaining = box_conv_index;\n      const int delta_height = height_stride;  // stride of height\n      const int h = remaining / delta_height;\n      remaining -= h * delta_height;\n      const int delta_width = num_anchors;  // stride of width\n      const int w = remaining / delta_width;\n      remaining -= w * delta_width;\n      // Loading the anchor a\n      // float4 is a struct with float x,y,z,w\n      const float4 anchor = d_anchors[box_conv_index];\n      // x1,y1,x2,y2 :coordinates of anchor a, shifted for position (h,w)\n      float x1 = anchor.y;\n      float x2 = anchor.w;\n      float y1 = anchor.x;\n      float y2 = anchor.z;\n\n      // TODO use fast math when possible\n\n      // Deltas of shape (N,height,width,num_anchors x 4)\n      int deltas_idx = box_conv_index + image_index * image_stride;\n      float4 deltas = d_bbox_deltas[deltas_idx];\n      float dx = deltas.y;\n      float dy = deltas.x;\n      float dw = deltas.w;\n      float dh = deltas.z;\n      // Upper bound on dw,dh\n      dw = fmin(dw, bbox_xform_clip);\n      dh = fmin(dh, bbox_xform_clip);\n\n      // Applying the deltas\n      float width = x2 - x1;\n      const float ctr_x = x1 + 0.5f * width;\n      const float pred_ctr_x = ctr_x + width * dx;  // TODO fuse madd\n      const float pred_w = width * expf(dw);\n      x1 = pred_ctr_x - 0.5f * pred_w;\n      x2 = pred_ctr_x + 0.5f * pred_w;\n\n      float height = y2 - y1;\n      const float ctr_y = y1 + 0.5f * height;\n      const float pred_ctr_y = ctr_y + height * dy;\n      const float pred_h = height * expf(dh);\n      y1 = pred_ctr_y - 0.5f * pred_h;\n      y2 = pred_ctr_y + 0.5f * pred_h;\n\n      // Clipping box to image\n      const float img_height = d_img_info_vec[5 * image_index + 0];\n      const float img_width = d_img_info_vec[5 * image_index + 1];\n      const float min_size_scaled =\n          min_size * d_img_info_vec[5 * image_index + 2];\n      x1 = fmax(fmin(x1, img_width), 0.0f);\n      y1 = fmax(fmin(y1, img_height), 0.0f);\n      x2 = fmax(fmin(x2, img_width), 0.0f);\n      y2 = fmax(fmin(y2, img_height), 0.0f);\n\n      // Filter boxes\n      // Removing boxes with one dim < min_size\n      // (center of box is in image, because of previous step)\n      width = x2 - x1;  // may have changed\n      height = y2 - y1;\n      bool keep_box = fmin(width, height) >= min_size_scaled;\n\n      // We are not deleting the box right now even if !keep_box\n      // we want to keep the relative order of the elements stable\n      // we'll do it in such a way later\n      // d_boxes_keep_flags size: (num_images,prenms_nboxes)\n      // d_out_boxes size: (num_images,prenms_nboxes)\n      const int out_index = image_index * prenms_nboxes + ibox;\n\n      d_boxes_keep_flags[out_index] = keep_box;\n      d_out_boxes[out_index] = {x1, y1, x2, y2};\n    }\n  }\n}\n\n// Copy the selected boxes and scores to output tensors.\n//\n__global__ void WriteUprightBoxesOutput(\n    const GpuLaunchConfig nboxes, const float4* d_image_boxes,\n    const float* d_image_scores, const int* d_image_boxes_keep_list,\n    const int n_rois, float* d_image_out_rois, float* d_image_out_rois_probs) {\n  CUDA_1D_KERNEL_LOOP(i, nboxes.virtual_thread_count) {\n    if (i < n_rois) {  // copy rois to output\n      const int ibox = d_image_boxes_keep_list[i];\n      const float4 box = d_image_boxes[ibox];\n      const float score = d_image_scores[ibox];\n      // Scattered memory accesses\n      // postnms_nboxes is small anyway\n      d_image_out_rois_probs[i] = score;\n      const int base_idx = 4 * i;\n      d_image_out_rois[base_idx + 0] = box.y;\n      d_image_out_rois[base_idx + 1] = box.x;\n      d_image_out_rois[base_idx + 2] = box.w;\n      d_image_out_rois[base_idx + 3] = box.z;\n    } else {  // set trailing entries to 0\n      d_image_out_rois_probs[i] = 0.;\n      const int base_idx = 4 * i;\n      d_image_out_rois[base_idx + 0] = 0.;\n      d_image_out_rois[base_idx + 1] = 0.;\n      d_image_out_rois[base_idx + 2] = 0.;\n      d_image_out_rois[base_idx + 3] = 0.;\n    }\n  }\n}\n\ntemplate <typename T>\nStatus ResetTensor(Tensor* t, const Eigen::GpuDevice& d) {\n  GpuLaunchConfig zconfig = GetGpuLaunchConfig(t->NumElements(), d);\n  return GpuLaunchKernel(SetZero<T>, zconfig.block_count,\n                         zconfig.thread_per_block, 0, d.stream(),\n                         zconfig.virtual_thread_count, (*t).flat<T>().data());\n}\n// Allocate scratch spaces that are needed for operation\n//\n\nStatus AllocateGenerationTempTensors(\n    OpKernelContext* context, Tensor* d_conv_layer_indexes,\n    Tensor* d_image_offset, Tensor* d_cub_temp_buffer,\n    Tensor* d_sorted_conv_layer_indexes, Tensor* d_sorted_scores,\n    Tensor* dev_boxes, Tensor* dev_boxes_keep_flags, int num_images,\n    int conv_layer_nboxes, size_t cub_temp_storage_bytes,\n    int num_boxes_to_generate, int box_dim) {\n  auto d = context->eigen_gpu_device();\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_INT32, TensorShape({num_images, conv_layer_nboxes}),\n      d_conv_layer_indexes));\n  TF_RETURN_IF_ERROR(ResetTensor<int>(d_conv_layer_indexes, d));\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_INT32, TensorShape({num_images + 1}), d_image_offset));\n  TF_RETURN_IF_ERROR(ResetTensor<int>(d_image_offset, d));\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_INT8, TensorShape({(int64)cub_temp_storage_bytes}),\n      d_cub_temp_buffer));\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_INT32, TensorShape({num_images, conv_layer_nboxes}),\n      d_sorted_conv_layer_indexes));\n  TF_RETURN_IF_ERROR(ResetTensor<int32>(d_sorted_conv_layer_indexes, d));\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_FLOAT, TensorShape({num_images, conv_layer_nboxes}),\n      d_sorted_scores));\n  TF_RETURN_IF_ERROR(ResetTensor<float>(d_sorted_scores, d));\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_FLOAT,\n      TensorShape({num_images, box_dim * num_boxes_to_generate}), dev_boxes));\n  TF_RETURN_IF_ERROR(ResetTensor<float>(dev_boxes, d));\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_INT8, TensorShape({num_images, num_boxes_to_generate}),\n      dev_boxes_keep_flags));\n  TF_RETURN_IF_ERROR(ResetTensor<int8>(dev_boxes_keep_flags, d));\n  return OkStatus();\n}\n\n// Allocate workspace for NMS operation\nStatus AllocatePreNMSTempTensors(\n    OpKernelContext* context, Tensor* dev_image_prenms_boxes,\n    Tensor* dev_image_prenms_scores, Tensor* dev_image_boxes_keep_list,\n    Tensor* dev_postnms_rois, Tensor* dev_postnms_rois_probs,\n    Tensor* dev_prenms_nboxes, int num_images, int num_boxes_to_generate,\n    int box_dim, int post_nms_topn, int pre_nms_topn) {\n  auto d = context->eigen_gpu_device();\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_FLOAT, TensorShape({box_dim * num_boxes_to_generate}),\n      dev_image_prenms_boxes));\n  TF_RETURN_IF_ERROR(ResetTensor<float>(dev_image_prenms_boxes, d));\n\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_FLOAT, TensorShape({num_boxes_to_generate}),\n      dev_image_prenms_scores));\n  TF_RETURN_IF_ERROR(ResetTensor<float>(dev_image_prenms_scores, d));\n\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_INT32, TensorShape({num_boxes_to_generate}),\n      dev_image_boxes_keep_list));\n  TF_RETURN_IF_ERROR(ResetTensor<int32>(dev_image_boxes_keep_list, d));\n\n  const int max_postnms_nboxes = std::min(num_boxes_to_generate, post_nms_topn);\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_FLOAT,\n      TensorShape({box_dim * num_images * max_postnms_nboxes}),\n      dev_postnms_rois));\n  TF_RETURN_IF_ERROR(ResetTensor<float>(dev_postnms_rois, d));\n\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_FLOAT, TensorShape({num_images * max_postnms_nboxes}),\n      dev_postnms_rois_probs));\n  TF_RETURN_IF_ERROR(ResetTensor<float>(dev_postnms_rois_probs, d));\n\n  TF_RETURN_IF_ERROR(context->allocate_temp(\n      DataType::DT_INT32, TensorShape({num_images}), dev_prenms_nboxes));\n  TF_RETURN_IF_ERROR(ResetTensor<int32>(dev_prenms_nboxes, d));\n\n  return OkStatus();\n}\n\n// Initialize index and offset arrays.\n// num_images is the batch size.\n__global__ void InitializeDataKernel(const Gpu2DLaunchConfig config,\n                                     int* d_image_offsets,\n                                     int* d_boxes_keys_iota) {\n  const int image_size = config.virtual_thread_count.x;\n  const int num_images = config.virtual_thread_count.y;\n  CUDA_AXIS_KERNEL_LOOP(img_idx, config.virtual_thread_count.y, Y) {\n    CUDA_AXIS_KERNEL_LOOP(box_idx, config.virtual_thread_count.x, X) {\n      d_boxes_keys_iota[img_idx * image_size + box_idx] = box_idx;\n\n      // One 1D line sets the 1D data\n      if (box_idx == 0) {\n        d_image_offsets[img_idx] = image_size * img_idx;\n        // One thread sets the last+1 offset\n        if (img_idx == 0) d_image_offsets[num_images] = image_size * num_images;\n      }\n    }\n  }\n}\n\n}  // namespace\n\nclass GenerateBoundingBoxProposals : public tensorflow::OpKernel {\n public:\n  explicit GenerateBoundingBoxProposals(\n      tensorflow::OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"post_nms_topn\", &post_nms_topn_));\n    OP_REQUIRES(context, post_nms_topn_ > 0,\n                errors::InvalidArgument(\"post_nms_topn can't be 0 or less\"));\n    bbox_xform_clip_default_ = log(1000.0 / 16.);\n  }\n\n  template <typename T>\n  Status GetScalarValue(OpKernelContext* context, int input, T* value) {\n    const Tensor& scalar_tensor = context->input(input);\n    if (!TensorShapeUtils::IsScalar(scalar_tensor.shape())) {\n      return errors::InvalidArgument(\"Expected a scalar in input \", input,\n                                     \"but got shape \",\n                                     scalar_tensor.shape().DebugString());\n    }\n    *value = scalar_tensor.scalar<T>()();\n    return OkStatus();\n  }\n\n  void Compute(tensorflow::OpKernelContext* context) override {\n    VLOG(1) << \"Starting Compute \" << name();\n    const auto scores = context->input(0);\n    const auto bbox_deltas = context->input(1);\n    const auto image_info = context->input(2);\n    const auto anchors = context->input(3);\n\n    OP_REQUIRES(context, scores.dims() == 4,\n                errors::InvalidArgument(\"`scores` must be rank 4 but is rank \",\n                                        scores.dims()));\n    OP_REQUIRES(\n        context, bbox_deltas.dims() == 4,\n        errors::InvalidArgument(\"`bbox_deltas` must be rank 4 but is rank \",\n                                bbox_deltas.dims()));\n    OP_REQUIRES(\n        context, image_info.dims() == 2,\n        errors::InvalidArgument(\"`image_info` must be rank 2 but is rank \",\n                                image_info.dims()));\n    OP_REQUIRES(context, anchors.dims() == 3,\n                errors::InvalidArgument(\"`anchors` must be rank 3 but is rank \",\n                                        anchors.dims()));\n\n    const auto num_images = scores.dim_size(0);\n    const auto num_anchors = scores.dim_size(3);\n    const auto height = scores.dim_size(1);\n    const auto width = scores.dim_size(2);\n    const auto box_dim = anchors.dim_size(2) / num_anchors;\n    OP_REQUIRES(context, box_dim == 4,\n                errors::OutOfRange(\"Box dimensions need to be 4\"));\n    // TODO(skama): make sure that inputs are ok.\n    const int image_stride = height * width;\n    const int conv_layer_nboxes =\n        image_stride *\n        num_anchors;  // total number of boxes when decoded on anchors.\n    // The following calls to CUB primitives do nothing\n    // (because the first arg is nullptr)\n    // except setting cub_*_temp_storage_bytes\n    float nms_threshold;\n    int pre_nms_topn;\n    float min_size;\n    OP_REQUIRES_OK(context, GetScalarValue(context, 4, &nms_threshold));\n    if (nms_threshold < 0 || nms_threshold > 1.0) {\n      context->SetStatus(errors::InvalidArgument(\n          \"nms_threshold should be between 0 and 1. Got \", nms_threshold));\n      return;\n    }\n    OP_REQUIRES_OK(context, GetScalarValue(context, 5, &pre_nms_topn));\n    if (pre_nms_topn <= 0) {\n      context->SetStatus(errors::InvalidArgument(\n          \"pre_nms_topn should be greater than 0\", pre_nms_topn));\n      return;\n    }\n    OP_REQUIRES_OK(context, GetScalarValue(context, 6, &min_size));\n    auto cuda_stream = GetGpuStream(context);\n    size_t cub_sort_temp_storage_bytes = 0;\n    float* flt_ptr = nullptr;\n    int* int_ptr = nullptr;\n    cudaError_t cuda_ret =\n        gpuprim::DeviceSegmentedRadixSort::SortPairsDescending(\n            nullptr, cub_sort_temp_storage_bytes, flt_ptr, flt_ptr, int_ptr,\n            int_ptr, num_images * conv_layer_nboxes, num_images, int_ptr,\n            int_ptr, 0, 8 * sizeof(float),  // sort all bits\n            cuda_stream);\n    TF_OP_REQUIRES_CUDA_SUCCESS(context, cuda_ret);\n    // get the size of select temp buffer\n    size_t cub_select_temp_storage_bytes = 0;\n    char* char_ptr = nullptr;\n    float4* f4_ptr = nullptr;\n    TF_OP_REQUIRES_CUDA_SUCCESS(\n        context, gpuprim::DeviceSelect::Flagged(\n                     nullptr, cub_select_temp_storage_bytes, f4_ptr, char_ptr,\n                     f4_ptr, int_ptr, image_stride * num_anchors, cuda_stream));\n    Tensor d_conv_layer_indexes;  // box indices on device\n    Tensor d_image_offset;        // starting offsets boxes for each image\n    Tensor d_cub_temp_buffer;     // buffer for cub sorting\n    Tensor d_sorted_conv_layer_indexes;  // output of cub sorting, indices of\n                                         // the sorted boxes\n    Tensor dev_sorted_scores;            // sorted scores, cub output\n    Tensor dev_boxes;                    // boxes on device\n    Tensor dev_boxes_keep_flags;  // bitmask for keeping the boxes or rejecting\n                                  // from output\n    const int nboxes_to_generate = std::min(conv_layer_nboxes, pre_nms_topn);\n    size_t cub_temp_storage_bytes =\n        std::max(cub_sort_temp_storage_bytes, cub_select_temp_storage_bytes);\n    OP_REQUIRES_OK(\n        context,\n        AllocateGenerationTempTensors(\n            context, &d_conv_layer_indexes, &d_image_offset, &d_cub_temp_buffer,\n            &d_sorted_conv_layer_indexes, &dev_sorted_scores, &dev_boxes,\n            &dev_boxes_keep_flags, num_images, conv_layer_nboxes,\n            cub_temp_storage_bytes, nboxes_to_generate, box_dim));\n    const GPUDevice& d = context->eigen_device<GPUDevice>();\n    Gpu2DLaunchConfig conf2d =\n        GetGpu2DLaunchConfig(conv_layer_nboxes, num_images, d);\n    // create box indices and offsets for each image on device\n    OP_REQUIRES_OK(\n        context, GpuLaunchKernel(InitializeDataKernel, conf2d.block_count,\n                                 conf2d.thread_per_block, 0, d.stream(), conf2d,\n                                 d_image_offset.flat<int>().data(),\n                                 d_conv_layer_indexes.flat<int>().data()));\n\n    // sort boxes with their scores.\n    // d_sorted_conv_layer_indexes will hold the pointers to old indices.\n    TF_OP_REQUIRES_CUDA_SUCCESS(\n        context,\n        gpuprim::DeviceSegmentedRadixSort::SortPairsDescending(\n            d_cub_temp_buffer.flat<int8>().data(), cub_temp_storage_bytes,\n            scores.flat<float>().data(), dev_sorted_scores.flat<float>().data(),\n            d_conv_layer_indexes.flat<int>().data(),\n            d_sorted_conv_layer_indexes.flat<int>().data(),\n            num_images * conv_layer_nboxes, num_images,\n            d_image_offset.flat<int>().data(),\n            d_image_offset.flat<int>().data() + 1, 0,\n            8 * sizeof(float),  // sort all bits\n            cuda_stream));\n    // Keeping only the topN pre_nms\n    conf2d = GetGpu2DLaunchConfig(nboxes_to_generate, num_images, d);\n\n    // create box y1,x1,y2,x2 from box_deltas and anchors (decode the boxes) and\n    // mark the boxes which are smaller that min_size ignored.\n    OP_REQUIRES_OK(\n        context,\n        GpuLaunchKernel(\n            GeneratePreNMSUprightBoxesKernel, conf2d.block_count,\n            conf2d.thread_per_block, 0, d.stream(), conf2d,\n            d_sorted_conv_layer_indexes.flat<int>().data(),\n            reinterpret_cast<const float4*>(bbox_deltas.flat<float>().data()),\n            reinterpret_cast<const float4*>(anchors.flat<float>().data()),\n            height, width, num_anchors, min_size,\n            image_info.flat<float>().data(), bbox_xform_clip_default_,\n            reinterpret_cast<float4*>(dev_boxes.flat<float>().data()),\n            nboxes_to_generate,\n            (char*)dev_boxes_keep_flags.flat<int8>().data()));\n    const int nboxes_generated = nboxes_to_generate;\n    const int roi_cols = box_dim;\n    Tensor dev_image_prenms_boxes;\n    Tensor dev_image_prenms_scores;\n    Tensor dev_image_boxes_keep_list;\n    Tensor dev_postnms_rois;\n    Tensor dev_postnms_rois_probs;\n    Tensor dev_prenms_nboxes;\n    // Allocate workspaces needed for NMS\n    OP_REQUIRES_OK(\n        context, AllocatePreNMSTempTensors(\n                     context, &dev_image_prenms_boxes, &dev_image_prenms_scores,\n                     &dev_image_boxes_keep_list, &dev_postnms_rois,\n                     &dev_postnms_rois_probs, &dev_prenms_nboxes, num_images,\n                     nboxes_generated, box_dim, post_nms_topn_, pre_nms_topn));\n    // get the pointers for temp storages\n    int* d_prenms_nboxes = dev_prenms_nboxes.flat<int>().data();\n    int h_prenms_nboxes = 0;\n    char* d_cub_temp_storage = (char*)d_cub_temp_buffer.flat<int8>().data();\n    float* d_image_prenms_boxes = dev_image_prenms_boxes.flat<float>().data();\n    float* d_image_prenms_scores = dev_image_prenms_scores.flat<float>().data();\n    int* d_image_boxes_keep_list = dev_image_boxes_keep_list.flat<int>().data();\n\n    int nrois_in_output = 0;\n    // get the pointers to boxes and scores\n    char* d_boxes_keep_flags = (char*)dev_boxes_keep_flags.flat<int8>().data();\n    float* d_boxes = dev_boxes.flat<float>().data();\n    float* d_sorted_scores = dev_sorted_scores.flat<float>().data();\n\n    // Create output tensors\n    Tensor* output_rois = nullptr;\n    Tensor* output_roi_probs = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({num_images, post_nms_topn_, roi_cols}),\n                       &output_rois));\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                1, TensorShape({num_images, post_nms_topn_}),\n                                &output_roi_probs));\n    float* d_postnms_rois = (*output_rois).flat<float>().data();\n    float* d_postnms_rois_probs = (*output_roi_probs).flat<float>().data();\n    gpuEvent_t copy_done;\n    gpuEventCreate(&copy_done);\n\n    // Do  per-image nms\n    for (int image_index = 0; image_index < num_images; ++image_index) {\n      // reset output workspaces\n      OP_REQUIRES_OK(context,\n                     ResetTensor<int32>(&dev_image_boxes_keep_list, d));\n      // Sub matrices for current image\n      // boxes\n      const float* d_image_boxes =\n          &d_boxes[image_index * nboxes_generated * box_dim];\n      // scores\n      const float* d_image_sorted_scores =\n          &d_sorted_scores[image_index * image_stride * num_anchors];\n      // keep flags\n      char* d_image_boxes_keep_flags =\n          &d_boxes_keep_flags[image_index * nboxes_generated];\n\n      // Output buffer for image\n      float* d_image_postnms_rois =\n          &d_postnms_rois[image_index * roi_cols * post_nms_topn_];\n      float* d_image_postnms_rois_probs =\n          &d_postnms_rois_probs[image_index * post_nms_topn_];\n\n      // Moving valid boxes (ie the ones with d_boxes_keep_flags[ibox] == true)\n      // to the output tensors\n      TF_OP_REQUIRES_CUDA_SUCCESS(\n          context, gpuprim::DeviceSelect::Flagged(\n                       d_cub_temp_storage, cub_temp_storage_bytes,\n                       reinterpret_cast<const float4*>(d_image_boxes),\n                       d_image_boxes_keep_flags,\n                       reinterpret_cast<float4*>(d_image_prenms_boxes),\n                       d_prenms_nboxes, nboxes_generated, d.stream()));\n      TF_OP_REQUIRES_CUDA_SUCCESS(\n          context,\n          gpuprim::DeviceSelect::Flagged(\n              d_cub_temp_storage, cub_temp_storage_bytes, d_image_sorted_scores,\n              d_image_boxes_keep_flags, d_image_prenms_scores, d_prenms_nboxes,\n              nboxes_generated, d.stream()));\n      d.memcpyDeviceToHost(&h_prenms_nboxes, d_prenms_nboxes, sizeof(int));\n      TF_OP_REQUIRES_CUDA_SUCCESS(context,\n                                  gpuEventRecord(copy_done, d.stream()));\n      TF_OP_REQUIRES_CUDA_SUCCESS(context, gpuEventSynchronize(copy_done));\n      // We know prenms_boxes <= topN_prenms, because nboxes_generated <=\n      // topN_prenms. Calling NMS on the generated boxes\n      const int prenms_nboxes = h_prenms_nboxes;\n      int nkeep;\n      OP_REQUIRES_OK(context, NmsGpu(d_image_prenms_boxes, prenms_nboxes,\n                                     nms_threshold, d_image_boxes_keep_list,\n                                     &nkeep, context, post_nms_topn_));\n      // All operations done after previous sort were keeping the relative order\n      // of the elements the elements are still sorted keep topN <=> truncate\n      // the array\n      const int postnms_nboxes = std::min(nkeep, post_nms_topn_);\n      // Moving the out boxes to the output tensors,\n      // adding the image_index dimension on the fly\n      GpuLaunchConfig config = GetGpuLaunchConfig(post_nms_topn_, d);\n      // make this single kernel\n      OP_REQUIRES_OK(\n          context,\n          GpuLaunchKernel(WriteUprightBoxesOutput, config.block_count,\n                          config.thread_per_block, 0, d.stream(), config,\n                          reinterpret_cast<const float4*>(d_image_prenms_boxes),\n                          d_image_prenms_scores, d_image_boxes_keep_list,\n                          postnms_nboxes, d_image_postnms_rois,\n                          d_image_postnms_rois_probs));\n      nrois_in_output += postnms_nboxes;\n      TF_OP_REQUIRES_CUDA_SUCCESS(context, cudaGetLastError());\n    }\n  }\n\n private:\n  int post_nms_topn_;\n  float bbox_xform_clip_default_;\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"GenerateBoundingBoxProposals\")\n                            .Device(tensorflow::DEVICE_GPU)\n                            .HostMemory(\"nms_threshold\")\n                            .HostMemory(\"min_size\")\n                            .HostMemory(\"pre_nms_topn\"),\n                        tensorflow::GenerateBoundingBoxProposals);\n}  // namespace tensorflow\n#endif"