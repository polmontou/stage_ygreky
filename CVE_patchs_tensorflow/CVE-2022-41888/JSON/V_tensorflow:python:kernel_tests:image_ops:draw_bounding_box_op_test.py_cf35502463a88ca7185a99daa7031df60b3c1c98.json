"# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for draw_bounding_box_op.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import image_ops\nfrom tensorflow.python.ops import image_ops_impl\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.platform import test\n\n\nclass DrawBoundingBoxOpTest(test.TestCase):\n\n  def _fillBorder(self, image, color):\n    \"\"\"Fill the border of the image.\n\n    Args:\n      image: Numpy array of shape [height, width, depth].\n      color: Numpy color of shape [depth] and either contents RGB/RGBA.\n\n    Returns:\n      image of original shape with border filled with \"color\".\n\n    Raises:\n      ValueError: Depths of image and color don\"t match.\n    \"\"\"\n    height, width, depth = image.shape\n    if depth != color.shape[0]:\n      raise ValueError(\"Image (%d) and color (%d) depths must match.\" %\n                       (depth, color.shape[0]))\n    image[0:height, 0, 0:depth] = color\n    image[0:height, width - 1, 0:depth] = color\n    image[0, 0:width, 0:depth] = color\n    image[height - 1, 0:width, 0:depth] = color\n    return image\n\n  def _testDrawBoundingBoxColorCycling(self,\n                                       img,\n                                       dtype=dtypes.float32,\n                                       colors=None):\n    \"\"\"Tests if cycling works appropriately.\n\n    Args:\n      img: 3-D numpy image on which to draw.\n      dtype: image dtype (float, half).\n      colors: color table.\n    \"\"\"\n    color_table = colors\n    if colors is None:\n      # THIS TABLE MUST MATCH draw_bounding_box_op.cc\n      color_table = np.asarray([[1, 1, 0, 1], [0, 0, 1, 1], [1, 0, 0, 1],\n                                [0, 1, 0, 1], [0.5, 0, 0.5,\n                                               1], [0.5, 0.5, 0, 1],\n                                [0.5, 0, 0, 1], [0, 0, 0.5, 1], [0, 1, 1, 1],\n                                [1, 0, 1, 1]])\n    assert len(img.shape) == 3\n    depth = img.shape[2]\n    assert depth <= color_table.shape[1]\n    assert depth == 1 or depth == 3 or depth == 4\n    ## Set red channel to 1 if image is GRY.\n    if depth == 1:\n      color_table[:, 0] = 1\n    num_colors = color_table.shape[0]\n    for num_boxes in range(1, num_colors + 2):\n      # Generate draw_bounding_box_op drawn image\n      image = np.copy(img)\n      color = color_table[(num_boxes - 1) % num_colors, 0:depth]\n      test_drawn_image = self._fillBorder(image, color)\n      bboxes = np.asarray([0, 0, 1, 1])\n      bboxes = np.vstack([bboxes for _ in range(num_boxes)])\n      bboxes = math_ops.cast(bboxes, dtypes.float32)\n      bboxes = array_ops.expand_dims(bboxes, 0)\n      image = ops.convert_to_tensor(image)\n      image = image_ops_impl.convert_image_dtype(image, dtype)\n      image = array_ops.expand_dims(image, 0)\n      image = image_ops.draw_bounding_boxes(image, bboxes, colors=colors)\n      with self.cached_session(use_gpu=False) as sess:\n        op_drawn_image = np.squeeze(sess.run(image), 0)\n        self.assertAllEqual(test_drawn_image, op_drawn_image)\n\n  def testDrawBoundingBoxRGBColorCycling(self):\n    \"\"\"Test if RGB color cycling works correctly.\"\"\"\n    image = np.zeros([10, 10, 3], \"float32\")\n    self._testDrawBoundingBoxColorCycling(image)\n\n  def testDrawBoundingBoxRGBAColorCycling(self):\n    \"\"\"Test if RGBA color cycling works correctly.\"\"\"\n    image = np.zeros([10, 10, 4], \"float32\")\n    self._testDrawBoundingBoxColorCycling(image)\n\n  def testDrawBoundingBoxGRY(self):\n    \"\"\"Test if drawing bounding box on a GRY image works.\"\"\"\n    image = np.zeros([4, 4, 1], \"float32\")\n    self._testDrawBoundingBoxColorCycling(image)\n\n  def testDrawBoundingBoxRGBColorCyclingWithColors(self):\n    \"\"\"Test if RGB color cycling works correctly with provided colors.\"\"\"\n    image = np.zeros([10, 10, 3], \"float32\")\n    colors = np.asarray([[1, 1, 0, 1], [0, 0, 1, 1], [0.5, 0, 0.5, 1],\n                         [0.5, 0.5, 0, 1], [0, 1, 1, 1], [1, 0, 1, 1]])\n    self._testDrawBoundingBoxColorCycling(image, colors=colors)\n\n  def testDrawBoundingBoxRGBAColorCyclingWithColors(self):\n    \"\"\"Test if RGBA color cycling works correctly with provided colors.\"\"\"\n    image = np.zeros([10, 10, 4], \"float32\")\n    colors = np.asarray([[0.5, 0, 0.5, 1], [0.5, 0.5, 0, 1], [0.5, 0, 0, 1],\n                         [0, 0, 0.5, 1]])\n    self._testDrawBoundingBoxColorCycling(image, colors=colors)\n\n  def testDrawBoundingBoxHalf(self):\n    \"\"\"Test if RGBA color cycling works correctly with provided colors.\"\"\"\n    image = np.zeros([10, 10, 4], \"float32\")\n    colors = np.asarray([[0.5, 0, 0.5, 1], [0.5, 0.5, 0, 1], [0.5, 0, 0, 1],\n                         [0, 0, 0.5, 1]])\n    self._testDrawBoundingBoxColorCycling(\n        image, dtype=dtypes.half, colors=colors)\n\n\nif __name__ == \"__main__\":\n  test.main()"