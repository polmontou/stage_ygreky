"# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functional tests for ExtractImagePatches op.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.platform import test\n\n\nclass ExtractImagePatches(test.TestCase):\n  \"\"\"Functional tests for ExtractImagePatches op.\"\"\"\n\n  def _VerifyValues(self, image, ksizes, strides, rates, padding, patches):\n    \"\"\"Tests input-output pairs for the ExtractImagePatches op.\n\n    Args:\n      image: Input tensor with shape: [batch, in_rows, in_cols, depth].\n      ksizes: Patch size specified as: [ksize_rows, ksize_cols].\n      strides: Output strides, specified as [stride_rows, stride_cols].\n      rates: Atrous rates, specified as [rate_rows, rate_cols].\n      padding: Padding type.\n      patches: Expected output.\n    \"\"\"\n    ksizes = [1] + ksizes + [1]\n    strides = [1] + strides + [1]\n    rates = [1] + rates + [1]\n\n    out_tensor = array_ops.extract_image_patches(\n        constant_op.constant(image),\n        ksizes=ksizes,\n        strides=strides,\n        rates=rates,\n        padding=padding,\n        name=\"im2col\")\n    self.assertAllClose(patches, self.evaluate(out_tensor))\n\n  def testKsize1x1Stride1x1Rate1x1(self):\n    \"\"\"Verifies that for 1x1 kernel the output equals the input.\"\"\"\n    # [2, 3, 4, 5]\n    image = np.reshape(range(120), [2, 3, 4, 5])\n    # [2, 3, 4, 5]\n    patches = np.reshape(range(120), [2, 3, 4, 5])\n    for padding in [\"VALID\", \"SAME\"]:\n      self._VerifyValues(\n          image,\n          ksizes=[1, 1],\n          strides=[1, 1],\n          rates=[1, 1],\n          padding=padding,\n          patches=patches)\n\n  def testKsize1x1Stride2x3Rate1x1(self):\n    \"\"\"Test for 1x1 kernel and strides.\"\"\"\n    # [2, 4, 5, 3]\n    image = np.reshape(range(120), [2, 4, 5, 3])\n    # [2, 2, 2, 3]\n    patches = image[:, ::2, ::3, :]\n    for padding in [\"VALID\", \"SAME\"]:\n      self._VerifyValues(\n          image,\n          ksizes=[1, 1],\n          strides=[2, 3],\n          rates=[1, 1],\n          padding=padding,\n          patches=patches)\n\n  def testKsize2x2Stride1x1Rate1x1Valid(self):\n    \"\"\"Test for 2x2 kernel with VALID padding.\"\"\"\n    # [1, 2, 2, 1]\n    image = [[[[1], [2]], [[3], [4]]]]\n    # [1, 1, 1, 4]\n    patches = [[[[1, 2, 3, 4]]]]\n    self._VerifyValues(\n        image,\n        ksizes=[2, 2],\n        strides=[1, 1],\n        rates=[1, 1],\n        padding=\"VALID\",\n        patches=patches)\n\n  def testKsize2x2Stride1x1Rate1x1Same(self):\n    \"\"\"Test for 2x2 kernel with SAME padding.\"\"\"\n    # [1, 2, 2, 1]\n    image = [[[[1], [2]], [[3], [4]]]]\n    # [1, 2, 2, 4]\n    patches = [[[[1, 2, 3, 4], [2, 0, 4, 0]], [[3, 4, 0, 0], [4, 0, 0, 0]]]]\n    self._VerifyValues(\n        image,\n        ksizes=[2, 2],\n        strides=[1, 1],\n        rates=[1, 1],\n        padding=\"SAME\",\n        patches=patches)\n\n  def testKsize2x2Stride1x1Rate2x2Valid(self):\n    \"\"\"Test for 2x2 kernel with 2x2 dilation.\"\"\"\n    # [1, 2, 2, 1]\n    image = np.arange(16).reshape(1, 4, 4, 1).astype(np.float32)\n    # [1, 2, 2, 4]\n    patches = [[[[0, 2, 8, 10], [1, 3, 9, 11]],\n                [[4, 6, 12, 14], [5, 7, 13, 15]]]]\n    self._VerifyValues(\n        image,\n        ksizes=[2, 2],\n        strides=[1, 1],\n        rates=[2, 2],\n        padding=\"VALID\",\n        patches=patches)\n\n  def testComplexDataTypes(self):\n    \"\"\"Test for complex data types\"\"\"\n    for dtype in [np.complex64, np.complex128]:\n      image = (\n          np.reshape(range(120), [2, 3, 4, 5]).astype(dtype) +\n          np.reshape(range(120, 240), [2, 3, 4, 5]).astype(dtype) * 1j)\n      patches = (\n          np.reshape(range(120), [2, 3, 4, 5]).astype(dtype) +\n          np.reshape(range(120, 240), [2, 3, 4, 5]).astype(dtype) * 1j)\n      for padding in [\"VALID\", \"SAME\"]:\n        self._VerifyValues(\n            image,\n            ksizes=[1, 1],\n            strides=[1, 1],\n            rates=[1, 1],\n            padding=padding,\n            patches=patches)\n\n  def testInvalidAttributes(self):\n    \"\"\"Test for passing weird things into ksizes.\"\"\"\n    with self.assertRaisesRegex(TypeError, \"Expected list\"):\n      image = constant_op.constant([0.0])\n      ksizes = math_ops.cast(\n          constant_op.constant(dtype=dtypes.int16, value=[[1, 4], [5, 2]]),\n          dtype=dtypes.qint16)\n      strides = [1, 1, 1, 1]\n      self.evaluate(\n          array_ops.extract_image_patches(\n              image, ksizes=ksizes, strides=strides, padding=\"SAME\"))\n\nif __name__ == \"__main__\":\n  test.main()"