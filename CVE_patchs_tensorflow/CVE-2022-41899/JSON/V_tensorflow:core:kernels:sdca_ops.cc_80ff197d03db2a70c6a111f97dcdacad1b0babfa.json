"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/sdca_ops.cc.\n\n#define EIGEN_USE_THREADS\n\n#include <stdint.h>\n\n#include <atomic>\n#include <limits>\n#include <memory>\n#include <new>\n#include <string>\n#include <vector>\n\n#include \"absl/strings/str_format.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_def_builder.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/hinge-loss.h\"\n#include \"tensorflow/core/kernels/logistic-loss.h\"\n#include \"tensorflow/core/kernels/loss.h\"\n#include \"tensorflow/core/kernels/poisson-loss.h\"\n#include \"tensorflow/core/kernels/sdca_internal.h\"\n#include \"tensorflow/core/kernels/smooth-hinge-loss.h\"\n#include \"tensorflow/core/kernels/squared-loss.h\"\n#include \"tensorflow/core/lib/core/coding.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/platform/fingerprint.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\nusing sdca::Example;\nusing sdca::Examples;\nusing sdca::ExampleStatistics;\nusing sdca::ModelWeights;\nusing sdca::Regularizations;\n\nstruct ComputeOptions {\n  explicit ComputeOptions(OpKernelConstruction* const context) {\n    string loss_type;\n    OP_REQUIRES_OK(context, context->GetAttr(\"loss_type\", &loss_type));\n    if (loss_type == \"logistic_loss\") {\n      loss_updater.reset(new LogisticLossUpdater);\n    } else if (loss_type == \"squared_loss\") {\n      loss_updater.reset(new SquaredLossUpdater);\n    } else if (loss_type == \"hinge_loss\") {\n      loss_updater.reset(new HingeLossUpdater);\n    } else if (loss_type == \"smooth_hinge_loss\") {\n      loss_updater.reset(new SmoothHingeLossUpdater);\n    } else if (loss_type == \"poisson_loss\") {\n      loss_updater.reset(new PoissonLossUpdater);\n    } else {\n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unsupported loss type: \", loss_type));\n    }\n    auto s = context->GetAttr(\"adaptative\", &adaptive);\n    if (!s.ok()) {\n      s = context->GetAttr(\"adaptive\", &adaptive);\n    }\n    OP_REQUIRES_OK(context, s);\n    OP_REQUIRES_OK(\n        context, context->GetAttr(\"num_sparse_features\", &num_sparse_features));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_sparse_features_with_values\",\n                                             &num_sparse_features_with_values));\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"num_dense_features\", &num_dense_features));\n    OP_REQUIRES(\n        context, num_sparse_features + num_dense_features > 0,\n        errors::InvalidArgument(\"Requires at least one feature to train.\"));\n\n    OP_REQUIRES(context,\n                static_cast<int64_t>(num_sparse_features) +\n                        static_cast<int64_t>(num_dense_features) <=\n                    std::numeric_limits<int>::max(),\n                errors::InvalidArgument(absl::StrFormat(\n                    \"Too many feature groups: %d > %d\",\n                    static_cast<int64_t>(num_sparse_features) +\n                        static_cast<int64_t>(num_dense_features),\n                    std::numeric_limits<int>::max())));\n    OP_REQUIRES_OK(\n        context, context->GetAttr(\"num_loss_partitions\", &num_loss_partitions));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_inner_iterations\",\n                                             &num_inner_iterations));\n    OP_REQUIRES_OK(context, regularizations.Initialize(context));\n  }\n\n  std::unique_ptr<DualLossUpdater> loss_updater;\n  int num_sparse_features = 0;\n  int num_sparse_features_with_values = 0;\n  int num_dense_features = 0;\n  int num_inner_iterations = 0;\n  int num_loss_partitions = 0;\n  bool adaptive = true;\n  Regularizations regularizations;\n};\n\n// TODO(shengx): The helper classes/methods are changed to support multiclass\n// SDCA, which lead to changes within this function. Need to revisit the\n// convergence once the multiclass SDCA is in.\nvoid DoCompute(const ComputeOptions& options, OpKernelContext* const context) {\n  ModelWeights model_weights;\n  OP_REQUIRES_OK(context, model_weights.Initialize(context));\n\n  Examples examples;\n  OP_REQUIRES_OK(\n      context,\n      examples.Initialize(context, model_weights, options.num_sparse_features,\n                          options.num_sparse_features_with_values,\n                          options.num_dense_features));\n\n  const Tensor* example_state_data_t;\n  OP_REQUIRES_OK(context,\n                 context->input(\"example_state_data\", &example_state_data_t));\n  TensorShape expected_example_state_shape({examples.num_examples(), 4});\n  OP_REQUIRES(context,\n              example_state_data_t->shape() == expected_example_state_shape,\n              errors::InvalidArgument(\n                  \"Expected shape \", expected_example_state_shape.DebugString(),\n                  \" for example_state_data, got \",\n                  example_state_data_t->shape().DebugString()));\n\n  Tensor mutable_example_state_data_t(*example_state_data_t);\n  auto example_state_data = mutable_example_state_data_t.matrix<float>();\n  OP_REQUIRES_OK(context, context->set_output(\"out_example_state_data\",\n                                              mutable_example_state_data_t));\n\n  if (options.adaptive) {\n    OP_REQUIRES_OK(context,\n                   examples.SampleAdaptiveProbabilities(\n                       options.num_loss_partitions, options.regularizations,\n                       model_weights, example_state_data, options.loss_updater,\n                       /*num_weight_vectors =*/1));\n  } else {\n    examples.RandomShuffle();\n  }\n  struct {\n    mutex mu;\n    Status value TF_GUARDED_BY(mu);\n  } train_step_status;\n  std::atomic<std::int64_t> atomic_index(-1);\n  auto train_step = [&](const int64_t begin, const int64_t end) {\n    // The static_cast here is safe since begin and end can be at most\n    // num_examples which is an int.\n    for (int id = static_cast<int>(begin); id < end; ++id) {\n      const int64_t example_index = examples.sampled_index(++atomic_index);\n      const Example& example = examples.example(example_index);\n      const float dual = example_state_data(example_index, 0);\n      const float example_weight = example.example_weight();\n      float example_label = example.example_label();\n      const Status conversion_status =\n          options.loss_updater->ConvertLabel(&example_label);\n      if (!conversion_status.ok()) {\n        mutex_lock l(train_step_status.mu);\n        train_step_status.value = conversion_status;\n        // Return from this worker thread - the calling thread is\n        // responsible for checking context status and returning on error.\n        return;\n      }\n\n      // Compute wx, example norm weighted by regularization, dual loss,\n      // primal loss.\n      // For binary SDCA, num_weight_vectors should be one.\n      const ExampleStatistics example_statistics =\n          example.ComputeWxAndWeightedExampleNorm(\n              options.num_loss_partitions, model_weights,\n              options.regularizations, 1 /* num_weight_vectors */);\n\n      const double new_dual = options.loss_updater->ComputeUpdatedDual(\n          options.num_loss_partitions, example_label, example_weight, dual,\n          example_statistics.wx[0], example_statistics.normalized_squared_norm);\n\n      // Compute new weights.\n      const double normalized_bounded_dual_delta =\n          (new_dual - dual) * example_weight /\n          options.regularizations.symmetric_l2();\n      model_weights.UpdateDeltaWeights(\n          context->eigen_cpu_device(), example,\n          std::vector<double>{normalized_bounded_dual_delta});\n\n      // Update example data.\n      example_state_data(example_index, 0) = new_dual;\n      example_state_data(example_index, 1) =\n          options.loss_updater->ComputePrimalLoss(\n              example_statistics.prev_wx[0], example_label, example_weight);\n      example_state_data(example_index, 2) =\n          options.loss_updater->ComputeDualLoss(dual, example_label,\n                                                example_weight);\n      example_state_data(example_index, 3) = example_weight;\n    }\n  };\n  // TODO(sibyl-Aix6ihai): Tune this properly based on sparsity of the data,\n  // number of cpus, and cost per example.\n  const int64_t kCostPerUnit = examples.num_features();\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *context->device()->tensorflow_cpu_worker_threads();\n\n  Shard(worker_threads.num_threads, worker_threads.workers,\n        examples.num_examples(), kCostPerUnit, train_step);\n  mutex_lock l(train_step_status.mu);\n  OP_REQUIRES_OK(context, train_step_status.value);\n}\n\n}  // namespace\n\nclass SdcaOptimizer : public OpKernel {\n public:\n  explicit SdcaOptimizer(OpKernelConstruction* const context)\n      : OpKernel(context), options_(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    DoCompute(options_, context);\n  }\n\n private:\n  // TODO(sibyl-Aix6ihai): We could use the type-constraint on loss_type, and\n  // template the entire class to avoid the virtual table lookup penalty in\n  // the inner loop.\n  ComputeOptions options_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"SdcaOptimizer\").Device(DEVICE_CPU),\n                        SdcaOptimizer);\nREGISTER_KERNEL_BUILDER(Name(\"SdcaOptimizerV2\").Device(DEVICE_CPU),\n                        SdcaOptimizer);\n\nclass SdcaShrinkL1 : public OpKernel {\n public:\n  explicit SdcaShrinkL1(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, regularizations_.Initialize(context));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    OpMutableInputList weights_inputs;\n    OP_REQUIRES_OK(context,\n                   context->mutable_input_list(\"weights\", &weights_inputs));\n\n    auto do_work = [&](const int64_t begin, const int64_t end) {\n      for (int i = begin; i < end; ++i) {\n        auto prox_w = weights_inputs.at(i, /*lock_held=*/true).flat<float>();\n        prox_w.device(context->eigen_cpu_device()) =\n            regularizations_.EigenShrinkVector(prox_w);\n      }\n    };\n\n    if (weights_inputs.size() > 0) {\n      int64_t num_weights = 0;\n      for (int i = 0; i < weights_inputs.size(); ++i) {\n        num_weights += weights_inputs.at(i, /*lock_held=*/true).NumElements();\n      }\n      // TODO(sibyl-Aix6ihai): Tune this value.\n      const int64_t kCostPerUnit = (num_weights * 50) / weights_inputs.size();\n      const DeviceBase::CpuWorkerThreads& worker_threads =\n          *context->device()->tensorflow_cpu_worker_threads();\n      Shard(worker_threads.num_threads, worker_threads.workers,\n            weights_inputs.size(), kCostPerUnit, do_work);\n    }\n  }\n\n private:\n  Regularizations regularizations_;\n};\nREGISTER_KERNEL_BUILDER(Name(\"SdcaShrinkL1\").Device(DEVICE_CPU), SdcaShrinkL1);\n\n// Computes platform independent, compact and unique (with very high\n// probability) representation of an example id. It shouldn't be put in\n// persistent storage, as its implementation may change in the future.\n//\n// The current probability of at least one collision for 1B example_ids is\n// approximately 10^-21 (ie 2^60 / 2^129).\nclass SdcaFprint : public OpKernel {\n public:\n  explicit SdcaFprint(OpKernelConstruction* const context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input.shape()),\n                errors::InvalidArgument(\"Input must be a vector, got shape \",\n                                        input.shape().DebugString()));\n    Tensor* out;\n    const int64_t num_elements = input.NumElements();\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, TensorShape({num_elements, 2}), &out));\n\n    const auto in_values = input.flat<tstring>();\n    auto out_values = out->matrix<int64_t>();\n\n    for (int64_t i = 0; i < num_elements; ++i) {\n      const Fprint128 fprint = Fingerprint128(in_values(i));\n      // Never return 0 or 1 as the first value of the hash to allow these to\n      // safely be used as sentinel values (e.g. dense hash table empty key).\n      out_values(i, 0) = TF_PREDICT_TRUE(fprint.low64 >= 2)\n                             ? fprint.low64\n                             : fprint.low64 + ~static_cast<uint64>(1);\n      out_values(i, 1) = fprint.high64;\n    }\n  }\n};\nREGISTER_KERNEL_BUILDER(Name(\"SdcaFprint\").Device(DEVICE_CPU), SdcaFprint);\n\n}  // namespace tensorflow"