"/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/core/grappler/utils/functions.h\"\n\n#include \"absl/container/flat_hash_map.h\"\n#include \"absl/container/flat_hash_set.h\"\n#include \"absl/strings/str_cat.h\"\n#include \"absl/strings/str_replace.h\"\n#include \"absl/strings/substitute.h\"\n#include \"tensorflow/core/common_runtime/function.h\"\n#include \"tensorflow/core/framework/attr_value.pb.h\"\n#include \"tensorflow/core/framework/function.h\"\n#include \"tensorflow/core/framework/function.pb.h\"\n#include \"tensorflow/core/framework/graph_def_util.h\"\n#include \"tensorflow/core/framework/node_def.pb.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/tensor_shape.pb.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/framework/versions.pb.h\"\n#include \"tensorflow/core/grappler/op_types.h\"\n#include \"tensorflow/core/grappler/utils.h\"\n#include \"tensorflow/core/lib/strings/scanner.h\"\n\nnamespace tensorflow {\nnamespace grappler {\n\nGrapplerFunctionItem::GrapplerFunctionItem(\n    string func_name, string description, AttrSlice func_attr,\n    std::vector<const FunctionDef::ArgAttrs*> arg_attr,\n    std::vector<InputArgInstantiation> input_args,\n    std::vector<OutputArgInstantiation> output_args,\n    std::vector<ControlOutput> control_outputs, const int graph_def_version,\n    const bool is_stateful, GraphDef&& function_body)\n    : description_(std::move(description)),\n      func_attr_(func_attr),\n      arg_attr_(std::move(arg_attr)),\n      input_args_(std::move(input_args)),\n      output_args_(std::move(output_args)),\n      control_outputs_(std::move(control_outputs)),\n      is_stateful_(is_stateful) {\n  id = std::move(func_name);\n  graph = std::move(function_body);\n  graph.mutable_versions()->set_producer(graph_def_version);\n\n  // Fill the feed nodes with function input arguments.\n  for (const InputArgInstantiation& input_arg : input_args_) {\n    feed.push_back({input_arg.node_name, Tensor()});\n  }\n  // Fill the fetch nodes with outputs.\n  for (const OutputArgInstantiation& output_arg : output_args_) {\n    fetch.push_back(output_arg.node_name);\n  }\n  // We must keep all control output nodes.\n  for (const ControlOutput& control_output : control_outputs_) {\n    keep_ops.push_back(control_output.node_name);\n  }\n\n  // Tensorflow functions execution semantics is different from the main graph,\n  // and we need to preserve it when we do graph optimizations.\n  optimization_options().allow_pruning_stateful_and_dataset_ops = false;\n}\n\nconst string& GrapplerFunctionItem::description() const { return description_; }\n\nconst std::vector<InputArgInstantiation>& GrapplerFunctionItem::inputs() const {\n  return input_args_;\n}\n\nconst InputArgInstantiation& GrapplerFunctionItem::input(int i) const {\n  return input_args_[i];\n}\n\nconst std::size_t GrapplerFunctionItem::input_size() const {\n  return input_args_.size();\n}\n\nconst std::vector<OutputArgInstantiation>& GrapplerFunctionItem::outputs()\n    const {\n  return output_args_;\n}\n\nconst OutputArgInstantiation& GrapplerFunctionItem::output(int i) const {\n  return output_args_[i];\n}\n\nconst std::size_t GrapplerFunctionItem::output_size() const {\n  return output_args_.size();\n}\n\nconst std::vector<ControlOutput>& GrapplerFunctionItem::control_outputs()\n    const {\n  return control_outputs_;\n}\n\nconst std::size_t GrapplerFunctionItem::control_output_size() const {\n  return control_outputs_.size();\n}\n\nconst AttrSlice& GrapplerFunctionItem::func_attr() const { return func_attr_; }\n\nconst std::vector<const FunctionDef::ArgAttrs*>&\nGrapplerFunctionItem::arg_attr() const {\n  return arg_attr_;\n}\n\nconst GraphDef& GrapplerFunctionItem::function_body() const { return graph; }\n\nGraphDef& GrapplerFunctionItem::mutable_function_body() { return graph; }\n\nbool GrapplerFunctionItem::is_stateful() const { return is_stateful_; }\n\nGrapplerFunctionItem& GrapplerFunctionItem::SwapFunctionBody(GraphDef&& other) {\n  graph = std::move(other);\n  return *this;\n}\n\nbool HasParametrizedType(const FunctionDef& func) {\n  const auto is_type_parametrized = [](const OpDef::ArgDef& arg) {\n    return !arg.type_attr().empty() || !arg.number_attr().empty() ||\n           !arg.type_list_attr().empty();\n  };\n\n  const auto& input = func.signature().input_arg();\n  const auto& output = func.signature().output_arg();\n  return std::any_of(input.begin(), input.end(), is_type_parametrized) ||\n         std::any_of(output.begin(), output.end(), is_type_parametrized);\n}\n\nbool HasParametrizedBody(const FunctionDef& func) {\n  const auto is_parametrized = [&](const NodeDef& node) {\n    for (const auto& attr : node.attr()) {\n      if (!attr.second.placeholder().empty()) return true;\n    }\n    return false;\n  };\n  return std::any_of(func.node_def().begin(), func.node_def().end(),\n                     is_parametrized);\n}\n\nbool IsParametrized(const FunctionDef& func) {\n  return HasParametrizedType(func) || HasParametrizedBody(func);\n}\n\nStatus InstantiationTypeParameters(\n    const FunctionDef& func, const AttrSlice& func_instantiation_attr,\n    absl::flat_hash_map<string, DataType>* type_parameters) {\n  if (!type_parameters->empty()) {\n    return errors::InvalidArgument(\"Type parameters output map must be empty\");\n  }\n\n  const auto resolve_type_attr = [&](const OpDef::ArgDef& arg) -> Status {\n    if (!arg.type_attr().empty()) {\n      DataType dtype;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(func_instantiation_attr, arg.type_attr(), &dtype));\n      type_parameters->emplace(arg.type_attr(), dtype);\n\n    } else if (!arg.type_list_attr().empty()) {\n      std::vector<DataType> dtypes;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(func_instantiation_attr, arg.type_list_attr(), &dtypes));\n      int index = 0;\n      for (const DataType& dtype : dtypes) {\n        type_parameters->emplace(absl::StrCat(arg.type_list_attr(), \":\", index),\n                                 dtype);\n        ++index;\n      }\n    }\n    return OkStatus();\n  };\n\n  for (const auto& input : func.signature().input_arg())\n    TF_RETURN_IF_ERROR(resolve_type_attr(input));\n  for (const auto& output : func.signature().output_arg())\n    TF_RETURN_IF_ERROR(resolve_type_attr(output));\n\n  return OkStatus();\n}\n\nStatus InstantiationBodyParameters(\n    const FunctionDef& func, const AttrSlice& func_instantiation_attr,\n    absl::flat_hash_map<string, AttrValue>* body_parameters) {\n  if (!body_parameters->empty()) {\n    return errors::InvalidArgument(\"Body parameters output map must be empty\");\n  }\n\n  for (const NodeDef& func_body_node : func.node_def()) {\n    for (auto& attr : func_body_node.attr()) {\n      const string& placeholder = attr.second.placeholder();\n\n      if (placeholder.empty() || body_parameters->contains(placeholder)) {\n        continue;\n      }\n\n      const AttrValue* placeholder_value =\n          func_instantiation_attr.Find(placeholder);\n      if (placeholder_value) {\n        body_parameters->insert({placeholder, *placeholder_value});\n      } else {\n        return errors::InvalidArgument(\"Can't resolve placeholder: \",\n                                       placeholder);\n      }\n    }\n  }\n\n  return OkStatus();\n}\n\nStatus MakeGrapplerFunctionItem(const FunctionDef& func,\n                                const AttrSlice& func_instantiation_attr,\n                                const FunctionLibraryDefinition& flib,\n                                const int graph_def_version,\n                                GrapplerFunctionItem* item) {\n  const OpDef& signature = func.signature();\n\n  if (signature.name().empty()) {\n    return errors::InvalidArgument(\"Function name must be specified\");\n  }\n\n  // Function types will be resolved from function instantiation attributes. All\n  // other attributes will be lost during conversion to FunctionDef.\n  for (const OpDef::AttrDef& attr : signature.attr()) {\n    if (attr.type() != \"type\") {\n      return errors::InvalidArgument(\n          \"Function signature must have only type attributes\");\n    }\n  }\n\n  // Instantiate function into a statically defined FunctionBody Graph.\n  std::unique_ptr<FunctionBody> fbody;\n  TF_RETURN_IF_ERROR(\n      FunctionDefToBodyHelper(func, func_instantiation_attr, &flib, &fbody));\n\n  GraphDef function_body;\n  fbody->graph->ToGraphDef(&function_body);\n\n  // Function body shares the library with the graph that instantiated it. We do\n  // not need a full copy of the function library, just the reachable subset.\n  *function_body.mutable_library() = flib.ReachableDefinitions(func).ToProto();\n\n  VLOG(3) << absl::Substitute(\n      \"Deleted $0 unreachable functions from the Grappler function item \"\n      \"instantiation of $1 (library size = $2)\",\n      flib.num_functions() - function_body.library().function_size(),\n      signature.name(), function_body.library().function_size());\n\n  const int num_instantiated_inputs = fbody->arg_types.size();\n  const int num_instantiated_outputs = fbody->ret_types.size();\n\n  std::vector<InputArgInstantiation> inputs;\n  inputs.reserve(num_instantiated_inputs);\n\n  for (int in_id = 0; in_id < num_instantiated_inputs; ++in_id) {\n    const Node* node = fbody->arg_nodes[in_id];\n    const DataType& dtype = fbody->arg_types[in_id];\n    inputs.emplace_back(node->name(), dtype);\n  }\n\n  std::vector<OutputArgInstantiation> outputs;\n  outputs.reserve(num_instantiated_outputs);\n\n  for (int out_id = 0; out_id < num_instantiated_outputs; ++out_id) {\n    const Node* node = fbody->ret_nodes[out_id];\n    const DataType& dtype = fbody->ret_types[out_id];\n    outputs.emplace_back(node->name(), dtype);\n  }\n\n  // Control outputs ensure that all side-effectful nodes in the function body\n  // will execute, even if they are not required to compute regular output args.\n  std::vector<ControlOutput> control_outputs;\n  control_outputs.reserve(func.control_ret_size());\n  for (const auto& control_ret : func.control_ret()) {\n    control_outputs.push_back({control_ret.first, control_ret.second});\n  }\n  // Sort control outputs to keep FunctionDef output stable. The sort order of\n  // map entries in func.control_ret() are not stable.\n  // See b/174715578 for context on why stability is desired.\n  std::sort(control_outputs.begin(), control_outputs.end());\n\n  std::vector<const FunctionDef::ArgAttrs*> arg_attr(inputs.size(), nullptr);\n  for (const auto& attr : func.arg_attr()) {\n    arg_attr.at(attr.first) = &attr.second;\n  }\n\n  *item = GrapplerFunctionItem(\n      /*func_name=*/signature.name(),\n      /*description=*/signature.description(),\n      /*func_attr=*/AttrSlice(&func.attr()), std::move(arg_attr),\n      std::move(inputs), std::move(outputs), std::move(control_outputs),\n      graph_def_version, signature.is_stateful(), std::move(function_body));\n  return OkStatus();\n}\n\nStatus MakeGrapplerFunctionItem(const FunctionDef& func,\n                                const FunctionLibraryDefinition& flib,\n                                const int graph_def_version,\n                                GrapplerFunctionItem* item) {\n  return MakeGrapplerFunctionItem(func, AttrSlice(), flib, graph_def_version,\n                                  item);\n}\n\nStatus ReplaceInputWithConst(const NodeDef& input_const, int input_index,\n                             GrapplerFunctionItem* item) {\n  if (!IsConstant(input_const)) {\n    return errors::InvalidArgument(\"Input node is not a constant: \",\n                                   SummarizeNodeDef(input_const));\n  }\n  const int item_input_size = item->input_size();\n  if (input_index < 0 || input_index >= item_input_size) {\n    return errors::InvalidArgument(\n        \"Function input index is out of bound: index=\", input_index,\n        \" input_size=\", item->input_size());\n  }\n\n  const InputArgInstantiation& input_arg = item->input(input_index);\n\n  for (NodeDef& node : *item->graph.mutable_node()) {\n    // Replace '_Arg' node in the function body with a 'Const' node.\n    if (node.name() == input_arg.node_name) {\n      node = input_const;\n      node.set_name(input_arg.node_name);\n      node.clear_input();\n      node.clear_device();  // device placement is defined by instantiating node\n    }\n\n    // Update index in all inputs after the removed const input.\n    if (IsArg(node)) {\n      auto attrs = AttrSlice(node);\n      int index;\n      TF_RETURN_IF_ERROR(GetNodeAttr(attrs, \"index\", &index));\n      if (index >= input_index) {\n        (*node.mutable_attr())[\"index\"].set_i(index - 1);\n      }\n    }\n  }\n\n  item->input_args_.erase(item->input_args_.begin() + input_index);\n  item->arg_attr_.erase(item->arg_attr_.begin() + input_index);\n\n  return OkStatus();\n}\n\nStatus RemoveFunctionOutputs(const absl::flat_hash_set<int>& remove_outputs,\n                             GrapplerFunctionItem* item,\n                             std::vector<std::pair<int, int>>* output_mapping) {\n  DCHECK(output_mapping->empty());\n\n  // Do some sanity checking of the removed outputs positions.\n  for (int remove_output : remove_outputs) {\n    const int item_output_size = item->output_size();\n    if (remove_output < 0 || remove_output >= item_output_size) {\n      return errors::InvalidArgument(\n          \"Function output index is out of bound: index=\", remove_output,\n          \" output_size=\", item->output_size());\n    }\n  }\n\n  absl::flat_hash_set<const OutputArgInstantiation*> remove_output_args;\n  const auto is_remove_output_arg = [&](const OutputArgInstantiation& output) {\n    return remove_output_args.find(&output) != remove_output_args.end();\n  };\n\n  for (int i = 0, end = item->output_size(); i < end; ++i) {\n    const OutputArgInstantiation& output = item->output(i);\n    if (remove_outputs.contains(i)) {\n      VLOG(3) << \"Remove functions output: name=\" << output.node_name\n              << \"(index = \" << i << \")\";\n      remove_output_args.insert(&output);\n    } else if (!remove_output_args.empty()) {\n      // Add output mapping only if output position changed.\n      output_mapping->push_back({i, i - remove_output_args.size()});\n    }\n  }\n\n  // Update 'index' attribute in all '_Retval' nodes that are in output mapping.\n  for (NodeDef& node : *item->graph.mutable_node()) {\n    if (IsRetval(node)) {\n      auto attrs = AttrSlice(node);\n      int index;\n      TF_RETURN_IF_ERROR(GetNodeAttr(attrs, \"index\", &index));\n\n      for (const auto& mapping : *output_mapping) {\n        const int from = mapping.first;\n        const int to = mapping.second;\n        if (index == from) {\n          (*node.mutable_attr())[\"index\"].set_i(to);\n        }\n      }\n    }\n  }\n\n  auto& o = item->output_args_;\n  o.erase(std::remove_if(o.begin(), o.end(), is_remove_output_arg), o.end());\n\n  return OkStatus();\n}\n\nnamespace {\n\n// FunctionDef uses different connectivity encoding for the function body nodes,\n// than a GraphDef (see function.proto for details). This is a helper class that\n// converts inputs in GraphDef format (node[:position]) to the FunctionDef\n// format (node:output[:position]).\nclass MakeFunctionDefHelper {\n public:\n  MakeFunctionDefHelper() = default;\n\n  Status Initialize(const GrapplerFunctionItem& item,\n                    const FunctionLibraryDefinition& flib);\n\n  // Converts input name from GraphDef format (name[:position]) to the\n  // FunctionDef input format (name[:output][:position]) using registered input\n  // arg instantiations and function body outputs.\n  Status AsFunctionDefInput(const string& graph_def_input,\n                            string* func_def_input) const;\n\n  // Updates Node inputs from GraphDef to FunctionDef format.\n  Status AsFunctionDefNode(NodeDef* function_body_node) const;\n\n  bool IsInputNode(const NodeDef& node) const {\n    return input_nodes_.contains(node.name());\n  }\n\n  bool IsOutputNode(const NodeDef& node) const {\n    return output_nodes_.contains(node.name());\n  }\n\n private:\n  absl::flat_hash_set<absl::string_view> input_nodes_;\n  absl::flat_hash_set<absl::string_view> output_nodes_;\n  // Mapping from function body node name to output names range map.\n  absl::flat_hash_map<string, tensorflow::NameRangeMap> function_body_outputs_;\n};\n\nStatus MakeFunctionDefHelper::Initialize(\n    const GrapplerFunctionItem& item, const FunctionLibraryDefinition& flib) {\n  for (const InputArgInstantiation& input_arg : item.inputs()) {\n    input_nodes_.insert(input_arg.node_name);\n  }\n  for (const OutputArgInstantiation& output_arg : item.outputs()) {\n    output_nodes_.insert(output_arg.node_name);\n  }\n\n  for (const NodeDef& node : item.function_body().node()) {\n    const OpRegistrationData* registration;\n    TF_RETURN_IF_ERROR(flib.LookUp(node.op(), &registration));\n\n    tensorflow::NameRangeMap outputs_range_map;\n    TF_RETURN_IF_ERROR(tensorflow::NameRangesForNode(\n        node, registration->op_def, nullptr, &outputs_range_map));\n\n    function_body_outputs_.emplace(node.name(), std::move(outputs_range_map));\n  }\n\n  return OkStatus();\n}\n\nStatus MakeFunctionDefHelper::AsFunctionDefInput(const string& graph_def_input,\n                                                 string* func_def_input) const {\n  if (IsControlInput(graph_def_input)) {\n    *func_def_input = graph_def_input;\n    return OkStatus();\n  }\n\n  const SafeTensorId tensor = ParseTensorName(graph_def_input);\n  DCHECK_GE(tensor.index(), 0);\n\n  // Graph def input corresponds to one of the function inputs.\n  const auto is_input = input_nodes_.find(tensor.node());\n  if (is_input != input_nodes_.end()) {\n    DCHECK_EQ(tensor.index(), 0);\n    *func_def_input = tensor.node();\n    return OkStatus();\n  }\n\n  // Or it must be output from one of the function body nodes\n  const auto is_body_output = function_body_outputs_.find(tensor.node());\n  if (is_body_output != function_body_outputs_.end()) {\n    const tensorflow::NameRangeMap& outputs_range_map = is_body_output->second;\n\n    for (const auto& el : outputs_range_map) {\n      const auto& output_name = el.first;\n      const auto& output_range = el.second;\n      if (tensor.index() >= output_range.first &&\n          tensor.index() < output_range.second) {\n        *func_def_input = absl::StrCat(tensor.node(), \":\", output_name, \":\",\n                                       tensor.index() - output_range.first);\n        return OkStatus();\n      }\n    }\n  }\n\n  return errors::InvalidArgument(\"Unknown graph def input: \", graph_def_input);\n}\n\nStatus MakeFunctionDefHelper::AsFunctionDefNode(\n    NodeDef* function_body_node) const {\n  string func_def_input;\n\n  for (int i = 0; i < function_body_node->input_size(); ++i) {\n    TF_RETURN_IF_ERROR(\n        AsFunctionDefInput(function_body_node->input(i), &func_def_input));\n    function_body_node->set_input(i, func_def_input);\n  }\n\n  return OkStatus();\n}\n\n}  // namespace\n\nStatus MakeFunctionDef(const GrapplerFunctionItem& item,\n                       const FunctionLibraryDefinition& flib,\n                       FunctionDef* func) {\n  func->mutable_signature()->set_name(item.id);\n  func->mutable_signature()->set_description(item.description());\n  func->mutable_signature()->set_is_stateful(item.is_stateful());\n\n  MakeFunctionDefHelper helper;\n  TF_RETURN_IF_ERROR(helper.Initialize(item, flib));\n\n  // Mapping from the '_Retval' node name to the output tensor.\n  absl::flat_hash_map<absl::string_view, string> output_tensors;\n  for (const NodeDef& func_body_node : item.function_body().node()) {\n    if (!helper.IsOutputNode(func_body_node)) continue;\n    if (func_body_node.input_size() != 1) {\n      return errors::Internal(\"_Retval node must have single input: \",\n                              SummarizeNodeDef(func_body_node));\n    }\n    output_tensors.emplace(func_body_node.name(), func_body_node.input(0));\n  }\n\n  for (const InputArgInstantiation& input_arg : item.inputs()) {\n    OpDef::ArgDef arg_def;\n    arg_def.set_name(input_arg.node_name);\n    arg_def.set_type(input_arg.data_type);\n    arg_def.set_is_ref(IsRefType(input_arg.data_type));\n    *func->mutable_signature()->add_input_arg() = arg_def;\n  }\n\n  // Add function output arguments.\n  for (const OutputArgInstantiation& output_arg : item.outputs()) {\n    const string output_name =\n        absl::StrReplaceAll(output_arg.node_name, {{\"_RetVal\", \"\"}});\n\n    OpDef::ArgDef arg_def;\n    arg_def.set_name(output_name);\n    arg_def.set_type(output_arg.data_type);\n    arg_def.set_is_ref(IsRefType(output_arg.data_type));\n    *func->mutable_signature()->add_output_arg() = arg_def;\n\n    auto it = output_tensors.find(output_arg.node_name);\n    if (it == output_tensors.end()) {\n      return errors::Internal(\n          \"Can't find an output tensor for the output node: \",\n          output_arg.node_name);\n    }\n\n    TF_RETURN_IF_ERROR(helper.AsFunctionDefInput(\n        it->second, &(*func->mutable_ret())[output_name]));\n  }\n\n  // Add function control outputs.\n  for (const ControlOutput& control_out : item.control_outputs()) {\n    func->mutable_control_ret()->insert(\n        {control_out.output_name, control_out.node_name});\n    *func->mutable_signature()->add_control_output() = control_out.output_name;\n  }\n\n  // Copy function definition specific attributes.\n  for (const auto& attr : item.func_attr()) {\n    const auto& attr_name = attr.first;\n    const auto& attr_value = attr.second;\n    (*func->mutable_attr())[attr_name] = attr_value;\n  }\n\n  // Copy function arg attributes.\n  for (int i = 0, end = item.arg_attr().size(); i < end; ++i) {\n    const auto* attr = item.arg_attr().at(i);\n    if (attr != nullptr) {\n      (*func->mutable_arg_attr())[i] = *attr;\n    }\n  }\n\n  // Copy function body nodes to the FunctionDef and update input format\n  for (const NodeDef& func_node : item.function_body().node()) {\n    // Skip original `_Arg` and `_Retval` nodes. If node was converted to some\n    // other type (e.g. inputs converted to placeholders), we need to check that\n    // it's not registered as function input or output node.\n    if (IsArg(func_node) || IsRetval(func_node) ||\n        helper.IsInputNode(func_node) || helper.IsOutputNode(func_node))\n      continue;\n\n    NodeDef* func_def_node = func->add_node_def();\n    *func_def_node = func_node;\n    TF_RETURN_IF_ERROR(helper.AsFunctionDefNode(func_def_node));\n  }\n\n  return OkStatus();\n}\n\n}  // end namespace grappler\n}  // end namespace tensorflow"