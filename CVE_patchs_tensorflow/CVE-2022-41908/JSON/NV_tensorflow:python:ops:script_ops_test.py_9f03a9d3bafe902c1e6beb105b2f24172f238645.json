"# Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for script operations.\"\"\"\n\nfrom tensorflow.python.eager import def_function\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import gen_script_ops\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.ops import script_ops\nfrom tensorflow.python.ops.script_ops import numpy_function\nfrom tensorflow.python.platform import test\n\n\nclass NumpyFunctionTest(test.TestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_numpy_arguments(self):\n\n    def plus(a, b):\n      return a + b\n\n    actual_result = script_ops.numpy_function(plus, [1, 2], dtypes.int32)\n    expect_result = constant_op.constant(3, dtypes.int32)\n    self.assertAllEqual(actual_result, expect_result)\n\n  def test_stateless(self):\n    call_count = 0\n\n    def plus(a, b):\n      nonlocal call_count\n      call_count += 1\n      return a + b\n\n    @def_function.function\n    def numpy_func_stateless(a, b):\n      return numpy_function(plus, [a, b], dtypes.int32, stateful=False)\n\n    @def_function.function\n    def func_stateless(a, b):\n      sum1 = numpy_func_stateless(a, b)\n      sum2 = numpy_func_stateless(a, b)\n      return sum1 + sum2\n\n    self.evaluate(func_stateless(\n        constant_op.constant(1),\n        constant_op.constant(2),\n    ))\n\n    self.assertIn(call_count, (1, 2))  # as stateless, func may be deduplicated\n\n  def test_stateful(self):\n    call_count = 0\n\n    def plus(a, b):\n      nonlocal call_count\n      call_count += 1\n      return a + b\n\n    @def_function.function\n    def numpy_func_stateful(a, b):\n      return numpy_function(plus, [a, b], dtypes.int32, stateful=True)\n\n    @def_function.function\n    def func_stateful(a, b):\n      sum1 = numpy_func_stateful(a, b)\n      sum2 = numpy_func_stateful(a, b)\n      return sum1 + sum2\n\n    self.evaluate(func_stateful(\n        constant_op.constant(1),\n        constant_op.constant(2),\n    ))\n\n    self.assertEqual(call_count,\n                     2)  # as stateful, func is guaranteed to execute twice\n\n\nclass PyFunctionTest(test.TestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_variable_arguments(self):\n\n    def plus(a, b):\n      return a + b\n\n    v1 = resource_variable_ops.ResourceVariable(1)\n    self.evaluate(v1.initializer)\n\n    actual_result = script_ops.eager_py_func(plus, [v1, 2], dtypes.int32)\n    expect_result = constant_op.constant(3, dtypes.int32)\n    self.assertAllEqual(actual_result, expect_result)\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_fail_on_non_utf8_token(self):\n    value = constant_op.constant(value=[1, 2])\n    token = b\"\\xb0\"\n    data_type = [dtypes.int32]\n    with self.assertRaises((errors.InternalError, UnicodeDecodeError)):\n      self.evaluate(\n          gen_script_ops.py_func(input=[value], token=token, Tout=data_type))\n\n\nif __name__ == \"__main__\":\n  test.main()"