"/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/op_requires.h\"\n#include \"tensorflow/core/framework/variant.h\"\n#include \"tensorflow/core/framework/variant_encode_decode.h\"\n#include \"tensorflow/core/kernels/composite_tensor_variant.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/protobuf/composite_tensor_variant.pb.h\"\n#include \"tensorflow/core/protobuf/struct.pb.h\"\n\nnamespace tensorflow {\n\nclass CompositeTensorVariantFromComponents : public OpKernel {\n public:\n  explicit CompositeTensorVariantFromComponents(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string type_spec_string;\n    OP_REQUIRES_OK(context, context->GetAttr(\"metadata\", &type_spec_string));\n    OP_REQUIRES(context, metadata_.ParseFromString(type_spec_string),\n                errors::InvalidArgument(\"Error parsing metadata\"));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    OpInputList components_in;\n    OP_REQUIRES_OK(context, context->input_list(\"components\", &components_in));\n\n    Tensor* encoded;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({}), &encoded));\n\n    std::vector<Tensor> components{components_in.begin(), components_in.end()};\n    encoded->flat<Variant>()(0) =\n        CompositeTensorVariant(metadata_, absl::MakeSpan(components));\n  }\n\n private:\n  CompositeTensorVariantMetadata metadata_;\n};\n\nclass CompositeTensorVariantToComponents : public OpKernel {\n public:\n  explicit CompositeTensorVariantToComponents(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string type_spec_string;\n    OP_REQUIRES_OK(context, context->GetAttr(\"metadata\", &type_spec_string));\n    OP_REQUIRES(context, metadata_.ParseFromString(type_spec_string),\n                errors::InvalidArgument(\"Error parsing `metadata`\"));\n\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"Tcomponents\", &component_dtypes_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    Tensor encoded_t = context->input(0);\n    OP_REQUIRES(\n        context, encoded_t.flat<Variant>().size() > 0,\n        errors::InvalidArgument(\"Input `encoded` must not be an empty variant \"\n                                \"tensor, but got \",\n                                encoded_t.DebugString()));\n    auto* encoded = encoded_t.flat<Variant>()(0).get<CompositeTensorVariant>();\n    OP_REQUIRES(context, encoded != nullptr,\n                errors::InvalidArgument(\"The input `encoded` is not a valid \"\n                                        \"CompositeTensorVariant tensor, got \",\n                                        encoded_t.DebugString()));\n\n    // Check that the encoded TypeSpec is compatible with the expected TypeSpec.\n    // For now, we just check that the class matches.\n    //\n    // TODO(b/173744905): Update this to do a generic compatibility check. This\n    // would require replacing the current design, where Python subclasses of\n    // TypeSpec can override is_compatible, with a design where compatibility\n    // can be deterministically determined from the metadata.\n    auto expected_class = metadata_.type_spec_proto().type_spec_class();\n    auto actual_class = encoded->metadata().type_spec_proto().type_spec_class();\n    OP_REQUIRES(\n        context, expected_class == actual_class,\n        errors::InvalidArgument(\n            \"Expected a \", TypeSpecProto::TypeSpecClass_Name(expected_class),\n            \" (based on `type_spec`), but `encoded` contains a \",\n            TypeSpecProto::TypeSpecClass_Name(actual_class)));\n\n    // Extract the component tensors.\n    OpOutputList components;\n    OP_REQUIRES_OK(context, context->output_list(\"components\", &components));\n    int num_components = encoded->flat_components().size();\n\n    OP_REQUIRES(context, component_dtypes_.size() == num_components,\n                errors::InvalidArgument(\"Encoded value has \", num_components,\n                                        \" tensor components; expected \",\n                                        component_dtypes_.size(),\n                                        \" components based on type_spec\"));\n\n    for (int i = 0; i < component_dtypes_.size(); i++) {\n      const Tensor& component = encoded->flat_components()[i];\n      OP_REQUIRES(context, component_dtypes_[i] == component.dtype(),\n                  errors::InvalidArgument(\"Tensor component \", i, \" had dtype \",\n                                          DataType_Name(component.dtype()),\n                                          \"; expected dtype \",\n                                          DataType_Name(component_dtypes_[i])));\n      components.set(i, component);\n    }\n  }\n\n private:\n  CompositeTensorVariantMetadata metadata_;\n  std::vector<DataType> component_dtypes_;\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"CompositeTensorVariantToComponents\").Device(DEVICE_CPU),\n    CompositeTensorVariantToComponents);\nREGISTER_KERNEL_BUILDER(\n    Name(\"CompositeTensorVariantFromComponents\").Device(DEVICE_CPU),\n    CompositeTensorVariantFromComponents);\n\n}  // namespace tensorflow"