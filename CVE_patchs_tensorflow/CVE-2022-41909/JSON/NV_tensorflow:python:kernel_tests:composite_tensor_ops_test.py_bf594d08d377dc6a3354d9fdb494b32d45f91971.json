"# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for composite_tensor_ops.\"\"\"\n\nfrom absl.testing import parameterized\n\nfrom tensorflow.python.eager import backprop\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import composite_tensor_ops\nfrom tensorflow.python.ops import gen_composite_tensor_ops\nfrom tensorflow.python.ops import gen_list_ops\nfrom tensorflow.python.ops import gradients_impl\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import parsing_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.ops.ragged import ragged_factory_ops\nfrom tensorflow.python.ops.ragged import ragged_tensor\nfrom tensorflow.python.platform import googletest\nfrom tensorflow.python.util import nest\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass ExtensionTypeTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  @parameterized.named_parameters([\n      ('Ragged', lambda: ragged_factory_ops.constant([[1, 2], [3], [4, 5, 6]])),\n      ('Sparse', lambda: sparse_ops.from_dense([[0, 0, 3, 0], [1, 2, 0, 0]])),\n  ])\n  def testEncodeAndDecode(self, value_factory):\n    value = value_factory()\n\n    encoded = composite_tensor_ops.composite_tensor_to_variants(value)\n    self.assertEqual(encoded.dtype, dtypes.variant)\n    self.assertEqual(encoded.shape.rank, 0)\n\n    decoded = composite_tensor_ops.composite_tensor_from_variant(\n        encoded, value._type_spec)\n    self.assertTrue(value._type_spec.is_compatible_with(decoded._type_spec))\n    value_components = nest.flatten(value, expand_composites=True)\n    decoded_components = nest.flatten(decoded, expand_composites=True)\n    self.assertLen(value_components, len(decoded_components))\n    for v, d in zip(value_components, decoded_components):\n      self.assertAllEqual(v, d)\n\n  @parameterized.named_parameters([\n      ('WrongType', lambda: ragged_factory_ops.constant([[1]]),\n       sparse_tensor.SparseTensorSpec([None, None], dtypes.int32),\n       r'Expected a SPARSE_TENSOR_SPEC \\(based on `type_spec`\\), but `encoded` '\n       'contains a RAGGED_TENSOR_SPEC'),\n      ('WrongNumComponents', lambda: ragged_factory_ops.constant([[1]]),\n       ragged_tensor.RaggedTensorSpec([None, None, None], dtypes.int32),\n       'Encoded value has 2 tensor components; expected 3 components'),\n      ('WrongDType', lambda: ragged_factory_ops.constant([[1]]),\n       ragged_tensor.RaggedTensorSpec([None, None], dtypes.float32),\n       'Tensor component 0 had dtype DT_INT32; expected dtype DT_FLOAT'),\n  ])\n  def testDecodingErrors(self, value, spec, message):\n    encoded = composite_tensor_ops.composite_tensor_to_variants(value())\n    with self.assertRaisesRegex(errors.InvalidArgumentError, message):\n      self.evaluate(\n          composite_tensor_ops.composite_tensor_from_variant(encoded, spec))\n\n  @parameterized.named_parameters([\n      ('IncompatibleSpec', lambda: ragged_factory_ops.constant([[1]]),\n       ragged_tensor.RaggedTensorSpec([None, None, None], dtypes.int32),\n       r'`type_spec` .* is not compatible with `value` .*'),\n  ])\n  def testEncodingErrors(self, value, spec, message):\n    with self.assertRaisesRegex(ValueError, message):\n      composite_tensor_ops.composite_tensor_to_variants(value(), spec)\n\n  def testDecodingEmptyNonScalarTensorError(self):\n    if not context.executing_eagerly():\n      # Creating a variant tensor of an empty list is not allowed in eager mode.\n      return\n\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                'must not be an empty variant tensor'):\n      gen_composite_tensor_ops.CompositeTensorVariantToComponents(\n          encoded=constant_op.constant([], dtype=dtypes.variant),\n          metadata='',\n          Tcomponents=[dtypes.int32])\n\n  def testDecodingInvalidEncodedInputError(self):\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                'not a valid CompositeTensorVariant tensor'):\n      self.evaluate(\n          gen_composite_tensor_ops.CompositeTensorVariantToComponents(\n              encoded=gen_list_ops.EmptyTensorList(\n                  element_dtype=dtypes.int32,\n                  element_shape=[1, 2],\n                  max_num_elements=2),\n              metadata='',\n              Tcomponents=[dtypes.int32]))\n\n  def testRoundTripThroughTensorProto(self):\n    value = ragged_factory_ops.constant([[1, 2], [3], [4, 5, 6]])\n    encoded = composite_tensor_ops.composite_tensor_to_variants(value)\n    proto = parsing_ops.SerializeTensor(tensor=encoded)\n    parsed = parsing_ops.ParseTensor(serialized=proto, out_type=dtypes.variant)\n    decoded = composite_tensor_ops.composite_tensor_from_variant(\n        parsed, value._type_spec)\n    self.assertAllEqual(value, decoded)\n\n  def testGradient(self):\n\n    def func(x):\n      x2 = composite_tensor_ops.composite_tensor_to_variants(x * 2)\n      x3 = composite_tensor_ops.composite_tensor_from_variant(x2, x._type_spec)\n      return x3.with_values(x3.values * math_ops.range(6.0))\n\n    x = ragged_factory_ops.constant([[1.0, 2.0, 3.0], [4.0], [5.0, 6.0]])\n    if context.executing_eagerly():\n      with backprop.GradientTape() as t:\n        t.watch(x.values)\n        y = func(x)\n        g = t.gradient(y.values, x.values)\n    else:\n      y = func(x)\n      g = gradients_impl.gradients(ys=y.values, xs=x.values)[0]\n    self.assertAllClose(g, [0.0, 2.0, 4.0, 6.0, 8.0, 10.0])\n\n\nif __name__ == '__main__':\n  googletest.main()"