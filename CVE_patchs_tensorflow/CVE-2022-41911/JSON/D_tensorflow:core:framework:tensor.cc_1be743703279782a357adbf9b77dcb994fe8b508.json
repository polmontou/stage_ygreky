"diff --git a/tensorflow/core/framework/tensor.cc b/tensorflow/core/framework/tensor.cc\nindex 14c0d4a0e6e..74f1a1bd03e 100644\n--- a/tensorflow/core/framework/tensor.cc\n+++ b/tensorflow/core/framework/tensor.cc\n@@ -29,6 +29,7 @@ limitations under the License.\n \n #include \"tensorflow/core/framework/tensor.h\"\n \n+#include <memory>\n #include <utility>\n \n #include \"absl/strings/escaping.h\"\n@@ -1183,12 +1184,10 @@ void PrintOneDimV2(int dim_index, const gtl::InlinedVector<int64, 4>& shape,\n }\n \n template <typename T>\n-string SummarizeArray(int64_t limit, int64_t num_elts,\n-                      const TensorShape& tensor_shape, const char* data,\n-                      const bool print_v2) {\n+string SummarizeArrayInternal(int64_t limit, int64_t num_elts,\n+                              const TensorShape& tensor_shape, const T* array,\n+                              const bool print_v2) {\n   string ret;\n-  const T* array = reinterpret_cast<const T*>(data);\n-\n   const gtl::InlinedVector<int64_t, 4> shape = tensor_shape.dim_sizes();\n   if (shape.empty()) {\n     for (int64_t i = 0; i < limit; ++i) {\n@@ -1211,6 +1210,29 @@ string SummarizeArray(int64_t limit, int64_t num_elts,\n \n   return ret;\n }\n+\n+template <typename T>\n+string SummarizeArray(int64_t limit, int64_t num_elts,\n+                      const TensorShape& tensor_shape, const char* data,\n+                      const bool print_v2) {\n+  const T* array = reinterpret_cast<const T*>(data);\n+  return SummarizeArrayInternal<T>(limit, num_elts, tensor_shape, array,\n+                                   print_v2);\n+}\n+\n+template <>\n+string SummarizeArray<bool>(int64_t limit, int64_t num_elts,\n+                            const TensorShape& tensor_shape, const char* data,\n+                            const bool print_v2) {\n+  // We first convert all chars to be 0/1 to not get InvalidEnumValue sanitizer\n+  // error\n+  auto mutable_data = std::unique_ptr<char[]>(new char[num_elts]);\n+  for (int64_t i = 0; i < num_elts; ++i)\n+    mutable_data.get()[i] = data[i] ? 1 : 0;\n+  bool* array = reinterpret_cast<bool*>(mutable_data.get());\n+  return SummarizeArrayInternal<bool>(limit, num_elts, tensor_shape, array,\n+                                      print_v2);\n+}\n }  // namespace\n \n string Tensor::SummarizeValue(int64_t max_entries, bool print_v2) const {"