"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Implementation notes:\n//\n// Tensor.cc uses a few templated classes and structs to facilitate\n// implementation of the Tensor class.\n//\n// * Buffer<T>: provides the implementation for a typed array T[n].\n//   The array is allocated by the given allocator. It runs T's\n//   default constructors and destructors when T is not a simple type\n//   (e.g., string.), and skips them otherwise.\n//\n// * Helper<T>: provides various routines given type T.  The routines\n//   includes running the constructor and destructor of T[], encoding\n//   an decoding T[] into/from a Cord, etc.\n\n#include \"tensorflow/core/framework/tensor.h\"\n\n#include <memory>\n#include <utility>\n\n#include \"absl/strings/escaping.h\"\n#include \"tensorflow/core/framework/allocation_description.pb.h\"\n#include \"tensorflow/core/framework/log_memory.h\"\n#include \"tensorflow/core/framework/resource_handle.h\"\n#include \"tensorflow/core/framework/resource_handle.pb.h\"\n#include \"tensorflow/core/framework/tensor.pb.h\"\n#include \"tensorflow/core/framework/tensor_description.pb.h\"\n#include \"tensorflow/core/framework/type_traits.h\"\n#include \"tensorflow/core/framework/typed_allocator.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/framework/variant.h\"\n#include \"tensorflow/core/framework/variant_encode_decode.h\"\n#include \"tensorflow/core/framework/variant_op_registry.h\"\n#include \"tensorflow/core/framework/variant_tensor_data.h\"\n#include \"tensorflow/core/lib/core/coding.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/protobuf.h\"\n#include \"tensorflow/core/platform/tensor_coding.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\n\n// Allow Tensors to be stored inside Variants with automatic\n// encoding/decoding when those Variants are themselves being decoded\n// in a Tensor's FromProto.\n//\n// NOTE(mrry): The corresponding \"copy function\" registrations can be found in\n// ../common_runtime/copy_tensor.cc (due to dependencies on other common_runtime\n// code).\nREGISTER_UNARY_VARIANT_DECODE_FUNCTION(Tensor, \"tensorflow::Tensor\");\n\nbool TensorBuffer::GetAllocatedBytes(size_t* out_bytes) const {\n  AllocationDescription allocation_description;\n  FillAllocationDescription(&allocation_description);\n  if (allocation_description.allocated_bytes() > 0) {\n    *out_bytes = allocation_description.allocated_bytes();\n    return true;\n  } else {\n    return false;\n  }\n}\n\nnamespace {\n\n// An un-templated base class for Buffer.\nclass BufferBase : public TensorBuffer {\n public:\n  explicit BufferBase(Allocator* alloc, void* data_ptr)\n      : TensorBuffer(data_ptr), alloc_(alloc) {}\n\n  TensorBuffer* root_buffer() override { return this; }\n\n  bool GetAllocatedBytes(size_t* out_bytes) const override {\n    if (alloc_->TracksAllocationSizes()) {\n      *out_bytes = alloc_->AllocatedSize(data());\n      return *out_bytes > 0;\n    } else {\n      return false;\n    }\n  }\n\n  void FillAllocationDescription(AllocationDescription* proto) const override {\n    void* data_ptr = data();\n    int64_t rb = size();\n    proto->set_requested_bytes(rb);\n    proto->set_allocator_name(alloc_->Name());\n    proto->set_ptr(reinterpret_cast<uintptr_t>(data_ptr));\n    if (alloc_->TracksAllocationSizes()) {\n      int64_t ab = alloc_->AllocatedSize(data_ptr);\n      proto->set_allocated_bytes(ab);\n      int64_t id = alloc_->AllocationId(data_ptr);\n      if (id > 0) {\n        proto->set_allocation_id(id);\n      }\n      if (RefCountIsOne()) {\n        proto->set_has_single_reference(true);\n      }\n    }\n  }\n\n  // Returns the type of the underlying memory.\n  AllocatorMemoryType GetMemoryType() const override {\n    return alloc_->GetMemoryType();\n  }\n\n protected:\n  void RecordDeallocation() {\n    LogMemory::RecordTensorDeallocation(alloc_->AllocationId(data()),\n                                        alloc_->Name());\n  }\n\n  Allocator* const alloc_;\n};\n\n// Typed ref-counted buffer: T[n].\ntemplate <typename T>\nclass Buffer : public BufferBase {\n public:\n  Buffer(Allocator* a, int64_t n);\n  Buffer(Allocator* a, int64_t n, const AllocationAttributes& allocation_attr);\n\n  size_t size() const override { return sizeof(T) * elem_; }\n\n private:\n  int64_t elem_;\n\n  ~Buffer() override;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(Buffer);\n};\n\nvoid LogUnexpectedSize(int64_t actual, int64_t expected) {\n  LOG(ERROR) << \"Input size was \" << actual << \" and expected \" << expected;\n}\n\nbool MemoryLoggingEnabled() {\n  static bool memory_logging_enabled = LogMemory::IsEnabled();\n  return memory_logging_enabled;\n}\n\n// A set of helper functions depending on T.\ntemplate <typename T>\nstruct Helper {\n  // By default, we assume T is a simple type (float, int32, etc.)\n  static_assert(is_simple_type<T>::value, \"T is not a simple type.\");\n  typedef protobuf::RepeatedField<T> RepeatedFieldType;\n\n  // Encoder of simple type T to a string.  We do a copy.\n  template <typename Destination>\n  static void Encode(TensorBuffer* in, int64_t n, Destination* out) {\n    DCHECK_EQ(in->size(), sizeof(T) * n);\n    port::AssignRefCounted(StringPiece(in->base<const char>(), in->size()), in,\n                           out);\n  }\n\n  // Decoder of simple type T. Copy the bytes from \"in\" into the\n  // tensor buffer.\n  template <typename Source>\n  static TensorBuffer* Decode(Allocator* a, const Source& in, int64_t n) {\n    if (in.size() != sizeof(T) * n) {\n      LogUnexpectedSize(in.size(), sizeof(T) * n);\n      return nullptr;\n    }\n    Buffer<T>* buf = new Buffer<T>(a, n);\n    char* data = buf->template base<char>();\n    if (data == nullptr) {\n      buf->Unref();\n      return nullptr;\n    }\n    port::CopyToArray(in, data);\n    return buf;\n  }\n\n  // Memory usage.\n  static int64_t TotalBytes(TensorBuffer* in, int64_t n) {\n    DCHECK_EQ(in->size(), sizeof(T) * n);\n    return in->size();\n  }\n};\n\n// Helper specialization for string (the only non-simple type we\n// support).\ntemplate <>\nstruct Helper<tstring> {\n  // Proto message uses RepeatedFieldType to hold repeated T.\n  typedef protobuf::RepeatedPtrField<string> RepeatedFieldType;\n\n  // Encodes \"n\" elements of type string stored in \"in\" into Cord\n  // \"out\", which is usually the TensorProto::tensor_content.\n  template <typename Destination>\n  static void Encode(TensorBuffer* in, int64_t n, Destination* out) {\n    port::EncodeStringList(in->base<const tstring>(), n, out);\n  }\n\n  // Decodes \"n\" elements of type string from \"in\" and constructs a\n  // buffer out of it. Returns nullptr if the decoding fails. \"in\" is\n  // usually the TensorProto::tensor_content.\n  template <typename Source>\n  static TensorBuffer* Decode(Allocator* a, const Source& in, int64_t n) {\n    Buffer<tstring>* buf = new Buffer<tstring>(a, n);\n    tstring* strings = buf->template base<tstring>();\n    if (strings == nullptr || !port::DecodeStringList(in, strings, n)) {\n      buf->Unref();\n      return nullptr;\n    }\n    return buf;\n  }\n\n  // Returns the estimated memory usage of \"n\" elements of type T\n  // stored in buffer \"in\".\n  static int64_t TotalBytes(TensorBuffer* in, int n) {\n    int64_t tot = in->size();\n    DCHECK_EQ(tot, sizeof(tstring) * n);\n    const tstring* p = in->base<const tstring>();\n    for (int i = 0; i < n; ++i, ++p) tot += p->size();\n    return tot;\n  }\n};\n\ntemplate <>\nstruct Helper<ResourceHandle> {\n  // Proto message uses RepeatedFieldType to hold repeated T.\n  typedef protobuf::RepeatedPtrField<string> RepeatedFieldType;\n\n  // Encodes \"n\" elements of type ResourceHandle stored in \"in\" into destination\n  // \"out\", which is usually the TensorProto::tensor_content.\n  template <typename Destination>\n  static void Encode(TensorBuffer* in, int64_t n, Destination* out) {\n    EncodeResourceHandleList(in->base<const ResourceHandle>(), n,\n                             port::NewStringListEncoder(out));\n  }\n\n  // Decodes \"n\" elements of type string from \"in\" and constructs a\n  // buffer out of it. Returns nullptr if the decoding fails. \"in\" is\n  // usually the TensorProto::tensor_content.\n  template <typename Source>\n  static TensorBuffer* Decode(Allocator* a, const Source& in, int64_t n) {\n    auto* buf = new Buffer<ResourceHandle>(a, n);\n    ResourceHandle* ps = buf->template base<ResourceHandle>();\n    if (ps == nullptr ||\n        !DecodeResourceHandleList(port::NewStringListDecoder(in), ps, n)) {\n      buf->Unref();\n      return nullptr;\n    }\n    return buf;\n  }\n\n  // Returns the estimated memory usage of \"n\" elements of type T\n  // stored in buffer \"in\".\n  static int64_t TotalBytes(TensorBuffer* in, int n) {\n    return n * sizeof(ResourceHandle);\n  }\n};\n\ntemplate <>\nstruct Helper<Variant> {\n  // Encodes \"n\" elements of type Variant stored in \"in\" into destination\n  // \"out\", which is usually the TensorProto::tensor_content.\n  template <typename Destination>\n  static void Encode(TensorBuffer* in, int64_t n, Destination* out) {\n    EncodeVariantList(in->base<const Variant>(), n,\n                      port::NewStringListEncoder(out));\n  }\n\n  // Decodes \"n\" elements of type Variant from \"in\" and constructs a\n  // buffer out of it. Returns nullptr if the decoding fails. \"in\" is\n  // usually the TensorProto::tensor_content.\n  template <typename Source>\n  static TensorBuffer* Decode(Allocator* a, const Source& in, int64_t n) {\n    auto* buf = new Buffer<Variant>(a, n);\n    Variant* ps = buf->template base<Variant>();\n    if (ps == nullptr ||\n        !DecodeVariantList(port::NewStringListDecoder(in), ps, n)) {\n      buf->Unref();\n      return nullptr;\n    }\n    return buf;\n  }\n\n  // Returns the estimated memory usage of \"n\" elements of type T\n  // stored in buffer \"in\".\n  static int64_t TotalBytes(TensorBuffer* in, int n) {\n    return n * sizeof(Variant);\n  }\n};\n\ntemplate <typename T>\nstruct ProtoHelper {};\n\n// For a C++ type \"T\" (float, double, int32, etc.), the repeated field\n// \"N\"_val (float_val, int_val, label_val, etc.) of type \"F\" (float,\n// int32, string, etc) in the TensorProto is used for serializing the\n// tensor of type \"T\".\n#define PROTO_TRAITS(T, F, N)                                          \\\n  template <>                                                          \\\n  struct ProtoHelper<T> {                                              \\\n    typedef Helper<F>::RepeatedFieldType FieldType;                    \\\n    static FieldType::const_iterator Begin(const TensorProto& proto) { \\\n      return proto.N##_val().begin();                                  \\\n    }                                                                  \\\n    static size_t NumElements(const TensorProto& proto) {              \\\n      return proto.N##_val().size();                                   \\\n    }                                                                  \\\n    static void Fill(const T* data, size_t n, TensorProto* proto) {    \\\n      typename ProtoHelper<T>::FieldType copy(data, data + n);         \\\n      proto->mutable_##N##_val()->Swap(&copy);                         \\\n    }                                                                  \\\n  };\nPROTO_TRAITS(float, float, float);\nPROTO_TRAITS(double, double, double);\nPROTO_TRAITS(int32, int32, int);\nPROTO_TRAITS(uint8, int32, int);\nPROTO_TRAITS(uint16, int32, int);\nPROTO_TRAITS(uint32, uint32, uint32);\nPROTO_TRAITS(int16, int32, int);\nPROTO_TRAITS(int8, int32, int);\nPROTO_TRAITS(bool, bool, bool);\nPROTO_TRAITS(tstring, tstring, string);\nPROTO_TRAITS(qint8, int32, int);\nPROTO_TRAITS(quint8, int32, int);\nPROTO_TRAITS(qint16, int32, int);\nPROTO_TRAITS(quint16, int32, int);\n#undef PROTO_TRAITS\n\ntemplate <>\nstruct ProtoHelper<int64_t> {\n  static protobuf::RepeatedField<int64_t>::const_iterator Begin(\n      const TensorProto& proto) {\n    return proto.int64_val().begin();\n  }\n  static size_t NumElements(const TensorProto& proto) {\n    return proto.int64_val().size();\n  }\n  static void Fill(const int64_t* data, size_t n, TensorProto* proto) {\n    protobuf::RepeatedField<protobuf_int64> copy(data, data + n);\n    proto->mutable_int64_val()->Swap(&copy);\n  }\n};\n\ntemplate <>\nstruct ProtoHelper<uint64> {\n  static protobuf::RepeatedField<uint64_t>::const_iterator Begin(\n      const TensorProto& proto) {\n    return proto.uint64_val().begin();\n  }\n  static size_t NumElements(const TensorProto& proto) {\n    return proto.uint64_val().size();\n  }\n  static void Fill(const uint64* data, size_t n, TensorProto* proto) {\n    protobuf::RepeatedField<protobuf_uint64> copy(data, data + n);\n    proto->mutable_uint64_val()->Swap(&copy);\n  }\n};\n\ntemplate <>\nstruct ProtoHelper<ResourceHandle> {\n  static protobuf::RepeatedPtrField<ResourceHandleProto>::const_iterator Begin(\n      const TensorProto& proto) {\n    return proto.resource_handle_val().begin();\n  }\n  static size_t NumElements(const TensorProto& proto) {\n    return proto.resource_handle_val().size();\n  }\n  static void Fill(const ResourceHandle* data, size_t n, TensorProto* proto) {\n    auto* handles = proto->mutable_resource_handle_val();\n    handles->Clear();\n    for (size_t i = 0; i < n; i++) {\n      data[i].AsProto(handles->Add());\n    }\n  }\n};\n\ntemplate <>\nstruct ProtoHelper<Variant> {\n  static protobuf::RepeatedPtrField<VariantTensorDataProto>::const_iterator\n  Begin(const TensorProto& proto) {\n    return proto.variant_val().begin();\n  }\n  static size_t NumElements(const TensorProto& proto) {\n    return proto.variant_val().size();\n  }\n  static void Fill(const Variant* data, size_t n, TensorProto* proto) {\n    auto* variant_values = proto->mutable_variant_val();\n    variant_values->Clear();\n    for (size_t i = 0; i < n; ++i) {\n      VariantTensorData tmp;\n      data[i].Encode(&tmp);\n      tmp.ToProto(variant_values->Add());\n    }\n  }\n};\n\ntemplate <>\nstruct ProtoHelper<complex64> {\n  typedef Helper<float>::RepeatedFieldType FieldType;\n  static const complex64* Begin(const TensorProto& proto) {\n    return reinterpret_cast<const complex64*>(proto.scomplex_val().data());\n  }\n  static size_t NumElements(const TensorProto& proto) {\n    return proto.scomplex_val().size() / 2;\n  }\n  static void Fill(const complex64* data, size_t n, TensorProto* proto) {\n    const float* p = reinterpret_cast<const float*>(data);\n    FieldType copy(p, p + n * 2);\n    proto->mutable_scomplex_val()->Swap(&copy);\n  }\n};\n\ntemplate <>\nstruct ProtoHelper<complex128> {\n  typedef Helper<double>::RepeatedFieldType FieldType;\n  static const complex128* Begin(const TensorProto& proto) {\n    return reinterpret_cast<const complex128*>(proto.dcomplex_val().data());\n  }\n  static size_t NumElements(const TensorProto& proto) {\n    return proto.dcomplex_val().size() / 2;\n  }\n  static void Fill(const complex128* data, size_t n, TensorProto* proto) {\n    const double* p = reinterpret_cast<const double*>(data);\n    FieldType copy(p, p + n * 2);\n    proto->mutable_dcomplex_val()->Swap(&copy);\n  }\n};\n\ntemplate <>\nstruct ProtoHelper<qint32> {\n  typedef Helper<int32>::RepeatedFieldType FieldType;\n  static const qint32* Begin(const TensorProto& proto) {\n    return reinterpret_cast<const qint32*>(proto.int_val().data());\n  }\n  static size_t NumElements(const TensorProto& proto) {\n    return proto.int_val().size();\n  }\n  static void Fill(const qint32* data, size_t n, TensorProto* proto) {\n    const int32* p = reinterpret_cast<const int32*>(data);\n    FieldType copy(p, p + n);\n    proto->mutable_int_val()->Swap(&copy);\n  }\n};\n\ntemplate <>\nstruct ProtoHelper<bfloat16> {\n  static void Fill(const bfloat16* data, size_t n, TensorProto* proto) {\n    proto->mutable_half_val()->Reserve(n);\n    for (size_t i = 0; i < n; ++i) {\n      proto->mutable_half_val()->AddAlreadyReserved(\n          Eigen::numext::bit_cast<uint16>(data[i]));\n    }\n  }\n};\n\ntemplate <>\nstruct ProtoHelper<Eigen::half> {\n  static void Fill(const Eigen::half* data, size_t n, TensorProto* proto) {\n    proto->mutable_half_val()->Reserve(n);\n    for (size_t i = 0; i < n; ++i) {\n      proto->mutable_half_val()->AddAlreadyReserved(\n          Eigen::numext::bit_cast<uint16>(data[i]));\n    }\n  }\n};\n\ntemplate <typename T>\nBuffer<T>::Buffer(Allocator* a, int64_t n)\n    : BufferBase(a, TypedAllocator::Allocate<T>(a, n, AllocationAttributes())),\n      elem_(n) {}\n\ntemplate <typename T>\nBuffer<T>::Buffer(Allocator* a, int64_t n,\n                  const AllocationAttributes& allocation_attr)\n    : BufferBase(a, TypedAllocator::Allocate<T>(a, n, allocation_attr)),\n      elem_(n) {}\n\ntemplate <typename T>\nBuffer<T>::~Buffer() {\n  if (data()) {\n    if (MemoryLoggingEnabled()) {\n      RecordDeallocation();\n    }\n    TypedAllocator::Deallocate<T>(alloc_, static_cast<T*>(data()), elem_);\n  }\n}\n\n// Allocates a T[n] buffer. Fills in the buffer with repeated values\n// in \"in\".  If \"in\" has less values than \"n\", fills the rest of T[n]\n// with the last value. If \"in\" has no values, fills T[n] with the\n// default value for T.\n//\n// This routine is using the typed fields (float_val, etc.) in the\n// tensor proto as opposed to the untyped binary representation\n// (tensor_content). This is used when we expect the TensorProto is\n// used by a client program which may not know how to encode a tensor\n// in the compact binary representation.\ntemplate <typename T>\nTensorBuffer* FromProtoField(Allocator* a, const TensorProto& in, int64_t n) {\n  CHECK_GT(n, 0);\n  Buffer<T>* buf = new Buffer<T>(a, n);\n  T* data = buf->template base<T>();\n  if (data == nullptr) {\n    buf->Unref();\n    return nullptr;\n  }\n\n  const int64_t in_n = ProtoHelper<T>::NumElements(in);\n  if (in_n <= 0) {\n    std::fill_n(data, n, T());\n  } else {\n    auto begin = ProtoHelper<T>::Begin(in);\n    if (n <= in_n) {\n      std::copy_n(begin, n, data);\n    } else {\n      std::copy_n(begin, in_n, data);\n      if (std::is_trivially_copyable<T>::value) {\n        const T last = *(data + in_n - 1);\n        std::fill_n(data + in_n, n - in_n, last);\n      } else {\n        const T& last = *(data + in_n - 1);\n        std::fill_n(data + in_n, n - in_n, last);\n      }\n    }\n  }\n\n  return buf;\n}\n\n// Separate implementation for `ResourceHandle` to handle the case when the\n// proto for the resource is invalid. See `resource_handle.h` constructor and\n// static factory builder.\ntemplate <>\nTensorBuffer* FromProtoField<ResourceHandle>(Allocator* a,\n                                             const TensorProto& in, int64_t n) {\n  CHECK_GT(n, 0);\n  Buffer<ResourceHandle>* buf = new Buffer<ResourceHandle>(a, n);\n  ResourceHandle* data = buf->template base<ResourceHandle>();\n  if (data == nullptr) {\n    buf->Unref();\n    return nullptr;\n  }\n  const int64_t in_n = ProtoHelper<ResourceHandle>::NumElements(in);\n  if (in_n <= 0) {\n    std::fill_n(data, n, ResourceHandle());\n  } else {\n    // If tensor shape says we have n < in_n elements in the output tensor\n    // then make sure to only decode the first n out of the in_n elements in the\n    // in tensors. In all other cases, we decode all in_n elements of in and set\n    // the remaining elements up to n to be the default ResourceHandle() value.\n    const int64_t real_n = n < in_n ? n : in_n;\n    for (int64_t i = 0; i < real_n; ++i) {\n      Status s = ResourceHandle::BuildResourceHandle(in.resource_handle_val(i),\n                                                     &data[i]);\n      if (!s.ok()) {\n        LOG(ERROR) << \"Could not decode resource handle from proto \\\"\"\n                   << in.resource_handle_val(i).ShortDebugString()\n                   << \"\\\", returned status: \" << s.ToString();\n        buf->Unref();\n        return nullptr;\n      }\n    }\n    for (int64_t i = in_n; i < n; ++i) {\n      data[i] = ResourceHandle();\n    }\n  }\n  return buf;\n}\n\ntemplate <>\nTensorBuffer* FromProtoField<Variant>(Allocator* a, const TensorProto& in,\n                                      int64_t n) {\n  CHECK_GT(n, 0);\n  Buffer<Variant>* buf = new Buffer<Variant>(a, n);\n  Variant* data = buf->template base<Variant>();\n  if (data == nullptr) {\n    buf->Unref();\n    return nullptr;\n  }\n  const int64_t in_n = ProtoHelper<Variant>::NumElements(in);\n  if (in_n <= 0) {\n    std::fill_n(data, n, Variant());\n  } else {\n    // If tensor shape says we have n < in_n elements in the output tensor\n    // then make sure to only decode the first n out of the in_n elements in the\n    // in tensors. In all other cases, we decode all in_n elements of in and set\n    // the remaining elements up to n to be the default Variant() value.\n    const int64_t real_n = n < in_n ? n : in_n;\n    for (int64_t i = 0; i < real_n; ++i) {\n      data[i] = in.variant_val(i);\n      if (!DecodeUnaryVariant(&data[i])) {\n        LOG(ERROR) << \"Could not decode variant with type_name: \\\"\"\n                   << data[i].TypeName()\n                   << \"\\\".  Perhaps you forgot to register a \"\n                      \"decoder via REGISTER_UNARY_VARIANT_DECODE_FUNCTION?\";\n        buf->Unref();\n        return nullptr;\n      }\n    }\n    for (int64_t i = in_n; i < n; ++i) {\n      data[i] = Variant();\n    }\n  }\n  return buf;\n}\n\n// fp16 and bfloat16 are opaque to the protobuf, so we deserialize these\n// identical to uint16 but with data stored in half_val instead of int_val (ie.,\n// we don't use ProtoHelper<uint16>).\ntemplate <>\nTensorBuffer* FromProtoField<Eigen::half>(Allocator* a, const TensorProto& in,\n                                          int64_t n) {\n  CHECK_GT(n, 0);\n  Buffer<Eigen::half>* buf = new Buffer<Eigen::half>(a, n);\n  uint16* data = buf->template base<uint16>();\n  if (data == nullptr) {\n    buf->Unref();\n    return nullptr;\n  }\n  const int64_t in_n = in.half_val().size();\n  auto begin = in.half_val().begin();\n  if (n <= in_n) {\n    std::copy_n(begin, n, data);\n  } else if (in_n > 0) {\n    std::copy_n(begin, in_n, data);\n    const uint16 last = *(data + in_n - 1);\n    std::fill_n(data + in_n, n - in_n, last);\n  } else {\n    std::fill_n(data, n, 0);\n  }\n  return buf;\n}\n\ntemplate <>\nTensorBuffer* FromProtoField<bfloat16>(Allocator* a, const TensorProto& in,\n                                       int64_t n) {\n  CHECK_GT(n, 0);\n  Buffer<bfloat16>* buf = new Buffer<bfloat16>(a, n);\n  uint16* data = buf->template base<uint16>();\n  if (data == nullptr) {\n    buf->Unref();\n    return nullptr;\n  }\n  const int64_t in_n = in.half_val().size();\n  auto begin = in.half_val().begin();\n  if (n <= in_n) {\n    std::copy_n(begin, n, data);\n  } else if (in_n > 0) {\n    std::copy_n(begin, in_n, data);\n    const uint16 last = *(data + in_n - 1);\n    std::fill_n(data + in_n, n - in_n, last);\n  } else {\n    std::fill_n(data, n, 0);\n  }\n  return buf;\n}\n\n// Copies T[n] stored in the buffer \"in\" into the repeated field in\n// \"out\" corresponding to type T.\ntemplate <typename T>\nvoid ToProtoField(const TensorBuffer& in, int64_t n, TensorProto* out) {\n  const T* data = in.base<const T>();\n  // NOTE: T may not the same as\n  // ProtoHelper<T>::FieldType::value_type.  E.g., T==int16,\n  // ProtoHelper<T>::FieldType::value_type==int32.  If performance is\n  // critical, we can specialize T=float and do memcpy directly.\n  ProtoHelper<T>::Fill(data, n, out);\n}\n\nvoid RefIfNonNull(core::RefCounted* buf) {\n  if (buf) buf->Ref();\n}\n\nvoid UnrefIfNonNull(core::RefCounted* buf) {\n  if (buf) buf->Unref();\n}\n\n}  // end namespace\n\nTensor::Tensor() : Tensor(DT_FLOAT) {}\n\nTensor::Tensor(DataType type) : shape_(type), buf_(nullptr) {}\n\nTensor::Tensor(DataType type, const TensorShape& shape, TensorBuffer* buf)\n    : shape_(shape), buf_(buf) {\n  set_dtype(type);\n  RefIfNonNull(buf);\n}\n\nTensor::Tensor(DataType type, TensorShape shape,\n               core::RefCountPtr<TensorBuffer> buf)\n    : shape_(std::move(shape)), buf_(buf.release()) {\n  set_dtype(type);\n}\n\nbool Tensor::IsInitialized() const {\n  return (buf_ != nullptr && buf_->data() != nullptr) ||\n         shape_.num_elements() == 0;\n}\n\nvoid Tensor::CheckType(DataType expected_dtype) const {\n  CHECK_EQ(dtype(), expected_dtype)\n      << \" \" << DataTypeString(expected_dtype) << \" expected, got \"\n      << DataTypeString(dtype());\n}\n\nvoid Tensor::CheckTypeAndIsAligned(DataType expected_dtype) const {\n  CHECK_EQ(dtype(), expected_dtype)\n      << \" \" << DataTypeString(expected_dtype) << \" expected, got \"\n      << DataTypeString(dtype());\n  CHECK(IsAligned()) << \"ptr = \" << base<void>();\n}\n\nvoid Tensor::CheckIsAlignedAndSingleElement() const {\n  CHECK(IsAligned()) << \"Aligned and single element\";\n  CHECK_EQ(1, NumElements()) << \"Must have a one element tensor\";\n}\n\nTensor::~Tensor() { UnrefIfNonNull(buf_); }\n\nStatus Tensor::BitcastFrom(const Tensor& other, DataType dtype,\n                           const TensorShape& shape) {\n  int in_size = DataTypeSize(other.dtype());\n  int out_size = DataTypeSize(dtype);\n  if (in_size == 0) {\n    return errors::InvalidArgument(\"other tensor has zero-sized data type\");\n  }\n  if (out_size == 0) {\n    return errors::InvalidArgument(\"specified output type is zero-sized\");\n  }\n  if (shape.num_elements() * out_size !=\n      other.shape().num_elements() * in_size) {\n    return errors::InvalidArgument(\n        \"input and output shapes/data type sizes are not compatible\");\n  }\n  shape_ = shape;\n  shape_.set_data_type(dtype);\n  if (buf_ != other.buf_) {\n    UnrefIfNonNull(buf_);\n    buf_ = other.buf_;\n    RefIfNonNull(buf_);\n  }\n  return OkStatus();\n}\n\n// Notice that buf_ either points to a regular TensorBuffer or a SubBuffer.\n// For the latter case, we have to make sure that the refcount is\n// one both for the SubBuffer _and_ the underlying TensorBuffer.\nbool Tensor::RefCountIsOne() const {\n  return buf_ != nullptr && buf_->RefCountIsOne() &&\n         buf_->root_buffer()->RefCountIsOne() && buf_->OwnsMemory();\n}\n\n// The macro CASES() expands to a switch statement conditioned on\n// TYPE_ENUM. Each case expands the STMTS after a typedef for T.\n#define SINGLE_ARG(...) __VA_ARGS__\n#define CASE(TYPE, STMTS)               \\\n  case DataTypeToEnum<TYPE>::value: {   \\\n    typedef TF_ATTRIBUTE_UNUSED TYPE T; \\\n    STMTS;                              \\\n    break;                              \\\n  }\n#define CASES_WITH_DEFAULT(TYPE_ENUM, STMTS, INVALID, DEFAULT) \\\n  switch (TYPE_ENUM) {                                         \\\n    CASE(float, SINGLE_ARG(STMTS))                             \\\n    CASE(double, SINGLE_ARG(STMTS))                            \\\n    CASE(int32, SINGLE_ARG(STMTS))                             \\\n    CASE(uint8, SINGLE_ARG(STMTS))                             \\\n    CASE(uint16, SINGLE_ARG(STMTS))                            \\\n    CASE(uint32, SINGLE_ARG(STMTS))                            \\\n    CASE(uint64, SINGLE_ARG(STMTS))                            \\\n    CASE(int16, SINGLE_ARG(STMTS))                             \\\n    CASE(int8, SINGLE_ARG(STMTS))                              \\\n    CASE(tstring, SINGLE_ARG(STMTS))                           \\\n    CASE(complex64, SINGLE_ARG(STMTS))                         \\\n    CASE(complex128, SINGLE_ARG(STMTS))                        \\\n    CASE(int64_t, SINGLE_ARG(STMTS))                           \\\n    CASE(bool, SINGLE_ARG(STMTS))                              \\\n    CASE(qint32, SINGLE_ARG(STMTS))                            \\\n    CASE(quint8, SINGLE_ARG(STMTS))                            \\\n    CASE(qint8, SINGLE_ARG(STMTS))                             \\\n    CASE(quint16, SINGLE_ARG(STMTS))                           \\\n    CASE(qint16, SINGLE_ARG(STMTS))                            \\\n    CASE(bfloat16, SINGLE_ARG(STMTS))                          \\\n    CASE(Eigen::half, SINGLE_ARG(STMTS))                       \\\n    CASE(ResourceHandle, SINGLE_ARG(STMTS))                    \\\n    CASE(Variant, SINGLE_ARG(STMTS))                           \\\n    case DT_INVALID:                                           \\\n      INVALID;                                                 \\\n      break;                                                   \\\n    default:                                                   \\\n      DEFAULT;                                                 \\\n      break;                                                   \\\n  }\n\n#define CASES(TYPE_ENUM, STMTS)                                      \\\n  CASES_WITH_DEFAULT(TYPE_ENUM, STMTS, LOG(FATAL) << \"Type not set\"; \\\n                     , LOG(FATAL) << \"Unexpected type: \" << TYPE_ENUM;)\n\nTensor::Tensor(Allocator* a, DataType type, const TensorShape& shape)\n    : shape_(shape), buf_(nullptr) {\n  set_dtype(type);\n  CHECK_NOTNULL(a);\n  if (shape_.num_elements() > 0 || a->AllocatesOpaqueHandle()) {\n    CASES(type, buf_ = new Buffer<T>(a, shape.num_elements()));\n  }\n  if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) {\n    LogMemory::RecordTensorAllocation(\"Unknown\", LogMemory::UNKNOWN_STEP_ID,\n                                      *this);\n  }\n}\n\nTensor::Tensor(Allocator* a, DataType type, const TensorShape& shape,\n               const AllocationAttributes& allocation_attr)\n    : shape_(shape), buf_(nullptr) {\n  set_dtype(type);\n  CHECK_NOTNULL(a);\n  if (shape_.num_elements() > 0 || a->AllocatesOpaqueHandle()) {\n    CASES(type, buf_ = new Buffer<T>(a, shape.num_elements(), allocation_attr));\n  }\n  if (MemoryLoggingEnabled() && !allocation_attr.allocation_will_be_logged &&\n      buf_ != nullptr && buf_->data() != nullptr) {\n    LogMemory::RecordTensorAllocation(\"Unknown (with attributes)\",\n                                      LogMemory::UNKNOWN_STEP_ID, *this);\n  }\n}\n\nStatus Tensor::BuildTensor(DataType type, const TensorShape& shape,\n                           Tensor* out_tensor) {\n  // Avoid crashes due to invalid or unsupported types.\n  CASES_WITH_DEFAULT(\n      type, {}, return errors::InvalidArgument(\"Type not set\"),\n      return errors::InvalidArgument(\"Unexpected type: \", DataType_Name(type)));\n  *out_tensor = Tensor(type, shape);\n  return OkStatus();\n}\n\n// NOTE(mrry): The default allocator for a Tensor (when none is specified) is\n// the default CPU allocator for NUMA zone 0. Accessing that currently involves\n// acquiring a lock, which guards initialization of the per-NUMA zone\n// allocators, and becomes highly contended.\n//\n// Note also that it would be better if all Tensor allocations required the user\n// to specify an allocator, for purposes of accounting, etc. However, the\n// default allocator is widely used throughout the codebase and in client code.\nstatic Allocator* get_default_cpu_allocator() {\n  static Allocator* default_cpu_allocator =\n      cpu_allocator(tsl::port::kNUMANoAffinity);\n  return default_cpu_allocator;\n}\n\nTensor::Tensor(DataType type, const TensorShape& shape)\n    : Tensor(get_default_cpu_allocator(), type, shape) {}\n\nbool Tensor::HostScalarTensorBufferBase::GetAllocatedBytes(\n    size_t* out_bytes) const {\n  // `this->FillAllocationDescription()` never sets allocated bytes information,\n  // so we can short-circuit the construction of an `AllocationDescription`.\n  return false;\n}\n\nvoid Tensor::HostScalarTensorBufferBase::FillAllocationDescription(\n    AllocationDescription* proto) const {\n  proto->set_requested_bytes(size());\n  proto->set_allocator_name(\"HostScalarTensorBuffer\");\n  proto->set_ptr(reinterpret_cast<uintptr_t>(data()));\n}\n\ntemplate <typename T>\nclass SubBuffer : public TensorBuffer {\n public:\n  // This buffer is an alias to buf[delta, delta + n).\n  SubBuffer(TensorBuffer* buf, int64_t delta, int64_t n)\n      : TensorBuffer(buf->base<T>() + delta),\n        root_(buf->root_buffer()),\n        elem_(n) {\n    // Sanity check. The caller should ensure the sub buffer is valid.\n    CHECK_LE(root_->base<T>(), this->base<T>());\n    T* root_limit = root_->base<T>() + root_->size() / sizeof(T);\n    CHECK_LE(this->base<T>(), root_limit);\n    CHECK_LE(this->base<T>() + n, root_limit);\n    // Hold a ref of the underlying root buffer.\n    // NOTE: 'buf' is a sub-buffer inside the 'root_' buffer.\n    root_->Ref();\n  }\n\n  size_t size() const override { return sizeof(T) * elem_; }\n  TensorBuffer* root_buffer() override { return root_; }\n  bool GetAllocatedBytes(size_t* out_bytes) const override {\n    return root_->GetAllocatedBytes(out_bytes);\n  }\n  void FillAllocationDescription(AllocationDescription* proto) const override {\n    root_->FillAllocationDescription(proto);\n  }\n\n private:\n  TensorBuffer* root_;\n  int64_t elem_;\n\n  ~SubBuffer() override { root_->Unref(); }\n\n  TF_DISALLOW_COPY_AND_ASSIGN(SubBuffer);\n};\n\nTensor Tensor::Slice(int64_t start, int64_t limit) const {\n  CHECK_GE(dims(), 1);\n  CHECK_LE(0, start);\n  CHECK_LE(start, limit);\n  int64_t dim0_size = shape_.dim_size(0);\n  CHECK_LE(limit, dim0_size);\n  if ((start == 0) && (limit == dim0_size)) {\n    return *this;\n  }\n  Tensor ret;\n  ret.shape_ = shape_;\n  ret.set_dtype(dtype());\n  ret.buf_ = nullptr;\n  if (dim0_size > 0) {\n    const int64_t elems_per_dim0 = NumElements() / dim0_size;\n    const int64_t delta = start * elems_per_dim0;\n    dim0_size = limit - start;\n    ret.shape_.set_dim(0, dim0_size);\n    const int64_t num_elems = dim0_size * elems_per_dim0;\n    if (buf_) {\n      DataType dt = dtype();\n      CASES(dt, ret.buf_ = new SubBuffer<T>(buf_, delta, num_elems));\n    }\n  }\n  return ret;\n}\n\nTensor Tensor::SubSlice(int64_t index) const {\n  CHECK_GE(dims(), 1);  // Crash ok.\n  CHECK_LE(0, index);   // Crash ok.\n  int64_t dim0_size = shape_.dim_size(0);\n  CHECK_LE(index, dim0_size);  // Crash ok.\n  Tensor ret;\n  ret.shape_ = shape_;\n  ret.shape_.RemoveDim(0);\n  ret.set_dtype(dtype());\n  ret.buf_ = nullptr;\n  if (dim0_size > 0) {\n    const int64_t elems_per_dim0 = NumElements() / dim0_size;\n    const int64_t delta = index * elems_per_dim0;\n    const int64_t num_elems = elems_per_dim0;\n    if (buf_) {\n      DataType dt = dtype();\n      CASES(dt, ret.buf_ = new SubBuffer<T>(buf_, delta, num_elems));\n    }\n  }\n  return ret;\n}\n\nbool Tensor::FromProto(const TensorProto& proto) {\n  return FromProto(get_default_cpu_allocator(), proto);\n}\n\nbool Tensor::FromProto(Allocator* a, const TensorProto& proto) {\n  CHECK_NOTNULL(a);\n  TensorBuffer* p = nullptr;\n  if (!TensorShape::IsValid(proto.tensor_shape())) return false;\n  if (proto.dtype() == DT_INVALID) return false;\n  TensorShape shape(proto.tensor_shape());\n  const int64_t N = shape.num_elements();\n  if (N > 0 && proto.dtype()) {\n    bool dtype_error = false;\n    if (!proto.tensor_content().empty()) {\n      const auto& content = proto.tensor_content();\n      CASES_WITH_DEFAULT(proto.dtype(), p = Helper<T>::Decode(a, content, N),\n                         dtype_error = true, dtype_error = true);\n    } else {\n      CASES_WITH_DEFAULT(proto.dtype(), p = FromProtoField<T>(a, proto, N),\n                         dtype_error = true, dtype_error = true);\n    }\n    if (dtype_error || p == nullptr) return false;\n  } else {\n    // Handle the case of empty tensors (N = 0) or tensors with incomplete shape\n    // (N = -1). All other values of `shape.num_elements()` should be invalid by\n    // construction.\n    // Here, we just need to validate that the `proto.dtype()` value is valid.\n    bool dtype_error = false;\n    CASES_WITH_DEFAULT(proto.dtype(), break, dtype_error = true,\n                       dtype_error = true);\n    if (dtype_error) return false;\n  }\n  shape_ = shape;\n  set_dtype(proto.dtype());\n  UnrefIfNonNull(buf_);\n  buf_ = p;\n  // TODO(misard) add tracking of which kernels and steps are calling\n  // FromProto.\n  if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) {\n    LogMemory::RecordTensorAllocation(\"Unknown (from Proto)\",\n                                      LogMemory::UNKNOWN_STEP_ID, *this);\n  }\n  return true;\n}\n\nvoid Tensor::AsProtoField(TensorProto* proto) const {\n  proto->Clear();\n  shape_.AsProto(proto->mutable_tensor_shape());\n  proto->set_dtype(dtype());\n  if (buf_) {\n    CASES(dtype(), ToProtoField<T>(*buf_, shape_.num_elements(), proto));\n  }\n}\n\nvoid Tensor::AsProtoTensorContent(TensorProto* proto) const {\n  proto->Clear();\n  proto->set_dtype(dtype());\n  shape_.AsProto(proto->mutable_tensor_shape());\n  if (buf_) {\n    CASES(dtype(), Helper<T>::Encode(buf_, shape_.num_elements(),\n                                     proto->mutable_tensor_content()));\n  }\n}\n\nsize_t Tensor::TotalBytes() const {\n  if (shape_.num_elements() == 0) return 0;\n  CHECK(buf_) << \"null buf_ with non-zero shape size \" << shape_.num_elements();\n  CASES(dtype(), return Helper<T>::TotalBytes(buf_, shape_.num_elements()));\n  return 0;  // Makes compiler happy.\n}\n\nsize_t Tensor::AllocatedBytes() const {\n  if (buf_) {\n    size_t ret;\n    if (buf_->GetAllocatedBytes(&ret)) {\n      return ret;\n    }\n  }\n  return TotalBytes();\n}\n\nbool Tensor::CanUseDMA() const {\n  CASES(dtype(), return is_simple_type<T>::value);\n  return false;  // Makes compiler happy.\n}\n\n#undef CASES\n#undef CASE\n\nnamespace {\n\n// StrCat and StrAppend don't support Eigen::half directly at the moment, and\n// we would like to keep them compatible with their absl counterparts, for ease\n// of migration. We could rely on errors::internal::PrepareForStrCat() but the\n// logic is so simple we can just replicate it here, where it is close to its\n// usage and easy to change later. And there's the extra benefit of not\n// accessing an 'internal' namespace.\ninline const strings::AlphaNum& PrintOneElement(const strings::AlphaNum& a,\n                                                bool print_v2) {\n  return a;\n}\ninline string PrintOneElement(const tstring& a, bool print_v2) {\n  if (print_v2) {\n    return \"\\\"\" + absl::Utf8SafeCEscape(a) + \"\\\"\";\n  } else {\n    return absl::Utf8SafeCEscape(a);\n  }\n}\ninline float PrintOneElement(const Eigen::half& h, bool print_v2) {\n  return static_cast<float>(h);\n}\n\ninline float PrintOneElement(bfloat16 f, bool print_v2) {\n  return static_cast<float>(f);\n}\n\n// Print from left dim to right dim recursively.\ntemplate <typename T>\nvoid PrintOneDim(int dim_index, const gtl::InlinedVector<int64, 4>& shape,\n                 int64_t limit, int shape_size, const T* data,\n                 int64_t* data_index, string* result) {\n  if (*data_index >= limit) return;\n  int64_t element_count = shape[dim_index];\n  // We have reached the right-most dimension of the tensor.\n  if (dim_index == shape_size - 1) {\n    for (int64_t i = 0; i < element_count; i++) {\n      if (*data_index >= limit) {\n        // If not enough elements has been printed, append \"...\".\n        if (dim_index != 0) {\n          strings::StrAppend(result, \"...\");\n        }\n        return;\n      }\n      if (i > 0) strings::StrAppend(result, \" \");\n      strings::StrAppend(result, PrintOneElement(data[(*data_index)++], false));\n    }\n    return;\n  }\n  // Loop every element of one dim.\n  for (int64_t i = 0; i < element_count; i++) {\n    bool flag = false;\n    if (*data_index < limit) {\n      strings::StrAppend(result, \"[\");\n      flag = true;\n    }\n    // As for each element, print the sub-dim.\n    PrintOneDim(dim_index + 1, shape, limit, shape_size, data, data_index,\n                result);\n    if (*data_index < limit || flag) {\n      strings::StrAppend(result, \"]\");\n      flag = false;\n    }\n  }\n}\n\n// Appends the spacing between elements for a given dim onto a result string\nvoid PrintDimSpacing(int dim_index, int num_dims, string* result) {\n  if (dim_index == num_dims - 1) {\n    strings::StrAppend(result, \" \");\n    return;\n  }\n  for (int j = 0; j < num_dims - dim_index - 1; j++) {\n    strings::StrAppend(result, \"\\n\");\n  }\n  for (int j = 0; j <= dim_index; j++) {\n    strings::StrAppend(result, \" \");\n  }\n}\n\n// Print from left dim to right dim recursively.\ntemplate <typename T>\nvoid PrintOneDimV2(int dim_index, const gtl::InlinedVector<int64, 4>& shape,\n                   int64_t num_elts_at_ends, int num_dims, const T* data,\n                   int64_t data_index, string* result) {\n  // We have recursed beyond all the dimensions into a single element\n  // of the tensor.\n  if (dim_index == num_dims) {\n    strings::StrAppend(result, PrintOneElement(data[data_index], true));\n    return;\n  }\n\n  strings::StrAppend(result, \"[\");\n  int64_t element_count = shape[dim_index];\n  int64_t start_of_end =\n      std::max(num_elts_at_ends, element_count - num_elts_at_ends);\n\n  // Loop every element of one dim.\n  int64_t elements_per_iter = 1;\n  for (int i = dim_index + 1; i < num_dims; i++) {\n    elements_per_iter *= shape[i];\n  }\n  for (int64_t i = 0; (i < num_elts_at_ends) && (i < element_count); i++) {\n    if (i > 0) {\n      PrintDimSpacing(dim_index, num_dims, result);\n    }\n\n    // As for each element, print the sub-dim.\n    PrintOneDimV2(dim_index + 1, shape, num_elts_at_ends, num_dims, data,\n                  data_index + elements_per_iter * i, result);\n  }\n  if (element_count > 2 * num_elts_at_ends) {\n    PrintDimSpacing(dim_index, num_dims, result);\n    strings::StrAppend(result, \"...\");\n  }\n  for (int64_t i = start_of_end; i < element_count; i++) {\n    // As for each element, print the sub-dim.\n    PrintDimSpacing(dim_index, num_dims, result);\n    PrintOneDimV2(dim_index + 1, shape, num_elts_at_ends, num_dims, data,\n                  data_index + elements_per_iter * i, result);\n  }\n\n  strings::StrAppend(result, \"]\");\n}\n\ntemplate <typename T>\nstring SummarizeArrayInternal(int64_t limit, int64_t num_elts,\n                              const TensorShape& tensor_shape, const T* array,\n                              const bool print_v2) {\n  string ret;\n  const gtl::InlinedVector<int64_t, 4> shape = tensor_shape.dim_sizes();\n  if (shape.empty()) {\n    for (int64_t i = 0; i < limit; ++i) {\n      if (i > 0) strings::StrAppend(&ret, \" \");\n      strings::StrAppend(&ret, PrintOneElement(array[i], print_v2));\n    }\n    if (num_elts > limit) strings::StrAppend(&ret, \"...\");\n    return ret;\n  }\n  if (print_v2) {\n    const int num_dims = tensor_shape.dims();\n    PrintOneDimV2(0, shape, limit, num_dims, array, 0, &ret);\n  } else {\n    int64_t data_index = 0;\n    const int shape_size = tensor_shape.dims();\n    PrintOneDim(0, shape, limit, shape_size, array, &data_index, &ret);\n\n    if (num_elts > limit) strings::StrAppend(&ret, \"...\");\n  }\n\n  return ret;\n}\n\ntemplate <typename T>\nstring SummarizeArray(int64_t limit, int64_t num_elts,\n                      const TensorShape& tensor_shape, const char* data,\n                      const bool print_v2) {\n  const T* array = reinterpret_cast<const T*>(data);\n  return SummarizeArrayInternal<T>(limit, num_elts, tensor_shape, array,\n                                   print_v2);\n}\n\ntemplate <>\nstring SummarizeArray<bool>(int64_t limit, int64_t num_elts,\n                            const TensorShape& tensor_shape, const char* data,\n                            const bool print_v2) {\n  // We first convert all chars to be 0/1 to not get InvalidEnumValue sanitizer\n  // error\n  auto mutable_data = std::unique_ptr<char[]>(new char[num_elts]);\n  for (int64_t i = 0; i < num_elts; ++i)\n    mutable_data.get()[i] = data[i] ? 1 : 0;\n  bool* array = reinterpret_cast<bool*>(mutable_data.get());\n  return SummarizeArrayInternal<bool>(limit, num_elts, tensor_shape, array,\n                                      print_v2);\n}\n}  // namespace\n\nstring Tensor::SummarizeValue(int64_t max_entries, bool print_v2) const {\n  const int64_t num_elts = NumElements();\n  if (max_entries < 0) {\n    max_entries = num_elts;\n  }\n  size_t limit = std::min(max_entries, num_elts);\n  if ((limit > 0) && (buf_ == nullptr)) {\n    return strings::StrCat(\"uninitialized Tensor of \", num_elts,\n                           \" elements of type \", dtype());\n  }\n  const char* data = limit > 0 ? tensor_data().data() : nullptr;\n  switch (dtype()) {\n    case DT_BFLOAT16:\n      return SummarizeArray<bfloat16>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_HALF:\n      return SummarizeArray<Eigen::half>(limit, num_elts, shape_, data,\n                                         print_v2);\n      break;\n    case DT_FLOAT:\n      return SummarizeArray<float>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_DOUBLE:\n      return SummarizeArray<double>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_UINT32:\n      return SummarizeArray<uint32>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_INT32:\n      return SummarizeArray<int32>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_UINT8:\n    case DT_QUINT8:\n      return SummarizeArray<uint8>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_UINT16:\n    case DT_QUINT16:\n      return SummarizeArray<uint16>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_INT16:\n    case DT_QINT16:\n      return SummarizeArray<int16>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_INT8:\n    case DT_QINT8:\n      return SummarizeArray<int8>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_UINT64:\n      return SummarizeArray<uint64>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_INT64:\n      return SummarizeArray<int64_t>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_BOOL:\n      // TODO(tucker): Is it better to emit \"True False...\"?  This\n      // will emit \"1 0...\" which is more compact.\n      return SummarizeArray<bool>(limit, num_elts, shape_, data, print_v2);\n      break;\n    case DT_STRING:\n      return SummarizeArray<tstring>(limit, num_elts, shape_, data, print_v2);\n      break;\n    default: {\n      // All irregular cases\n      string ret;\n      if (print_v2 && (dims() > 0)) {\n        strings::StrAppend(&ret, \"[\");\n      }\n      // TODO(irving): Don't call flat every time around this\n      // loop.\n      for (size_t i = 0; i < limit; ++i) {\n        if (i > 0) strings::StrAppend(&ret, \" \");\n        switch (dtype()) {\n          case DT_VARIANT: {\n            const Variant& v = flat<Variant>()(i);\n            strings::StrAppend(&ret, \"<\", v.SummarizeValue(), \">\");\n          } break;\n          case DT_RESOURCE: {\n            const ResourceHandle& r = flat<ResourceHandle>()(i);\n            strings::StrAppend(&ret, \"<\", r.SummarizeValue(), \">\");\n          } break;\n          default:\n            // TODO(zhifengc, josh11b): Pretty-print other types (bool,\n            // complex64, quantized).\n            strings::StrAppend(&ret, \"?\");\n        }\n      }\n      if (max_entries < num_elts) strings::StrAppend(&ret, \"...\");\n      if (print_v2 && (dims() > 0)) {\n        strings::StrAppend(&ret, \"]\");\n      }\n      return ret;\n    }\n  }\n}\n\nStringPiece Tensor::tensor_data() const {\n  if (buf_ == nullptr) return StringPiece();  // Don't die for empty tensors\n  return StringPiece(static_cast<char*>(buf_->data()), TotalBytes());\n}\n\nvoid* Tensor::data() const {\n  if (buf_ == nullptr) return nullptr;  // Don't die for empty tensors\n  return static_cast<void*>(buf_->data());\n}\n\nbool Tensor::SharesBufferWith(const Tensor& b) const {\n  return buf_ != nullptr && b.buf_ != nullptr &&\n         buf_->root_buffer() == b.buf_->root_buffer();\n}\n\nstring Tensor::DebugString(int num_values) const {\n  return strings::StrCat(\"Tensor<type: \", DataTypeString(dtype()),\n                         \" shape: \", shape().DebugString(),\n                         \" values: \", SummarizeValue(num_values), \">\");\n}\n\nstring Tensor::DeviceSafeDebugString() const {\n  return strings::StrCat(\"Tensor<type: \", DataTypeString(dtype()),\n                         \" shape: \", shape().DebugString(), \">\");\n}\n\nvoid Tensor::FillDescription(TensorDescription* description) const {\n  description->set_dtype(dtype());\n  shape().AsProto(description->mutable_shape());\n  if (buf_ != nullptr && buf_->data() != nullptr) {\n    buf_->FillAllocationDescription(\n        description->mutable_allocation_description());\n  }\n}\n\ngtl::InlinedVector<int64_t, 4> Tensor::ComputeFlatInnerDims(\n    gtl::ArraySlice<int64_t> orig, int64_t num_out_dims) {\n  gtl::InlinedVector<int64_t, 4> out_dims(num_out_dims, 0);\n  int64_t offset = orig.size() - num_out_dims;\n  for (int64_t out_dim = num_out_dims - 1; out_dim >= 0; --out_dim) {\n    const int64_t in_dim = out_dim + offset;\n    out_dims[out_dim] = in_dim < 0 ? 1 : orig[in_dim];\n  }\n  for (int64_t in_dim = 0; in_dim < offset; ++in_dim) {\n    out_dims[0] *= orig[in_dim];\n  }\n  return out_dims;\n}\n\ngtl::InlinedVector<int64_t, 4> Tensor::ComputeFlatOuterDims(\n    gtl::ArraySlice<int64_t> orig, int64_t num_out_dims) {\n  gtl::InlinedVector<int64_t, 4> out_dims(num_out_dims, 0);\n  for (int64_t out_dim = 0; out_dim <= num_out_dims - 1; ++out_dim) {\n    out_dims[out_dim] = out_dim >= orig.size() ? 1 : orig[out_dim];\n  }\n  for (int64_t in_dim = num_out_dims; in_dim < orig.size(); ++in_dim) {\n    out_dims[num_out_dims - 1] *= orig[in_dim];\n  }\n  return out_dims;\n}\n\n}  // namespace tensorflow"