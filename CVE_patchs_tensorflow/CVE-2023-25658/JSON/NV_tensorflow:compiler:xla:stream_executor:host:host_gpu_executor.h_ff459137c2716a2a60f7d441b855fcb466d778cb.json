"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Declares the HostExecutor class, which is a CPU-only implementation of\n// the StreamExecutor interface. For now, this is used for testing and to\n// examine the performance of host-based StreamExecutor code.\n#ifndef TENSORFLOW_COMPILER_XLA_STREAM_EXECUTOR_HOST_HOST_GPU_EXECUTOR_H_\n#define TENSORFLOW_COMPILER_XLA_STREAM_EXECUTOR_HOST_HOST_GPU_EXECUTOR_H_\n\n#include <cstdint>\n\n#include \"absl/functional/any_invocable.h\"\n#include \"tensorflow/compiler/xla/stream_executor/blas.h\"\n#include \"tensorflow/compiler/xla/stream_executor/host/host_stream.h\"\n#include \"tensorflow/compiler/xla/stream_executor/host/host_timer.h\"\n#include \"tensorflow/compiler/xla/stream_executor/rng.h\"\n#include \"tensorflow/compiler/xla/stream_executor/stream_executor.h\"\n#include \"tensorflow/compiler/xla/stream_executor/stream_executor_internal.h\"\n#include \"tensorflow/tsl/platform/errors.h\"\n\nnamespace stream_executor {\nnamespace host {\n\n// An implementation of StreamExecutor that does no communication or interaction\n// with a device, but DOES perform memory operations backed by the host.\n// Plugin routines (RNG, BLAS) are also supported and functional.\n// Kernel invocations will fail, but host callbacks may be enqueued on this\n// executor and its associated stream, and should follow standard ordering\n// semantics.\n//\n// This is useful for evaluating the performance of host-based or fallback\n// routines executed under the context of a GPU executor.\n// See stream_executor.h for description of the below operations.\nclass HostExecutor : public internal::StreamExecutorInterface {\n public:\n  explicit HostExecutor(const PluginConfig& plugin_config);\n  ~HostExecutor() override;\n\n  // The stack size used for host streams can be set via\n  // device_options.non_portable_tags[\"host_stack_size\"].\n  tsl::Status Init(int device_ordinal, DeviceOptions device_options) override;\n\n  tsl::Status GetKernel(const MultiKernelLoaderSpec& spec,\n                        KernelBase* kernel) override {\n    return tsl::errors::Unimplemented(\"Not Implemented\");\n  }\n  tsl::Status Launch(Stream* stream, const ThreadDim& thread_dims,\n                     const BlockDim& block_dims, const KernelBase& kernel,\n                     const KernelArgsArrayBase& args) override {\n    return tsl::errors::Unimplemented(\"Not Implemented\");\n  }\n\n  DeviceMemoryBase Allocate(uint64_t size, int64_t memory_space) override;\n  void* GetSubBuffer(DeviceMemoryBase* parent, uint64_t offset_bytes,\n                     uint64_t size_bytes) override;\n  void Deallocate(DeviceMemoryBase* mem) override;\n\n  void* HostMemoryAllocate(uint64_t size) override { return new char[size]; }\n  void HostMemoryDeallocate(void* mem) override {\n    delete[] static_cast<char*>(mem);\n  }\n  bool HostMemoryRegister(void* mem, uint64_t size) override { return true; }\n  bool HostMemoryUnregister(void* mem) override { return true; }\n\n  bool Memcpy(Stream* stream, void* host_dst, const DeviceMemoryBase& gpu_src,\n              uint64_t size) override;\n  bool Memcpy(Stream* stream, DeviceMemoryBase* gpu_dst, const void* host_src,\n              uint64_t size) override;\n  bool MemcpyDeviceToDevice(Stream* stream, DeviceMemoryBase* gpu_dst,\n                            const DeviceMemoryBase& gpu_src,\n                            uint64_t size) override;\n\n  tsl::Status MemZero(Stream* stream, DeviceMemoryBase* location,\n                      uint64_t size) override;\n  tsl::Status Memset(Stream* stream, DeviceMemoryBase* location,\n                     uint8_t pattern, uint64_t size) override;\n  tsl::Status Memset32(Stream* stream, DeviceMemoryBase* location,\n                       uint32_t pattern, uint64_t size) override;\n\n  // No \"synchronize all activity\" implemented for this platform at the moment.\n  bool SynchronizeAllActivity() override { return true; }\n  tsl::Status SynchronousMemZero(DeviceMemoryBase* location,\n                                 uint64_t size) override;\n\n  tsl::Status SynchronousMemSet(DeviceMemoryBase* location, int value,\n                                uint64_t size) override;\n\n  tsl::Status SynchronousMemcpy(DeviceMemoryBase* gpu_dst, const void* host_src,\n                                uint64_t size) override;\n  tsl::Status SynchronousMemcpy(void* host_dst, const DeviceMemoryBase& gpu_src,\n                                uint64_t size) override;\n  tsl::Status SynchronousMemcpyDeviceToDevice(DeviceMemoryBase* gpu_dst,\n                                              const DeviceMemoryBase& gpu_src,\n                                              uint64_t size) override;\n\n  bool HostCallback(Stream* stream,\n                    absl::AnyInvocable<tsl::Status() &&> callback) override;\n\n  tsl::Status AllocateEvent(Event* event) override;\n  tsl::Status DeallocateEvent(Event* event) override;\n  tsl::Status RecordEvent(Stream* stream, Event* event) override;\n  tsl::Status WaitForEvent(Stream* stream, Event* event) override;\n  Event::Status PollForEventStatus(Event* event) override;\n\n  bool AllocateStream(Stream* stream) override;\n  void DeallocateStream(Stream* stream) override;\n  bool CreateStreamDependency(Stream* dependent, Stream* other) override;\n\n  // No special initialization is necessary for host timers.\n  bool AllocateTimer(Timer* timer) override { return true; }\n\n  void DeallocateTimer(Timer* timer) override {}\n\n  bool StartTimer(Stream* stream, Timer* timer) override;\n\n  bool StopTimer(Stream* stream, Timer* timer) override;\n\n  tsl::Status BlockHostUntilDone(Stream* stream) override;\n\n  int PlatformDeviceCount() override { return 1; }\n\n  bool DeviceMemoryUsage(int64_t* free, int64_t* total) const override;\n\n  tsl::StatusOr<std::unique_ptr<DeviceDescription>> CreateDeviceDescription()\n      const override {\n    return CreateDeviceDescription(0);\n  }\n\n  static tsl::StatusOr<std::unique_ptr<DeviceDescription>>\n  CreateDeviceDescription(int device_ordinal);\n\n  tsl::Status EnablePeerAccessTo(StreamExecutorInterface* other) override {\n    return ::tsl::OkStatus();\n  }\n\n  bool CanEnablePeerAccessTo(StreamExecutorInterface* other) override {\n    return true;\n  }\n\n  bool SupportsBlas() const override;\n  blas::BlasSupport* CreateBlas() override;\n\n  bool SupportsDnn() const override { return false; }\n  dnn::DnnSupport* CreateDnn() override { return nullptr; }\n\n  bool SupportsFft() const override;\n  fft::FftSupport* CreateFft() override;\n\n  bool SupportsRng() const override;\n  rng::RngSupport* CreateRng() override;\n\n  std::unique_ptr<internal::EventInterface> CreateEventImplementation()\n      override;\n\n  std::unique_ptr<internal::KernelInterface> CreateKernelImplementation()\n      override {\n    return nullptr;\n  }\n\n  std::unique_ptr<internal::StreamInterface> GetStreamImplementation() override;\n\n  std::unique_ptr<internal::TimerInterface> GetTimerImplementation() override {\n    return std::unique_ptr<internal::TimerInterface>(new HostTimer());\n  }\n\n  void* GpuContextHack() override { return nullptr; }\n\n private:\n  const PluginConfig plugin_config_;\n  // Size of thread stacks for streams in bytes. '0' means \"the default size\".\n  size_t thread_stack_size_in_bytes_ = 0;\n};\n\n}  // namespace host\n}  // namespace stream_executor\n\n#endif  // TENSORFLOW_COMPILER_XLA_STREAM_EXECUTOR_HOST_HOST_GPU_EXECUTOR_H_"