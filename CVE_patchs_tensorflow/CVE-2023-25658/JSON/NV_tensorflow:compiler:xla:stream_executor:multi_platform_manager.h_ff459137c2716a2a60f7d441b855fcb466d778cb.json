"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// This is a registration-oriented interface for multiple platforms. It will\n// replace the MachineManager singleton interface, as MachineManager does not\n// currently support simultaneous use of multiple platforms.\n//\n// Usage:\n//\n// In your BUILD rule, add a dependency on a platform plugin that you'd like\n// to use, such as:\n//\n//   //third_party/tensorflow/compiler/xla/stream_executor/cuda:cuda_platform\n//   //third_party/tensorflow/compiler/xla/stream_executor/opencl:opencl_platform\n//\n// This will register platform plugins that can be discovered via this\n// interface. Sample API usage:\n//\n//   tsl::StatusOr<Platform*> platform_status =\n//      se::MultiPlatformManager::PlatformWithName(\"OpenCL\");\n//   if (!platform_status.ok()) { ... }\n//   Platform* platform = platform_status.value();\n//   LOG(INFO) << platform->VisibleDeviceCount() << \" devices visible\";\n//   if (platform->VisibleDeviceCount() <= 0) { return; }\n//\n//   for (int i = 0; i < platform->VisibleDeviceCount(); ++i) {\n//     tsl::StatusOr<StreamExecutor*> executor_status =\n//        platform->ExecutorForDevice(i);\n//     if (!executor_status.ok()) {\n//       LOG(INFO) << \"could not retrieve executor for device ordinal \" << i\n//                 << \": \" << executor_status.status();\n//       continue;\n//     }\n//     LOG(INFO) << \"found usable executor: \" << executor_status.value();\n//   }\n//\n// A few things to note:\n//  - There is no standard formatting/practice for identifying the name of a\n//    platform. Ideally, a platform will list its registered name in its header\n//    or in other associated documentation.\n//  - Platform name lookup is case-insensitive. \"OpenCL\" or \"opencl\" (or even\n//    (\"OpEnCl\") would work correctly in the above example.\n//\n// And similarly, for standard interfaces (BLAS, RNG, etc.) you can add\n// dependencies on support libraries, e.g.:\n//\n//    //third_party/tensorflow/compiler/xla/stream_executor/cuda:pluton_blas_plugin\n//    //third_party/tensorflow/compiler/xla/stream_executor/cuda:cudnn_plugin\n//    //third_party/tensorflow/compiler/xla/stream_executor/cuda:cublas_plugin\n//    //third_party/tensorflow/compiler/xla/stream_executor/cuda:curand_plugin\n\n#ifndef TENSORFLOW_COMPILER_XLA_STREAM_EXECUTOR_MULTI_PLATFORM_MANAGER_H_\n#define TENSORFLOW_COMPILER_XLA_STREAM_EXECUTOR_MULTI_PLATFORM_MANAGER_H_\n\n#include <functional>\n#include <map>\n#include <memory>\n#include <vector>\n\n#include \"absl/strings/string_view.h\"\n#include \"tensorflow/compiler/xla/stream_executor/platform.h\"\n#include \"tensorflow/compiler/xla/stream_executor/platform/initialize.h\"\n#include \"tensorflow/compiler/xla/stream_executor/platform/port.h\"\n#include \"tensorflow/tsl/platform/status.h\"\n#include \"tensorflow/tsl/platform/statusor.h\"\n\nnamespace stream_executor {\n\n// Manages multiple platforms that may be present on the current machine.\nclass MultiPlatformManager {\n public:\n  // Registers a platform object, returns an error status if the platform is\n  // already registered. The associated listener, if not null, will be used to\n  // trace events for ALL executors for that platform.\n  // Takes ownership of platform.\n  static tsl::Status RegisterPlatform(std::unique_ptr<Platform> platform);\n\n  // Retrieves the platform registered with the given platform name (e.g.\n  // \"CUDA\", \"OpenCL\", ...) or id (an opaque, comparable value provided by the\n  // Platform's Id() method).\n  //\n  // If the platform has not already been initialized, it will be initialized\n  // with a default set of parameters.\n  //\n  // If the requested platform is not registered, an error status is returned.\n  // Ownership of the platform is NOT transferred to the caller --\n  // the MultiPlatformManager owns the platforms in a singleton-like fashion.\n  static tsl::StatusOr<Platform*> PlatformWithName(absl::string_view target);\n  static tsl::StatusOr<Platform*> PlatformWithId(const Platform::Id& id);\n\n  // Same functions as above, but allows platforms to be returned without\n  // initialization if initialize_platform == false.\n  static tsl::StatusOr<Platform*> PlatformWithName(absl::string_view target,\n                                                   bool initialize_platform);\n  static tsl::StatusOr<Platform*> PlatformWithId(const Platform::Id& id,\n                                                 bool initialize_platform);\n\n  // Retrieves the platform registered with the given platform name (e.g.\n  // \"CUDA\", \"OpenCL\", ...) or id (an opaque, comparable value provided by the\n  // Platform's Id() method).\n  //\n  // The platform will be initialized with the given options. If the platform\n  // was already initialized, an error will be returned.\n  //\n  // If the requested platform is not registered, an error status is returned.\n  // Ownership of the platform is NOT transferred to the caller --\n  // the MultiPlatformManager owns the platforms in a singleton-like fashion.\n  static tsl::StatusOr<Platform*> InitializePlatformWithName(\n      absl::string_view target,\n      const std::map<std::string, std::string>& options);\n\n  static tsl::StatusOr<Platform*> InitializePlatformWithId(\n      const Platform::Id& id,\n      const std::map<std::string, std::string>& options);\n\n  // Retrieves the platforms satisfying the given filter, i.e. returns true.\n  // Returned Platforms are always initialized.\n  static tsl::StatusOr<std::vector<Platform*>> PlatformsWithFilter(\n      const std::function<bool(const Platform*)>& filter);\n\n  static tsl::StatusOr<std::vector<Platform*>> PlatformsWithFilter(\n      const std::function<bool(const Platform*)>& filter,\n      bool initialize_platform);\n\n  // Although the MultiPlatformManager \"owns\" its platforms, it holds them as\n  // undecorated pointers to prevent races during program exit (between this\n  // object's data and the underlying platforms (e.g., CUDA, OpenCL).\n  // Because certain platforms have unpredictable deinitialization\n  // times/sequences, it is not possible to strucure a safe deinitialization\n  // sequence. Thus, we intentionally \"leak\" allocated platforms to defer\n  // cleanup to the OS. This should be acceptable, as these are one-time\n  // allocations per program invocation.\n  // The MultiPlatformManager should be considered the owner\n  // of any platforms registered with it, and leak checking should be disabled\n  // during allocation of such Platforms, to avoid spurious reporting at program\n  // exit.\n\n  // Interface for a listener that gets notified at certain events.\n  class Listener {\n   public:\n    virtual ~Listener() = default;\n    // Callback that is invoked when a Platform is registered.\n    virtual void PlatformRegistered(Platform* platform) = 0;\n  };\n  // Registers a listeners to receive notifications about certain events.\n  // Precondition: No Platform has been registered yet.\n  static tsl::Status RegisterListener(std::unique_ptr<Listener> listener);\n};\n\n}  // namespace stream_executor\n\n// multi_platform_manager.cc will define these instances.\n//\n// Registering a platform:\n// REGISTER_MODULE_INITIALIZER_SEQUENCE(my_platform, multi_platform_manager);\n// REGISTER_MODULE_INITIALIZER_SEQUENCE(multi_platform_manager_listener,\n// my_platform);\n//\n// Registering a listener:\n// REGISTER_MODULE_INITIALIZER_SEQUENCE(my_listener,\n// multi_platform_manager_listener);\nDECLARE_MODULE_INITIALIZER(multi_platform_manager);\nDECLARE_MODULE_INITIALIZER(multi_platform_manager_listener);\n\n#endif  // TENSORFLOW_COMPILER_XLA_STREAM_EXECUTOR_MULTI_PLATFORM_MANAGER_H_"