"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/compiler/xla/stream_executor/plugin_registry.h\"\n\n#include \"absl/base/const_init.h\"\n#include \"absl/strings/str_cat.h\"\n#include \"absl/strings/str_format.h\"\n#include \"absl/synchronization/mutex.h\"\n#include \"tensorflow/compiler/xla/stream_executor/multi_platform_manager.h\"\n#include \"tensorflow/tsl/platform/errors.h\"\n\nnamespace stream_executor {\n\nconst PluginId kNullPlugin = nullptr;\n\n// Returns the string representation of the specified PluginKind.\nstd::string PluginKindString(PluginKind plugin_kind) {\n  switch (plugin_kind) {\n    case PluginKind::kBlas:\n      return \"BLAS\";\n    case PluginKind::kDnn:\n      return \"DNN\";\n    case PluginKind::kFft:\n      return \"FFT\";\n    case PluginKind::kRng:\n      return \"RNG\";\n    case PluginKind::kInvalid:\n    default:\n      return \"kInvalid\";\n  }\n}\n\nPluginRegistry::DefaultFactories::DefaultFactories() :\n    blas(kNullPlugin), dnn(kNullPlugin), fft(kNullPlugin), rng(kNullPlugin) { }\n\nstatic absl::Mutex& GetPluginRegistryMutex() {\n  static absl::Mutex mu(absl::kConstInit);\n  return mu;\n}\n\n/* static */ PluginRegistry* PluginRegistry::instance_ = nullptr;\n\nPluginRegistry::PluginRegistry() {}\n\n/* static */ PluginRegistry* PluginRegistry::Instance() {\n  absl::MutexLock lock{&GetPluginRegistryMutex()};\n  if (instance_ == nullptr) {\n    instance_ = new PluginRegistry();\n  }\n  return instance_;\n}\n\nvoid PluginRegistry::MapPlatformKindToId(PlatformKind platform_kind,\n                                         Platform::Id platform_id) {\n  platform_id_by_kind_[platform_kind] = platform_id;\n}\n\ntemplate <typename FACTORY_TYPE>\ntsl::Status PluginRegistry::RegisterFactoryInternal(\n    PluginId plugin_id, const std::string& plugin_name, FACTORY_TYPE factory,\n    std::map<PluginId, FACTORY_TYPE>* factories) {\n  absl::MutexLock lock{&GetPluginRegistryMutex()};\n\n  if (factories->find(plugin_id) != factories->end()) {\n    return tsl::Status(\n        tsl::error::ALREADY_EXISTS,\n        absl::StrFormat(\"Attempting to register factory for plugin %s when \"\n                        \"one has already been registered\",\n                        plugin_name));\n  }\n\n  (*factories)[plugin_id] = factory;\n  plugin_names_[plugin_id] = plugin_name;\n  return ::tsl::OkStatus();\n}\n\ntemplate <typename FACTORY_TYPE>\ntsl::StatusOr<FACTORY_TYPE> PluginRegistry::GetFactoryInternal(\n    PluginId plugin_id, const std::map<PluginId, FACTORY_TYPE>& factories,\n    const std::map<PluginId, FACTORY_TYPE>& generic_factories) const {\n  auto iter = factories.find(plugin_id);\n  if (iter == factories.end()) {\n    iter = generic_factories.find(plugin_id);\n    if (iter == generic_factories.end()) {\n      return tsl::Status(\n          tsl::error::NOT_FOUND,\n          absl::StrFormat(\"Plugin ID %p not registered.\", plugin_id));\n    }\n  }\n\n  return iter->second;\n}\n\nbool PluginRegistry::SetDefaultFactory(Platform::Id platform_id,\n                                       PluginKind plugin_kind,\n                                       PluginId plugin_id) {\n  if (!HasFactory(platform_id, plugin_kind, plugin_id)) {\n    tsl::StatusOr<Platform*> status =\n        MultiPlatformManager::PlatformWithId(platform_id);\n    std::string platform_name = \"<unregistered platform>\";\n    if (status.ok()) {\n      platform_name = status.value()->Name();\n    }\n\n    LOG(ERROR) << \"A factory must be registered for a platform before being \"\n               << \"set as default! \"\n               << \"Platform name: \" << platform_name\n               << \", PluginKind: \" << PluginKindString(plugin_kind)\n               << \", PluginId: \" << plugin_id;\n    return false;\n  }\n\n  switch (plugin_kind) {\n    case PluginKind::kBlas:\n      default_factories_[platform_id].blas = plugin_id;\n      break;\n    case PluginKind::kDnn:\n      default_factories_[platform_id].dnn = plugin_id;\n      break;\n    case PluginKind::kFft:\n      default_factories_[platform_id].fft = plugin_id;\n      break;\n    case PluginKind::kRng:\n      default_factories_[platform_id].rng = plugin_id;\n      break;\n    default:\n      LOG(ERROR) << \"Invalid plugin kind specified: \"\n                 << static_cast<int>(plugin_kind);\n      return false;\n  }\n\n  return true;\n}\n\nbool PluginRegistry::HasFactory(const PluginFactories& factories,\n                                PluginKind plugin_kind,\n                                PluginId plugin_id) const {\n  switch (plugin_kind) {\n    case PluginKind::kBlas:\n      return factories.blas.find(plugin_id) != factories.blas.end();\n    case PluginKind::kDnn:\n      return factories.dnn.find(plugin_id) != factories.dnn.end();\n    case PluginKind::kFft:\n      return factories.fft.find(plugin_id) != factories.fft.end();\n    case PluginKind::kRng:\n      return factories.rng.find(plugin_id) != factories.rng.end();\n    default:\n      LOG(ERROR) << \"Invalid plugin kind specified: \"\n                 << PluginKindString(plugin_kind);\n      return false;\n  }\n}\n\nbool PluginRegistry::HasFactory(Platform::Id platform_id,\n                                PluginKind plugin_kind,\n                                PluginId plugin_id) const {\n  auto iter = factories_.find(platform_id);\n  if (iter != factories_.end()) {\n    if (HasFactory(iter->second, plugin_kind, plugin_id)) {\n      return true;\n    }\n  }\n\n  return HasFactory(generic_factories_, plugin_kind, plugin_id);\n}\n\n// Explicit instantiations to support types exposed in user/public API.\n#define EMIT_PLUGIN_SPECIALIZATIONS(FACTORY_TYPE, FACTORY_VAR, PLUGIN_STRING) \\\n  template tsl::StatusOr<PluginRegistry::FACTORY_TYPE>                        \\\n  PluginRegistry::GetFactoryInternal<PluginRegistry::FACTORY_TYPE>(           \\\n      PluginId plugin_id,                                                     \\\n      const std::map<PluginId, PluginRegistry::FACTORY_TYPE>& factories,      \\\n      const std::map<PluginId, PluginRegistry::FACTORY_TYPE>&                 \\\n          generic_factories) const;                                           \\\n                                                                              \\\n  template tsl::Status                                                        \\\n  PluginRegistry::RegisterFactoryInternal<PluginRegistry::FACTORY_TYPE>(      \\\n      PluginId plugin_id, const std::string& plugin_name,                     \\\n      PluginRegistry::FACTORY_TYPE factory,                                   \\\n      std::map<PluginId, PluginRegistry::FACTORY_TYPE>* factories);           \\\n                                                                              \\\n  template <>                                                                 \\\n  tsl::Status PluginRegistry::RegisterFactory<PluginRegistry::FACTORY_TYPE>(  \\\n      Platform::Id platform_id, PluginId plugin_id, const std::string& name,  \\\n      PluginRegistry::FACTORY_TYPE factory) {                                 \\\n    return RegisterFactoryInternal(plugin_id, name, factory,                  \\\n                                   &factories_[platform_id].FACTORY_VAR);     \\\n  }                                                                           \\\n                                                                              \\\n  template <>                                                                 \\\n  tsl::Status PluginRegistry::RegisterFactoryForAllPlatforms<                 \\\n      PluginRegistry::FACTORY_TYPE>(PluginId plugin_id,                       \\\n                                    const std::string& name,                  \\\n                                    PluginRegistry::FACTORY_TYPE factory) {   \\\n    return RegisterFactoryInternal(plugin_id, name, factory,                  \\\n                                   &generic_factories_.FACTORY_VAR);          \\\n  }                                                                           \\\n                                                                              \\\n  template <>                                                                 \\\n  tsl::StatusOr<PluginRegistry::FACTORY_TYPE> PluginRegistry::GetFactory(     \\\n      Platform::Id platform_id, PluginId plugin_id) {                         \\\n    if (plugin_id == PluginConfig::kDefault) {                                \\\n      plugin_id = default_factories_[platform_id].FACTORY_VAR;                \\\n                                                                              \\\n      if (plugin_id == kNullPlugin) {                                         \\\n        return tsl::Status(                                                   \\\n            tsl::error::FAILED_PRECONDITION,                                  \\\n            \"No suitable \" PLUGIN_STRING                                      \\\n            \" plugin registered. Have you linked in a \" PLUGIN_STRING         \\\n            \"-providing plugin?\");                                            \\\n      } else {                                                                \\\n        VLOG(2) << \"Selecting default \" PLUGIN_STRING \" plugin, \"             \\\n                << plugin_names_[plugin_id];                                  \\\n      }                                                                       \\\n    }                                                                         \\\n    return GetFactoryInternal(plugin_id, factories_[platform_id].FACTORY_VAR, \\\n                              generic_factories_.FACTORY_VAR);                \\\n  }                                                                           \\\n                                                                              \\\n  /* TODO(b/22689637): Also temporary WRT MultiPlatformManager */             \\\n  template <>                                                                 \\\n  tsl::StatusOr<PluginRegistry::FACTORY_TYPE> PluginRegistry::GetFactory(     \\\n      PlatformKind platform_kind, PluginId plugin_id) {                       \\\n    auto iter = platform_id_by_kind_.find(platform_kind);                     \\\n    if (iter == platform_id_by_kind_.end()) {                                 \\\n      return tsl::Status(tsl::error::FAILED_PRECONDITION,                     \\\n                         absl::StrFormat(\"Platform kind %d not registered.\",  \\\n                                         static_cast<int>(platform_kind)));   \\\n    }                                                                         \\\n    return GetFactory<PluginRegistry::FACTORY_TYPE>(iter->second, plugin_id); \\\n  }\n\nEMIT_PLUGIN_SPECIALIZATIONS(BlasFactory, blas, \"BLAS\");\nEMIT_PLUGIN_SPECIALIZATIONS(DnnFactory, dnn, \"DNN\");\nEMIT_PLUGIN_SPECIALIZATIONS(FftFactory, fft, \"FFT\");\nEMIT_PLUGIN_SPECIALIZATIONS(RngFactory, rng, \"RNG\");\n\n}  // namespace stream_executor"