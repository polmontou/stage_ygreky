"/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"rocm/include/hiprand/hiprand.h\"\n#include \"tensorflow/compiler/xla/stream_executor/device_memory.h\"\n#include \"tensorflow/compiler/xla/stream_executor/gpu/gpu_activation.h\"\n#include \"tensorflow/compiler/xla/stream_executor/gpu/gpu_executor.h\"\n#include \"tensorflow/compiler/xla/stream_executor/gpu/gpu_helpers.h\"\n#include \"tensorflow/compiler/xla/stream_executor/gpu/gpu_rng.h\"\n#include \"tensorflow/compiler/xla/stream_executor/gpu/gpu_stream.h\"\n#include \"tensorflow/compiler/xla/stream_executor/platform/dso_loader.h\"\n#include \"tensorflow/compiler/xla/stream_executor/platform/initialize.h\"\n#include \"tensorflow/compiler/xla/stream_executor/platform/logging.h\"\n#include \"tensorflow/compiler/xla/stream_executor/rng.h\"\n#include \"tensorflow/compiler/xla/stream_executor/rocm/rocm_platform_id.h\"\n#include \"tensorflow/tsl/platform/env.h\"\n\n// Formats hiprandStatus_t to output prettified values into a log stream.\nstd::ostream& operator<<(std::ostream& in, const hiprandStatus_t& status) {\n#define OSTREAM_HIPRAND_STATUS(__name) \\\n  case HIPRAND_STATUS_##__name:        \\\n    in << \"HIPRAND_STATUS_\" #__name;   \\\n    return in;\n\n  switch (status) {\n    OSTREAM_HIPRAND_STATUS(SUCCESS)\n    OSTREAM_HIPRAND_STATUS(VERSION_MISMATCH)\n    OSTREAM_HIPRAND_STATUS(NOT_INITIALIZED)\n    OSTREAM_HIPRAND_STATUS(ALLOCATION_FAILED)\n    OSTREAM_HIPRAND_STATUS(TYPE_ERROR)\n    OSTREAM_HIPRAND_STATUS(OUT_OF_RANGE)\n    OSTREAM_HIPRAND_STATUS(LENGTH_NOT_MULTIPLE)\n    OSTREAM_HIPRAND_STATUS(LAUNCH_FAILURE)\n    OSTREAM_HIPRAND_STATUS(PREEXISTING_FAILURE)\n    OSTREAM_HIPRAND_STATUS(INITIALIZATION_FAILED)\n    OSTREAM_HIPRAND_STATUS(ARCH_MISMATCH)\n    OSTREAM_HIPRAND_STATUS(INTERNAL_ERROR)\n    default:\n      in << \"hiprandStatus_t(\" << static_cast<int>(status) << \")\";\n      return in;\n  }\n}\n\nnamespace stream_executor {\nnamespace gpu {\n\nPLUGIN_REGISTRY_DEFINE_PLUGIN_ID(kGpuRandPlugin);\n\nnamespace wrap {\n\n#ifdef PLATFORM_GOOGLE\n\n#define STREAM_EXECUTOR_HIPRAND_WRAP(__name)                        \\\n  struct WrapperShim__##__name {                                    \\\n    template <typename... Args>                                     \\\n    hiprandStatus_t operator()(GpuExecutor* parent, Args... args) { \\\n      gpu::ScopedActivateExecutorContext sac{parent};               \\\n      return ::__name(args...);                                     \\\n    }                                                               \\\n  } __name;\n\n#else\n\n#define STREAM_EXECUTOR_HIPRAND_WRAP(__name)                              \\\n  struct DynLoadShim__##__name {                                          \\\n    static const char* kName;                                             \\\n    using FuncPtrT = std::add_pointer<decltype(::__name)>::type;          \\\n    static void* GetDsoHandle() {                                         \\\n      auto s = internal::CachedDsoLoader::GetRocrandDsoHandle();          \\\n      return s.value();                                                   \\\n    }                                                                     \\\n    static FuncPtrT LoadOrDie() {                                         \\\n      void* f;                                                            \\\n      auto s = tsl::Env::Default()->GetSymbolFromLibrary(GetDsoHandle(),  \\\n                                                         kName, &f);      \\\n      CHECK(s.ok()) << \"could not find \" << kName                         \\\n                    << \" in rocrand DSO; dlerror: \" << s.error_message(); \\\n      return reinterpret_cast<FuncPtrT>(f);                               \\\n    }                                                                     \\\n    static FuncPtrT DynLoad() {                                           \\\n      static FuncPtrT f = LoadOrDie();                                    \\\n      return f;                                                           \\\n    }                                                                     \\\n    template <typename... Args>                                           \\\n    hiprandStatus operator()(GpuExecutor* parent, Args... args) {         \\\n      gpu::ScopedActivateExecutorContext sac{parent};                     \\\n      return DynLoad()(args...);                                          \\\n    }                                                                     \\\n  } __name;                                                               \\\n  const char* DynLoadShim__##__name::kName = #__name;\n\n#endif\n\nSTREAM_EXECUTOR_HIPRAND_WRAP(hiprandCreateGenerator);\nSTREAM_EXECUTOR_HIPRAND_WRAP(hiprandDestroyGenerator);\nSTREAM_EXECUTOR_HIPRAND_WRAP(hiprandSetStream);\nSTREAM_EXECUTOR_HIPRAND_WRAP(hiprandGenerateUniform);\nSTREAM_EXECUTOR_HIPRAND_WRAP(hiprandGenerateUniformDouble);\nSTREAM_EXECUTOR_HIPRAND_WRAP(hiprandSetPseudoRandomGeneratorSeed);\nSTREAM_EXECUTOR_HIPRAND_WRAP(hiprandSetGeneratorOffset);\nSTREAM_EXECUTOR_HIPRAND_WRAP(hiprandGenerateNormal);\nSTREAM_EXECUTOR_HIPRAND_WRAP(hiprandGenerateNormalDouble);\n\n}  // namespace wrap\n\nGpuRng::GpuRng(GpuExecutor* parent) : parent_(parent), rng_(nullptr) {}\n\nGpuRng::~GpuRng() {\n  if (rng_ != nullptr) {\n    wrap::hiprandDestroyGenerator(parent_, rng_);\n  }\n}\n\nbool GpuRng::Init() {\n  absl::MutexLock lock{&mu_};\n  CHECK(rng_ == nullptr);\n\n  hiprandStatus_t ret =\n      wrap::hiprandCreateGenerator(parent_, &rng_, HIPRAND_RNG_PSEUDO_DEFAULT);\n  if (ret != HIPRAND_STATUS_SUCCESS) {\n    LOG(ERROR) << \"failed to create random number generator: \" << ret;\n    return false;\n  }\n\n  CHECK(rng_ != nullptr);\n  return true;\n}\n\nbool GpuRng::SetStream(Stream* stream) {\n  hiprandStatus_t ret =\n      wrap::hiprandSetStream(parent_, rng_, AsGpuStreamValue(stream));\n  if (ret != HIPRAND_STATUS_SUCCESS) {\n    LOG(ERROR) << \"failed to set stream for random generation: \" << ret;\n    return false;\n  }\n\n  return true;\n}\n\n// Returns true if std::complex stores its contents as two consecutive\n// elements. Tests int, float and double, as the last two are independent\n// specializations.\nconstexpr bool ComplexIsConsecutiveFloats() {\n  return sizeof(std::complex<int>) == 8 && sizeof(std::complex<float>) == 8 &&\n         sizeof(std::complex<double>) == 16;\n}\n\ntemplate <typename T>\nbool GpuRng::DoPopulateRandUniformInternal(Stream* stream, DeviceMemory<T>* v) {\n  absl::MutexLock lock{&mu_};\n  static_assert(ComplexIsConsecutiveFloats(),\n                \"std::complex values are not stored as consecutive values\");\n\n  if (!SetStream(stream)) {\n    return false;\n  }\n\n  // std::complex<T> is currently implemented as two consecutive T variables.\n  uint64_t element_count = v->ElementCount();\n  if (std::is_same<T, std::complex<float>>::value ||\n      std::is_same<T, std::complex<double>>::value) {\n    element_count *= 2;\n  }\n\n  hiprandStatus_t ret;\n  if (std::is_same<T, float>::value ||\n      std::is_same<T, std::complex<float>>::value) {\n    ret = wrap::hiprandGenerateUniform(\n        parent_, rng_, reinterpret_cast<float*>(GpuMemoryMutable(v)),\n        element_count);\n  } else {\n    ret = wrap::hiprandGenerateUniformDouble(\n        parent_, rng_, reinterpret_cast<double*>(GpuMemoryMutable(v)),\n        element_count);\n  }\n  if (ret != HIPRAND_STATUS_SUCCESS) {\n    LOG(ERROR) << \"failed to do uniform generation of \" << v->ElementCount()\n               << \" \" << TypeString<T>() << \"s at \" << v->opaque() << \": \"\n               << ret;\n    return false;\n  }\n\n  return true;\n}\n\nbool GpuRng::DoPopulateRandUniform(Stream* stream, DeviceMemory<float>* v) {\n  return DoPopulateRandUniformInternal(stream, v);\n}\n\nbool GpuRng::DoPopulateRandUniform(Stream* stream, DeviceMemory<double>* v) {\n  return DoPopulateRandUniformInternal(stream, v);\n}\n\nbool GpuRng::DoPopulateRandUniform(Stream* stream,\n                                   DeviceMemory<std::complex<float>>* v) {\n  return DoPopulateRandUniformInternal(stream, v);\n}\n\nbool GpuRng::DoPopulateRandUniform(Stream* stream,\n                                   DeviceMemory<std::complex<double>>* v) {\n  return DoPopulateRandUniformInternal(stream, v);\n}\n\ntemplate <typename ElemT, typename FuncT>\nbool GpuRng::DoPopulateRandGaussianInternal(Stream* stream, ElemT mean,\n                                            ElemT stddev,\n                                            DeviceMemory<ElemT>* v,\n                                            FuncT func) {\n  absl::MutexLock lock{&mu_};\n\n  if (!SetStream(stream)) {\n    return false;\n  }\n\n  uint64_t element_count = v->ElementCount();\n  hiprandStatus_t ret =\n      func(parent_, rng_, GpuMemoryMutable(v), element_count, mean, stddev);\n\n  if (ret != HIPRAND_STATUS_SUCCESS) {\n    LOG(ERROR) << \"failed to do gaussian generation of \" << v->ElementCount()\n               << \" floats at \" << v->opaque() << \": \" << ret;\n    return false;\n  }\n\n  return true;\n}\n\nbool GpuRng::DoPopulateRandGaussian(Stream* stream, float mean, float stddev,\n                                    DeviceMemory<float>* v) {\n  return DoPopulateRandGaussianInternal(stream, mean, stddev, v,\n                                        wrap::hiprandGenerateNormal);\n}\n\nbool GpuRng::DoPopulateRandGaussian(Stream* stream, double mean, double stddev,\n                                    DeviceMemory<double>* v) {\n  return DoPopulateRandGaussianInternal(stream, mean, stddev, v,\n                                        wrap::hiprandGenerateNormalDouble);\n}\n\nbool GpuRng::SetSeed(Stream* stream, const uint8* seed, uint64_t seed_bytes) {\n  absl::MutexLock lock{&mu_};\n  CHECK(rng_ != nullptr);\n\n  if (!CheckSeed(seed, seed_bytes)) {\n    return false;\n  }\n\n  if (!SetStream(stream)) {\n    return false;\n  }\n\n  // Requires 8 bytes of seed data; checked in RngSupport::CheckSeed (above)\n  // (which itself requires 16 for API consistency with host RNG fallbacks).\n  hiprandStatus_t ret = wrap::hiprandSetPseudoRandomGeneratorSeed(\n      parent_, rng_, *(reinterpret_cast<const uint64_t*>(seed)));\n  if (ret != HIPRAND_STATUS_SUCCESS) {\n    LOG(ERROR) << \"failed to set rng seed: \" << ret;\n    return false;\n  }\n\n  ret = wrap::hiprandSetGeneratorOffset(parent_, rng_, 0);\n  if (ret != HIPRAND_STATUS_SUCCESS) {\n    LOG(ERROR) << \"failed to reset rng position: \" << ret;\n    return false;\n  }\n  return true;\n}\n\n}  // namespace gpu\n\nvoid initialize_rocrand() {\n  auto rocRandAlreadyRegistered = PluginRegistry::Instance()->HasFactory(\n      rocm::kROCmPlatformId, PluginKind::kRng, gpu::kGpuRandPlugin);\n\n  if (!rocRandAlreadyRegistered) {\n    tsl::Status status =\n        PluginRegistry::Instance()->RegisterFactory<PluginRegistry::RngFactory>(\n            rocm::kROCmPlatformId, gpu::kGpuRandPlugin, \"rocRAND\",\n            [](internal::StreamExecutorInterface* parent) -> rng::RngSupport* {\n              gpu::GpuExecutor* rocm_executor =\n                  dynamic_cast<gpu::GpuExecutor*>(parent);\n              if (rocm_executor == nullptr) {\n                LOG(ERROR)\n                    << \"Attempting to initialize an instance of the hipRAND \"\n                    << \"support library with a non-ROCM StreamExecutor\";\n                return nullptr;\n              }\n\n              gpu::GpuRng* rng = new gpu::GpuRng(rocm_executor);\n              if (!rng->Init()) {\n                // Note: Init() will log a more specific error.\n                delete rng;\n                return nullptr;\n              }\n              return rng;\n            });\n\n    if (!status.ok()) {\n      LOG(ERROR) << \"Unable to register rocRAND factory: \"\n                 << status.error_message();\n    }\n\n    PluginRegistry::Instance()->SetDefaultFactory(\n        rocm::kROCmPlatformId, PluginKind::kRng, gpu::kGpuRandPlugin);\n  }\n}\n\n}  // namespace stream_executor\n\nREGISTER_MODULE_INITIALIZER(register_rocrand,\n                            { stream_executor::initialize_rocrand(); });"