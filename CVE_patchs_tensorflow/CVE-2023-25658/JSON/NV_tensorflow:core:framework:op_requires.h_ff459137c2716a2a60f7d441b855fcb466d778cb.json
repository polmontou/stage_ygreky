"/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_CORE_FRAMEWORK_OP_REQUIRES_H_\n#define TENSORFLOW_CORE_FRAMEWORK_OP_REQUIRES_H_\n\n#include \"tensorflow/core/platform/macros.h\"\n\nnamespace tensorflow {\n\n// Convenience macros for asserting and handling exceptional conditions.\n// Analogous to the CHECK* macros provided by logging.h.\n//\n// Example use:\n// void Compute(OperationContext* context) {\n//   OP_REQUIRES(context, context->num_inputs() == 2,\n//               errors::InvalidArgument(\"FooOp requires 2 arguments\"));\n//   ...\n//   Status status = SomeUncertainMethod();\n//   OP_REQUIRES_OK(context, status);\n//   ...\n// }\n//\n// These macros depend on CheckNotInComputeAsync, which must be defined before\n// invoking the macro. We specifically don't include op_kernel.h from this\n// header to reduce this header's dependencies. These macros may be used with\n// alternative implementations of OpKernelContext with fewer dependencies.\n\n#define OP_REQUIRES(CTX, EXP, STATUS)                     \\\n  do {                                                    \\\n    if (!TF_PREDICT_TRUE(EXP)) {                          \\\n      CheckNotInComputeAsync((CTX), \"OP_REQUIRES_ASYNC\"); \\\n      (CTX)->CtxFailure(__FILE__, __LINE__, (STATUS));    \\\n      return;                                             \\\n    }                                                     \\\n  } while (0)\n\n#define OP_REQUIRES_OK(CTX, ...)                             \\\n  do {                                                       \\\n    ::tensorflow::Status _s(__VA_ARGS__);                    \\\n    if (!TF_PREDICT_TRUE(_s.ok())) {                         \\\n      CheckNotInComputeAsync((CTX), \"OP_REQUIRES_OK_ASYNC\"); \\\n      (CTX)->CtxFailureWithWarning(__FILE__, __LINE__, _s);  \\\n      return;                                                \\\n    }                                                        \\\n  } while (0)\n\n#define OP_REQUIRES_OK_OR_SET_PAYLOAD(CTX, PAYLOAD_KEY, PAYLOAD_VALUE, STATUS) \\\n  do {                                                                         \\\n    if (!TF_PREDICT_TRUE(STATUS.ok())) {                                       \\\n      CheckNotInComputeAsync((CTX), \"OP_REQUIRES_OK_ASYNC\");                   \\\n      if (!PAYLOAD_VALUE.empty()) {                                            \\\n        STATUS.SetPayload(PAYLOAD_KEY, absl::Cord(PAYLOAD_VALUE));             \\\n      }                                                                        \\\n      (CTX)->CtxFailureWithWarning(__FILE__, __LINE__, STATUS);                \\\n      return;                                                                  \\\n    }                                                                          \\\n  } while (0)\n\n#define OP_REQUIRES_ASYNC(CTX, EXP, STATUS, CALLBACK)  \\\n  do {                                                 \\\n    if (!TF_PREDICT_TRUE(EXP)) {                       \\\n      (CTX)->CtxFailure(__FILE__, __LINE__, (STATUS)); \\\n      (CALLBACK)();                                    \\\n      return;                                          \\\n    }                                                  \\\n  } while (0)\n\n#define OP_REQUIRES_OK_ASYNC(CTX, STATUS, CALLBACK)         \\\n  do {                                                      \\\n    const ::tensorflow::Status& _s(STATUS);                 \\\n    if (!TF_PREDICT_TRUE(_s.ok())) {                        \\\n      (CTX)->CtxFailureWithWarning(__FILE__, __LINE__, _s); \\\n      (CALLBACK)();                                         \\\n      return;                                               \\\n    }                                                       \\\n  } while (0)\n\n#define OP_REQUIRES_VALUE(lhs, ctx, rexpr)                                   \\\n  OP_REQUIRES_VALUE_IMPL(                                                    \\\n      TF_STATUS_MACROS_CONCAT_NAME(_status_or_value, __COUNTER__), lhs, ctx, \\\n      rexpr)\n\n#define OP_REQUIRES_VALUE_IMPL(statusor, lhs, ctx, rexpr) \\\n  auto statusor = (rexpr);                                \\\n  OP_REQUIRES_OK(ctx, statusor.status());                 \\\n  lhs = std::move(statusor.value())\n\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_CORE_FRAMEWORK_OP_REQUIRES_H_"