"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_TSL_DISTRIBUTED_RUNTIME_RPC_GRPC_UTIL_H_\n#define TENSORFLOW_TSL_DISTRIBUTED_RUNTIME_RPC_GRPC_UTIL_H_\n\n#include <memory>\n#include <string>\n\n#include \"grpcpp/grpcpp.h\"\n#include \"grpcpp/support/byte_buffer.h\"\n#include \"tensorflow/tsl/platform/protobuf.h\"\n#include \"tensorflow/tsl/platform/status.h\"\n#include \"tensorflow/tsl/platform/stringpiece.h\"\n#include \"tensorflow/tsl/platform/stringprintf.h\"\n#include \"tensorflow/tsl/protobuf/distributed_runtime_payloads.pb.h\"\n\nnamespace tsl {\n\n// Proto: tensorflow::distributed_runtime::GrpcPayloadsLost\n// Location: tsl/protobuf/distributed_runtime_payloads.proto\n// Usage: Flags the Status to have lost payloads during GRPC conversion.\nconstexpr char kGrpcPayloadsLost[] =\n    \"type.googleapis.com/tensorflow.distributed_runtime.GrpcPayloadsLost\";\n\n// Given the total number of RPC retries attempted, return a randomized\n// amount of time to delay before retrying the request.\n//\n// The average computed backoff increases with the number of RPCs attempted.\n// See implementation for details on the calculations.\nint64_t ComputeBackoffMicroseconds(int current_retry_attempt,\n                                   int64_t min_delay = 1000,\n                                   int64_t max_delay = 10000000);\n\nconstexpr char kStreamRemovedMessage[] = \"Stream removed\";\n\n// Identify if the given grpc::Status corresponds to an HTTP stream removed\n// error (see chttp2_transport.cc).\n//\n// When auto-reconnecting to a remote worker after it restarts, gRPC can return\n// an UNKNOWN error code with a \"Stream removed\" error message. This should not\n// be treated as an unrecoverable error.\n//\n// N.B. This is dependent on the error message from grpc remaining consistent.\ninline bool IsStreamRemovedError(const ::grpc::Status& s) {\n  return !s.ok() && s.error_code() == ::grpc::StatusCode::UNKNOWN &&\n         s.error_message() == kStreamRemovedMessage;\n}\n\ninline std::string SerializePayloads(const Status& s) {\n  tensorflow::distributed_runtime::GrpcPayloadContainer container;\n  s.ForEachPayload([&container](StringPiece key, StringPiece value) {\n    (*container.mutable_payloads())[std::string(key)] = std::string(value);\n  });\n  return container.SerializeAsString();\n}\n\ninline void InsertSerializedPayloads(Status& s, std::string payloads) {\n  tensorflow::distributed_runtime::GrpcPayloadContainer container;\n  if (container.ParseFromString(payloads)) {\n    for (const auto& key_val : container.payloads()) {\n      s.SetPayload(key_val.first, absl::Cord(key_val.second));\n    }\n  } else {\n    s.SetPayload(kGrpcPayloadsLost,\n                 absl::Cord(tensorflow::distributed_runtime::GrpcPayloadsLost()\n                                .SerializeAsString()));\n  }\n}\n\ninline Status FromGrpcStatus(const ::grpc::Status& s) {\n  if (s.ok()) {\n    return OkStatus();\n  } else {\n    Status converted;\n    // Convert \"UNKNOWN\" stream removed errors into unavailable, to allow\n    // for retry upstream.\n    if (IsStreamRemovedError(s)) {\n      converted = Status(tensorflow::error::UNAVAILABLE, s.error_message());\n    }\n    converted = Status(static_cast<tensorflow::error::Code>(s.error_code()),\n                       s.error_message());\n    InsertSerializedPayloads(converted, s.error_details());\n    return converted;\n  }\n}\n\ninline ::grpc::Status ToGrpcStatus(const Status& s) {\n  if (s.ok()) {\n    return ::grpc::Status::OK;\n  } else {\n    if (s.error_message().size() > 3072 /* 3k bytes */) {\n      // TODO(b/62947679): Remove truncation once the gRPC issue is resolved.\n      string scratch =\n          strings::Printf(\"%.3072s ... [truncated]\", s.error_message().c_str());\n      LOG(ERROR) << \"Truncated error message: \" << s;\n      return ::grpc::Status(static_cast<::grpc::StatusCode>(s.code()), scratch,\n                            SerializePayloads(s));\n    }\n    return ::grpc::Status(static_cast<::grpc::StatusCode>(s.code()),\n                          s.error_message(), SerializePayloads(s));\n  }\n}\n\ntypedef std::shared_ptr<::grpc::Channel> SharedGrpcChannelPtr;\n\n// Serialize src and store in *dst.\n::grpc::Status GrpcMaybeUnparseProto(const protobuf::Message& src,\n                                     ::grpc::ByteBuffer* dst);\n\n// Parse contents of src and initialize *dst with them.\nbool GrpcMaybeParseProto(::grpc::ByteBuffer* src, protobuf::Message* dst);\n\n// Copy string src to grpc buffer *dst.\n::grpc::Status GrpcMaybeUnparseProto(const string& src,\n                                     ::grpc::ByteBuffer* dst);\n\n// Copy grpc buffer src to string *dst.\nbool GrpcMaybeParseProto(::grpc::ByteBuffer* src, string* dst);\n\n// Copy grpc buffer src to tstring *dst.\nbool GrpcMaybeParseProto(::grpc::ByteBuffer* src, tstring* dst);\n}  // namespace tsl\n\n#endif  // TENSORFLOW_TSL_DISTRIBUTED_RUNTIME_RPC_GRPC_UTIL_H_"