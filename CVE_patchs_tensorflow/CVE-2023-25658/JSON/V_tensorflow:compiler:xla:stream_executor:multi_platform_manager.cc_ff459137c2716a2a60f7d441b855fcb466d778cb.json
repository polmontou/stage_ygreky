"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/compiler/xla/stream_executor/multi_platform_manager.h\"\n\n#include <string>\n\n#include \"absl/base/thread_annotations.h\"\n#include \"absl/container/flat_hash_map.h\"\n#include \"absl/strings/ascii.h\"\n#include \"absl/strings/str_format.h\"\n#include \"absl/strings/str_join.h\"\n#include \"absl/strings/string_view.h\"\n#include \"absl/synchronization/mutex.h\"\n#include \"tensorflow/compiler/xla/stream_executor/lib/error.h\"\n#include \"tensorflow/compiler/xla/stream_executor/lib/initialize.h\"\n#include \"tensorflow/tsl/platform/errors.h\"\n\nnamespace stream_executor {\nnamespace {\n\nclass MultiPlatformManagerImpl {\n public:\n  tsl::Status RegisterPlatform(std::unique_ptr<Platform> platform)\n      ABSL_LOCKS_EXCLUDED(mu_);\n\n  tsl::StatusOr<Platform*> PlatformWithName(absl::string_view target)\n      ABSL_LOCKS_EXCLUDED(mu_);\n\n  tsl::StatusOr<Platform*> PlatformWithId(const Platform::Id& id)\n      ABSL_LOCKS_EXCLUDED(mu_);\n\n  tsl::StatusOr<Platform*> PlatformWithName(absl::string_view target,\n                                            bool initialize_platform)\n      ABSL_LOCKS_EXCLUDED(mu_);\n\n  tsl::StatusOr<Platform*> PlatformWithId(const Platform::Id& id,\n                                          bool initialize_platform)\n      ABSL_LOCKS_EXCLUDED(mu_);\n\n  tsl::StatusOr<Platform*> InitializePlatformWithName(\n      absl::string_view target,\n      const std::map<std::string, std::string>& options)\n      ABSL_LOCKS_EXCLUDED(mu_);\n  tsl::StatusOr<Platform*> InitializePlatformWithId(\n      const Platform::Id& id, const std::map<std::string, std::string>& options)\n      ABSL_LOCKS_EXCLUDED(mu_);\n\n  tsl::StatusOr<std::vector<Platform*>> PlatformsWithFilter(\n      const std::function<bool(const Platform*)>& filter,\n      bool initialize_platform) ABSL_LOCKS_EXCLUDED(mu_);\n\n  using Listener = MultiPlatformManager::Listener;\n  tsl::Status RegisterListener(std::unique_ptr<Listener> listener)\n      ABSL_LOCKS_EXCLUDED(mu_);\n\n private:\n  // Looks up the platform object with the given name.  Assumes the Platforms\n  // mutex is held.\n  tsl::StatusOr<Platform*> LookupByNameLocked(absl::string_view target)\n      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);\n\n  // Looks up the platform object with the given id.  Assumes the Platforms\n  // mutex is held.\n  tsl::StatusOr<Platform*> LookupByIdLocked(const Platform::Id& id)\n      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);\n\n  // Returns the names of the initialied platforms satisfying the given filter.\n  // By default, it will return all initialized platform names.\n  std::vector<std::string> InitializedPlatformNamesWithFilter(\n      const std::function<bool(const Platform*)>& filter = [](const Platform*) {\n        return true;\n      }) ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);\n\n  absl::Mutex mu_;\n  std::vector<std::unique_ptr<Listener>> listeners_ ABSL_GUARDED_BY(mu_);\n  absl::flat_hash_map<Platform::Id, Platform*> id_map_ ABSL_GUARDED_BY(mu_);\n  absl::flat_hash_map<std::string, Platform*> name_map_ ABSL_GUARDED_BY(mu_);\n};\n\ntsl::Status MultiPlatformManagerImpl::RegisterPlatform(\n    std::unique_ptr<Platform> platform) {\n  CHECK(platform != nullptr);\n  std::string key = absl::AsciiStrToLower(platform->Name());\n  absl::MutexLock lock(&mu_);\n  if (name_map_.find(key) != name_map_.end()) {\n    return tsl::Status(port::error::INTERNAL,\n                       \"platform is already registered with name: \\\"\" +\n                           platform->Name() + \"\\\"\");\n  }\n  Platform* platform_ptr = platform.get();\n  CHECK(id_map_.emplace(platform->id(), platform_ptr).second);\n  // Release ownership/uniqueness to prevent destruction on program exit.\n  // This avoids Platforms \"cleaning up\" on program exit, because otherwise,\n  // there are _very_ tricky races between StreamExecutor and underlying\n  // platforms (CUDA, OpenCL) during exit. Since these are fixed-size and 1x per\n  // program, these are deemed acceptable.\n  name_map_[key] = platform.release();\n  for (const auto& listener : listeners_) {\n    listener->PlatformRegistered(platform_ptr);\n  }\n  return ::tsl::OkStatus();\n}\n\ntsl::StatusOr<Platform*> MultiPlatformManagerImpl::PlatformWithName(\n    absl::string_view target) {\n  return PlatformWithName(target, /*initialize_platform=*/true);\n}\n\ntsl::StatusOr<Platform*> MultiPlatformManagerImpl::PlatformWithId(\n    const Platform::Id& id) {\n  return PlatformWithId(id, /*initialize_platform=*/true);\n}\n\ntsl::StatusOr<Platform*> MultiPlatformManagerImpl::PlatformWithName(\n    absl::string_view target, bool initialize_platform) {\n  absl::MutexLock lock(&mu_);\n\n  TF_ASSIGN_OR_RETURN(Platform * platform, LookupByNameLocked(target));\n  if (initialize_platform && !platform->Initialized()) {\n    TF_RETURN_IF_ERROR(platform->Initialize({}));\n  }\n\n  return platform;\n}\n\ntsl::StatusOr<Platform*> MultiPlatformManagerImpl::PlatformWithId(\n    const Platform::Id& id, bool initialize_platform) {\n  absl::MutexLock lock(&mu_);\n\n  TF_ASSIGN_OR_RETURN(Platform * platform, LookupByIdLocked(id));\n  if (initialize_platform && !platform->Initialized()) {\n    TF_RETURN_IF_ERROR(platform->Initialize({}));\n  }\n\n  return platform;\n}\n\ntsl::StatusOr<Platform*> MultiPlatformManagerImpl::InitializePlatformWithName(\n    absl::string_view target,\n    const std::map<std::string, std::string>& options) {\n  absl::MutexLock lock(&mu_);\n\n  TF_ASSIGN_OR_RETURN(Platform * platform, LookupByNameLocked(target));\n  if (platform->Initialized()) {\n    return tsl::Status(\n        port::error::FAILED_PRECONDITION,\n        absl::StrCat(\"platform \\\"\", target, \"\\\" is already initialized\"));\n  }\n\n  TF_RETURN_IF_ERROR(platform->Initialize(options));\n\n  return platform;\n}\n\ntsl::StatusOr<Platform*> MultiPlatformManagerImpl::InitializePlatformWithId(\n    const Platform::Id& id, const std::map<std::string, std::string>& options) {\n  absl::MutexLock lock(&mu_);\n\n  TF_ASSIGN_OR_RETURN(Platform * platform, LookupByIdLocked(id));\n  if (platform->Initialized()) {\n    return tsl::Status(\n        port::error::FAILED_PRECONDITION,\n        absl::StrFormat(\"platform with id %p is already initialized\", id));\n  }\n\n  TF_RETURN_IF_ERROR(platform->Initialize(options));\n\n  return platform;\n}\n\ntsl::Status MultiPlatformManagerImpl::RegisterListener(\n    std::unique_ptr<Listener> listener) {\n  absl::MutexLock lock(&mu_);\n  CHECK(id_map_.empty());\n  CHECK(name_map_.empty());\n  listeners_.push_back(std::move(listener));\n  return ::tsl::OkStatus();\n}\n\ntsl::StatusOr<std::vector<Platform*>>\nMultiPlatformManagerImpl::PlatformsWithFilter(\n    const std::function<bool(const Platform*)>& filter,\n    bool initialize_platform) {\n  absl::MutexLock lock(&mu_);\n  CHECK_EQ(id_map_.size(), name_map_.size());\n  std::vector<Platform*> platforms;\n  platforms.reserve(id_map_.size());\n  for (const auto& entry : id_map_) {\n    Platform* platform = entry.second;\n    if (filter(platform)) {\n      if (initialize_platform && !platform->Initialized()) {\n        TF_RETURN_IF_ERROR(platform->Initialize({}));\n      }\n      platforms.push_back(platform);\n    }\n  }\n  return platforms;\n}\n\nstd::vector<std::string>\nMultiPlatformManagerImpl::InitializedPlatformNamesWithFilter(\n    const std::function<bool(const Platform*)>& filter) {\n  CHECK_EQ(id_map_.size(), name_map_.size());\n  std::vector<std::string> initialized_platforms_names;\n  initialized_platforms_names.reserve(id_map_.size());\n  for (const auto& entry : id_map_) {\n    Platform* platform = entry.second;\n    if (filter(platform)) {\n      if (platform->Initialized()) {\n        initialized_platforms_names.push_back(platform->Name());\n      }\n    }\n  }\n  return initialized_platforms_names;\n}\n\ntsl::StatusOr<Platform*> MultiPlatformManagerImpl::LookupByNameLocked(\n    absl::string_view target) {\n  auto it = name_map_.find(absl::AsciiStrToLower(target));\n  if (it == name_map_.end()) {\n    return tsl::Status(\n        port::error::NOT_FOUND,\n        absl::StrCat(\"Could not find registered platform with name: \\\"\", target,\n                     \"\\\". Available platform names are: \",\n                     absl::StrJoin(InitializedPlatformNamesWithFilter(), \" \")));\n  }\n  return it->second;\n}\n\ntsl::StatusOr<Platform*> MultiPlatformManagerImpl::LookupByIdLocked(\n    const Platform::Id& id) {\n  auto it = id_map_.find(id);\n  if (it == id_map_.end()) {\n    return tsl::Status(\n        port::error::NOT_FOUND,\n        absl::StrFormat(\"could not find registered platform with id: %p\", id));\n  }\n  return it->second;\n}\n\nMultiPlatformManagerImpl& Impl() {\n  static MultiPlatformManagerImpl* impl = new MultiPlatformManagerImpl;\n  return *impl;\n}\n\n}  // namespace\n\n/*static*/ tsl::Status MultiPlatformManager::RegisterPlatform(\n    std::unique_ptr<Platform> platform) {\n  return Impl().RegisterPlatform(std::move(platform));\n}\n\n/*static*/ tsl::StatusOr<Platform*> MultiPlatformManager::PlatformWithName(\n    absl::string_view target) {\n  return Impl().PlatformWithName(target);\n}\n\n/*static*/ tsl::StatusOr<Platform*> MultiPlatformManager::PlatformWithId(\n    const Platform::Id& id) {\n  return Impl().PlatformWithId(id);\n}\n\n/*static*/ tsl::StatusOr<Platform*> MultiPlatformManager::PlatformWithId(\n    const Platform::Id& id, bool initialize_platform) {\n  return Impl().PlatformWithId(id, initialize_platform);\n}\n\n/*static*/ tsl::StatusOr<Platform*> MultiPlatformManager::PlatformWithName(\n    absl::string_view target, bool initialize_platform) {\n  return Impl().PlatformWithName(target, initialize_platform);\n}\n\n/*static*/ tsl::StatusOr<Platform*>\nMultiPlatformManager::InitializePlatformWithName(\n    absl::string_view target,\n    const std::map<std::string, std::string>& options) {\n  return Impl().InitializePlatformWithName(target, options);\n}\n\n/*static*/ tsl::StatusOr<Platform*>\nMultiPlatformManager::InitializePlatformWithId(\n    const Platform::Id& id, const std::map<std::string, std::string>& options) {\n  return Impl().InitializePlatformWithId(id, options);\n}\n\n/*static*/ tsl::Status MultiPlatformManager::RegisterListener(\n    std::unique_ptr<Listener> listener) {\n  return Impl().RegisterListener(std::move(listener));\n}\n\n/*static*/ tsl::StatusOr<std::vector<Platform*>>\nMultiPlatformManager::PlatformsWithFilter(\n    const std::function<bool(const Platform*)>& filter) {\n  return PlatformsWithFilter(filter, /*initialize_platform=*/true);\n}\n\n/*static*/ tsl::StatusOr<std::vector<Platform*>>\nMultiPlatformManager::PlatformsWithFilter(\n    const std::function<bool(const Platform*)>& filter,\n    bool initialize_platform) {\n  return Impl().PlatformsWithFilter(filter, initialize_platform);\n}\n\n}  // namespace stream_executor\n\nREGISTER_MODULE_INITIALIZER(\n    multi_platform_manager,\n    {\n        // Nothing -- this is just a module initializer\n        // definition to reference for sequencing\n        // purposes from Platform subclasses that register\n        // themselves with the MultiPlatformManager.\n    });\n\nREGISTER_MODULE_INITIALIZER(\n    multi_platform_manager_listener,\n    {\n        // Nothing -- this is just a module initializer definition to reference\n        // for sequencing registration of listeners with the\n        // MultiPlatformManager.\n    });\n\n// Listener registration should happen before platform registration.\nREGISTER_MODULE_INITIALIZER_SEQUENCE(multi_platform_manager_listener,\n                                     multi_platform_manager);"