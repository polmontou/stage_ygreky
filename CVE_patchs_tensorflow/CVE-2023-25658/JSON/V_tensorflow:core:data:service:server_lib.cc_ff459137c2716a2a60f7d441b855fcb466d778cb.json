"/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/data/service/server_lib.h\"\n\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"grpcpp/server.h\"\n#include \"grpcpp/server_builder.h\"\n#include \"tensorflow/core/data/service/credentials_factory.h\"\n#include \"tensorflow/core/data/service/export.pb.h\"\n#include \"tensorflow/core/data/service/grpc_dispatcher_impl.h\"\n#include \"tensorflow/core/data/service/grpc_util.h\"\n#include \"tensorflow/core/data/service/grpc_worker_impl.h\"\n#include \"tensorflow/core/platform/errors.h\"\n\nnamespace tensorflow {\nnamespace data {\n\nnamespace {\nconstexpr char kPortPlaceholder[] = \"%port%\";\n}\n\nGrpcDataServerBase::GrpcDataServerBase(\n    int port, const std::string& protocol, const std::string server_type,\n    std::vector<std::unique_ptr<::grpc::ServerBuilderOption>> options)\n    : requested_port_(port),\n      protocol_(protocol),\n      server_type_(server_type),\n      bound_port_(port),\n      server_options_(std::move(options)) {}\n\nStatus GrpcDataServerBase::Start() {\n  if (stopped_) {\n    return errors::FailedPrecondition(\n        \"Server cannot be started after it has been stopped.\");\n  }\n  if (started_) {\n    return OkStatus();\n  }\n  ::grpc::ServerBuilder builder;\n  for (std::unique_ptr<::grpc::ServerBuilderOption>& option : server_options_) {\n    builder.SetOption(std::move(option));\n  }\n  server_options_.clear();\n\n  std::shared_ptr<::grpc::ServerCredentials> credentials;\n  TF_RETURN_IF_ERROR(\n      CredentialsFactory::CreateServerCredentials(protocol_, &credentials));\n  builder.AddListeningPort(strings::StrCat(\"0.0.0.0:\", requested_port_),\n                           credentials, &bound_port_);\n  builder.SetMaxReceiveMessageSize(-1);\n\n  AddDataServiceToBuilder(builder);\n  AddProfilerServiceToBuilder(builder);\n  server_ = builder.BuildAndStart();\n  if (!server_) {\n    return errors::Internal(\"Could not start gRPC server\");\n  }\n\n  TF_RETURN_IF_ERROR(StartServiceInternal());\n\n  started_ = true;\n  LOG(INFO) << \"Started tf.data \" << server_type_\n            << \" running at 0.0.0.0:\" << BoundPort();\n  return OkStatus();\n}\n\nvoid GrpcDataServerBase::Stop() {\n  if (stopped_) {\n    return;\n  }\n  if (server_) {\n    StopServiceInternal();\n    server_->Shutdown();\n    LOG(INFO) << \"Shut down \" << server_type_ << \" server running at port \"\n              << BoundPort();\n  }\n  stopped_ = true;\n}\n\nvoid GrpcDataServerBase::Join() { server_->Wait(); }\n\nint GrpcDataServerBase::BoundPort() { return bound_port(); }\n\nvoid GrpcDataServerBase::AddProfilerServiceToBuilder(\n    ::grpc::ServerBuilder& builder) {\n  profiler_service_ = profiler::CreateProfilerService();\n  builder.RegisterService(profiler_service_.get());\n}\n\nDispatchGrpcDataServer::DispatchGrpcDataServer(\n    const experimental::DispatcherConfig& config,\n    std::vector<std::unique_ptr<::grpc::ServerBuilderOption>> options)\n    : GrpcDataServerBase(config.port(), config.protocol(), \"DispatchServer\",\n                         std::move(options)),\n      config_(config) {}\n\nDispatchGrpcDataServer::~DispatchGrpcDataServer() { delete service_; }\n\nvoid DispatchGrpcDataServer::AddDataServiceToBuilder(\n    ::grpc::ServerBuilder& builder) {\n  service_ = std::make_unique<GrpcDispatcherImpl>(config_, builder).release();\n}\n\nStatus DispatchGrpcDataServer::StartServiceInternal() {\n  return service_->Start();\n}\n\nStatus DispatchGrpcDataServer::NumWorkers(int* num_workers) {\n  GetWorkersRequest req;\n  GetWorkersResponse resp;\n  ::grpc::ServerContext ctx;\n  ::grpc::Status s = service_->GetWorkers(&ctx, &req, &resp);\n  if (!s.ok()) {\n    return grpc_util::WrapError(\"Failed to get workers\", s);\n  }\n  *num_workers = resp.workers_size();\n  return OkStatus();\n}\n\nsize_t DispatchGrpcDataServer::NumActiveIterations() {\n  return service_->NumActiveIterations();\n}\n\nServerStateExport DispatchGrpcDataServer::ExportState() const {\n  ServerStateExport server_state_export;\n  *server_state_export.mutable_dispatcher_state_export() =\n      service_->ExportState();\n  return server_state_export;\n}\n\nWorkerGrpcDataServer::WorkerGrpcDataServer(\n    const experimental::WorkerConfig& config,\n    std::vector<std::unique_ptr<::grpc::ServerBuilderOption>> options)\n    : GrpcDataServerBase(config.port(), config.protocol(), \"WorkerServer\",\n                         std::move(options)),\n      config_(config) {}\n\nWorkerGrpcDataServer::~WorkerGrpcDataServer() { delete service_; }\n\nvoid WorkerGrpcDataServer::AddDataServiceToBuilder(\n    ::grpc::ServerBuilder& builder) {\n  service_ = std::make_unique<GrpcWorkerImpl>(config_, builder).release();\n}\n\nStatus WorkerGrpcDataServer::StartServiceInternal() {\n  std::string base_address = config_.worker_address();\n  if (base_address.empty()) {\n    base_address = absl::StrCat(\"localhost:\", kPortPlaceholder);\n  }\n  std::string worker_address = str_util::StringReplace(\n      base_address, kPortPlaceholder, absl::StrCat(bound_port()),\n      /*replace_all=*/false);\n  std::string transfer_address = worker_address;\n  std::string transfer_protocol = config_.data_transfer_protocol();\n  if (!transfer_protocol.empty() && transfer_protocol != \"grpc\") {\n    TF_RETURN_IF_ERROR(DataTransferServer::Build(\n        transfer_protocol, service_->get_element_getter(), &transfer_server_));\n    TF_RETURN_IF_ERROR(transfer_server_->Start());\n    LOG(INFO) << \"Data transfer server started at 0.0.0.0:\"\n              << transfer_server_->get_port();\n    transfer_address = str_util::StringReplace(\n        config_.data_transfer_address(), kPortPlaceholder,\n        absl::StrCat(transfer_server_->get_port()),\n        /*replace_all=*/false);\n  }\n  TF_RETURN_IF_ERROR(service_->Start(worker_address, transfer_address));\n  return OkStatus();\n}\n\nvoid WorkerGrpcDataServer::StopServiceInternal() { service_->Stop(); }\n\nStatus WorkerGrpcDataServer::NumTasks(int* num_tasks) {\n  GetWorkerTasksRequest req;\n  GetWorkerTasksResponse resp;\n  ::grpc::ServerContext ctx;\n  ::grpc::Status s = service_->GetWorkerTasks(&ctx, &req, &resp);\n  if (!s.ok()) {\n    return grpc_util::WrapError(\"Failed to get tasks\", s);\n  }\n  *num_tasks = resp.tasks_size();\n  return OkStatus();\n}\n\nServerStateExport WorkerGrpcDataServer::ExportState() const {\n  ServerStateExport server_state_export;\n  *server_state_export.mutable_worker_state_export() = service_->ExportState();\n  return server_state_export;\n}\n\nStatus NewDispatchServer(const experimental::DispatcherConfig& config,\n                         std::unique_ptr<DispatchGrpcDataServer>& out_server) {\n  out_server = std::make_unique<DispatchGrpcDataServer>(config);\n  return OkStatus();\n}\n\nStatus NewWorkerServer(const experimental::WorkerConfig& config,\n                       std::unique_ptr<WorkerGrpcDataServer>& out_server) {\n  out_server = std::make_unique<WorkerGrpcDataServer>(config);\n  return OkStatus();\n}\n\n}  // namespace data\n}  // namespace tensorflow"