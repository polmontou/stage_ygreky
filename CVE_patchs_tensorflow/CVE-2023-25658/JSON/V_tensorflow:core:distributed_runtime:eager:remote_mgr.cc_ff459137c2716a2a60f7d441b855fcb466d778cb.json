"/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/distributed_runtime/eager/remote_mgr.h\"\n\n#include <memory>\n#include <tuple>\n#include <utility>\n#include <vector>\n\n#include \"tensorflow/core/distributed_runtime/eager/remote_tensor_handle.h\"\n#include \"tensorflow/core/platform/error_payloads.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/status.h\"\n\nnamespace tensorflow {\n\nnamespace {\nStatus WithErrorSourcePayload(Status error) {\n  core::platform::ErrorSourceProto error_source_proto;\n  error_source_proto.set_error_source(\n      core::platform::ErrorSourceProto::EAGER_REMOTE_MGR);\n  error.SetPayload(tensorflow::kErrorSource,\n                   error_source_proto.SerializeAsString());\n  return error;\n}\n}  // namespace\n\nnamespace eager {\n\nvoid RemoteMgr::AddOperationOutputs(\n    const gtl::ArraySlice<tensorflow::TensorHandle*> handles,\n    int64_t operation_id) {\n  mutex_lock l(remote_tensor_handle_mu_);\n  for (int i = 0, end = handles.size(); i < end; i++) {\n    // TODO(nareshmodi): Correctly handle operation_id not being unique.\n    remote_tensor_handle_map_.emplace(\n        RemoteTensorHandleInternal(operation_id, i), handles[i]);\n  }\n}\n\nvoid RemoteMgr::AddOperationOutput(tensorflow::TensorHandle* handle,\n                                   int64_t operation_id, int32_t output_num) {\n  mutex_lock l(remote_tensor_handle_mu_);\n  remote_tensor_handle_map_.emplace(\n      RemoteTensorHandleInternal(operation_id, output_num), handle);\n}\n\nStatus RemoteMgr::GetTensorHandleImpl(\n    const RemoteTensorHandleInternal& remote_handle,\n    tensorflow::TensorHandle** handle) {\n  auto iter = remote_tensor_handle_map_.find(remote_handle);\n  if (iter == remote_tensor_handle_map_.end()) {\n    // TODO(b/217820532): Fix the tensor deallocation order issue.\n    return WithErrorSourcePayload(errors::InvalidArgument(\n        \"Unable to find the relevant tensor remote_handle: Op ID: \",\n        remote_handle.op_id, \", Output num: \", remote_handle.output_num,\n        \". One possible cause is that the tensor was accessed after \"\n        \"deallocation in a distributed worker setup. Try setting \"\n        \"`os.environ['TF_ENABLE_EAGER_CLIENT_STREAMING_ENQUEUE']='False'` in \"\n        \"your client to disable async streaming behavior to see if it fixes \"\n        \"the problem.\"));\n  }\n\n  *handle = iter->second;\n\n  return OkStatus();\n}\n\nStatus RemoteMgr::GetTensorHandle(\n    const RemoteTensorHandleInternal& remote_handle,\n    tensorflow::TensorHandle** handle) {\n  tf_shared_lock l(remote_tensor_handle_mu_);\n  return GetTensorHandleImpl(remote_handle, handle);\n}\n\nStatus RemoteMgr::GetMirroredResourceShape(\n    const RemoteTensorHandleInternal& remote_handle,\n    std::vector<DtypeAndPartialTensorShape>* handle) {\n  tf_shared_lock l(mirrored_resource_shape_mu_);\n  auto iter = mirrored_resource_shape_map_.find(remote_handle);\n  if (iter == mirrored_resource_shape_map_.end()) {\n    // TODO(b/217820532): Fix the tensor deallocation order issue.\n    return WithErrorSourcePayload(errors::InvalidArgument(\n        \"Unable to find the relevant tensor remote_handle: Op ID: \",\n        remote_handle.op_id, \", Output num: \", remote_handle.output_num,\n        \". One possible cause is that the tensor was accessed after \"\n        \"deallocation in a distributed worker setup. Try setting \"\n        \"`os.environ['TF_ENABLE_EAGER_CLIENT_STREAMING_ENQUEUE']='False'` in \"\n        \"your client to disable async streaming behavior to see if it fixes \"\n        \"the problem.\"));\n  }\n\n  *handle = iter->second;\n\n  return OkStatus();\n}\n\nStatus RemoteMgr::GetRemoteTensorHandle(const tensorflow::TensorHandle* handle,\n                                        const bool wait_until_ready,\n                                        int64_t* op_id, int32* output_num) {\n  TF_RETURN_IF_ERROR(handle->RemoteAddress(handle->device(), wait_until_ready,\n                                           op_id, output_num));\n  tensorflow::TensorHandle* h;\n  TF_RETURN_IF_ERROR(\n      GetTensorHandleImpl(RemoteTensorHandleInternal(*op_id, *output_num), &h));\n  if (handle != h) {\n    return WithErrorSourcePayload(errors::Internal(\n        \"Found two different tensor handles with the same op_id:\", *op_id,\n        \" and output_num:\", *output_num));\n  }\n  return OkStatus();\n}\n\nStatus RemoteMgr::DeleteTensorHandle(\n    const RemoteTensorHandleInternal& remote_handle) {\n  {\n    mutex_lock l(remote_tensor_handle_mu_);\n    auto iter = remote_tensor_handle_map_.find(remote_handle);\n    if (iter != remote_tensor_handle_map_.end()) {\n      iter->second->Unref();\n      remote_tensor_handle_map_.erase(iter);\n      return OkStatus();\n    }\n  }\n  {\n    mutex_lock l(mirrored_resource_shape_mu_);\n    auto iter = mirrored_resource_shape_map_.find(remote_handle);\n    if (iter != mirrored_resource_shape_map_.end()) {\n      mirrored_resource_shape_map_.erase(iter);\n      return OkStatus();\n    }\n  }\n  return WithErrorSourcePayload(errors::InvalidArgument(\n      \"Unable to find the relevant tensor remote_handle: Op ID: \",\n      remote_handle.op_id, \", Output num: \", remote_handle.output_num));\n}\n\nStatus RemoteMgr::SerializeRemoteTensorHandle(\n    TensorHandle* in, const bool wait_until_ready, RemoteTensorHandle* out,\n    Device* device, const string& device_name,\n    const bool serialize_resource_dtype_and_shape) {\n  int64_t op_id;\n  int32_t output_num;\n  if (!in->RemoteAddress(device, wait_until_ready, &op_id, &output_num).ok()) {\n    tf_shared_lock l(remote_tensor_handle_mu_);\n    TF_RETURN_IF_ERROR(\n        GetRemoteTensorHandle(in, wait_until_ready, &op_id, &output_num));\n  }\n  out->Clear();\n  out->set_op_id(op_id);\n  out->set_output_num(output_num);\n  out->set_op_device(in->op_device() ? in->op_device()->name() : \"\");\n  out->set_device(device_name);\n  out->set_dtype(in->dtype);\n  if (serialize_resource_dtype_and_shape) {\n    std::vector<DtypeAndPartialTensorShape> resource_dtypes_and_shapes;\n    TF_RETURN_IF_ERROR(\n        in->GetResourceHandleDtypesAndShapes(&resource_dtypes_and_shapes));\n    for (const auto& dtype_and_shape : resource_dtypes_and_shapes) {\n      ResourceDtypeAndShape* dtype_and_shape_proto =\n          out->add_resource_dtypes_and_shapes();\n      dtype_and_shape_proto->set_dtype(dtype_and_shape.dtype);\n      dtype_and_shape.shape.AsProto(dtype_and_shape_proto->mutable_shape());\n    }\n  }\n  return OkStatus();\n}\n\nStatus RemoteMgr::DeserializeRemoteTensorHandle(const RemoteTensorHandle& in,\n                                                TensorHandle** out) {\n  Device* device;\n  if (parent_->local_device_mgr()->LookupDevice(in.op_device(), &device).ok() ||\n      parent_->local_device_mgr()->LookupDevice(in.device(), &device).ok()) {\n    TF_RETURN_IF_ERROR(GetTensorHandle(RemoteTensorHandleInternal(in), out));\n    (*out)->Ref();\n  } else {\n    // Create a remote TensorHandle for remote tensors which have not been\n    // copied to the local worker yet (e.g. remote function inputs).\n    const string& device_name =\n        in.op_device().empty() ? in.device() : in.op_device();\n    TF_RETURN_IF_ERROR(\n        parent_->FindDeviceFromName(device_name.c_str(), &device));\n    *out = TensorHandle::CreateLazyRemoteHandle(in.op_id(), in.output_num(),\n                                                in.dtype(), device,\n                                                /*is_ready=*/true, parent_);\n    std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes;\n    if (!GetMirroredResourceShape(RemoteTensorHandleInternal(in),\n                                  &dtypes_and_shapes)\n             .ok()) {\n      for (const auto& dtype_and_shape_proto :\n           in.resource_dtypes_and_shapes()) {\n        dtypes_and_shapes.push_back(DtypeAndPartialTensorShape{\n            dtype_and_shape_proto.dtype(),\n            TensorShape(dtype_and_shape_proto.shape())});\n      }\n      mutex_lock l(mirrored_resource_shape_mu_);\n      mirrored_resource_shape_map_.emplace(\n          RemoteTensorHandleInternal(in.op_id(), in.output_num()),\n          dtypes_and_shapes);\n    }\n    (*out)->SetResourceHandleDtypeAndShape(std::move(dtypes_and_shapes));\n  }\n\n  return OkStatus();\n}\n\nEagerExecutor& RemoteMgr::GetOrCreateExecutorForStream(uint64 stream_id) {\n  mutex_lock l(executor_map_mu_);\n  auto it = executor_map_.find(stream_id);\n  if (it == executor_map_.end()) {\n    auto it_and_bool = executor_map_.emplace(\n        std::piecewise_construct, std::forward_as_tuple(stream_id),\n        std::forward_as_tuple(/*async=*/true));\n    DCHECK(it_and_bool.second);\n    it = it_and_bool.first;\n  }\n  return it->second;\n}\n\nvoid RemoteMgr::DeleteExecutorForStream(uint64 stream_id) {\n  mutex_lock l(executor_map_mu_);\n  auto it = executor_map_.find(stream_id);\n  if (it == executor_map_.end()) {\n    return;\n  }\n  Status s = it->second.ShutDown();\n  if (!s.ok()) {\n    LOG(ERROR) << \"EagerExecutor shutdown with error \" << s.error_message();\n  }\n  executor_map_.erase(it);\n}\n\n}  // namespace eager\n}  // namespace tensorflow"