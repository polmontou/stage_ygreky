"/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/tpu/kernels/tpu_functional_ops.h\"\n\n#include <algorithm>\n#include <memory>\n\n#include \"absl/strings/match.h\"\n#include \"tensorflow/compiler/xla/stream_executor/tpu/c_api_decl.h\"\n#include \"tensorflow/compiler/xla/stream_executor/tpu/tpu_platform_interface.h\"\n#include \"tensorflow/core/framework/cancellation.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/platform/status.h\"\n#include \"tensorflow/core/protobuf/error_codes.pb.h\"\n#include \"tensorflow/core/protobuf/tpu/topology.pb.h\"\n\n#define EIGEN_USE_THREADS\n\n#include \"absl/base/call_once.h\"\n#include \"absl/strings/str_cat.h\"\n#include \"absl/synchronization/mutex.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/compiler/tf2xla/sharding_util.h\"\n#include \"tensorflow/compiler/tf2xla/side_effect_util.h\"\n#include \"tensorflow/compiler/xla/xla_data.pb.h\"\n#include \"tensorflow/core/common_runtime/function_body.h\"\n#include \"tensorflow/core/common_runtime/graph_constructor.h\"\n#include \"tensorflow/core/common_runtime/placer.h\"\n#include \"tensorflow/core/common_runtime/rendezvous_mgr.h\"\n#include \"tensorflow/core/framework/graph_to_functiondef.h\"\n#include \"tensorflow/core/framework/metrics.h\"\n#include \"tensorflow/core/framework/node_def.pb.h\"\n#include \"tensorflow/core/framework/node_def_util.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/framework/resource_var.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor.pb.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/graph/graph_partition.h\"\n#include \"tensorflow/core/graph/node_builder.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/hash/hash.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/platform/blocking_counter.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/fingerprint.h\"\n#include \"tensorflow/core/platform/refcount.h\"\n#include \"tensorflow/core/profiler/lib/traceme.h\"\n#include \"tensorflow/core/tpu/kernels/tpu_compile_op_support.h\"\n#include \"tensorflow/core/tpu/kernels/tpu_fingerprint_lookup.h\"\n#include \"tensorflow/core/tpu/kernels/tpu_op_consts.h\"\n#include \"tensorflow/core/tpu/kernels/tpu_op_util.h\"\n#include \"tensorflow/core/tpu/kernels/tpu_util.h\"\n#include \"tensorflow/core/tpu/tpu_configuration.h\"\n#include \"tensorflow/core/tpu/tpu_defs.h\"\n#include \"tensorflow/core/util/dump_graph.h\"\n\nnamespace tensorflow {\nnamespace {\n\nconstexpr char kTpuReplicateAttr[] = \"_tpu_replicate\";\nconstexpr int kLastDimOfTpuInputFastPath = 128;\nconstexpr int kOtherDimOfTpuInputFastPath = 8;\n\nconstexpr char kXLAShardingAttrName[] = \"sharding\";\nconstexpr char kXLAShardingAttrAltName[] = \"_XlaSharding\";\n\ntpu::TopologyProto GetTPUTopology() {\n  const tpu::TpuTopologyExternal& topology =\n      tpu::TpuPlatformInterface::GetRegisteredPlatform()->topology();\n\n  tpu::TopologyProto topology_proto;\n  topology_proto.set_num_tasks(topology.HostCount());\n  topology_proto.set_num_tpu_devices_per_task(\n      topology.LogicalDevicesPerHost(TpuCoreTypeEnum::kTensorCore));\n\n  // mesh shape.\n  int devices_per_chip =\n      topology.LogicalDevicesPerChip(TpuCoreTypeEnum::kTensorCore);\n  topology_proto.add_mesh_shape(topology.chip_bounds().x);\n  topology_proto.add_mesh_shape(topology.chip_bounds().y);\n  topology_proto.add_mesh_shape(topology.chip_bounds().z);\n  topology_proto.add_mesh_shape(devices_per_chip);\n\n  // device coordinates.\n  for (const tpu::TpuCoreLocationExternal& core :\n       topology.cores(TpuCoreTypeEnum::kTensorCore)) {\n    const tpu::TpuDimensionsExternal coords = core.chip_coordinates();\n    topology_proto.add_device_coordinates(coords.x);\n    topology_proto.add_device_coordinates(coords.y);\n    topology_proto.add_device_coordinates(coords.z);\n    topology_proto.add_device_coordinates(core.index());\n  }\n\n  return topology_proto;\n}\n\nstruct TPUVariableInfo {\n  TPUVariableInfo(int device_ordinal_id, bool use_fast_mem)\n      : device_ordinal(device_ordinal_id), fast_mem(use_fast_mem) {}\n  // The TPU core which the variable will be placed on.\n  int device_ordinal;\n  // If true, try to place the variable on fast memory space if hardware\n  // support.\n  bool fast_mem;\n};\n\n// Check the descendants to parse the placement information for the input node.\n// num_cores_per_replica descriables how many cores the single model uses.\nStatus ParseTPUVariableInfor(const Node* node, const int num_cores_per_replica,\n                             TPUVariableInfo* var_info) {\n  int core = 0;\n  bool use_fast_mem = false;\n  VLOG(3) << \"Parse tpu variable information for \" << node->name();\n  for (const Edge* edge : node->out_edges()) {\n    if (edge->IsControlEdge()) continue;\n    Node* next = edge->dst();\n    VLOG(3) << \"Neighbor node \" << next->name();\n    // Looking through Enter/Switch/ReadVariableOp nodes.\n    while (next->IsEnter() || next->IsSwitch() ||\n           next->type_string() == \"ReadVariableOp\") {\n      Node* new_node = nullptr;\n      for (const Edge* e : next->out_edges()) {\n        if (!e->IsControlEdge()) {\n          new_node = e->dst();\n          break;\n        }\n      }\n      if (new_node == nullptr) break;\n      next = new_node;\n    }\n    if (next != edge->dst()) {\n      VLOG(3) << \"Looked through Enter/Switch node \" << next->DebugString();\n    }\n    TF_ASSIGN_OR_RETURN(absl::optional<xla::OpSharding> sharding,\n                        ParseShardingFromDevice(*next, num_cores_per_replica,\n                                                /*add_metadata=*/false));\n    if (sharding.has_value() && sharding->tile_assignment_devices_size() > 0) {\n      core = sharding->tile_assignment_devices(0);\n      VLOG(3) << next->name() << \" is placed on core \" << core;\n    }\n    if (next->attrs().Find(TPU_FAST_MEM_ATTR) != nullptr) {\n      use_fast_mem = true;\n      VLOG(3) << next->name() << \" has \" << TPU_FAST_MEM_ATTR << \" attribute\";\n    }\n  }\n  VLOG(1) << \"Place \" << node->name() << \" to core: \" << core\n          << \" fast_mem: \" << use_fast_mem;\n  var_info->device_ordinal = core;\n  var_info->fast_mem = use_fast_mem;\n\n  return OkStatus();\n}\n\n// Helper to instantiate function \"func\" in the library \"lib\".\nStatus Instantiate(FunctionLibraryRuntime* lib, const NameAttrList& func,\n                   FunctionLibraryRuntime::Handle* handle) {\n  return lib->Instantiate(func.name(), AttrSlice(&func.attr()), handle);\n}\n\nstatic constexpr const char* const kDeviceOrdinalAttr = \"device_ordinal\";\n\nstatic constexpr const char* const kTPUExecuteOp = \"TPUExecute\";\nstatic constexpr const char* const kInfeedEnqueueOp = \"InfeedEnqueue\";\nstatic constexpr const char* const kInfeedEnqueueTupleOp = \"InfeedEnqueueTuple\";\nstatic constexpr const char* const kOutfeedDequeueOp = \"OutfeedDequeue\";\nstatic constexpr const char* const kOutfeedDequeueTupleOp =\n    \"OutfeedDequeueTuple\";\nstatic constexpr const char* const kOutfeedDequeueV2Op = \"OutfeedDequeueV2\";\nstatic constexpr const char* const kOutfeedDequeueTupleV2Op =\n    \"OutfeedDequeueTupleV2\";\nstatic constexpr const char* const kVarHandleOp = \"VarHandleOp\";\n\nstatic constexpr const char* const kTPUDeviceNamePrefix = \"/device:TPU:\";\nstatic constexpr const int kTPUDefaultDeviceOrdinal = 0;\n\nbool IsSupportedTPUOp(const string& op_name) {\n  return op_name == kTPUExecuteOp || op_name == kInfeedEnqueueOp ||\n         op_name == kInfeedEnqueueTupleOp || op_name == kOutfeedDequeueOp ||\n         op_name == kOutfeedDequeueTupleOp || op_name == kOutfeedDequeueV2Op ||\n         op_name == kOutfeedDequeueTupleV2Op;\n}\n\n// Sets the sharding attributes for an XlaSharding node.\nvoid SetXlaShardingNodeAttr(Node* xla_sharding_node, int num_cores_per_replica,\n                            int rank, int shard_dim) {\n  auto sharding = absl::make_optional<xla::OpSharding>();\n  sharding->set_type(xla::OpSharding::OTHER);\n\n  std::vector<int64_t> dims(rank, 1LL);\n  dims[shard_dim] = num_cores_per_replica;\n  for (auto dim : dims) {\n    sharding->add_tile_assignment_dimensions(dim);\n  }\n\n  // Sets up tile_assignment_devices.\n  for (int d = 0; d < num_cores_per_replica; ++d) {\n    sharding->add_tile_assignment_devices(d);\n  }\n\n  xla_sharding_node->ClearAttr(kXLAShardingAttrName);\n  xla_sharding_node->ClearAttr(kXLAShardingAttrAltName);\n  xla_sharding_node->AddAttr(kXLAShardingAttrName,\n                             sharding->SerializeAsString());\n  xla_sharding_node->AddAttr(kXLAShardingAttrAltName,\n                             sharding->SerializeAsString());\n}\n\n// If 'device_name' is a TPU device, set its device_ordinal to 'device_ordinal'\n// and set '*rewritten' to true. Otherwise, do nothing.\nStatus UpdateTPUDeviceOrdinal(int device_ordinal, string* device_name,\n                              bool* rewritten) {\n  DeviceNameUtils::ParsedName device;\n  if (!DeviceNameUtils::ParseFullName(*device_name, &device)) {\n    return errors::InvalidArgument(\"Unable to parse device name \",\n                                   *device_name);\n  }\n  if (device.type == DEVICE_TPU_NODE) {\n    device.id = device_ordinal;\n    *rewritten = true;\n  }\n  *device_name = DeviceNameUtils::ParsedNameToString(device);\n  return OkStatus();\n}\n\nconst Edge* FindHostToDeviceEdge(Node* arg_node) {\n  const Edge* candidate_edge = nullptr;\n  for (const Edge* edge : arg_node->out_edges())\n    if (!edge->IsControlEdge()) {\n      // Find CPU -> TPU input edge.\n      const Edge* original_edge;\n      while (edge->src()->attrs().Find(kTpuReplicateAttr) != nullptr ||\n             edge->dst()->attrs().Find(kTpuReplicateAttr) == nullptr) {\n        const Node* new_src = edge->dst();\n        original_edge = edge;\n        for (const Edge* new_edge : new_src->out_edges())\n          if (!new_edge->IsControlEdge()) {\n            original_edge = edge;\n            edge = new_edge;\n            break;\n          }\n        if (original_edge == edge) break;\n      }\n      // TPU input edge: src is on CPU and dest is on TPU.\n      if (edge->src()->attrs().Find(kTpuReplicateAttr) != nullptr ||\n          edge->dst()->attrs().Find(kTpuReplicateAttr) == nullptr)\n        continue;\n      // Won't work with GuaranteeConst.\n      if (edge->src()->type_string() == \"GuaranteeConst\") break;\n      candidate_edge = edge;\n    }\n  return candidate_edge;\n}\n\nStatus CreateInputProxy(Graph* graph, const Edge* candidate_edge,\n                        const Edge** tpu_input_edge) {\n  std::vector<const Edge*> edges_to_replace;\n  for (const Edge* input_edge : candidate_edge->src()->out_edges()) {\n    if (!input_edge->IsControlEdge() &&\n        input_edge->dst()->attrs().Find(kTpuReplicateAttr) != nullptr)\n      edges_to_replace.push_back(input_edge);\n  }\n  // Build an Identity node as the proxy of the original edge source.\n  Node* input_identity_node = nullptr;\n  TF_RETURN_IF_ERROR(\n      NodeBuilder(strings::StrCat(candidate_edge->src()->name(), \"/proxy\"),\n                  \"Identity\")\n          .Input(candidate_edge->src())\n          .Attr(\"T\", candidate_edge->src()->output_type(0))\n          .Attr(kTpuReplicateAttr,\n                candidate_edge->dst()->attrs().Find(kTpuReplicateAttr)->s())\n          .Finalize(graph, &input_identity_node));\n  // Find the tpu input edge from original source to proxy identity.\n  for (const Edge* input_edge : input_identity_node->in_edges())\n    if (input_edge->src() == candidate_edge->src()) {\n      *tpu_input_edge = input_edge;\n      break;\n    }\n  // Replace original input edges with proxy's output.\n  for (const Edge* input_edge : edges_to_replace) {\n    graph->RemoveEdge(input_edge);\n    graph->AddEdge(input_identity_node, 0, input_edge->dst(),\n                   input_edge->dst_input());\n  }\n  return OkStatus();\n}\n\nStatus GetClusterName(Graph* graph, string* cluster_name) {\n  *cluster_name = \"\";\n  for (const Node* node : graph->nodes()) {\n    if (node->attrs().Find(kTpuReplicateAttr) == nullptr) continue;\n    if (cluster_name->empty())\n      *cluster_name = node->attrs().Find(kTpuReplicateAttr)->s();\n    // When optimization is turned on, the graph should only have one TPU\n    // cluster.\n    if (*cluster_name != node->attrs().Find(kTpuReplicateAttr)->s())\n      return errors::FailedPrecondition(\n          \"Only one cluster is allowed when optimization is turned on for \"\n          \"TPUPartitionedCall. Found \",\n          node->attrs().Find(kTpuReplicateAttr)->s(), \" and \", *cluster_name);\n  }\n  return OkStatus();\n}\n\n// Removes nodes that has no effect that directly descends from _Arg node.\n//\n// This is currently used for removing TPUReplicatedInput and XlaSharding node\n// are always descendants of _Arg node. During optimization, we try to insert\n// nodes in between _Arg and _Arg's children, where some of the nodes inserted\n// are TPU nodes. We will add the TPUReplicatedInput and XlaSharding op nodes\n// back where necessary.\n//\n// Returns the number of nodes that were removed.\nint64_t RemoveDescendantNodeOfArg(\n    Graph* graph, const std::string& node_type_to_remove,\n    const std::set<std::string>& must_be_child_of) {\n  int64_t nodes_removed = 0;\n  std::vector<std::pair<const Edge*, std::vector<const Edge*>>> edges_to_remove;\n\n  for (Node* node : graph->nodes()) {\n    if (node_type_to_remove != node->type_string()) continue;\n    if (!must_be_child_of.empty()) {\n      bool has_arg_parent = false;\n      for (const Edge* edge : node->in_edges()) {\n        if (must_be_child_of.count(edge->src()->type_string()) > 0) {\n          has_arg_parent = true;\n        }\n      }\n      if (!has_arg_parent) continue;\n    }\n    nodes_removed++;\n\n    const Edge* input_edge = nullptr;\n    std::vector<const Edge*> output_edges;\n    for (const Edge* edge : node->in_edges())\n      if (!edge->IsControlEdge()) {\n        input_edge = edge;\n        break;\n      }\n    for (const Edge* edge : node->out_edges())\n      if (!edge->IsControlEdge()) {\n        output_edges.push_back(edge);\n      }\n    if (input_edge != nullptr && !output_edges.empty())\n      edges_to_remove.push_back(std::make_pair(input_edge, output_edges));\n  }\n  for (const auto& it : edges_to_remove) {\n    for (const Edge* output_edge : it.second) {\n      graph->RemoveEdge(output_edge);\n      graph->AddEdge(it.first->src(), it.first->src_output(),\n                     output_edge->dst(), output_edge->dst_input());\n    }\n    graph->RemoveNode(it.first->dst());\n  }\n  return nodes_removed;\n}\n\nuint64 GetInputHash(OpKernelContext* ctx) {\n  uint64 input_hash = 0;  // initialization for determinism.\n  // Use the number of elements to compute hash.\n  // TODO(chiachenc): use fhe full shape to compute the hash.\n  for (int i = 0; i < ctx->num_inputs(); ++i) {\n    VLOG(4) << \"InputHash, combine input \" << i\n            << \", NumElements: \" << ctx->input(i).NumElements();\n    input_hash = Hash64Combine(input_hash, ctx->input(i).NumElements());\n  }\n  return input_hash;\n}\n\nstring HashShapeAndType(const string prefix, const std::vector<int>& input_dims,\n                        const DataType& dtype, const bool input_shape_opt) {\n  string hash = strings::StrCat(prefix, dtype, \"_dims\");\n  // We will concat at the last dimension.\n  for (int d = 0; d < input_dims.size() - 1; ++d) {\n    strings::StrAppend(&hash, \"_\", input_dims.at(d));\n  }\n\n  if (input_shape_opt) {\n    if (input_dims.back() % kLastDimOfTpuInputFastPath == 0) {\n      strings::StrAppend(&hash, \"_last_\", kLastDimOfTpuInputFastPath, \"n\");\n    } else {\n      strings::StrAppend(&hash, \"_last_other\");\n    }\n  }\n  return hash;\n}\n\n// Get the information for input and output tensors (shapes, dtypes, etc).\nStatus GetInputOutputInfo(\n    Graph* graph, GraphShapeInfo& tpu_inferred_info,\n    std::map<int, InferredShape>& arg_shapes, EdgeShapes& tpu_input_shapes,\n    absl::flat_hash_map<const Edge*, DataType>& tpu_input_dtypes,\n    OpKernelContext* ctx) {\n  // Search for the device-to-host or tpu-to-cpu edges.\n  for (Node* node : graph->op_nodes()) {\n    if (!node->IsArg()) continue;\n    const DataType dtype = node->attrs().Find(\"T\")->type();\n    const int arg_index = node->attrs().Find(\"index\")->i();\n    if (dtype != DT_INT32 && dtype != DT_BFLOAT16 && dtype != DT_FLOAT &&\n        dtype != DT_BOOL && dtype != DT_QINT8 && dtype != DT_QUINT8)\n      continue;\n    VLOG(3) << \"Argnode: \" << node->DebugString();\n    const Tensor& tensor = ctx->input(arg_index);\n\n    // Search for the cross-device edge from arg node.\n    const Edge* candidate_edge = FindHostToDeviceEdge(node);\n    if (candidate_edge == nullptr) continue;\n\n    // Make proxy and get the sole tpu_input_edge for transfer the input tensor\n    // corresponding to the current _Arg node.\n    const Edge* tpu_input_edge = nullptr;\n    TF_RETURN_IF_ERROR(\n        CreateInputProxy(graph, candidate_edge, &tpu_input_edge));\n    if (tpu_input_edge == nullptr)\n      return errors::NotFound(\"Couldn't find TPU input edge for\", node->name());\n\n    // Optimize edge: original source to proxy identity.\n    VLOG(3) << \"Input: \" << tpu_input_edge->src()->name();\n    std::vector<int>& input_shapes = tpu_input_shapes[tpu_input_edge];\n    input_shapes.clear();\n    for (int d = 0; d < tensor.dims(); ++d) {\n      input_shapes.push_back(tensor.dim_size(d));\n      VLOG(3) << \"Input Tensor: Dim[\" << d << \"] = \" << tensor.dim_size(d);\n    }\n    tpu_input_dtypes[tpu_input_edge] = tensor.dtype();\n\n    // Collect shapes for non-resource-variable args.\n    PartialTensorShape partial_tensor_shape;\n    auto partial_shape = PartialTensorShape::MakePartialShape(\n        input_shapes.data(), input_shapes.size(), &partial_tensor_shape);\n    InferredShape inferred_shape = {partial_tensor_shape};\n    arg_shapes[arg_index] = inferred_shape;\n  }\n  return OkStatus();\n}\n\n// Converts a integer vector that represents the shapes to a Tensorshape.\nStatus ConvertEdgeShapesToTensorShapes(\n    const std::map<std::string, std::vector<int>>& named_input_shapes,\n    std::vector<TensorShape>* shapes) {\n  shapes->resize(named_input_shapes.size());\n  int32_t i = 0;\n  // keys in tpu_input_shapes may be stale.\n  for (const auto& iter : named_input_shapes) {\n    VLOG(2) << iter.first << \", rank: \" << iter.second.size();\n    const int64_t rank = iter.second.size();\n    std::vector<int64_t> dims(rank);\n    for (int64_t d = 0; d < rank; ++d) {\n      VLOG(2) << \" dim[\" << d << \"]: \" << iter.second.at(d);\n      dims[d] = iter.second.at(d);\n    }\n    TF_RETURN_IF_ERROR(TensorShapeUtils::MakeShape(dims, &(*shapes)[i]));\n    i++;\n  }\n  return OkStatus();\n}\n\n// Get the TF fingerprint with the information from the TPUCompileOp or\n// _TPUCompileMlirOp.\nStatus MaybeRegisterFingerprint(\n    Graph* graph,\n    const std::map<std::string, std::vector<int>>& named_input_shapes,\n    uint64 input_hash) {\n  // Find the compiler metadata.\n  tpu::TPUCompileMetadataProto metadata_proto;\n  std::map<std::string, std::vector<int>> inputs_to_keep;\n  int num_dynamic_shapes = -1;\n  tensorflow::uint64 fingerprint = 0;\n\n  for (Node* node : graph->op_nodes()) {\n    if (node->type_string() == \"TPUCompile\" ||\n        node->type_string() == \"_TPUCompileMlir\") {\n      num_dynamic_shapes = node->attrs().Find(\"NumDynamicShapes\")->i();\n      if (num_dynamic_shapes <= 0) {\n        break;\n      }\n      int visited = 0;\n      // TPUCompileOp/_TPUCompileMlirOp take Shape nodes as inputs.\n      // The number of Shape nodes matches the number of dynamic shaped inputs.\n      // The Shape nodes come from the input nodes:\n      //   [TPU Input] --> [Input Shape] --> [TPUCompileOp]\n      for (auto in_node : node->in_nodes()) {\n        if (in_node->type_string() != \"Shape\") {\n          continue;\n        }\n        for (auto input_node : in_node->in_nodes()) {\n          auto iter = named_input_shapes.find(input_node->name());\n          if (iter != named_input_shapes.end()) {\n            inputs_to_keep[iter->first] = iter->second;\n          }\n        }\n        visited++;\n        if (visited == num_dynamic_shapes) {\n          break;\n        }\n      }\n      std::string metadata = node->attrs().Find(\"metadata\")->s();\n      metadata_proto.ParseFromString(metadata);\n\n      if (node->type_string() == \"_TPUCompileMlir\") {\n        std::string mlir_module = node->attrs().Find(\"mlir_module\")->s();\n        fingerprint = tensorflow::Fingerprint64(mlir_module);\n      } else {\n        fingerprint = metadata_proto.function_library_fingerprint();\n      }\n\n      break;\n    }\n  }\n  VLOG(2) << \"inputs_to_keep size: \" << inputs_to_keep.size();\n  if (inputs_to_keep.size() != num_dynamic_shapes) {\n    VLOG(2) << \"Cannot match all inputs shapes. Skip fingerprint registration.\";\n    return OkStatus();\n  }\n\n  std::vector<TensorShape> input_shapes;\n  TF_RETURN_IF_ERROR(\n      ConvertEdgeShapesToTensorShapes(inputs_to_keep, &input_shapes));\n\n  std::vector<TensorShape> arg_shapes;\n  auto status =\n      tpu::ComputeArgumentShapes(metadata_proto, input_shapes, &arg_shapes);\n  if (!status.ok()) {\n    VLOG(2) << status.error_message();\n    return OkStatus();\n  }\n  uint64 tf_fingerprint =\n      tpu::CreateFingerprintWithNameAndShapes(fingerprint, arg_shapes);\n  VLOG(2) << \"fingerprint: \" << fingerprint;\n  VLOG(2) << \"TF fingerprint: \" << tf_fingerprint;\n\n  ResourceMgr* rm = GetTPUConfigResourceMgr();\n  tpu::TpuFingerprintLookup* fingerprint_lookup;\n  TF_RETURN_IF_ERROR(rm->Lookup<tpu::TpuFingerprintLookup>(\n      rm->default_container(), tpu::kFingerprintLookupResourceName,\n      &fingerprint_lookup));\n  fingerprint_lookup->RegisterKeyAndIntermediatePair(input_hash,\n                                                     tf_fingerprint);\n  return OkStatus();\n}\n\nbool FindTpuReplicatedInputAndXlaSharding(\n    const Graph* graph, XlaShardingInfoMap& xla_sharding_ops,\n    TpuReplicatedInputInfoMap& tpu_replicated_input_ops) {\n  bool xla_spmd_input_sharded = false;\n  // Detect whether there are XLA Sharding on the inputs, if there are, then\n  // we cannot remove the replicated inputs or the xla sharding ops.\n  for (Node* xla_sharding_node : graph->nodes()) {\n    if (xla_sharding_node->type_string() == \"XlaSharding\") {\n      for (const Edge* edge : xla_sharding_node->in_edges()) {\n        if (edge->src()->type_string() == \"TPUReplicatedInput\") {\n          Node* tpu_replicated_input_node = edge->src();\n          Node* tpu_replicated_metadata_node = nullptr;\n          for (const Edge* input_edge : tpu_replicated_input_node->in_edges()) {\n            if (input_edge->IsControlEdge()) {\n              tpu_replicated_metadata_node = input_edge->src();\n            }\n          }\n\n          for (const Edge* input_edge : tpu_replicated_input_node->in_edges()) {\n            if (input_edge->src()->type_string() == \"_Arg\") {\n              Node* arg_node = input_edge->src();\n\n              xla_sharding_ops[arg_node->name()] = std::make_tuple(\n                  xla_sharding_node->attrs().Find(\"T\")->type(),\n                  xla_sharding_node->attrs().Find(\"sharding\")->s(),\n                  xla_sharding_node->attrs().Find(\"_tpu_replicate\")->s());\n\n              tpu_replicated_input_ops[arg_node->name()] = std::make_tuple(\n                  tpu_replicated_input_node->attrs().Find(\"T\")->type(),\n                  tpu_replicated_metadata_node);\n\n              VLOG(2) << \"Detected input is sharded. XlaSharding node: \"\n                      << xla_sharding_node->DebugString()\n                      << \", TPUReplicatedInput node: \"\n                      << edge->src()->DebugString()\n                      << \", _Arg node: \" << arg_node->DebugString();\n              xla_spmd_input_sharded = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  return xla_spmd_input_sharded;\n}\n\n// Returns the name of the framework that rewrote the graph to support\n// inference on TPUs. This name is accessed later during metric collection.\nstring GetProducerName(const string& function_name) {\n  if (absl::StrContains(function_name, \"tpu_fn_icv2_\")) {\n    if (absl::StrContains(function_name, \"_tf_quant\")) {\n      return \"TPU_INFERENCE_CONVERTER_V2_TF_QUANTIZER\";\n    }\n    return \"TPU_INFERENCE_CONVERTER_V2\";\n  }\n  if (absl::StrContains(function_name, \"tpu_func_0\") ||\n      absl::StrContains(function_name, \"_with_batch\") ||\n      absl::StrContains(function_name, \"_optim\")) {\n    if (absl::StrContains(function_name, \"_tf_quant\")) {\n      return \"TPU_INFERENCE_CONVERTER_TF_QUANTIZER\";\n    }\n    return \"TPU_INFERENCE_CONVERTER\";\n  }\n  return \"UNKNOWN\";\n}\n\n// Gets the proper tensor dimension from XLA OpSharding.\n// \"replicate_on_last_tile_dim\" and \"last_tile_dims\" should be deducted from the\n// real Tensor dimensions when tiled.\n// For example:\n// f32[8,512](sharding={devices=[1,1,2]0,1 last_tile_dims={REPLICATED})\n// also means a replicated tensor over all devices.\n//\n// See xla_data.proto for detailed explanations on the fields.\nint GetDimsFromXLAShardingTiled(const xla::OpSharding xla_sharding) {\n  return xla_sharding.tile_assignment_dimensions_size() -\n         (xla_sharding.replicate_on_last_tile_dim() ? 1 : 0) -\n         xla_sharding.last_tile_dims_size();\n}\n\n}  // end namespace\n\nnamespace tpu_functional_internal {\n\n// An optimization pass that separates tensors to leverage the fast path in\n// TPU input preparation. The algorithm is as follows:\n// (1) Group all tensors that have same dimensions except the last dimension. A\n// group of tensors will be concatenated by the last dimension in a later pass.\n// (2) Check all groups of tensors and find groups whose dimensions after concat\n// cannot leverage the fast path.\n// (3) For groups of tensors that don't leverage the fast path, split tensors\n// into two sub-groups such that one sub-group of tensors can leverage the fast\n// path.\n// Exception in (2) is that concated tensors are small, which means separating\n// tensors would introduce overheads of data transfer to device.\n// This optimization takes effect when both --input_shape_opt and\n// --group_tensors_for_packing are true.\nGroupedEdges GroupTensorsForInputPacking(\n    const EdgeShapes& tpu_input_shapes,\n    const absl::flat_hash_map<const Edge*, DataType>& tpu_input_dtypes,\n    bool input_shape_opt, bool group_tensors_for_packing) {\n  GroupedEdges grouped_input_edges;\n  for (const auto& iter : tpu_input_shapes) {\n    if (iter.second.empty()) continue;\n    DataType dtype = tpu_input_dtypes.find(iter.first)->second;\n    string hash_key = HashShapeAndType(\"input_tensors_dtype_\", iter.second,\n                                       dtype, /*input_shape_opt*/ false);\n    grouped_input_edges[hash_key].push_back(iter.first);\n  }\n  // Apply grouping when both are true.\n  if (!input_shape_opt || !group_tensors_for_packing)\n    return grouped_input_edges;\n\n  GroupedEdges grouped_input_edges_opt;\n  for (const auto& iter : grouped_input_edges) {\n    int sum_last_dim = 0;\n    int product_other_dims = 0;\n    VLOG(3) << \"group name: \" << iter.first;\n    for (const auto& edge : iter.second) {\n      const std::vector<int>& input_shapes =\n          tpu_input_shapes.find(edge)->second;\n      sum_last_dim += input_shapes.back();\n      if (product_other_dims == 0) {\n        product_other_dims = 1;\n        for (int d = 0; d < input_shapes.size() - 1; ++d)\n          product_other_dims *= input_shapes.at(d);\n      }\n    }\n    VLOG(3) << \"sum_last_dim: \" << sum_last_dim;\n    VLOG(3) << \"product_other_dims: \" << product_other_dims;\n    // Already uses fast path, skip further grouping.\n    if ((sum_last_dim % kLastDimOfTpuInputFastPath) == 0 &&\n        (product_other_dims % kOtherDimOfTpuInputFastPath) == 0) {\n      grouped_input_edges_opt[iter.first] = iter.second;\n      continue;\n    }\n    // Tensors are small, skip further grouping.\n    if ((sum_last_dim * product_other_dims) <\n        (kLastDimOfTpuInputFastPath * kOtherDimOfTpuInputFastPath)) {\n      grouped_input_edges_opt[iter.first] = iter.second;\n      continue;\n    }\n    VLOG(3) << \"Splitting tensors.\";\n    for (const auto& edge : iter.second) {\n      auto tpu_input_shape = tpu_input_shapes.find(edge)->second;\n      string hash_key =\n          HashShapeAndType(\"input_tensors_dtype_\", tpu_input_shape,\n                           tpu_input_dtypes.find(edge)->second,\n                           /*input_shape_opt*/ true);\n      grouped_input_edges_opt[hash_key].push_back(edge);\n    }\n  }\n  return grouped_input_edges_opt;\n}\n\nGroupedEdges GroupTensorsForOutputPacking(Graph* graph,\n                                          EdgeShapes& tpu_output_shapes,\n                                          GraphShapeInfo* shape_info) {\n  GroupedEdges shape_to_output;\n  for (const Edge* edge : graph->edges()) {\n    if (edge->IsControlEdge()) continue;\n\n    // TPU input edge: src is on TPU and dest is on CPU.\n    if (edge->dst()->type_string() != \"TPUReplicatedOutput\") continue;\n    if (!shape_info->count(edge->src()->name())) continue;\n\n    // output shapes for hashing\n    std::vector<int>& output_shapes = tpu_output_shapes[edge];\n    output_shapes.clear();\n\n    int output_id = edge->src_output();\n    auto inferred_shape_vec = shape_info->at(edge->src()->name());\n\n    for (int d : inferred_shape_vec.at(output_id).shape.dim_sizes()) {\n      output_shapes.push_back(d);\n    }\n\n    // Hash Shape and Types.\n    DataType dtype = edge->src()->input_type(output_id);\n    string hash_key =\n        HashShapeAndType(\"output_tensors_dtype_\", output_shapes, dtype, false);\n\n    shape_to_output[hash_key].push_back(edge);\n  }\n  return shape_to_output;\n}\n\n// Concatenates input tensors on CPU along the last dimension if all other\n// dimensions are the same, and split them on TPU to reduce input overhead.\n// `tpu_input_shapes` maps an edge to the shape of its output tensor.\n// `grouped_input_edges` maps tensor name to all edges output from this tensor.\nStatus CreateConcatAndSplitNodesForInputTensor(\n    Graph* graph, const string& cluster_name, EdgeShapes* tpu_input_shapes,\n    const absl::flat_hash_map<std::string, std::vector<const Edge*>>&\n        grouped_input_edges,\n    int32_t minimum_input_tensors_packing, bool xla_spmd_input_sharded,\n    const XlaShardingInfoMap& xla_sharding_info,\n    const TpuReplicatedInputInfoMap& tpu_replicated_input_info) {\n  for (const auto& iter : grouped_input_edges) {\n    std::vector<int> last_dim_vec;\n    std::vector<NodeBuilder::NodeOut> concat_nodeouts;\n    absl::flat_hash_map<std::string, int> tensor_to_split_output;\n    int rank;\n    DataType dtype = DT_INVALID;\n    std::string src_name;\n    for (const Edge* edge : iter.second) {\n      src_name = edge->src()->name();\n      string tensor_name =\n          absl::StrCat(edge->src()->name(), \":\", edge->src_output());\n      // Create Concat / Split pair for a tensor if not exist yet.\n      if (tensor_to_split_output.contains(tensor_name)) continue;\n      tensor_to_split_output[tensor_name] = concat_nodeouts.size();\n      concat_nodeouts.push_back(\n          NodeBuilder::NodeOut(edge->src(), edge->src_output()));\n      dtype = edge->src()->output_type(edge->src_output());\n      rank = tpu_input_shapes->at(edge).size();\n      last_dim_vec.push_back(tpu_input_shapes->at(edge).back());\n    }\n\n    const int num_tensors = tensor_to_split_output.size();\n    VLOG(3) << iter.first << \" num_tensors: \" << num_tensors;\n    if (num_tensors < minimum_input_tensors_packing) {\n      VLOG(3) << \"skip concat/split \" << iter.first;\n      continue;\n    }\n\n    Node* concat_axis_node = nullptr;\n    TensorShape t_shape;\n    Tensor dim_tensor(DT_INT32, t_shape);\n    // Concat and Split at the last dim.\n    dim_tensor.flat<int>()(0) = rank - 1;\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(strings::StrCat(iter.first, \"/concat/axis\"), \"Const\")\n            .Attr(\"dtype\", DT_INT32)\n            .Attr(\"value\", dim_tensor)\n            .Finalize(graph, &concat_axis_node));\n\n    Node* concat_node = nullptr;\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(strings::StrCat(iter.first, \"/concat\"), \"ConcatV2\")\n            .Input(concat_nodeouts)\n            .Input(concat_axis_node)\n            .Attr(\"T\", dtype)\n            .Attr(\"Tidx\", DT_INT32)\n            .Attr(\"N\", num_tensors)\n            .Finalize(graph, &concat_node));\n\n    Node* split_dim_node = nullptr;\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(strings::StrCat(iter.first, \"/split/split_dim\"), \"Const\")\n            .Attr(\"dtype\", DT_INT32)\n            .Attr(\"value\", dim_tensor)\n            .Attr(kTpuReplicateAttr, cluster_name)\n            .Finalize(graph, &split_dim_node));\n\n    Node* split_vec_node = nullptr;\n    TensorShape split_vec_shape;\n    split_vec_shape.AddDim(1);\n    split_vec_shape.set_dim(0, last_dim_vec.size());\n\n    Tensor split_vec_tensor(DT_INT32, split_vec_shape);\n    for (int i = 0; i < last_dim_vec.size(); ++i) {\n      split_vec_tensor.flat<int>()(i) = last_dim_vec[i];\n    }\n    VLOG(3) << \"split_vec_tensor: \" << split_vec_tensor.DebugString();\n\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(strings::StrCat(iter.first, \"/split/vec\"), \"Const\")\n            .Attr(\"dtype\", DT_INT32)\n            .Attr(\"value\", split_vec_tensor)\n            .Attr(kTpuReplicateAttr, cluster_name)\n            .Finalize(graph, &split_vec_node));\n\n    Node* split_node = nullptr;\n    Node* input_to_split_node = concat_node;\n    Node* output_from_concat_node = nullptr;\n    if (xla_spmd_input_sharded &&\n        tpu_replicated_input_info.count(src_name) > 0 &&\n        xla_sharding_info.count(src_name) > 0) {\n      // Create new TPUReplicatedInput and XLAShardingOp nodes\n      //\n      // Rewrite the graph from:\n      //   Concat -> Split\n      // to\n      //   Concat -> TPUReplicatedInput -> XlaSharding -> Split\n      Node* tpu_replicated_input = nullptr;\n      Node* xla_sharding_op = nullptr;\n\n      std::vector<NodeBuilder::NodeOut> replicated_input;\n      replicated_input.push_back(NodeBuilder::NodeOut(concat_node));\n\n      // TODO(b/183060455): Add TPUReplicatedInput to all graphs.\n      TF_RETURN_IF_ERROR(\n          NodeBuilder(strings::StrCat(iter.first, \"/TPUReplicatedInput\"),\n                      \"TPUReplicatedInput\")\n              .Input(replicated_input)\n              .ControlInput(std::get<1>(tpu_replicated_input_info.at(src_name)))\n              .Attr(\"N\", 1)\n              .Attr(\"T\", std::get<0>(tpu_replicated_input_info.at(src_name)))\n              .Attr(\"index\", -1)\n              .Attr(\"is_mirrored_variable\", false)\n              .Attr(\"is_packed\", false)\n              .Finalize(graph, &tpu_replicated_input));\n      VLOG(2) << \"Created new TPUReplicatedInput node \"\n              << tpu_replicated_input->DebugString();\n\n      TF_RETURN_IF_ERROR(\n          NodeBuilder(strings::StrCat(iter.first, \"/XlaSharding\"),\n                      \"XlaSharding\")\n              .Input(tpu_replicated_input)\n              .Attr(\"T\", std::get<0>(xla_sharding_info.at(src_name)))\n              .Attr(\"sharding\", std::get<1>(xla_sharding_info.at(src_name)))\n              .Attr(\"_XlaSharding\", std::get<1>(xla_sharding_info.at(src_name)))\n              .Attr(\"_tpu_replicate\",\n                    std::get<2>(xla_sharding_info.at(src_name)))\n              .Finalize(graph, &xla_sharding_op));\n      VLOG(2) << \"Created new XLA sharding node \"\n              << xla_sharding_op->DebugString();\n\n      input_to_split_node = xla_sharding_op;\n      output_from_concat_node = tpu_replicated_input;\n    }\n    // Update the `tpu_input_shapes` mapping: Add the new edge\n    // from concat to split.\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(strings::StrCat(iter.first, \"/split\"), \"SplitV\")\n            .Input(input_to_split_node)\n            .Input(split_vec_node)\n            .Input(split_dim_node)\n            .Attr(\"T\", dtype)\n            .Attr(\"num_split\", num_tensors)\n            .Attr(kTpuReplicateAttr, cluster_name)\n            .Finalize(graph, &split_node));\n\n    if (output_from_concat_node == nullptr)\n      output_from_concat_node = split_node;\n\n    const Edge* concat_to_split;\n    for (const Edge* edge : concat_node->out_edges())\n      if (edge->dst() == output_from_concat_node) {\n        concat_to_split = edge;\n        break;\n      }\n    if (rank > 1) {\n      for (int d = 0; d < rank - 1; ++d)\n        (*tpu_input_shapes)[concat_to_split].push_back(\n            tpu_input_shapes->at(iter.second.back()).at(d));\n    }\n    (*tpu_input_shapes)[concat_to_split].push_back(\n        std::accumulate(last_dim_vec.begin(), last_dim_vec.end(), 0));\n\n    // Connect split node to original tensor output.\n    for (const Edge* edge : iter.second) {\n      string tensor_name =\n          absl::StrCat(edge->src()->name(), \":\", edge->src_output());\n      int output_index = tensor_to_split_output.at(tensor_name);\n      graph->RemoveEdge(edge);\n      graph->AddEdge(split_node, output_index, edge->dst(), edge->dst_input());\n      // Update the `tpu_input_shapes` mapping: Remove old edges.\n      tpu_input_shapes->erase(edge);\n    }\n    VLOG(3) << \"Concat node: \" << concat_node->DebugString();\n  }\n  return OkStatus();\n}\n\n// Concatenates input tensors on TPU along the last dimension if all other\n// dimensions are the same, and split them on CPU to reduce outfeed overhead.\n// `tpu_inferred_info` maps an edge to the inferred shape of its output tensor.\n// `shape_to_output` maps tensor name to all edges output from this tensor.\nStatus CreateConcatAndSplitNodesForOutputTensor(\n    Graph* graph, const string& cluster_name, EdgeShapes* tpu_output_shapes,\n    GraphShapeInfo* tpu_inferred_info, GroupedEdges shape_to_output,\n    int32_t minimum_output_tensors_packing) {\n  for (const auto& iter : shape_to_output) {\n    std::vector<int> last_dim_vec;\n    std::vector<NodeBuilder::NodeOut> concat_nodeouts;\n    absl::flat_hash_map<std::string, int> tensor_to_split_output;\n    int rank;\n    DataType dtype = DT_INVALID;\n    for (const Edge* edge : iter.second) {\n      string tensor_name =\n          absl::StrCat(edge->src()->name(), \":\", edge->src_output());\n\n      // Create Concat / Split pair for a tensor if not exist yet.\n      if (tensor_to_split_output.contains(tensor_name)) continue;\n      tensor_to_split_output[tensor_name] = concat_nodeouts.size();\n\n      concat_nodeouts.push_back(\n          NodeBuilder::NodeOut(edge->src(), edge->src_output()));\n      dtype = edge->src()->output_type(edge->src_output());\n      rank = tpu_output_shapes->at(edge).size();\n      last_dim_vec.push_back(tpu_output_shapes->at(edge).back());\n    }\n\n    const int num_tensors = tensor_to_split_output.size();\n    if (num_tensors < minimum_output_tensors_packing) {\n      VLOG(3) << \"skip concat/split \" << iter.first;\n      continue;\n    }\n\n    Node* concat_axis_node = nullptr;\n    TensorShape t_shape;\n    Tensor dim_tensor(DT_INT32, t_shape);\n    // Concat and Split at the last dim.\n    dim_tensor.flat<int>()(0) = rank - 1;\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(strings::StrCat(iter.first, \"/concat/axis\"), \"Const\")\n            .Attr(\"dtype\", DT_INT32)\n            .Attr(\"value\", dim_tensor)\n            .Attr(kTpuReplicateAttr, cluster_name)\n            .Finalize(graph, &concat_axis_node));\n\n    Node* concat_node = nullptr;\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(strings::StrCat(iter.first, \"/concat\"), \"ConcatV2\")\n            .Input(concat_nodeouts)\n            .Input(concat_axis_node)\n            .Attr(\"T\", dtype)\n            .Attr(\"Tidx\", DT_INT32)\n            .Attr(\"N\", num_tensors)\n            .Attr(kTpuReplicateAttr, cluster_name)\n            .Finalize(graph, &concat_node));\n\n    Node* tpu_replicated_output_node = nullptr;\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(strings::StrCat(iter.first, \"/tpu_replicated_output\"),\n                    \"TPUReplicatedOutput\")\n            .Input(concat_node)\n            .Attr(\"T\", dtype)\n            .Attr(\"num_replicas\", 1)\n            .Finalize(graph, &tpu_replicated_output_node));\n\n    Node* split_dim_node = nullptr;\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(strings::StrCat(iter.first, \"/split/split_dim\"), \"Const\")\n            .Attr(\"dtype\", DT_INT32)\n            .Attr(\"value\", dim_tensor)\n            .Finalize(graph, &split_dim_node));\n\n    Node* split_vec_node = nullptr;\n    TensorShape split_vec_shape;\n    split_vec_shape.AddDim(1);\n    split_vec_shape.set_dim(0, last_dim_vec.size());\n\n    Tensor split_vec_tensor(DT_INT32, split_vec_shape);\n    for (int i = 0; i < last_dim_vec.size(); ++i) {\n      split_vec_tensor.flat<int>()(i) = last_dim_vec[i];\n    }\n    VLOG(3) << \"split_vec_tensor: \" << split_vec_tensor.DebugString();\n\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(strings::StrCat(iter.first, \"/split/vec\"), \"Const\")\n            .Attr(\"dtype\", DT_INT32)\n            .Attr(\"value\", split_vec_tensor)\n            .Finalize(graph, &split_vec_node));\n\n    Node* split_node = nullptr;\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(strings::StrCat(iter.first, \"/split\"), \"SplitV\")\n            .Input(tpu_replicated_output_node)\n            .Input(split_vec_node)\n            .Input(split_dim_node)\n            .Attr(\"T\", dtype)\n            .Attr(\"num_split\", num_tensors)\n            .Finalize(graph, &split_node));\n\n    // Update the `tpu_out_shapes` mapping: Add the new edge\n    // from concat to split.\n    const Edge* concat_to_split;\n    for (const Edge* edge : concat_node->out_edges())\n      if (edge->dst() == split_node) {\n        concat_to_split = edge;\n        break;\n      }\n\n    if (rank > 1) (*tpu_output_shapes)[concat_to_split].push_back(-1);\n    for (int d = 1; d < rank - 1; ++d)\n      (*tpu_output_shapes)[concat_to_split].push_back(\n          tpu_output_shapes->at(iter.second.back()).at(d));\n    (*tpu_output_shapes)[concat_to_split].push_back(\n        std::accumulate(last_dim_vec.begin(), last_dim_vec.end(), 0));\n\n    for (const Edge* edge : iter.second) {\n      // 1. Find old TPURelicatedOutput output edges\n      std::vector<const Edge*> output_edge_vec;\n      for (const Edge* output_edge : edge->dst()->out_edges())\n        output_edge_vec.push_back(output_edge);\n\n      string tensor_name =\n          absl::StrCat(edge->src()->name(), \":\", edge->src_output());\n      int output_index = tensor_to_split_output.at(tensor_name);\n      VLOG(3) << \"output_index: \" << output_index;\n\n      // Connect split node to original tensor output.\n      for (const Edge* output_edge : output_edge_vec) {\n        VLOG(3) << \"output_edge\" << output_edge->DebugString();\n        graph->RemoveEdge(output_edge);\n        graph->AddEdge(split_node, output_index, output_edge->dst(),\n                       output_edge->dst_input());\n        // Update the `tpu_output_shapes` mapping: Remove old edges.\n        tpu_output_shapes->erase(output_edge);\n      }\n      graph->RemoveNode(edge->dst());\n    }\n    VLOG(3) << \"Concat node: \" << concat_node->DebugString();\n  }\n  return OkStatus();\n}\n\nStatus InsertReshapeNodePairs(Graph* graph, const string& cluster_name,\n                              EdgeShapes* tpu_input_shapes,\n                              int num_cores_per_replica) {\n  std::vector<const Edge*> tpu_input_edges_original;\n  for (const auto& it : *tpu_input_shapes)\n    if (!it.second.empty()) tpu_input_edges_original.push_back(it.first);\n  for (const Edge* edge : tpu_input_edges_original) {\n    VLOG(3) << \"Reshape input: \" << edge->DebugString();\n\n    // Check if there is a TPUReplicatedInput and XlaSharding in the middle\n    bool xla_sharded_input = false;\n    Node* xla_sharding_node = nullptr;\n    if (edge->dst()->type_string() == \"TPUReplicatedInput\" &&\n        edge->dst()->out_nodes().begin()->type_string() == \"XlaSharding\") {\n      VLOG(3) << \"Detected TPUReplicatedInput \" << edge->dst()->DebugString()\n              << \" and XlaSharding \"\n              << edge->dst()->out_nodes().begin()->DebugString()\n              << \", setting xla_sharded_input = true\";\n      xla_sharded_input = true;\n      xla_sharding_node = *(edge->dst()->out_nodes().begin());\n    }\n\n    // 1. Build Reshape node for flatten.\n\n    // 1.1 Build Const node for shape\n    Node* flatten_reshape_shape_node = nullptr;\n    Tensor flattened_input_shape_tensor;\n    flattened_input_shape_tensor =\n        Tensor(DT_INT32, TensorShape({static_cast<int64_t>(1)}));\n    flattened_input_shape_tensor.flat<int>()(0) = -1;\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(absl::StrCat(edge->src()->name(), \"/flatten/Reshape/shape\"),\n                    \"Const\")\n            .Attr(\"dtype\", DT_INT32)\n            .Attr(\"value\", flattened_input_shape_tensor)\n            .Finalize(graph, &flatten_reshape_shape_node));\n\n    // 1.2 Build Reshape node for flatten.\n    Node* flatten_reshape_node = nullptr;\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(absl::StrCat(edge->src()->name(), \"/flatten/Reshape\"),\n                    \"Reshape\")\n            .Input(edge->src(), edge->src_output())\n            .Input(flatten_reshape_shape_node)\n            .Attr(\"T\", edge->src()->output_type(edge->src_output()))\n            .Attr(\"Tshape\", DT_INT32)\n            .Finalize(graph, &flatten_reshape_node));\n\n    // 2. Build Reshape node for recover.\n\n    // 2.1 Build Const node for shape.\n    Node* recover_reshape_shape_node = nullptr;\n    Tensor original_input_shape_tensor(\n        DT_INT32,\n        TensorShape({static_cast<int64_t>(tpu_input_shapes->at(edge).size())}));\n    original_input_shape_tensor.flat<int>()(0) = -1;\n    for (int d = 1; d < tpu_input_shapes->at(edge).size(); ++d)\n      original_input_shape_tensor.flat<int>()(d) =\n          tpu_input_shapes->at(edge).at(d);\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(absl::StrCat(edge->src()->name(), \"/recover/Reshape/shape\"),\n                    \"Const\")\n            .Attr(\"dtype\", DT_INT32)\n            .Attr(\"value\", original_input_shape_tensor)\n            .Attr(kTpuReplicateAttr, cluster_name)  // This node is on TPU.\n            .Finalize(graph, &recover_reshape_shape_node));\n\n    // 2.2 Build Reshape node for recover.\n    Node* recover_reshape_input_node = flatten_reshape_node;\n    const Edge* original_recover_reshape_input_edge = nullptr;\n    if (xla_sharded_input) {\n      // We want to find the node after the XlaSharding node\n      original_recover_reshape_input_edge =\n          *(edge->dst()->out_nodes().begin()->out_edges().begin());\n      recover_reshape_input_node = *(edge->dst()->out_nodes().begin());\n      VLOG(3) << \"Recover reshape input node: \"\n              << recover_reshape_input_node->DebugString()\n              << \", recover reshape input edge: \"\n              << original_recover_reshape_input_edge->DebugString();\n    }\n\n    Node* recover_reshape_node = nullptr;\n    TF_RETURN_IF_ERROR(\n        NodeBuilder(absl::StrCat(edge->src()->name(), \"/recover/Reshape\"),\n                    \"Reshape\")\n            .Input(recover_reshape_input_node)\n            .Input(recover_reshape_shape_node)\n            .Attr(\"T\", edge->src()->output_type(edge->src_output()))\n            .Attr(\"Tshape\", DT_INT32)\n            .Attr(kTpuReplicateAttr, cluster_name)  // This node is on TPU.\n            .Finalize(graph, &recover_reshape_node));\n\n    // 3. Rewrite XlaSharding attribute if necessary\n    if (xla_sharding_node != nullptr) {\n      // The flattened tensor always has rank = 1 and we want to shard the only\n      // dimension (0).\n      SetXlaShardingNodeAttr(xla_sharding_node, num_cores_per_replica, 1, 0);\n    }\n\n    // 4. Connect / disconnect nodes.\n    if (xla_sharded_input) {\n      graph->AddEdge(flatten_reshape_node, 0, edge->dst(), edge->dst_input());\n    }\n\n    if (original_recover_reshape_input_edge != nullptr) {\n      graph->AddEdge(recover_reshape_node, 0,\n                     original_recover_reshape_input_edge->dst(),\n                     original_recover_reshape_input_edge->dst_input());\n    } else {\n      graph->AddEdge(recover_reshape_node, 0, edge->dst(), edge->dst_input());\n    }\n\n    graph->RemoveEdge(edge);\n    if (original_recover_reshape_input_edge != nullptr) {\n      graph->RemoveEdge(original_recover_reshape_input_edge);\n    }\n\n    // 4. Update EdgeShapes.\n    int dimension = 1;\n    for (auto& it : (*tpu_input_shapes)[edge]) {\n      dimension *= it;\n    }\n    VLOG(3) << \"Dimension after reshape: \" << dimension;\n    for (const Edge* out_edge : flatten_reshape_node->out_edges()) {\n      if (out_edge->dst() == recover_reshape_node) {\n        (*tpu_input_shapes)[out_edge].push_back(dimension);\n        tpu_input_shapes->erase(edge);\n        break;\n      }\n    }\n    VLOG(3) << \"Reshape optimization done for \" << edge->src()->name();\n  }\n  return OkStatus();\n}\n}  // namespace tpu_functional_internal\n\nvoid TPUPartitionedCallOp::ComputeAsync(OpKernelContext* ctx,\n                                        DoneCallback done) {\n  Status init_status;\n  absl::call_once(once_, [&]() {\n    library_runtime_ = ctx->function_library();\n    if (library_runtime_ == nullptr) {\n      init_status = errors::Internal(\"No function library is provided.\");\n      return;\n    }\n    flib_def_ = std::make_unique<FunctionLibraryDefinition>(\n        *library_runtime_->GetFunctionLibraryDefinition());\n    device_mgr_ = library_runtime_->device_mgr();\n    for (auto d : device_mgr_->ListDevices()) {\n      device_set_.AddDevice(d);\n    }\n\n    DeviceNameUtils::ParsedName tpu_device_name;\n    tpu_device_name.has_type = true;\n    tpu_device_name.type = \"TPU\";\n    std::vector<Device*> tpu_devices;\n    device_set_.FindMatchingDevices(tpu_device_name, &tpu_devices_);\n  });\n  OP_REQUIRES_OK_ASYNC(ctx, init_status, done);\n\n  // Initialize the ordinal selector with information from the graph if it is\n  // the first time we are running this op.\n  absl::call_once(ordinal_selector_once_, [&]() {\n    std::unique_ptr<Graph> graph(new Graph(flib_def_.get()));\n    bool enable_spmd_xla_partitioning = false;\n    TPUMetadata tpu_metadata;\n    {\n      absl::MutexLock l(&mu_);\n      OP_REQUIRES_OK_ASYNC(\n          ctx,\n          GetGraphFromFunction(graph.get(), /*device_ordinal=*/0,\n                               &enable_spmd_xla_partitioning, &tpu_metadata),\n          done);\n    }\n    if (enable_spmd_xla_partitioning) {\n      ordinal_selector_ = std::make_shared<tpu::TPUOrdinalSelector>(\n          tpu_metadata.num_cores_per_replica);\n    } else {\n      ordinal_selector_ = std::make_shared<tpu::TPUOrdinalSelector>();\n    }\n\n    metrics::RecordTPUXlaSpmdCoresPerReplica(\n        tpu_metadata.num_cores_per_replica);\n  });\n  OP_REQUIRES_ASYNC(\n      ctx, ordinal_selector_ != nullptr,\n      errors::Internal(\"The TPUOrdinalSelector is not initialized.\"), done);\n\n  uint64 input_hash = GetInputHash(ctx);\n  int64_t ordinal_selector_req_id = -1;\n  // Select a TPU core.\n  int32_t device_ordinal = 0;\n  OP_REQUIRES_OK_ASYNC(\n      ctx,\n      GetTpuCoreOrdinal(ctx, input_hash, &ordinal_selector_req_id,\n                        &device_ordinal),\n      done);\n  uint64 cache_hash = Hash64Combine(input_hash, device_ordinal);\n  absl::ReleasableMutexLock lock(&mu_);\n\n  const std::vector<DeviceAndFHandle>* functions;\n\n  bool cache_miss = !partition_cache_.count(cache_hash);\n  if (cache_miss) {\n    VLOG(3) << \"Cache Miss: partitioning function \" << func_.name()\n            << \" cache_hash: \" << cache_hash\n            << \" device_ordinal: \" << device_ordinal;\n\n    profiler::TraceMe trace_me(\n        \"TPUPartitionedCallOp-RewriteAndInstantiateFunctions\");\n    std::unique_ptr<Graph> graph(new Graph(flib_def_.get()));\n    bool enable_spmd_xla_partitioning = false;\n    TPUMetadata tpu_metadata;\n    OP_REQUIRES_OK_ASYNC(\n        ctx,\n        GetGraphFromFunction(graph.get(), device_ordinal,\n                             &enable_spmd_xla_partitioning, &tpu_metadata),\n        done);\n\n    VLOG(1) << DumpGraphToFile(\"before_input_output_optimizations\", *graph,\n                               flib_def_.get());\n\n    std::map<std::string, std::vector<int>> named_input_shapes;\n    OP_REQUIRES_OK_ASYNC(\n        ctx,\n        OptimizeTpuInputOutputTensors(graph.get(), enable_spmd_xla_partitioning,\n                                      tpu_metadata.num_cores_per_replica,\n                                      named_input_shapes, ctx),\n        done);\n\n    VLOG(1) << DumpGraphToFile(\n        \"before_replace_resource_args_with_var_handle_ops\", *graph,\n        flib_def_.get());\n    OP_REQUIRES_OK_ASYNC(ctx,\n                         ReplaceResourceArgsWithVarHandleOps(\n                             graph.get(), ctx, device_ordinal,\n                             enable_spmd_xla_partitioning, tpu_metadata),\n                         done);\n\n    VLOG(1) << DumpGraphToFile(\n        \"after_replace_resource_args_with_var_handle_ops\", *graph,\n        flib_def_.get());\n\n    // Graph rewrite passes.\n    GraphOptimizationPassOptions optimization_options;\n    // TODO(akshayka): Thread the SessionOptions into this kernel, or make\n    // it possible to specify the relevant options via attributes.\n    SessionOptions session_options;\n    session_options.config.mutable_experimental()\n        ->set_xla_fusion_autotuner_thresh(autotuner_thresh_);\n\n    session_options.env = ctx->env();\n    optimization_options.session_handle = ctx->session_handle();\n    optimization_options.session_options = &session_options;\n    optimization_options.graph = &graph;\n    optimization_options.flib_def = flib_def_.get();\n    optimization_options.device_set = &device_set_;\n    OP_REQUIRES_OK_ASYNC(\n        ctx, PlacementHelper(device_set_, optimization_options, func_.name()),\n        done);\n\n    if (!enable_spmd_xla_partitioning ||\n        tpu_metadata.num_cores_per_replica == 1) {\n      OP_REQUIRES_OK_ASYNC(\n          ctx,\n          MaybeRegisterFingerprint(graph.get(), named_input_shapes, input_hash),\n          done);\n    }\n    // `subgraphs` maps from device names to functions.\n    std::unordered_map<std::string, std::unique_ptr<Graph>> subgraphs;\n    optimization_options.graph = nullptr;\n    optimization_options.device_set = nullptr;\n    optimization_options.partition_graphs = &subgraphs;\n    VLOG(1) << DumpGraphToFile(\"before_partition_helper.pbtxt\", *graph,\n                               flib_def_.get());\n    OP_REQUIRES_OK_ASYNC(ctx,\n                         PartitionHelper(device_set_, optimization_options,\n                                         graph.get(), &subgraphs),\n                         done);\n    OP_REQUIRES_OK_ASYNC(\n        ctx,\n        InstantiateFunctionsFromSubgraphs(\n            device_set_, device_ordinal, cache_hash,\n            tpu_metadata.num_cores_per_replica, std::move(subgraphs)),\n        done);\n  }\n  functions = &partition_cache_[cache_hash];\n  lock.Release();\n\n  ExecuteFunctions(*functions, ctx, device_ordinal, ordinal_selector_req_id,\n                   std::move(done));\n}\n\nStatus TPUPartitionedCallOp::GetTpuCoreOrdinal(OpKernelContext* ctx,\n                                               uint64 input_hash,\n                                               int64_t* ordinal_selector_req_id,\n                                               int32_t* core_ordinal) {\n  profiler::TraceMe trace_me(\"TPUPartitionedCallOp-GetTpuCoreOrdinal\");\n  const Tensor* device_ordinal_t;\n  TF_RETURN_IF_ERROR(ctx->input(kDeviceOrdinalAttr, &device_ordinal_t));\n  int device_ordinal = device_ordinal_t->scalar<int>()();\n  if (device_ordinal == tpu::kDeferredCoreSelectionReserved) {\n    device_ordinal =\n        ordinal_selector_->GetOrdinal(input_hash, ordinal_selector_req_id);\n  }\n  *core_ordinal = device_ordinal;\n  return OkStatus();\n}\n\nStatus TPUPartitionedCallOp::InitializeVarOnTPU(\n    OpKernelContext* ctx, const core::RefCountPtr<Var>& var, NodeDef* ndef,\n    int device_ordinal, bool fast_mem) {\n  const string device = strings::StrCat(kTPUDeviceNamePrefix, device_ordinal);\n  std::unique_ptr<Graph> init_graph(new Graph(OpRegistry::Global()));\n  TF_ASSIGN_OR_RETURN(Node * init_handle, init_graph->AddNode(*ndef));\n  init_handle->set_assigned_device_name(device);\n\n  NodeDef init_const_ndef;\n  init_const_ndef.set_name(\"initial_value\");\n#if defined(LIBTPU_ON_GCE)  // TODO(b/217559071) - Remove once _TPUConst is OSS\n  init_const_ndef.set_op(\"Const\");\n#else\n  init_const_ndef.set_op(\"_TPUConst\");\n  AddNodeAttr(\"memory_space\", \"HBM\", &init_const_ndef);\n#endif\n  init_const_ndef.set_device(device);\n  AddNodeAttr(\"dtype\", var->tensor()->dtype(), &init_const_ndef);\n  AddNodeAttr(\"value\", *var->tensor(), &init_const_ndef);\n\n  TF_ASSIGN_OR_RETURN(Node * init_const, init_graph->AddNode(init_const_ndef));\n\n  NodeDef assign_node_def;\n  assign_node_def.set_name(\"Assign\");\n  assign_node_def.set_op(\"AssignVariableOp\");\n  assign_node_def.set_device(device);\n  AddNodeAttr(\"dtype\", var->tensor()->dtype(), &assign_node_def);\n  TF_ASSIGN_OR_RETURN(Node * init_assign, init_graph->AddNode(assign_node_def));\n\n  init_graph->AddEdge(init_handle, 0, init_assign, 0);\n  init_graph->AddEdge(init_const, 0, init_assign, 1);\n  FHandle fhandle;\n  const string fname =\n      strings::StrCat(ndef->name(), \"_init_ord_\", device_ordinal);\n\n  TF_RETURN_IF_ERROR(\n      InstantiatePartition(*init_graph, fname, device, &fhandle, nullptr));\n\n  FunctionLibraryRuntime::Options opts;\n  opts.step_container = ctx->step_container();\n  opts.cancellation_manager = ctx->cancellation_manager();\n  opts.stats_collector = ctx->stats_collector();\n\n  // Blocking on threads in the same thread pool is disallowed because\n  // concurrent warm-up requests can exhaust the default thread pool.\n  // Create a new thread pool to initialize variables on TPU.\n  std::function<void(std::function<void()>)> runner =\n      [this](std::function<void()> fn) { pool_.Schedule(fn); };\n  opts.runner = &runner;\n\n  opts.source_device = local_device_name_;\n  PrivateIntraProcessRendezvous rendez(device_mgr_);\n  opts.rendezvous = &rendez;\n  opts.remote_execution = true;\n\n  std::vector<Tensor> dummy_args;\n  std::vector<Tensor>* dummy_rets = new std::vector<Tensor>;\n  Notification done;\n  Status status;\n  profiler::TraceMe trace_me(\"TPUPartitionedCallOp-InitializeVarOnTPU\");\n  library_runtime_->Run(opts, fhandle, dummy_args, dummy_rets,\n                        [dummy_rets, &done, &status](const Status& s) {\n                          status = s;\n                          delete dummy_rets;\n                          done.Notify();\n                        });\n  done.WaitForNotification();\n  TF_RETURN_IF_ERROR(status);\n\n  // We don't actually want the variable initialization functions\n  // in the function library definition and the function library\n  // runtime, because flib_def_ is used for the graph rewrite passes.\n  // The TPU distributed rewrite pass computes a fingerprint for\n  // flib_def_, which will throw an length error if there are\n  // many variables whose initialization functions are added\n  // to the library definition.\n  TF_RETURN_IF_ERROR(flib_def_->RemoveFunction(fname));\n  TF_RETURN_IF_ERROR(library_runtime_->ReleaseHandle(fhandle));\n  return OkStatus();\n}\n\nStatus TPUPartitionedCallOp::InitializeShardedVarOnTPU(\n    OpKernelContext* ctx, const core::RefCountPtr<Var>& var,\n    std::vector<NodeDef>& ndefs, int split_dim,\n    const std::vector<string>& tpu_devices) {\n  std::unique_ptr<Graph> init_graph(new Graph(OpRegistry::Global()));\n  int num_cores = ndefs.size();\n  string cpu_device = \"/device:CPU:0\";\n\n  std::vector<Node*> init_handles;\n  for (int i = 0; i < num_cores; i++) {\n    TF_ASSIGN_OR_RETURN(Node * init_handle, init_graph->AddNode(ndefs[i]));\n    init_handle->set_assigned_device_name(tpu_devices[i]);\n    init_handles.push_back(init_handle);\n  }\n\n  NodeDef init_const_ndef;\n  init_const_ndef.set_name(\"initial_value\");\n  init_const_ndef.set_op(\"Const\");\n  init_const_ndef.set_device(cpu_device);\n  AddNodeAttr(\"dtype\", var->tensor()->dtype(), &init_const_ndef);\n  AddNodeAttr(\"value\", *var->tensor(), &init_const_ndef);\n  TF_ASSIGN_OR_RETURN(Node * init_const, init_graph->AddNode(init_const_ndef));\n  init_const->set_assigned_device_name(cpu_device);\n\n  Node* assign_value_node = init_const;\n  // If the variable is sharded, we will insert \"Split\" node between the initial\n  // value and AssignVariableOp, so the variables on each TPU device get\n  // assigned to the splitted value.\n  //\n  // initial_value--Split--AssignVariableOp (\"/device:TPU:0\")\n  //                  |\n  //            AssignVariableOp (\"/device:TPU:1\")\n  if (split_dim >= 0) {\n    // Add a split dimension node.\n    NodeDef split_dim_def;\n    split_dim_def.set_name(\"initial_value_split_dim\");\n    split_dim_def.set_op(\"Const\");\n    split_dim_def.set_device(cpu_device);\n    AddNodeAttr(\"dtype\", DT_INT32, &split_dim_def);\n    TensorProto tensor_proto;\n    tensor_proto.set_dtype(DT_INT32);\n    tensor_proto.add_int_val(split_dim);\n    TensorShape shape({});\n    shape.AsProto(tensor_proto.mutable_tensor_shape());\n    AddNodeAttr(\"value\", tensor_proto, &split_dim_def);\n    TF_ASSIGN_OR_RETURN(Node * split_dim_node,\n                        init_graph->AddNode(split_dim_def));\n    split_dim_node->set_assigned_device_name(cpu_device);\n\n    // Add a split node.\n    NodeDef split_def;\n    int split_num = ndefs.size();\n    split_def.set_name(\"initial_value_split\");\n    split_def.set_op(\"Split\");\n    split_def.set_device(cpu_device);\n    AddNodeAttr(\"num_split\", split_num, &split_def);\n    AddNodeAttr(\"T\", var->tensor()->dtype(), &split_def);\n    split_def.add_input(absl::StrCat(split_dim_node->name(), \":0\"));\n    split_def.add_input(absl::StrCat(init_const->name(), \":0\"));\n    TF_ASSIGN_OR_RETURN(Node * split_node, init_graph->AddNode(split_def));\n    split_node->set_assigned_device_name(cpu_device);\n\n    init_graph->AddEdge(split_dim_node, 0, split_node, 0);\n    init_graph->AddEdge(init_const, 0, split_node, 1);\n\n    assign_value_node = split_node;\n  }\n\n  for (int i = 0; i < num_cores; i++) {\n    NodeDef assign_node_def;\n    assign_node_def.set_name(absl::StrCat(\"Assign_\", i));\n    assign_node_def.set_op(\"AssignVariableOp\");\n    assign_node_def.set_device(tpu_devices[i]);\n    AddNodeAttr(\"dtype\", var->tensor()->dtype(), &assign_node_def);\n    TF_ASSIGN_OR_RETURN(Node * init_assign,\n                        init_graph->AddNode(assign_node_def));\n    init_assign->set_assigned_device_name(tpu_devices[i]);\n\n    init_graph->AddEdge(init_handles[i], 0, init_assign, 0);\n    if (split_dim >= 0) {\n      init_graph->AddEdge(assign_value_node, i, init_assign, 1);\n    } else {\n      init_graph->AddEdge(assign_value_node, 0, init_assign, 1);\n    }\n  }\n\n  GraphOptimizationPassOptions optimization_options;\n  SessionOptions session_options;\n  session_options.env = ctx->env();\n  optimization_options.session_handle = ctx->session_handle();\n  optimization_options.session_options = &session_options;\n  optimization_options.flib_def = flib_def_.get();\n  optimization_options.graph = nullptr;\n  optimization_options.device_set = nullptr;\n  std::unordered_map<std::string, std::unique_ptr<Graph>> subgraphs;\n  optimization_options.partition_graphs = &subgraphs;\n  TF_RETURN_IF_ERROR(PartitionHelper(device_set_, optimization_options,\n                                     init_graph.get(), &subgraphs));\n\n  std::vector<DeviceAndFHandle> functions;\n  std::vector<std::string> function_names;\n  for (auto& pair : subgraphs) {\n    string target = pair.first;\n    Device* device;\n    TF_RETURN_IF_ERROR(\n        library_runtime_->device_mgr()->LookupDevice(target, &device));\n    Graph* subgraph = pair.second.get();\n    string function_name = flib_def_->UniqueFunctionName(\n        strings::StrCat(func_.name(), \"_hash_\", pair.first));\n    function_names.push_back(function_name);\n    FHandle handle;\n    TF_RETURN_IF_ERROR(InstantiatePartition(*subgraph, function_name, target,\n                                            &handle, nullptr));\n    functions.push_back(DeviceAndFHandle{.device = target, .handle = handle});\n  }\n\n  FunctionLibraryRuntime::Options opts;\n\n  // Blocking on threads in the same thread pool is disallowed because\n  // concurrent warm-up requests can exhaust the default thread pool.\n  // Create a new thread pool to initialize variables on TPU.\n  std::function<void(std::function<void()>)> runner =\n      [this](std::function<void()> fn) { pool_.Schedule(fn); };\n  opts.runner = &runner;\n\n  opts.step_container = ctx->step_container();\n  opts.cancellation_manager = ctx->cancellation_manager();\n  opts.stats_collector = ctx->stats_collector();\n  opts.source_device = local_device_name_;\n  opts.run_all_kernels_inline = ctx->run_all_kernels_inline();\n\n  OpInputList arguments;\n  TF_RETURN_IF_ERROR(ctx->input_list(\"args\", &arguments));\n\n  PrivateIntraProcessRendezvous rendez(device_mgr_);\n  opts.rendezvous = &rendez;\n\n  BlockingCounter bcount(functions.size());\n  std::vector<Status> statuses(functions.size());\n  for (int i = 0; i < functions.size(); i++) {\n    const DeviceAndFHandle& entry = functions[i];\n    const string& target_device = entry.device;\n    FHandle handle = entry.handle;\n\n    TF_RETURN_IF_ERROR(\n        ShouldUseRemoteExecutionForFn(target_device, &(opts.remote_execution)));\n    std::vector<Tensor> dummy_args;\n    std::vector<Tensor>* dummy_rets = new std::vector<Tensor>;\n\n    profiler::TraceMe trace_me(\n        \"TPUPartitionedCallOp-InitializeShardedVarOnTPU\");\n    library_runtime_->Run(opts, handle, dummy_args, dummy_rets,\n                          [dummy_rets, i, &bcount, &statuses](const Status& s) {\n                            statuses[i] = s;\n                            delete dummy_rets;\n                            bcount.DecrementCount();\n                          });\n  }\n  bcount.Wait();\n\n  StatusGroup status_group;\n  for (const auto& status : statuses) {\n    status_group.Update(status);\n  }\n  TF_RETURN_IF_ERROR(status_group.as_summary_status());\n\n  for (int i = 0; i < functions.size(); i++) {\n    TF_RETURN_IF_ERROR(flib_def_->RemoveFunction(function_names[i]));\n    TF_RETURN_IF_ERROR(library_runtime_->ReleaseHandle(functions[i].handle));\n  }\n  return OkStatus();\n}\n\nbool TPUPartitionedCallOp::IsInputToTPUReplicate(Node* node) {\n  for (Node* successor : node->out_nodes()) {\n    if (successor->attrs().Find(kTpuReplicateAttr) != nullptr) {\n      return true;\n    }\n  }\n  return false;\n}\n\nStatus TPUPartitionedCallOp::ReplaceResourceArgsWithVarHandleOps(\n    Graph* graph, OpKernelContext* ctx, int device_ordinal,\n    bool enable_spmd_xla_partitioning, const TPUMetadata& tpu_metadata) {\n  // Currently variable deduplication is not supported for XLA SPMD\n  // partitioning. It is possible that it could be supported in the future.\n  bool enable_variable_deduplication =\n      runtime_params_.enable_variable_deduplication;\n  if (enable_spmd_xla_partitioning && tpu_metadata.num_cores_per_replica > 1) {\n    // If enable_spmd_xla_partitioning is true, the user set the\n    // enable_auto_xla_input_sharding flag. Warn them that only one of the flags\n    // can be set safely when num_cores_per_replica > 1. If\n    // num_cores_per_replica==1, enable_spmd_xla_partitioning is effectively a\n    // no-op so we can skip this check.\n    LOG(WARNING) << \"Disabling variable deduplication because it is not \"\n                    \"compatible with enable_auto_xla_input_sharding.\";\n    enable_variable_deduplication = false;\n  }\n  std::vector<Node*> tpu_resource_args;\n  std::vector<int> arg_indices;\n  absl::flat_hash_map<const Node*, xla::OpSharding> variable_to_xla_sharding;\n  for (Node* node : graph->op_nodes()) {\n    if (node->IsArg()) {\n      const AttrValue* attr_value;\n      TF_RETURN_IF_ERROR(node->attrs().Find(\"T\", &attr_value));\n      DataType dtype = attr_value->type();\n      if (dtype == DT_RESOURCE && IsInputToTPUReplicate(node)) {\n        // If this VarHandleOp is used by a TPU computation,\n        // we need to create a TPU version of the variable,\n        TF_RETURN_IF_ERROR(node->attrs().Find(\"index\", &attr_value));\n        int index = attr_value->i();\n        tpu_resource_args.push_back(node);\n        arg_indices.push_back(index);\n        replaced_input_indices_[index] = true;\n      }\n    }\n  }\n\n  VLOG(3) << \"tpu_resource_args.size(): \" << tpu_resource_args.size();\n  // Create a mapping from ResourceHandle to variable node. When a\n  // ResourceHandle backs several variable nodes, the variable nodes refer to\n  // the same underlying resource. In that case, only one variable node needs\n  // to be mirrored to the TPU for that resource.\n  absl::flat_hash_map<uint64, Node*> tpu_variables;\n  for (int i = 0; i < tpu_resource_args.size(); i++) {\n    Node* node = tpu_resource_args[i];\n    ResourceHandle handle = HandleFromInput(ctx, arg_indices[i]);\n\n    if (tpu_metadata.num_cores_per_replica > 1 &&\n        enable_spmd_xla_partitioning) {\n      TF_RETURN_IF_ERROR(ReplaceAndPartitionXLAShardingVariable(\n          graph, ctx, device_ordinal, handle, node, tpu_metadata));\n      continue;\n    }\n    TPUVariableInfo var_info(/*device_ordinal_id=*/0, /*use_fast_mem=*/false);\n    TF_RETURN_IF_ERROR(ParseTPUVariableInfor(\n        node, tpu_metadata.num_cores_per_replica, &var_info));\n    // Only respect graph's placement when model parallelism enabled.\n    if (tpu_metadata.num_cores_per_replica > 1)\n      device_ordinal = var_info.device_ordinal;\n\n    const uint64 handle_fp =\n        Fingerprint64(strings::StrCat(handle.container(), handle.name()));\n    if (enable_variable_deduplication && tpu_variables.contains(handle_fp) &&\n        tpu_metadata.num_cores_per_replica == 1) {\n      Node* tpu_variable = tpu_variables.at(handle_fp);\n      std::vector<Node*> dst_nodes;\n      std::vector<int> src_indices;\n      std::vector<int> dst_indices;\n      for (const Edge* edge : node->out_edges()) {\n        dst_nodes.push_back(edge->dst());\n        src_indices.push_back(edge->src_output());\n        dst_indices.push_back(edge->dst_input());\n      }\n      graph->RemoveNode(node);\n      for (int i = 0; i < dst_nodes.size(); i++) {\n        graph->AddEdge(tpu_variable, src_indices[i], dst_nodes[i],\n                       dst_indices[i]);\n      }\n    } else {\n      uint64 fp =\n          Fingerprint64(strings::StrCat(handle.container(), handle.name(), i));\n      NodeDef ndef;\n      ndef.set_name(strings::StrCat(handle.name(), fp));\n      ndef.set_op(kVarHandleOp);\n      if (tpu_metadata.num_cores_per_replica > 1) {\n        ndef.set_device(strings::StrCat(kTPUDeviceNamePrefix, device_ordinal));\n      } else {\n        // Assign this new VarHandleOp to TPU:0 so the partitioner only\n        // partiitons the graph into two subgraphs, one on CPU and one on TPU.\n        // The actual device ordinal on which this VarHandleOp runs is assigned\n        // after partitioning (in SetDeviceOrdinal).\n        ndef.set_device(\n            strings::StrCat(kTPUDeviceNamePrefix, kTPUDefaultDeviceOrdinal));\n      }\n\n      // Replace each _Arg node of type DT_RESOURCE that goes into a TPU node\n      // by a VarHandleOp on TPU with shared_name \"v_tpu_x\" where \"v\" is the\n      // shared_name of the variable on CPU and \"x\" is the rewritten device\n      // ordinal.\n      const string sname =\n          strings::StrCat(handle.name(), \"_tpu_\", device_ordinal);\n      AddNodeAttr(\"shared_name\", sname, &ndef);\n      const string cname = ctx->resource_manager()->default_container();\n      AddNodeAttr(\"container\", cname, &ndef);\n      core::RefCountPtr<Var> var;\n      TF_RETURN_IF_ERROR(LookupResource(ctx, handle, &var));\n      AddNodeAttr(\"dtype\", var->tensor()->dtype(), &ndef);\n      TensorShapeProto proto;\n      var->tensor()->shape().AsProto(&proto);\n      AddNodeAttr(\"shape\", proto, &ndef);\n      TF_ASSIGN_OR_RETURN(Node * new_node, graph->AddNode(ndef));\n      std::vector<const Edge*> in_edges(node->in_edges().begin(),\n                                        node->in_edges().end());\n      for (const Edge* edge : in_edges) {\n        graph->AddEdge(edge->src(), edge->src_output(), new_node,\n                       edge->dst_input());\n      }\n      std::vector<Node*> dst_nodes;\n      std::vector<int> src_indices;\n      std::vector<int> dst_indices;\n      for (const Edge* edge : node->out_edges()) {\n        dst_nodes.push_back(edge->dst());\n        src_indices.push_back(edge->src_output());\n        dst_indices.push_back(edge->dst_input());\n      }\n      graph->RemoveNode(node);\n      for (int i = 0; i < dst_nodes.size(); i++) {\n        graph->AddEdge(new_node, src_indices[i], dst_nodes[i], dst_indices[i]);\n      }\n      // Don't initialize variables on TPU if it is done for the ordinal\n      // already.\n      if (seen_ordinals_.contains(device_ordinal)) continue;\n\n      Device* d;\n      TF_RETURN_IF_ERROR(library_runtime_->device_mgr()->LookupDevice(\n          strings::StrCat(kTPUDeviceNamePrefix, device_ordinal), &d));\n      Var* tpu_var;\n      Status status = d->resource_manager()->Lookup(cname, sname, &tpu_var);\n      if (!status.ok()) {\n        TF_RETURN_IF_ERROR(InitializeVarOnTPU(ctx, var, &ndef, device_ordinal,\n                                              var_info.fast_mem));\n        VLOG(3) << \"Initialized variable on TPU: \" << sname\n                << \" device_ordinal: \" << device_ordinal;\n      }\n      tpu_variables[handle_fp] = new_node;\n    }\n  }\n\n  // adjust the index attr of other non-resource arg nodes\n  int new_index = 0;\n  for (Node* node : graph->op_nodes()) {\n    if (node->IsArg()) {\n      node->ClearAttr(\"index\");\n      node->AddAttr(\"index\", new_index);\n      new_index++;\n    }\n  }\n\n  seen_ordinals_.insert(device_ordinal);\n\n  return OkStatus();\n}\n\nStatus TPUPartitionedCallOp::ReplaceAndPartitionXLAShardingVariable(\n    Graph* graph, OpKernelContext* ctx, int device_ordinal,\n    ResourceHandle& handle, Node* variable, const TPUMetadata& tpu_metadata) {\n  if (device_ordinal >= tpu_metadata.topology.num_tpu_devices_per_task()) {\n    return errors::InvalidArgument(\n        \"There are \", tpu_metadata.topology.num_tpu_devices_per_task(),\n        \" TPU devices, however selected device_ordinal: \", device_ordinal,\n        \" exceeds the range\");\n  }\n\n  TF_ASSIGN_OR_RETURN(\n      auto sharding,\n      GetShardingFromNodeDef(variable->def(), /*add_metadata=*/false));\n  xla::OpSharding xla_sharding;\n  bool is_var_sharded = false;\n  if (sharding.has_value() &&\n      sharding.value().type() == xla::OpSharding::OTHER) {\n    xla_sharding = sharding.value();\n    for (int dim = 0; dim < GetDimsFromXLAShardingTiled(xla_sharding); dim++) {\n      is_var_sharded |= xla_sharding.tile_assignment_dimensions(dim) > 1;\n    }\n  } else {\n    xla_sharding.set_type(xla::OpSharding::REPLICATED);\n    is_var_sharded = false;\n  }\n\n  core::RefCountPtr<Var> var;\n  TF_RETURN_IF_ERROR(LookupResource(ctx, handle, &var));\n\n  VLOG(3) << \"Replace and partition variable \" << variable->name()\n          << \" is_var_sharded: \" << is_var_sharded\n          << \" shape: \" << var->tensor()->shape().DebugString()\n          << \" with xla_sharding: \" << xla_sharding.DebugString();\n\n  int split_dim = -1;\n  int split_size = 0;\n\n  if (is_var_sharded) {\n    for (int dim = 0; dim < GetDimsFromXLAShardingTiled(xla_sharding); dim++) {\n      if (xla_sharding.tile_assignment_dimensions(dim) > 1) {\n        if (split_dim != -1) {\n          return errors::InvalidArgument(\n              \"Currently we only support inference with one split dimension, \"\n              \"however got sharding: \",\n              xla_sharding.DebugString());\n        }\n        split_dim = dim;\n        split_size = xla_sharding.tile_assignment_dimensions(dim);\n      }\n    }\n    if (split_dim == -1 || split_dim >= var->tensor()->dims()) {\n      return errors::InvalidArgument(\n          \"sharding split_dim \", split_dim, \" for variable: \", variable->name(),\n          \" is -1 or large than the number of dimensions \",\n          var->tensor()->dims());\n    }\n  }\n\n  const auto& topology = tpu_metadata.topology;\n  int num_cores_per_replica = tpu_metadata.num_cores_per_replica;\n  xla::Array4D<int> mapping(topology.mesh_shape(0), topology.mesh_shape(1),\n                            topology.mesh_shape(2), topology.mesh_shape(3), -1);\n  int pos = 0;\n  // The topology should only have one task.\n  for (int device = 0; device < topology.num_tpu_devices_per_task(); device++) {\n    int32_t x = topology.device_coordinates(pos++);\n    int32_t y = topology.device_coordinates(pos++);\n    int32_t z = topology.device_coordinates(pos++);\n    int32_t core = topology.device_coordinates(pos++);\n    mapping(x, y, z, core) = device;\n  }\n\n  const string cname = ctx->resource_manager()->default_container();\n  std::vector<Node*> per_core_vars;\n  std::vector<string> tpu_devices;\n  for (int i = 0; i < num_cores_per_replica; i++) {\n    int offset = i * 4;\n    int device_index = mapping(tpu_metadata.device_assignment[offset],\n                               tpu_metadata.device_assignment[offset + 1],\n                               tpu_metadata.device_assignment[offset + 2],\n                               tpu_metadata.device_assignment[offset + 3]);\n\n    NodeDef ndef;\n    uint64 fp = Fingerprint64(\n        strings::StrCat(handle.container(), handle.name(), \"_\", device_index));\n    ndef.set_name(strings::StrCat(handle.name(), fp));\n    ndef.set_op(kVarHandleOp);\n    string tpu_device = strings::StrCat(kTPUDeviceNamePrefix, device_index);\n    ndef.set_device(tpu_device);\n    tpu_devices.push_back(tpu_device);\n\n    // Replace each _Arg node of type DT_RESOURCE that goes into a TPU node\n    // by a VarHandleOp on TPU with shared_name \"v_tpu_x\" where \"v\" is the\n    // shared_name of the variable on CPU and \"x\" is the rewritten device\n    // ordinal.\n    const string sname = strings::StrCat(handle.name(), \"_tpu_\", device_index);\n    AddNodeAttr(\"shared_name\", sname, &ndef);\n    AddNodeAttr(\"container\", cname, &ndef);\n    AddNodeAttr(\"dtype\", var->tensor()->dtype(), &ndef);\n\n    TensorShapeProto proto;\n    var->tensor()->shape().AsProto(&proto);\n\n    if (is_var_sharded) {\n      int dim_size = proto.dim(split_dim).size();\n      if (dim_size % split_size != 0) {\n        return errors::InvalidArgument(\"dimension size \", dim_size,\n                                       \" cannot be divisible by split size \",\n                                       split_size);\n      }\n      proto.mutable_dim(split_dim)->set_size(dim_size / split_size);\n    }\n    AddNodeAttr(\"shape\", proto, &ndef);\n\n    TF_ASSIGN_OR_RETURN(Node * new_node, graph->AddNode(ndef));\n    per_core_vars.push_back(new_node);\n  }\n\n  // Insert TPUPartitionedInput op.\n  NodeDefBuilder builder(absl::StrCat(handle.name(), \"/tpu_partitioned_input\"),\n                         \"TPUPartitionedInput\");\n  builder.Attr(\"N\", num_cores_per_replica);\n  builder.Attr(\"T\", DT_RESOURCE);\n  builder.Attr(\"partition_dim\", split_dim);\n  builder.Attr(\"_XlaSharding\", xla_sharding.SerializeAsString());\n  std::vector<NodeDefBuilder::NodeOut> inputs;\n  inputs.reserve(num_cores_per_replica);\n  for (int i = 0; i < num_cores_per_replica; i++) {\n    inputs.push_back({per_core_vars[i]->name(), 0, DT_RESOURCE});\n  }\n  builder.Input(inputs);\n  NodeDef node_def;\n  TF_RETURN_IF_ERROR(builder.Finalize(&node_def));\n  TF_ASSIGN_OR_RETURN(Node * tpu_partitioned_input_node,\n                      graph->AddNode(node_def));\n\n  for (int i = 0; i < num_cores_per_replica; i++) {\n    graph->AddEdge(per_core_vars[i], 0, tpu_partitioned_input_node, i);\n  }\n\n  // Insert TPUReplicatedInput op.\n  NodeDefBuilder replicated_builder(\n      absl::StrCat(handle.name(), \"/tpu_replicated_input\"),\n      \"TPUReplicatedInput\");\n  replicated_builder.Attr(\"N\", 1);\n  replicated_builder.Attr(\"T\", DT_RESOURCE);\n  replicated_builder.Attr(\"is_mirrored_variable\", true);\n  std::vector<NodeDefBuilder::NodeOut> replicated_inputs;\n  replicated_inputs.push_back(\n      {tpu_partitioned_input_node->name(), 0, DT_RESOURCE});\n  replicated_builder.Input(replicated_inputs);\n  NodeDef replicated_node_def;\n  TF_RETURN_IF_ERROR(replicated_builder.Finalize(&replicated_node_def));\n  Status replicated_s;\n  Node* tpu_replicated_input_node =\n      graph->AddNode(replicated_node_def, &replicated_s);\n  if (!replicated_s.ok()) {\n    return replicated_s;\n  }\n  graph->AddEdge(tpu_partitioned_input_node, 0, tpu_replicated_input_node, 0);\n\n  // Connect the TPUReplicatedInput node to the previous output nodes of the\n  // variable, and remove the variable node.\n  std::vector<Node*> dst_nodes;\n  std::vector<int> src_indices;\n  std::vector<int> dst_indices;\n  for (const Edge* edge : variable->out_edges()) {\n    dst_nodes.push_back(edge->dst());\n    src_indices.push_back(edge->src_output());\n    dst_indices.push_back(edge->dst_input());\n  }\n  for (int i = 0; i < dst_nodes.size(); i++) {\n    graph->AddEdge(tpu_replicated_input_node, src_indices[i], dst_nodes[i],\n                   dst_indices[i]);\n  }\n\n  graph->RemoveNode(variable);\n\n  std::vector<NodeDef> ndefs;\n  Status status;\n  for (int i = 0; i < num_cores_per_replica; i++) {\n    Device* d;\n    TF_RETURN_IF_ERROR(\n        library_runtime_->device_mgr()->LookupDevice(tpu_devices[i], &d));\n    string sname;\n    const NodeDef& ndef = per_core_vars[i]->def();\n    TF_RETURN_IF_ERROR(GetNodeAttr(ndef, \"shared_name\", &sname));\n    ndefs.push_back(ndef);\n    Var* tpu_var;\n    status = d->resource_manager()->Lookup(cname, sname, &tpu_var);\n  }\n\n  if (!status.ok()) {\n    TF_RETURN_IF_ERROR(\n        InitializeShardedVarOnTPU(ctx, var, ndefs, split_dim, tpu_devices));\n    if (VLOG_IS_ON(4)) {\n      for (int i = 0; i < num_cores_per_replica; i++) {\n        string sname;\n        TF_RETURN_IF_ERROR(GetNodeAttr(ndefs[i], \"shared_name\", &sname));\n        LOG(INFO) << \"Initialized sharded variable on TPU: \" << sname\n                  << \" device: \" << tpu_devices[i];\n      }\n    }\n  }\n\n  return OkStatus();\n}\n\nStatus TPUPartitionedCallOp::InferShapesWithResourceVar(\n    Graph* graph, OpKernelContext* ctx,\n    std::map<int, InferredShape>& arg_shapes,\n    GraphShapeInfo* tpu_inferred_info) {\n  auto shape_inference_graph_interim =\n      absl::make_unique<Graph>(graph->flib_def());\n  CopyGraph(*graph, shape_inference_graph_interim.get());\n\n  for (Node* node : shape_inference_graph_interim->nodes()) {\n    if (node->type_string() != \"_Arg\" ||\n        node->attrs().Find(\"T\")->type() != DT_RESOURCE)\n      continue;\n\n    std::vector<std::function<void()>> to_remove;\n\n    for (const Edge* out_edge : node->out_edges()) {\n      Node* read_node = out_edge->dst();\n      if (read_node->type_string() != \"ReadVariableOp\") continue;\n\n      for (const Edge* variable_edge : read_node->out_edges()) {\n        // We are delaying these modifications as we cannot do in-place\n        // modification of EdgeSets.\n        to_remove.push_back(\n            [variable_edge, graph = shape_inference_graph_interim.get(), node] {\n              Node* dst = variable_edge->dst();\n              graph->RemoveEdge(variable_edge);\n              graph->AddEdge(node, variable_edge->src_output(), dst,\n                             variable_edge->dst_input());\n            });\n      }\n      to_remove.push_back(\n          [graph = shape_inference_graph_interim.get(), out_edge, read_node] {\n            graph->RemoveEdge(out_edge);\n            graph->RemoveNode(read_node);\n          });\n    }\n\n    for (auto& func : to_remove) {\n      func();\n    }\n\n    int resource_arg_index = node->attrs().Find(\"index\")->i();\n\n    // Get resource variable tensor\n    core::RefCountPtr<Var> variable;\n    const ResourceHandle& handle = HandleFromInput(ctx, resource_arg_index);\n    TF_RETURN_IF_ERROR(LookupResource(ctx, handle, &variable));\n\n    const Tensor* variable_tensor = variable->tensor();\n    std::vector<int> variable_tensor_vec;\n\n    variable_tensor_vec.reserve(variable_tensor->dims());\n    for (int d = 0; d < variable_tensor->dims(); ++d) {\n      variable_tensor_vec.push_back(variable_tensor->dim_size(d));\n    }\n\n    PartialTensorShape partial_tensor_shape;\n    auto partial_shape = PartialTensorShape::MakePartialShape(\n        variable_tensor_vec.data(), variable_tensor_vec.size(),\n        &partial_tensor_shape);\n    InferredShape inferred_shape = {partial_tensor_shape};\n    arg_shapes.emplace(resource_arg_index, inferred_shape);\n  }\n\n  TF_RETURN_IF_ERROR(tensorflow::InferShapes(\n      shape_inference_graph_interim.get(), arg_shapes,\n      &shape_inference_graph_interim->flib_def(), tpu_inferred_info));\n  return OkStatus();\n}\n\nStatus TPUPartitionedCallOp::ShardInputsWithXlaSharding(\n    Graph* graph, const std::string& cluster_name, int num_cores_per_replica,\n    OpKernelContext* ctx) {\n  for (Node* replicated_input_node : graph->nodes()) {\n    if (replicated_input_node->type_string() != \"TPUReplicatedInput\") continue;\n\n    Node* arg_node;\n    auto input_node_status = replicated_input_node->input_node(0, &arg_node);\n    if (!input_node_status.ok()) {\n      VLOG(2) << \"Skip because cannot retrieve input node 0 of \"\n              << replicated_input_node->name() << \" because \"\n              << input_node_status.ToString();\n      continue;\n    }\n\n    // Check if this TPUReplicatedInput can qualify because it has _Arg\n    // as input and doesn't have XlaSharding already as an output, then\n    // try to shard inputs automatically.\n    //\n    // In short, we want to see the following graph:\n    //    _Arg -> TPUReplicatedInput -> (not XlaSharding op)\n    // and transform it to:\n    //    _Arg -> TPUReplicatedInput -> XlaSharding -> (not XlaSharding op)\n    if (arg_node->IsArg() &&\n        replicated_input_node->out_nodes().begin()->type_string() !=\n            \"XlaSharding\") {\n      int arg_id;\n      if (!absl::SimpleAtoi(absl::StripPrefix(arg_node->name(), \"arg_\"),\n                            &arg_id)) {\n        VLOG(3) << \"Skip auto-sharding because we are unable to extract \"\n                   \"argument number from \"\n                << arg_node->name();\n        continue;\n      }\n\n      auto shape = ctx->input(arg_id).shape();\n\n      VLOG(3) << \"Identified arg node \" << arg_node->DebugString()\n              << \" for TPUReplicatedInput \"\n              << replicated_input_node->DebugString();\n      VLOG(3) << \"Shape within TPUReplicatedInput is: \" << shape.DebugString();\n\n      int rank = shape.dims();\n      int shard_dim =\n          (runtime_params_.auto_xla_input_sharding_dim + rank) % rank;\n\n      if (shape.dim_size(shard_dim) % num_cores_per_replica != 0) {\n        VLOG(3) << \"Skip auto-sharding \" << replicated_input_node->name()\n                << \" because the specified sharding dimension \" << shard_dim\n                << \" cannot be evenly split by \" << num_cores_per_replica;\n        continue;\n      }\n\n      auto sharding = absl::make_optional<xla::OpSharding>();\n      sharding->set_type(xla::OpSharding::OTHER);\n\n      // Sets up tile_assignment_dimensions.\n      std::vector<int64_t> dims(rank, 1LL);\n      dims[shard_dim] = num_cores_per_replica;\n      for (auto dim : dims) {\n        sharding->add_tile_assignment_dimensions(dim);\n      }\n\n      // Sets up tile_assignment_devices.\n      for (int d = 0; d < num_cores_per_replica; ++d) {\n        sharding->add_tile_assignment_devices(d);\n      }\n\n      std::vector<const Edge*> edges_to_remove;\n      for (const Edge* edge : replicated_input_node->out_edges()) {\n        if (edge->IsControlEdge()) continue;\n        edges_to_remove.push_back(edge);\n      }\n\n      // Create XlaSharding Op.\n      Node* sharding_op = nullptr;\n      TF_RETURN_IF_ERROR(\n          NodeBuilder(absl::StrCat(replicated_input_node->name(), \"/sharding\"),\n                      \"XlaSharding\")\n              .Input(replicated_input_node, 0)\n              .Attr(\"T\", replicated_input_node->output_type(0))\n              .Attr(kXLAShardingAttrName, sharding->SerializeAsString())\n              .Attr(kXLAShardingAttrAltName, sharding->SerializeAsString())\n              .Attr(\"_tpu_replicate\", cluster_name)\n              .Finalize(graph, &sharding_op));\n      for (const Edge* edge : edges_to_remove) {\n        VLOG(3) << \"XlaSharding op creation output edge \"\n                << edge->DebugString();\n        graph->RemoveEdge(edge);\n        graph->AddEdge(sharding_op, 0, edge->dst(), edge->dst_input());\n      }\n\n      VLOG(3) << \"Auto shard \" << replicated_input_node->name() << \" by dim \"\n              << shard_dim << \" into \" << num_cores_per_replica << \" slices\";\n\n      VLOG(3) << \"Created XlaSharding Op \" << sharding_op->DebugString();\n    }\n  }\n\n  return OkStatus();\n}\n\n// OptimizeTpuInputOutputTensors does the following things;\n//  (1) Detect input arguments, and add XlaSharding op to the arguments if the\n//  enable_auto_xla_input_sharding is turned on\n//  (2) Pack multiple input tensors into one tensor by a concat to avoid PCIe\n//  transfer overheads for small tensors.\n//  (3) Reshape input tensors to R1 to leverage the fast path in TPU input\n//  preparation done by runtime.\n//  (4) Pack multiple output tensors into one tensor by a concat.\n//\n// (1) is controlled by --enable_auto_xla_input_sharding and\n// --auto_xla_input_sharding_dim\n// (2) and (3) are controlled by flags --minimum_input_tensors_packing\n// and --input_shape_opt, respectively, while (4) is controlled by\n// --minimum_output_tensors_packing.\nStatus TPUPartitionedCallOp::OptimizeTpuInputOutputTensors(\n    Graph* graph, bool enable_spmd_xla_partitioning, int num_cores_per_replica,\n    std::map<std::string, std::vector<int>>& named_input_shapes,\n    OpKernelContext* ctx) {\n  std::string cluster_name;\n  TF_RETURN_IF_ERROR(GetClusterName(graph, &cluster_name));\n\n  if (runtime_params_.enable_auto_xla_input_sharding) {\n    VLOG(2) << DumpGraphToFile(\"before_enable_auto_xla_input_sharding\", *graph,\n                               flib_def_.get());\n\n    TF_RETURN_IF_ERROR(ShardInputsWithXlaSharding(graph, cluster_name,\n                                                  num_cores_per_replica, ctx));\n  }\n\n  GraphShapeInfo tpu_inferred_info;\n  std::map<int, InferredShape> arg_shapes;\n  EdgeShapes tpu_input_shapes;\n  absl::flat_hash_map<const Edge*, DataType> tpu_input_dtypes;\n\n  // Contains attrs \"T\", \"sharding\", \"_tpu_replicate\" for each XlaSharding op.\n  XlaShardingInfoMap xla_sharding_ops;\n\n  // Contains attrs \"T\", and a pointer to tpu_replicated_metadata for ctrl dep\n  TpuReplicatedInputInfoMap tpu_replicated_input_ops;\n\n  bool xla_spmd_input_sharded = false;\n\n  if (enable_spmd_xla_partitioning) {\n    xla_spmd_input_sharded = FindTpuReplicatedInputAndXlaSharding(\n        graph, xla_sharding_ops, tpu_replicated_input_ops);\n  }\n\n  VLOG(1) << \"xla_spmd_input_sharded: \" << xla_spmd_input_sharded;\n  VLOG(2) << DumpGraphToFile(\"before_remove_descendant_nodes\", *graph,\n                             flib_def_.get());\n\n  if (!xla_spmd_input_sharded ||\n      runtime_params_.minimum_input_tensors_packing > 1 ||\n      runtime_params_.enable_auto_xla_input_sharding) {\n    // Currently we remove `TPUReplicatedInput` nodes when the input tensors are\n    // not sharded, input tensors packing optimization is enabled or when\n    // auto xla input sharding is there, or else downstream rewrites will be\n    // confused.\n    RemoveDescendantNodeOfArg(graph, \"TPUReplicatedInput\",\n                              /*must_be_child_of=*/{});\n  }\n\n  if (xla_spmd_input_sharded) {\n    // We are setting must_be_child_of to {\"Arg\"} because we do not want\n    // to remove other XlaSharding ops that might be in the graph. We only\n    // want the XlaSharding ops that are directly attached to the input\n    // arguments to be removed.\n    RemoveDescendantNodeOfArg(graph, \"XlaSharding\",\n                              /*must_be_child_of=*/{\"_Arg\"});\n  }\n\n  VLOG(2) << DumpGraphToFile(\"before_get_input_output_info\", *graph,\n                             flib_def_.get());\n\n  TF_RETURN_IF_ERROR(GetInputOutputInfo(graph, tpu_inferred_info, arg_shapes,\n                                        tpu_input_shapes, tpu_input_dtypes,\n                                        ctx));\n\n  VLOG(2) << DumpGraphToFile(\"before_optimize_tpu_input_output_tensors\", *graph,\n                             flib_def_.get());\n\n  if (runtime_params_.minimum_output_tensors_packing > 1) {\n    // Copy graph to shape_inference_graph\n    EdgeShapes tpu_output_shapes;\n    TF_RETURN_IF_ERROR(\n        InferShapesWithResourceVar(graph, ctx, arg_shapes, &tpu_inferred_info));\n\n    // Find TPU -> CPU output edges.\n    GroupedEdges shape_to_output =\n        tpu_functional_internal::GroupTensorsForOutputPacking(\n            graph, tpu_output_shapes, &tpu_inferred_info);\n\n    TF_RETURN_IF_ERROR(\n        tpu_functional_internal::CreateConcatAndSplitNodesForOutputTensor(\n            graph, cluster_name, &tpu_output_shapes, &tpu_inferred_info,\n            shape_to_output, runtime_params_.minimum_output_tensors_packing));\n  }\n\n  if (runtime_params_.minimum_input_tensors_packing > 1) {\n    GroupedEdges grouped_input_edges =\n        tpu_functional_internal::GroupTensorsForInputPacking(\n            tpu_input_shapes, tpu_input_dtypes, runtime_params_.input_shape_opt,\n            runtime_params_.group_tensors_for_packing);\n    TF_RETURN_IF_ERROR(\n        tpu_functional_internal::CreateConcatAndSplitNodesForInputTensor(\n            graph, cluster_name, &tpu_input_shapes, grouped_input_edges,\n            runtime_params_.minimum_input_tensors_packing,\n            xla_spmd_input_sharded, xla_sharding_ops,\n            tpu_replicated_input_ops));\n  }\n  if (runtime_params_.input_shape_opt) {\n    TF_RETURN_IF_ERROR(tpu_functional_internal::InsertReshapeNodePairs(\n        graph, cluster_name, &tpu_input_shapes, num_cores_per_replica));\n  }\n  VLOG(1) << DumpGraphToFile(\"optim_result\", *graph);\n\n  // With or without optimizations, collect the input names and shapes.\n  for (const auto& iter : tpu_input_shapes) {\n    std::string name = iter.first->src()->name();\n    named_input_shapes[name] = iter.second;\n  }\n  return OkStatus();\n}\n\nStatus TPUPartitionedCallOp::GetGraphFromFunction(\n    Graph* graph, int device_ordinal, bool* use_spmd_for_xla_partitioning,\n    TPUMetadata* tpu_metadata) {\n  FunctionLibraryRuntime::InstantiateOptions opts;\n  FHandle handle;\n  TF_RETURN_IF_ERROR(library_runtime_->Instantiate(\n      func_.name(), AttrSlice(&func_.attr()), opts, &handle));\n  const FunctionBody* fbody = library_runtime_->GetFunctionBody(handle);\n  if (fbody == nullptr) {\n    return errors::Internal(\"Could not find handle \", handle);\n  }\n  CopyGraph(*fbody->graph, graph);\n\n  // Pin the inputs and outputs to the local device to simplify the\n  // function-dispatching logic.\n  local_device_name_ = library_runtime_->device()->name();\n  replaced_input_indices_.resize(fbody->arg_nodes.size(), false);\n  for (Node* node : graph->op_nodes()) {\n    if (node->IsArg() || node->IsRetval()) {\n      node->set_assigned_device_name(local_device_name_);\n    } else if (node->type_string() == \"TPUReplicateMetadata\") {\n      // Record the producer name so it can be accessed later during metric\n      // collection.\n      string producer_name = GetProducerName(func_.name());\n      node->AddAttr(\"_producer_name\", producer_name);\n\n      TF_RETURN_IF_ERROR(GetNodeAttr(node->attrs(), \"num_cores_per_replica\",\n                                     &tpu_metadata->num_cores_per_replica));\n      TF_RETURN_IF_ERROR(GetNodeAttr(node->attrs(),\n                                     \"use_spmd_for_xla_partitioning\",\n                                     use_spmd_for_xla_partitioning));\n      VLOG(1) << \"num_core_per_replica = \"\n              << tpu_metadata->num_cores_per_replica\n              << \", use_spmd_for_xla_partitioning = \"\n              << *use_spmd_for_xla_partitioning;\n\n      if (tpu_metadata->num_cores_per_replica > 1) {\n        int num_replicas;\n        TF_RETURN_IF_ERROR(\n            GetNodeAttr(node->attrs(), \"num_replicas\", &num_replicas));\n        if (num_replicas > 1) {\n          return errors::InvalidArgument(\n              \"num_replicas shouldn't be large than 1, however it is: \",\n              num_replicas);\n        }\n\n        TF_RETURN_IF_ERROR(GetNodeAttr(node->attrs(), \"device_assignment\",\n                                       &tpu_metadata->device_assignment));\n\n        if (!tpu_metadata->device_assignment.empty() && device_ordinal > 0) {\n          return errors::InvalidArgument(\n              \"`device_assignment` shouldn't be set manually in the graph when \"\n              \"round-robin core selection is enabled.\");\n        }\n\n        tpu_metadata->topology = GetTPUTopology();\n        VLOG(1) << \"TPU topology: \" << tpu_metadata->topology.DebugString();\n        std::string topology_str;\n        TF_RETURN_IF_ERROR(\n            GetNodeAttr(node->attrs(), \"topology\", &topology_str));\n        if (!topology_str.empty()) {\n          LOG(WARNING)\n              << \"Ignore the `topology` value set in TPUReplicateMetadata \"\n                 \"node, the TPU topology is queried in the runtime.\";\n        }\n        node->ClearAttr(\"topology\");\n        node->AddAttr(\"topology\", tpu_metadata->topology.SerializeAsString());\n\n        if (tpu_metadata->topology.num_tasks() > 1) {\n          return errors::InvalidArgument(\n              \"TPUPartitionedCallOp is only supported in single-host setup, \"\n              \"however num_task is: \",\n              tpu_metadata->topology.num_tasks());\n        }\n\n        if (tpu_metadata->device_assignment.empty()) {\n          VLOG(1) << \"Auto assigning device assignment\";\n\n          // The auto generated device assignment should be the same as or a\n          // slice of TPU topology device_coordinates. This guarantees the\n          // logical device IDs order the same as the physical device IDs order.\n          // It is important for round-robin core selection, as we assume\n          // the TPU device group for one inference request is\n          // [TPU:device_ordinal, TPU:device_ordinal + num_cores_per_replica].\n\n          auto coordinates_start =\n              tpu_metadata->topology.device_coordinates().begin() +\n              device_ordinal * 4;\n          auto coordinates_end =\n              tpu_metadata->topology.device_coordinates().begin() +\n              (device_ordinal + tpu_metadata->num_cores_per_replica) * 4;\n\n          node->ClearAttr(\"device_assignment\");\n          tpu_metadata->device_assignment.insert(\n              tpu_metadata->device_assignment.begin(), coordinates_start,\n              coordinates_end);\n          node->AddAttr(\"device_assignment\", tpu_metadata->device_assignment);\n        }\n\n        if (tpu_metadata->topology.num_tpu_devices_per_task() <\n            tpu_metadata->num_cores_per_replica) {\n          return errors::InvalidArgument(\n              \"num_cores_per_replica: \", tpu_metadata->num_cores_per_replica,\n              \" in the graph is larger than the number of available TPU \"\n              \"devices: \",\n              tpu_metadata->topology.num_tpu_devices_per_task());\n        }\n      }\n    }\n  }\n  return OkStatus();\n}\n\nStatus TPUPartitionedCallOp::PlacementHelper(\n    const DeviceSet& device_set,\n    const GraphOptimizationPassOptions& optimization_options,\n    const string& function_name) {\n  TF_RETURN_IF_ERROR(OptimizationPassRegistry::Global()->RunGrouping(\n      OptimizationPassRegistry::PRE_PLACEMENT, optimization_options));\n  Placer placer(optimization_options.graph->get(), function_name,\n                optimization_options.flib_def, &device_set);\n  TF_RETURN_IF_ERROR(placer.Run());\n  TF_RETURN_IF_ERROR(OptimizationPassRegistry::Global()->RunGrouping(\n      OptimizationPassRegistry::POST_PLACEMENT, optimization_options));\n  TF_RETURN_IF_ERROR(OptimizationPassRegistry::Global()->RunGrouping(\n      OptimizationPassRegistry::POST_REWRITE_FOR_EXEC, optimization_options));\n  return OkStatus();\n}\n\nStatus TPUPartitionedCallOp::PartitionHelper(\n    const DeviceSet& device_set,\n    const GraphOptimizationPassOptions& optimization_options, Graph* graph,\n    std::unordered_map<std::string, std::unique_ptr<Graph>>* subgraphs) {\n  PartitionOptions partition_options;\n  partition_options.node_to_loc = [](const Node* node) {\n    // TODO(akshayka): To better support the distributed case, first split\n    // the graph by worker (e.g,. using the master session's\n    // `SplitByWorker` policy), and then recursively partition the\n    // per-worker shards at the remote worker(s).\n    return node->assigned_device_name();\n  };\n  int64_t edge_name_counter = 0;\n  partition_options.new_name = [&edge_name_counter](const string& prefix) {\n    return strings::StrCat(prefix, \"/_\", ++edge_name_counter);\n  };\n  partition_options.get_incarnation = [&device_set](const string& name) {\n    const Device* d = device_set.FindDeviceByName(name);\n    if (d == nullptr) {\n      return PartitionOptions::kIllegalIncarnation;\n    } else {\n      return d->attributes().incarnation();\n    }\n  };\n  partition_options.control_flow_added = false;\n  std::unordered_map<std::string, GraphDef> partitions;\n  TF_RETURN_IF_ERROR(Partition(partition_options, graph, &partitions));\n\n  VLOG(3) << \"Partitioned function '\" << func_.name() << \"', yielding \"\n          << partitions.size() << \" shards.\";\n\n  const FunctionLibraryDefinition* flib_def = &graph->flib_def();\n  for (auto& partition : partitions) {\n    std::unique_ptr<Graph> subgraph(new Graph(flib_def));\n    GraphConstructorOptions opts;\n    opts.allow_internal_ops = true;\n    opts.expect_device_spec = true;\n    const string& device = partition.first;\n    GraphDef& graph_def = partition.second;\n    TF_RETURN_IF_ERROR(\n        ConvertGraphDefToGraph(opts, std::move(graph_def), subgraph.get()));\n    subgraphs->emplace(device, std::move(subgraph));\n  }\n\n  TF_RETURN_IF_ERROR(OptimizationPassRegistry::Global()->RunGrouping(\n      OptimizationPassRegistry::POST_PARTITIONING, optimization_options));\n\n  return OkStatus();\n}\n\nStatus TPUPartitionedCallOp::InstantiatePartition(\n    const Graph& graph, const string& function_name,\n    const string& target_device, FHandle* handle,\n    std::unique_ptr<FunctionLibraryDefinition>* out_flib_def) {\n  FunctionDef shard;\n  TF_RETURN_IF_ERROR(GraphToFunctionDef(graph, function_name, &shard));\n  TF_RETURN_IF_ERROR(flib_def_->AddFunctionDef(shard));\n  FunctionLibraryRuntime::InstantiateOptions opts;\n  opts.target = target_device;\n  if (out_flib_def) {\n    *out_flib_def = std::make_unique<FunctionLibraryDefinition>(*flib_def_);\n    opts.lib_def = out_flib_def->get();\n  } else {\n    opts.lib_def = flib_def_.get();\n  }\n  return library_runtime_->Instantiate(function_name, AttrSlice(&shard.attr()),\n                                       opts, handle);\n}\n\nStatus TPUPartitionedCallOp::SetDeviceOrdinal(const DeviceSet& device_set,\n                                              int device_ordinal, Graph* graph,\n                                              bool* modified) {\n  int ordinal = -1;\n  for (Node* node : graph->op_nodes()) {\n    if (node->type_string() == kVarHandleOp) {\n      if (IsInputToTPUReplicate(node)) {\n        // If this VarHandleOp is going to a TPU computation,\n        // it refers to the TPU variable that we created when replacing the\n        // resource arguments with VarHandleOps.\n        node->set_assigned_device_name(\n            strings::StrCat(kTPUDeviceNamePrefix, device_ordinal));\n      }\n      continue;\n    }\n    if (HasNodeAttr(node->def(), kXlaHasHostTransferAttrName)) {\n      // Outside compilation related node.\n      TF_RETURN_IF_ERROR(\n          SetDeviceOrdinalAttributeForNode(node, device_ordinal));\n      *modified = true;\n      continue;\n    }\n    const AttrValue* attr = node->attrs().Find(kDeviceOrdinalAttr);\n    if (attr != nullptr) {\n      if (!IsSupportedTPUOp(node->type_string())) {\n        return errors::InvalidArgument(\"Node \", node->type_string(),\n                                       \" is not yet supported.\");\n      }\n      if (ordinal == -1) {\n        ordinal = attr->i();\n      } else {\n        if (ordinal != attr->i()) {\n          return errors::InvalidArgument(\n              \"Can only partition graphs that use a single device ordinal.\");\n        }\n      }\n      node->ClearAttr(kDeviceOrdinalAttr);\n      node->AddAttr(kDeviceOrdinalAttr, device_ordinal);\n      VLOG(3) << \"Set device ordinal of \" << node->type_string() << \" to \"\n              << device_ordinal;\n      *modified = true;\n    }\n    if (node->IsSend() || node->IsRecv()) {\n      static const char* kSendDevice = \"send_device\";\n      static const char* kSendDeviceIncarnation = \"send_device_incarnation\";\n      static const char* kRecvDevice = \"recv_device\";\n      const AttrValue* attr = node->attrs().Find(kSendDevice);\n      if (attr != nullptr) {\n        string device = attr->s();\n        TF_RETURN_IF_ERROR(\n            UpdateTPUDeviceOrdinal(device_ordinal, &device, modified));\n        node->ClearAttr(kSendDevice);\n        node->AddAttr(kSendDevice, device);\n        node->ClearAttr(kSendDeviceIncarnation);\n        const Device* d = device_set.FindDeviceByName(device);\n        int64_t send_incarnation = (d == nullptr)\n                                       ? PartitionOptions::kIllegalIncarnation\n                                       : d->attributes().incarnation();\n        node->AddAttr(kSendDeviceIncarnation, send_incarnation);\n      }\n      attr = node->attrs().Find(kRecvDevice);\n      if (attr != nullptr) {\n        string device = attr->s();\n        TF_RETURN_IF_ERROR(\n            UpdateTPUDeviceOrdinal(device_ordinal, &device, modified));\n        node->ClearAttr(kRecvDevice);\n        node->AddAttr(kRecvDevice, device);\n      }\n    }\n  }\n  return OkStatus();\n}\n\nStatus TPUPartitionedCallOp::InstantiateFunctionsFromSubgraphs(\n    const DeviceSet& device_set, int replica_id, uint64 cache_hash,\n    int num_cores_per_replica,\n    std::unordered_map<std::string, std::unique_ptr<Graph>> subgraphs) {\n  const Device* reference_device = nullptr;\n  auto entry =\n      partition_cache_.emplace(cache_hash, std::vector<DeviceAndFHandle>());\n\n  bool rewritten = false;\n  for (auto& pair : subgraphs) {\n    string target = pair.first;\n    int device_ordinal = replica_id;\n    if (num_cores_per_replica > 1) {\n      DeviceNameUtils::ParsedName parsed_device;\n      if (!DeviceNameUtils::ParseFullName(target, &parsed_device)) {\n        return errors::InvalidArgument(\"Malformed assigned device '\", target,\n                                       \"'\");\n      }\n      device_ordinal = parsed_device.id;\n    }\n    Device* device;\n    TF_RETURN_IF_ERROR(\n        library_runtime_->device_mgr()->LookupDevice(target, &device));\n    if (reference_device == nullptr) {\n      reference_device = device;\n    } else {\n      if (!DeviceNameUtils::IsSameAddressSpace(\n              device->parsed_name(), reference_device->parsed_name())) {\n        return errors::InvalidArgument(\n            \"TPUPartitionedCallOp does not yet support inter-process\"\n            \"execution.\");\n      }\n    }\n    TF_RETURN_IF_ERROR(device->MaybeRewriteGraph(&pair.second));\n    Graph* subgraph = pair.second.get();\n    // For model paralleism inference, we only support num_replica == 1, thus\n    // there is no need to update the device_ordinal anymore.\n    if (num_cores_per_replica == 1) {\n      TF_RETURN_IF_ERROR(\n          SetDeviceOrdinal(device_set, device_ordinal, subgraph, &rewritten));\n    } else {\n      VLOG(1) << \"Skip SetDeviceOrdinal()\";\n    }\n    string function_name = flib_def_->UniqueFunctionName(\n        strings::StrCat(func_.name(), \"_hash_\", cache_hash));\n    TF_RETURN_IF_ERROR(\n        UpdateTPUDeviceOrdinal(device_ordinal, &target, &rewritten));\n    FHandle handle;\n    // Use a copy of the current `flib_def_` to instantiate the function to\n    // avoid races.\n    std::unique_ptr<FunctionLibraryDefinition> sub_flib_def;\n    TF_RETURN_IF_ERROR(InstantiatePartition(*subgraph, function_name, target,\n                                            &handle, &sub_flib_def));\n    // Add handle to the cache entry.\n    entry.first->second.push_back(\n        DeviceAndFHandle{.device = target,\n                         .handle = handle,\n                         .flib_def = std::move(sub_flib_def)});\n  }\n\n  if (!rewritten) {\n    // For regular use cases, TPUPartitionedCallOp only works when the\n    // function being called in rewritten for TPU. If we don't see any signs\n    // of this rewriting, warn the user about it.\n    // We don't raise an error because we want to support the use case of\n    // running tpu.initialize_system eagerly. In this case, we can't use\n    // tpu.rewrite because it will add compilation ops that require TPU\n    // to be initialized, i.e. there is a chicken and egg problem.\n    // We run tpu.initialize_system through TPUPartitionedCallOp because it\n    // invokes graph rewrite passes that are necessary for initialization to\n    // work.\n    LOG(INFO) << \"Function body was not rewritten for TPU. \"\n              << \"This is probably a bug unless you are initializing \"\n              << \"TPUs eagerly.\";\n  }\n  return OkStatus();\n}\n\nvoid TPUPartitionedCallOp::ExecuteRemoteFunction(\n    const FunctionLibraryRuntime::Options& opts, FHandle handle,\n    OpKernelContext* ctx, ReffedStatusCallback* done) {\n  std::vector<Tensor> dummy_args;\n  std::vector<Tensor>* dummy_rets = new std::vector<Tensor>;\n\n  profiler::TraceMe trace_me(\"TPUPartitionedCallOp-ExecuteRemote\");\n  library_runtime_->Run(opts, handle, dummy_args, dummy_rets,\n                        [dummy_rets, done, ctx](const Status& status) {\n                          if (!status.ok()) {\n                            done->UpdateStatus(status);\n                          }\n                          delete dummy_rets;\n                          done->Unref();\n                        });\n}\n\nvoid TPUPartitionedCallOp::ExecuteLocalFunction(\n    const FunctionLibraryRuntime::Options& opts, const OpInputList& arguments,\n    FHandle handle, OpKernelContext* ctx, ReffedStatusCallback* done) {\n  std::vector<Tensor> args;\n\n  for (int i = 0; i < arguments.size(); ++i) {\n    if (!replaced_input_indices_[i]) {\n      // _Arg nodes of type DT_RESOURCE that go into a TPU node have been\n      // replaced by TPU VarHandleOp nodes. No longer need to pass them as\n      // inputs.\n      args.push_back(arguments[i]);\n    }\n  }\n  auto* rets = new std::vector<Tensor>;\n\n  profiler::TraceMe trace_me(\"TPUPartitionedCallOp-ExecuteLocal\");\n  library_runtime_->Run(opts, handle, args, rets,\n                        [rets, done, ctx](const Status& status) {\n                          if (!status.ok()) {\n                            done->UpdateStatus(status);\n                          } else {\n                            for (int i = 0; i < rets->size(); ++i) {\n                              ctx->set_output(i, (*rets)[i]);\n                            }\n                          }\n                          delete rets;\n                          done->Unref();\n                        });\n}\n\nvoid TPUPartitionedCallOp::ExecuteFunctions(\n    const std::vector<DeviceAndFHandle>& functions, OpKernelContext* ctx,\n    int device_ordinal, int64_t ordinal_selector_req_id, DoneCallback done) {\n  profiler::TraceMe trace_me(\"TPUPartitionedCallOp-ExecuteFunctions\");\n  FunctionLibraryRuntime::Options opts;\n  opts.step_container = ctx->step_container();\n  opts.stats_collector = ctx->stats_collector();\n  // TODO(akshayka): Consider selecting a runner on a per-device basis,\n  // i.e., using device-specific threadpools when available.\n  opts.runner = ctx->runner();\n  opts.source_device = local_device_name_;\n  opts.run_all_kernels_inline = ctx->run_all_kernels_inline();\n\n  OpInputList arguments;\n  OP_REQUIRES_OK_ASYNC(ctx, ctx->input_list(\"args\", &arguments), done);\n\n  auto* local_cm = new CancellationManager(ctx->cancellation_manager());\n  auto* rendez = new RefCountedIntraProcessRendezvous(device_mgr_);\n  opts.cancellation_manager = local_cm;\n  opts.rendezvous = rendez;\n\n  StatusCallback callback(\n      [rendez = rendez, local_cm, done = std::move(done),\n       device_ordinal = device_ordinal, req_id = ordinal_selector_req_id, ctx,\n       ordinal_selector = ordinal_selector_](const Status& status) {\n        delete local_cm;\n        rendez->Unref();\n        if (!status.ok()) {\n          ctx->SetStatus(status);\n        }\n        done();\n        if (req_id >= 0) {\n          ordinal_selector->DequeueFromCoreSelector(device_ordinal, req_id);\n        }\n      });\n\n  auto* refcounted_done = new ReffedStatusCallback(std::move(callback));\n  for (int i = 1; i < functions.size(); ++i) {\n    refcounted_done->Ref();\n  }\n  for (const DeviceAndFHandle& entry : functions) {\n    const string& target_device = entry.device;\n    FHandle handle = entry.handle;\n    VLOG(3) << \"Running function shard on device \" << target_device\n            << \" with local device name \" << local_device_name_;\n    if (target_device == local_device_name_) {\n      opts.remote_execution = false;\n      ExecuteLocalFunction(opts, arguments, handle, ctx, refcounted_done);\n    } else {\n      opts.remote_execution = true;\n      ExecuteRemoteFunction(opts, handle, ctx, refcounted_done);\n    }\n  }\n}\n\nREGISTER_KERNEL_BUILDER(Name(\"TPUPartitionedCall\").Device(DEVICE_CPU),\n                        TPUPartitionedCallOp);\n\n}  // end namespace tensorflow"