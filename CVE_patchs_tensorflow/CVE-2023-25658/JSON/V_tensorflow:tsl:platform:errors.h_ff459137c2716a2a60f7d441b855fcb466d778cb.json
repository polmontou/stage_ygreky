"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_TSL_PLATFORM_ERRORS_H_\n#define TENSORFLOW_TSL_PLATFORM_ERRORS_H_\n\n#include <sstream>\n#include <string>\n#include <utility>\n\n#include \"absl/base/attributes.h\"\n#include \"absl/strings/str_join.h\"\n#include \"tensorflow/tsl/platform/logging.h\"\n#include \"tensorflow/tsl/platform/macros.h\"\n#include \"tensorflow/tsl/platform/status.h\"\n#include \"tensorflow/tsl/platform/str_util.h\"\n#include \"tensorflow/tsl/platform/strcat.h\"\n\nnamespace tsl {\nnamespace error {\n// NOLINTBEGIN(misc-unused-using-decls)\n// TODO(aminim): figure out the protobuf migration story.\nusing tensorflow::error::ABORTED;\nusing tensorflow::error::ALREADY_EXISTS;\nusing tensorflow::error::CANCELLED;\nusing tensorflow::error::Code;\nusing tensorflow::error::DATA_LOSS;\nusing tensorflow::error::DEADLINE_EXCEEDED;\nusing tensorflow::error::FAILED_PRECONDITION;\nusing tensorflow::error::INTERNAL;\nusing tensorflow::error::INVALID_ARGUMENT;\nusing tensorflow::error::NOT_FOUND;\nusing tensorflow::error::OK;\nusing tensorflow::error::OUT_OF_RANGE;\nusing tensorflow::error::PERMISSION_DENIED;\nusing tensorflow::error::RESOURCE_EXHAUSTED;\nusing tensorflow::error::UNAUTHENTICATED;\nusing tensorflow::error::UNAVAILABLE;\nusing tensorflow::error::UNIMPLEMENTED;\nusing tensorflow::error::UNKNOWN;\n// NOLINTEND(misc-unused-using-decls)\n}  // namespace error\n\nnamespace errors {\n\nnamespace internal {\n\n// The DECLARE_ERROR macro below only supports types that can be converted\n// into StrCat's AlphaNum. For the other types we rely on a slower path\n// through std::stringstream. To add support of a new type, it is enough to\n// make sure there is an operator<<() for it:\n//\n//   std::ostream& operator<<(std::ostream& os, const MyType& foo) {\n//     os << foo.ToString();\n//     return os;\n//   }\n// Eventually absl::strings will have native support for this and we will be\n// able to completely remove PrepareForStrCat().\ntemplate <typename T>\ntypename std::enable_if<!std::is_convertible<T, strings::AlphaNum>::value,\n                        std::string>::type\nPrepareForStrCat(const T& t) {\n  std::stringstream ss;\n  ss << t;\n  return ss.str();\n}\ninline const strings::AlphaNum& PrepareForStrCat(const strings::AlphaNum& a) {\n  return a;\n}\n\n}  // namespace internal\n\n// Maps UNIX errors into a Status.\nStatus IOError(const string& context, int err_number);\n\n// Returns all payloads from a Status as a key-value map.\ninline std::unordered_map<std::string, std::string> GetPayloads(\n    const ::tsl::Status& status) {\n  std::unordered_map<std::string, std::string> payloads;\n  status.ForEachPayload(\n      [&payloads](tsl::StringPiece key, tsl::StringPiece value) {\n        payloads[std::string(key)] = std::string(value);\n      });\n  return payloads;\n}\n\n// Inserts all given payloads into the given status. Will overwrite existing\n// payloads if they exist with the same key.\ninline void InsertPayloads(\n    ::tsl::Status& status,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  for (const auto& payload : payloads) {\n    status.SetPayload(payload.first, payload.second);\n  }\n}\n\n// Copies all payloads from one Status to another. Will overwrite existing\n// payloads in the destination if they exist with the same key.\ninline void CopyPayloads(const ::tsl::Status& from, ::tsl::Status& to) {\n  from.ForEachPayload([&to](tsl::StringPiece key, tsl::StringPiece value) {\n    to.SetPayload(key, value);\n  });\n}\n\n// Creates a new status with the given code, message and payloads.\ninline ::tsl::Status Create(\n    Code code, ::tsl::StringPiece message,\n    const std::unordered_map<std::string, std::string>& payloads,\n    SourceLocation loc = SourceLocation::current()) {\n  Status status(code, message, loc);\n  InsertPayloads(status, payloads);\n  return status;\n}\n\n// Returns a new Status, replacing its message with the given.\ninline ::tsl::Status CreateWithUpdatedMessage(const ::tsl::Status& status,\n                                              ::tsl::StringPiece message) {\n  return Create(status.code(), message, GetPayloads(status));\n}\n\n// Append some context to an error message.  Each time we append\n// context put it on a new line, since it is possible for there\n// to be several layers of additional context.\ntemplate <typename... Args>\nvoid AppendToMessage(::tsl::Status* status, Args... args) {\n  auto new_status = ::tsl::Status(\n      status->code(),\n      ::tsl::strings::StrCat(status->error_message(), \"\\n\\t\", args...));\n  CopyPayloads(*status, new_status);\n  *status = std::move(new_status);\n}\n\n// For propagating errors when calling a function.\n#define TF_RETURN_IF_ERROR(...)                          \\\n  do {                                                   \\\n    ::tsl::Status _status = (__VA_ARGS__);               \\\n    if (TF_PREDICT_FALSE(!_status.ok())) return _status; \\\n  } while (0)\n\n#define TF_RETURN_WITH_CONTEXT_IF_ERROR(expr, ...)           \\\n  do {                                                       \\\n    ::tsl::Status _status = (expr);                          \\\n    if (TF_PREDICT_FALSE(!_status.ok())) {                   \\\n      ::tsl::errors::AppendToMessage(&_status, __VA_ARGS__); \\\n      return _status;                                        \\\n    }                                                        \\\n  } while (0)\n\n// Convenience functions for generating and using error status.\n// Example usage:\n//   status.Update(errors::InvalidArgument(\"The \", foo, \" isn't right.\"));\n//   if (errors::IsInvalidArgument(status)) { ... }\n//   switch (status.code()) { case error::INVALID_ARGUMENT: ... }\n\n// CANCELLED\ntemplate <typename... Args>\n::tsl::Status Cancelled(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::CANCELLED,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status CancelledWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::CANCELLED, message, payloads);\n}\n\n// InvalidArgument\ntemplate <typename... Args>\n::tsl::Status InvalidArgument(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::INVALID_ARGUMENT,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\n// Specialized overloads to capture source location for up to three arguments.\ntemplate <typename Arg1, typename Arg2, typename Arg3>\n::tsl::Status InvalidArgument(Arg1 arg1, Arg2 arg2, Arg3 arg3,\n                              SourceLocation loc = SourceLocation::current()) {\n  return ::tsl::Status(\n      ::tsl::error::Code::INVALID_ARGUMENT,\n      ::tsl::strings::StrCat(::tsl::errors::internal::PrepareForStrCat(arg1),\n                             ::tsl::errors::internal::PrepareForStrCat(arg2),\n                             ::tsl::errors::internal::PrepareForStrCat(arg3)),\n      loc);\n}\ntemplate <typename Arg1, typename Arg2>\n::tsl::Status InvalidArgument(Arg1 arg1, Arg2 arg2,\n                              SourceLocation loc = SourceLocation::current()) {\n  return ::tsl::Status(\n      ::tsl::error::Code::INVALID_ARGUMENT,\n      ::tsl::strings::StrCat(::tsl::errors::internal::PrepareForStrCat(arg1),\n                             ::tsl::errors::internal::PrepareForStrCat(arg2)),\n      loc);\n}\ntemplate <typename Arg1>\n::tsl::Status InvalidArgument(Arg1 arg1,\n                              SourceLocation loc = SourceLocation::current()) {\n  return ::tsl::Status(\n      ::tsl::error::Code::INVALID_ARGUMENT,\n      ::tsl::strings::StrCat(::tsl::errors::internal::PrepareForStrCat(arg1)),\n      loc);\n}\ntemplate <typename... Args>\n::tsl::Status InvalidArgumentWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads,\n    SourceLocation loc = SourceLocation::current()) {\n  return errors::Create(::tsl::error::Code::INVALID_ARGUMENT, message, payloads,\n                        loc);\n}\n\n// NotFound\ntemplate <typename... Args>\n::tsl::Status NotFound(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::NOT_FOUND,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\n// Specialized overloads to capture source location for up to three arguments.\ntemplate <typename Arg1, typename Arg2, typename Arg3>\n::tsl::Status NotFound(Arg1 arg1, Arg2 arg2, Arg3 arg3,\n                       SourceLocation loc = SourceLocation::current()) {\n  return ::tsl::Status(\n      ::tsl::error::Code::NOT_FOUND,\n      ::tsl::strings::StrCat(::tsl::errors::internal::PrepareForStrCat(arg1),\n                             ::tsl::errors::internal::PrepareForStrCat(arg2),\n                             ::tsl::errors::internal::PrepareForStrCat(arg3)),\n      loc);\n}\ntemplate <typename Arg1, typename Arg2>\n::tsl::Status NotFound(Arg1 arg1, Arg2 arg2,\n                       SourceLocation loc = SourceLocation::current()) {\n  return ::tsl::Status(\n      ::tsl::error::Code::NOT_FOUND,\n      ::tsl::strings::StrCat(::tsl::errors::internal::PrepareForStrCat(arg1),\n                             ::tsl::errors::internal::PrepareForStrCat(arg2)),\n      loc);\n}\ntemplate <typename Arg1>\n::tsl::Status NotFound(Arg1 arg1,\n                       SourceLocation loc = SourceLocation::current()) {\n  return ::tsl::Status(\n      ::tsl::error::Code::NOT_FOUND,\n      ::tsl::strings::StrCat(::tsl::errors::internal::PrepareForStrCat(arg1)),\n      loc);\n}\ntemplate <typename... Args>\n::tsl::Status NotFoundWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads,\n    SourceLocation loc = SourceLocation::current()) {\n  return errors::Create(::tsl::error::Code::NOT_FOUND, message, payloads, loc);\n}\n\n// AlreadyExists\ntemplate <typename... Args>\n::tsl::Status AlreadyExists(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::ALREADY_EXISTS,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status AlreadyExistsWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::ALREADY_EXISTS, message, payloads);\n}\n\n// ResourceExhausted\ntemplate <typename... Args>\n::tsl::Status ResourceExhausted(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::RESOURCE_EXHAUSTED,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status ResourceExhaustedWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::RESOURCE_EXHAUSTED, message,\n                        payloads);\n}\n\n// Unavailable\ntemplate <typename... Args>\n::tsl::Status Unavailable(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::UNAVAILABLE,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status UnavailableWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::UNAVAILABLE, message, payloads);\n}\n\n// FailedPrecondition\ntemplate <typename... Args>\n::tsl::Status FailedPrecondition(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::FAILED_PRECONDITION,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status FailedPreconditionWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::FAILED_PRECONDITION, message,\n                        payloads);\n}\n\n// OutOfRange\ntemplate <typename... Args>\n::tsl::Status OutOfRange(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::OUT_OF_RANGE,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status OutOfRangeWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::OUT_OF_RANGE, message, payloads);\n}\n\n// Unimplemented\ntemplate <typename... Args>\n::tsl::Status Unimplemented(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::UNIMPLEMENTED,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status UnimplementedWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::UNIMPLEMENTED, message, payloads);\n}\n\n// Internal\ntemplate <typename... Args>\n::tsl::Status Internal(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::INTERNAL,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status InternalWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::INTERNAL, message, payloads);\n}\n\n// Aborted\ntemplate <typename... Args>\n::tsl::Status Aborted(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::ABORTED,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status AbortedWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::ABORTED, message, payloads);\n}\n\n// DeadlineExceeded\ntemplate <typename... Args>\n::tsl::Status DeadlineExceeded(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::DEADLINE_EXCEEDED,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status DeadlineExceededWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::DEADLINE_EXCEEDED, message,\n                        payloads);\n}\n\n// DataLoss\ntemplate <typename... Args>\n::tsl::Status DataLoss(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::DATA_LOSS,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status DataLossWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::DATA_LOSS, message, payloads);\n}\n\n// Unknown\ntemplate <typename... Args>\n::tsl::Status Unknown(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::UNKNOWN,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status UnknownPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::UNKNOWN, message, payloads);\n}\n// PermissionDenied\ntemplate <typename... Args>\n::tsl::Status PermissionDenied(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::PERMISSION_DENIED,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status PermissionDeniedWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::PERMISSION_DENIED, message,\n                        payloads);\n}\n\n// Unauthenticated\ntemplate <typename... Args>\n::tsl::Status Unauthenticated(Args... args) {\n  return ::tsl::Status(::tsl::error::Code::UNAUTHENTICATED,\n                       ::tsl::strings::StrCat(\n                           ::tsl::errors::internal::PrepareForStrCat(args)...));\n}\ntemplate <typename... Args>\n::tsl::Status UnauthenticatedWithPayloads(\n    const ::tsl::StringPiece& message,\n    const std::unordered_map<std::string, std::string>& payloads) {\n  return errors::Create(::tsl::error::Code::UNAUTHENTICATED, message, payloads);\n}\n\nbool IsAborted(const Status& status);\nbool IsAlreadyExists(const Status& status);\nbool IsCancelled(const Status& status);\nbool IsDataLoss(const Status& status);\nbool IsDeadlineExceeded(const Status& status);\nbool IsFailedPrecondition(const Status& status);\nbool IsInternal(const Status& status);\nbool IsInvalidArgument(const Status& status);\nbool IsNotFound(const Status& status);\nbool IsOutOfRange(const Status& status);\nbool IsPermissionDenied(const Status& status);\nbool IsResourceExhausted(const Status& status);\nbool IsUnauthenticated(const Status& status);\nbool IsUnavailable(const Status& status);\nbool IsUnimplemented(const Status& status);\nbool IsUnknown(const Status& status);\n\n// Produces a formatted string pattern from the name which can uniquely identify\n// this node upstream to produce an informative error message. The pattern\n// followed is: {{node <name>}}\n// Note: The pattern below determines the regex _NODEDEF_NAME_RE in the file\n// tensorflow/python/client/session.py\n// LINT.IfChange\ninline std::string FormatNodeNameForError(const std::string& name) {\n  return strings::StrCat(\"{{node \", name, \"}}\");\n}\n// LINT.ThenChange(//tensorflow/python/client/session.py)\ntemplate <typename T>\nstd::string FormatNodeNamesForError(const T& names) {\n  return absl::StrJoin(\n      names, \", \", [](std::string* output, const std::string& s) {\n        ::tsl::strings::StrAppend(output, FormatNodeNameForError(s));\n      });\n}\n// LINT.IfChange\ninline std::string FormatColocationNodeForError(const std::string& name) {\n  return strings::StrCat(\"{{colocation_node \", name, \"}}\");\n}\n// LINT.ThenChange(//tensorflow/python/framework/error_interpolation.py)\ntemplate <typename T>\nstd::string FormatColocationNodeForError(const T& names) {\n  return absl::StrJoin(\n      names, \", \", [](std::string* output, const std::string& s) {\n        ::tsl::strings::StrAppend(output, FormatColocationNodeForError(s));\n      });\n}\n\ninline std::string FormatFunctionForError(const std::string& name) {\n  return strings::StrCat(\"{{function_node \", name, \"}}\");\n}\n\ninline Status ReplaceErrorFromNonCommunicationOps(const Status s,\n                                                  const std::string& op_name) {\n  assert(::tsl::errors::IsUnavailable(s));\n  return Status(\n      error::Code::INTERNAL,\n      strings::StrCat(\n          s.error_message(), \"\\nExecuting non-communication op <\", op_name,\n          \"> originally returned UnavailableError, and was replaced by \"\n          \"InternalError to avoid invoking TF network error handling logic.\"));\n}\n\ntemplate <typename T>\nstd::string FormatOriginalNodeLocationForError(const T& node_names,\n                                               const T& func_names) {\n  std::vector<std::string> error_message;\n  for (int i = 0; i != node_names.size(); ++i) {\n    if (i != 0) {\n      error_message.push_back(\", \");\n    }\n    if (i < func_names.size()) {\n      error_message.push_back(FormatFunctionForError(func_names[i]));\n    }\n    error_message.push_back(FormatNodeNameForError(node_names[i]));\n  }\n  return absl::StrJoin(error_message, \"\");\n}\n\n// The CanonicalCode() for non-errors.\nusing ::tsl::error::OK;  // NOLINT\n\n}  // namespace errors\n}  // namespace tsl\n\n#endif  // TENSORFLOW_TSL_PLATFORM_ERRORS_H_"