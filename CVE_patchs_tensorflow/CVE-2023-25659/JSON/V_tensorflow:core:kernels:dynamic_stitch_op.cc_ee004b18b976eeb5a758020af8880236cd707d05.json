"/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/data_flow_ops.cc.\n\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/gpu_device_array.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\ntypedef Eigen::GpuDevice GPUDevice;\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <class T>\nclass DynamicStitchOpImplBase : public OpKernel {\n public:\n  explicit DynamicStitchOpImplBase(OpKernelConstruction* c,\n                                   const string& op_name)\n      : OpKernel(c) {\n    // Compute expected input signature\n    const DataType dt = DataTypeToEnum<T>::v();\n    const int n = c->num_inputs() / 2;\n    DataTypeVector expected;\n    for (int i = 0; i < n; i++) {\n      expected.push_back(DT_INT32);\n    }\n    for (int i = 0; i < n; i++) {\n      expected.push_back(dt);\n    }\n    OP_REQUIRES_OK(c, c->MatchSignature(expected, {dt}));\n    OP_REQUIRES(c, c->num_inputs() > 0,\n                errors::InvalidArgument(op_name + \": Must have some inputs\"));\n    OP_REQUIRES(c, c->num_inputs() % 2 == 0,\n                errors::InvalidArgument(\n                    op_name + \": Must have even number of arguments\"));\n  }\n\n protected:\n  // Check if data0.shape[indices0.dims():] == data1.shape[indices1.dims():]\n  static bool SameExtraShape(const Tensor& data0, const Tensor& indices0,\n                             const Tensor& data1, const Tensor& indices1) {\n    const int extra0 = data0.dims() - indices0.dims();\n    const int extra1 = data1.dims() - indices1.dims();\n    if (extra0 != extra1) return false;\n    for (int i = 0; i < extra0; i++) {\n      if (data0.dim_size(indices0.dims() + i) !=\n          data1.dim_size(indices1.dims() + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void CheckArgsAndAllocateResult(OpKernelContext* c,\n                                  OpInputList* indices_inputs,\n                                  OpInputList* data_inputs, int* first_dim_size,\n                                  int* data_elements_size,\n                                  Tensor** result_ptr) {\n    // Find maximum index in the indices vectors\n    OP_REQUIRES_OK(c, c->input_list(\"indices\", indices_inputs));\n\n    int32_t max_index = -1;\n    if (data_elements_size) {\n      *data_elements_size = 0;\n    }\n    for (const Tensor& indices : *indices_inputs) {\n      if (indices.NumElements() > 0) {\n        Eigen::Tensor<int32, 0, Eigen::RowMajor> m =\n            indices.flat<int32>().maximum();\n        max_index = std::max(m(), max_index);\n      }\n      if (data_elements_size) {\n        *data_elements_size += indices.NumElements();\n      }\n    }\n\n    *first_dim_size = max_index + 1;\n\n    // Validate that data[i].shape = indices[i].shape + constant\n    OP_REQUIRES_OK(c, c->input_list(\"data\", data_inputs));\n    const Tensor& data0 = (*data_inputs)[0];\n    const Tensor& indices0 = (*indices_inputs)[0];\n    for (int input_num = 0; input_num < indices_inputs->size(); input_num++) {\n      const Tensor& indices = (*indices_inputs)[input_num];\n      const Tensor& data = (*data_inputs)[input_num];\n      OP_REQUIRES(\n          c, TensorShapeUtils::StartsWith(data.shape(), indices.shape()),\n          errors::InvalidArgument(\"data[\", input_num,\n                                  \"].shape = \", data.shape().DebugString(),\n                                  \" does not start with indices[\", input_num,\n                                  \"].shape = \", indices.shape().DebugString()));\n      OP_REQUIRES(\n          c, input_num == 0 || SameExtraShape(data0, indices0, data, indices),\n          errors::InvalidArgument(\n              \"Need data[0].shape[\", indices0.dims(), \":] = data[\", input_num,\n              \"].shape[\", indices.dims(),\n              \":], got data[0].shape = \", data0.shape().DebugString(),\n              \", data[\", input_num, \"].shape = \", data.shape().DebugString(),\n              \", indices[0].shape = \", indices0.shape().DebugString(),\n              \", indices[\", input_num,\n              \"].shape = \", indices.shape().DebugString()));\n    }\n\n    // Allocate result tensor of shape\n    //   [*first_dim_size] + data.shape[indices.dims:]\n    TensorShape result_shape;\n    OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(*first_dim_size));\n    for (int d = indices0.dims(); d < data0.dims(); d++) {\n      OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(data0.dim_size(d)));\n    }\n    OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, result_ptr));\n  }\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename T>\nvoid DynamicStitchGPUImpl(const Eigen::GpuDevice& gpu_device,\n                          const int32_t slice_size,\n                          const int32_t first_dim_size,\n                          const GpuDeviceArrayStruct<int>& input_indices,\n                          const GpuDeviceArrayStruct<const T*>& input_ptrs,\n                          T* output);\n#define REGISTER_GPU(T)                                           \\\n  extern template void DynamicStitchGPUImpl(                      \\\n      const Eigen::GpuDevice& gpu_device, const int32 slice_size, \\\n      const int32 first_dim_size,                                 \\\n      const GpuDeviceArrayStruct<int32>& input_indices,           \\\n      const GpuDeviceArrayStruct<const T*>& input_ptrs, T* output);\n\nTF_CALL_int32(REGISTER_GPU);\nTF_CALL_int64(REGISTER_GPU);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_GPU);\nTF_CALL_COMPLEX_TYPES(REGISTER_GPU);\n#undef REGISTER_GPU\n\ntemplate <class T>\nclass DynamicStitchOpGPU : public DynamicStitchOpImplBase<T> {\n public:\n  explicit DynamicStitchOpGPU(OpKernelConstruction* c)\n      : DynamicStitchOpImplBase<T>(c, \"DynamicStitchOp\") {}\n\n  void Compute(OpKernelContext* c) override {\n    OpInputList indices_inputs;\n    OpInputList data_inputs;\n    int first_dim_size;\n    int data_elements_size;\n    Tensor* merged = nullptr;\n    this->CheckArgsAndAllocateResult(c, &indices_inputs, &data_inputs,\n                                     &first_dim_size, &data_elements_size,\n                                     &merged);\n    if (!c->status().ok()) {\n      // Avoid segmentation faults if merged cannot be allocated and an error is\n      // passed back in the context.\n      return;\n    }\n\n    // TODO(jeff): Currently we leave uninitialized any portions of\n    // merged that aren't covered by an index in indices.  What should we do?\n    if (first_dim_size > 0) {\n      // because the collision requirements, we have to deal with\n      // collision first before send data to gpu kernel.\n      // TODO(ekelsen): Instead of doing a serial scan on the CPU to pick the\n      // last of duplicated indices, it could instead be done of the GPU\n      // implicitly using atomics to make sure the last index is the final\n      // write.\n      const int slice_size = merged->flat_outer_dims<T>().dimension(1);\n      GpuDeviceArrayOnHost<int32> indices_flat(c, first_dim_size);\n      GpuDeviceArrayOnHost<const T*> data_flat(c, data_elements_size);\n      OP_REQUIRES_OK(c, indices_flat.Init());\n      OP_REQUIRES_OK(c, data_flat.Init());\n      // initialize the indices_flat (-1 represents missing indices)\n      for (int i = 0; i < first_dim_size; ++i) {\n        indices_flat.Set(i, -1);\n      }\n\n      // data_flat index\n      int32_t idx = 0;\n      // sum of indices_inputs[i].NumElements() for compute indices_flat value.\n      int32_t base_size = 0;\n      for (int i = 0; i < indices_inputs.size(); ++i) {\n        auto indices_vec = indices_inputs[i].flat<int32>();\n        auto data_ptr_base = data_inputs[i].template flat<T>().data();\n        for (int j = 0; j < indices_vec.size(); ++j) {\n          // indices_flat's indices represent the indices of output.\n          // indices_flat's values represent the indices of input_data where the\n          // data located.\n          indices_flat.Set(indices_vec(j), base_size + j);\n          data_flat.Set(\n              idx, const_cast<T*>(reinterpret_cast<const T*>(data_ptr_base) +\n                                  j * slice_size));\n          ++idx;\n        }\n        base_size += indices_vec.size();\n      }\n      OP_REQUIRES_OK(c, indices_flat.Finalize());\n      OP_REQUIRES_OK(c, data_flat.Finalize());\n\n      auto output = merged->template flat<T>().data();\n      DynamicStitchGPUImpl<T>(c->eigen_gpu_device(), slice_size, first_dim_size,\n                              indices_flat.data(), data_flat.data(), output);\n    }\n  }\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <class T, bool Parallel>\nclass DynamicStitchOpImplCPU : public DynamicStitchOpImplBase<T> {\n public:\n  explicit DynamicStitchOpImplCPU(OpKernelConstruction* c)\n      : DynamicStitchOpImplBase<T>(\n            c, (Parallel ? \"ParallelDynamicStitchOp\" : \"DynamicStitchOp\")) {}\n\n  void Compute(OpKernelContext* c) override {\n    OpInputList indices_inputs;\n    OpInputList data_inputs;\n    int first_dim_size;\n    Tensor* merged = nullptr;\n    this->CheckArgsAndAllocateResult(c, &indices_inputs, &data_inputs,\n                                     &first_dim_size, nullptr, &merged);\n    if (!c->status().ok()) {\n      // Avoid segmentation faults if merged cannot be allocated and an error is\n      // passed back in the context.\n      return;\n    }\n\n    // TODO(jeff): Currently we leave uninitialized any portions of\n    // merged that aren't covered by an index in indices.  What should we do?\n    if (first_dim_size > 0) {\n      auto merged_flat = merged->flat_outer_dims<T>();\n      // slice_size must not be stored as int for cases of tensors over 2GB.\n      const auto slice_size = merged_flat.dimension(1);\n      const size_t slice_bytes = slice_size * sizeof(T);\n      auto OnInputNumber = [&](int input_num) {\n        const Tensor& indices = indices_inputs[input_num];\n        auto indices_vec = indices.flat<int32>();\n        const Tensor& data = data_inputs[input_num];\n        auto data_flat =\n            data.shaped<T, 2>({indices_vec.dimension(0), slice_size});\n\n        if (DataTypeCanUseMemcpy(DataTypeToEnum<T>::v())) {\n          T* merged_base = merged_flat.data();\n          const T* data_base = data_flat.data();\n          for (int i = 0; i < indices_vec.size(); i++) {\n            int32_t index = internal::SubtleMustCopy(indices_vec(i));\n            OP_REQUIRES(\n                c, FastBoundsCheck(index, first_dim_size),\n                errors::InvalidArgument(\"indices[\", i, \"] is out of range\"));\n            memcpy(merged_base + index * slice_size, data_base + i * slice_size,\n                   slice_bytes);\n          }\n        } else {\n          Eigen::DSizes<Eigen::DenseIndex, 2> sizes(1, slice_size);\n          for (int i = 0; i < indices_vec.size(); i++) {\n            // Copy slice data[i] to merged[indices[i]]\n            Eigen::DSizes<Eigen::DenseIndex, 2> data_indices(i, 0);\n            int32_t index = internal::SubtleMustCopy(indices_vec(i));\n            OP_REQUIRES(\n                c, FastBoundsCheck(index, first_dim_size),\n                errors::InvalidArgument(\"indices[\", i, \"] is out of range\"));\n            Eigen::DSizes<Eigen::DenseIndex, 2> merged_indices(index, 0);\n            merged_flat.slice(merged_indices, sizes) =\n                data_flat.slice(data_indices, sizes);\n          }\n        }\n      };\n      if (Parallel &&\n          c->device()->tensorflow_cpu_worker_threads()->num_threads > 1) {\n        auto thread_pool =\n            c->device()->tensorflow_cpu_worker_threads()->workers;\n        size_t total_indices_size = 0;\n        for (int input_num = 0; input_num < indices_inputs.size();\n             ++input_num) {\n          total_indices_size += indices_inputs[input_num].NumElements();\n        }\n        const double avg_indices_size =\n            static_cast<double>(total_indices_size) / indices_inputs.size();\n        auto bytes_processed = slice_bytes * avg_indices_size;\n        auto LoopBody = [&](int first, int last) {\n          for (int input_num = first; input_num < last; ++input_num) {\n            OnInputNumber(input_num);\n          }\n        };\n        thread_pool->ParallelFor(indices_inputs.size(), bytes_processed,\n                                 LoopBody);\n      } else {\n        for (int input_num = 0; input_num < indices_inputs.size();\n             input_num++) {\n          OnInputNumber(input_num);\n        }\n      }\n    }\n  }\n};\n\n// Using inheritance rather than a typedef so that these classes might have more\n// functionality later.\n\ntemplate <typename T>\nstruct DynamicStitchOpCPU : DynamicStitchOpImplCPU<T, false> {\n  using DynamicStitchOpImplCPU<T, false>::DynamicStitchOpImplCPU;\n};\n\ntemplate <typename T>\nstruct ParallelDynamicStitchOpCPU : DynamicStitchOpImplCPU<T, true> {\n  using DynamicStitchOpImplCPU<T, true>::DynamicStitchOpImplCPU;\n};\n\n#define REGISTER_DYNAMIC_STITCH(type)                    \\\n  REGISTER_KERNEL_BUILDER(Name(\"DynamicStitch\")          \\\n                              .Device(DEVICE_CPU)        \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\"),    \\\n                          DynamicStitchOpCPU<type>)      \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParallelDynamicStitch\")  \\\n                              .Device(DEVICE_CPU)        \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\"),    \\\n                          ParallelDynamicStitchOpCPU<type>)\n\nTF_CALL_POD_STRING_TYPES(REGISTER_DYNAMIC_STITCH);\nTF_CALL_variant(REGISTER_DYNAMIC_STITCH);\nTF_CALL_QUANTIZED_TYPES(REGISTER_DYNAMIC_STITCH);\n#undef REGISTER_DYNAMIC_STITCH\n\n#define REGISTER_PARALLEL_DYNAMIC_STITCH(type)           \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParallelDynamicStitch\")  \\\n                              .Device(DEVICE_DEFAULT)    \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\")     \\\n                              .HostMemory(\"data\")        \\\n                              .HostMemory(\"merged\"),     \\\n                          ParallelDynamicStitchOpCPU<type>)\n\nTF_CALL_int32(REGISTER_PARALLEL_DYNAMIC_STITCH);\nTF_CALL_int64(REGISTER_PARALLEL_DYNAMIC_STITCH);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_PARALLEL_DYNAMIC_STITCH);\nTF_CALL_COMPLEX_TYPES(REGISTER_PARALLEL_DYNAMIC_STITCH);\n#undef REGISTER_PARALLEL_DYNAMIC_STITCH\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define REGISTER_DYNAMIC_STITCH_GPU(type)                \\\n  REGISTER_KERNEL_BUILDER(Name(\"DynamicStitch\")          \\\n                              .Device(DEVICE_GPU)        \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\"),    \\\n                          DynamicStitchOpGPU<type>)\n\nTF_CALL_int32(REGISTER_DYNAMIC_STITCH_GPU);\nTF_CALL_int64(REGISTER_DYNAMIC_STITCH_GPU);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_DYNAMIC_STITCH_GPU);\nTF_CALL_COMPLEX_TYPES(REGISTER_DYNAMIC_STITCH_GPU);\n#undef REGISTER_DYNAMIC_STITCH_GPU\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace tensorflow"