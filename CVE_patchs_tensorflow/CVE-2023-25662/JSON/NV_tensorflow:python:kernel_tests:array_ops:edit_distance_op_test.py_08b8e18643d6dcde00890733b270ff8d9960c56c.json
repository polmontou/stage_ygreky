"# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for tensorflow.kernels.edit_distance_op.\"\"\"\n\nimport numpy as np\nfrom tensorflow.python.eager import def_function\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.platform import test\n\n\ndef ConstantOf(x):\n  x = np.asarray(x)\n  # Convert to int64 if it's not a string or unicode\n  if x.dtype.char not in \"SU\":\n    x = np.asarray(x, dtype=np.int64)\n  return constant_op.constant(x)\n\n\nclass EditDistanceTest(test.TestCase):\n\n  def _testEditDistanceST(self,\n                          hypothesis_st,\n                          truth_st,\n                          normalize,\n                          expected_output,\n                          expected_shape,\n                          expected_err_re=None):\n    edit_distance = array_ops.edit_distance(\n        hypothesis=hypothesis_st, truth=truth_st, normalize=normalize)\n\n    if expected_err_re is None:\n      self.assertEqual(edit_distance.get_shape(), expected_shape)\n      output = self.evaluate(edit_distance)\n      self.assertAllClose(output, expected_output)\n    else:\n      with self.assertRaisesOpError(expected_err_re):\n        self.evaluate(edit_distance)\n\n  def _testEditDistance(self,\n                        hypothesis,\n                        truth,\n                        normalize,\n                        expected_output,\n                        expected_err_re=None):\n    # Shape inference figures out the shape from the shape variables\n    # Explicit tuple() needed since zip returns an iterator in Python 3.\n    expected_shape = [\n        max(h, t) for h, t in tuple(zip(hypothesis[2], truth[2]))[:-1]\n    ]\n\n    # SparseTensorValue inputs.\n    with ops.Graph().as_default() as g, self.session(g):\n      # hypothesis and truth are (index, value, shape) tuples\n      self._testEditDistanceST(\n          hypothesis_st=sparse_tensor.SparseTensorValue(\n              *[ConstantOf(x) for x in hypothesis]),\n          truth_st=sparse_tensor.SparseTensorValue(\n              *[ConstantOf(x) for x in truth]),\n          normalize=normalize,\n          expected_output=expected_output,\n          expected_shape=expected_shape,\n          expected_err_re=expected_err_re)\n\n    # SparseTensor inputs.\n    with ops.Graph().as_default() as g, self.session(g):\n      # hypothesis and truth are (index, value, shape) tuples\n      self._testEditDistanceST(\n          hypothesis_st=sparse_tensor.SparseTensor(\n              *[ConstantOf(x) for x in hypothesis]),\n          truth_st=sparse_tensor.SparseTensor(*[ConstantOf(x) for x in truth]),\n          normalize=normalize,\n          expected_output=expected_output,\n          expected_shape=expected_shape,\n          expected_err_re=expected_err_re)\n\n  def testEditDistanceNormalized(self):\n    hypothesis_indices = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    hypothesis_values = [0, 1, 1, -1]\n    hypothesis_shape = [2, 2]\n    truth_indices = [[0, 0], [1, 0], [1, 1]]\n    truth_values = [0, 1, 1]\n    truth_shape = [2, 2]\n    expected_output = [1.0, 0.5]\n\n    self._testEditDistance(\n        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),\n        truth=(truth_indices, truth_values, truth_shape),\n        normalize=True,\n        expected_output=expected_output)\n\n  def testEditDistanceUnnormalized(self):\n    hypothesis_indices = [[0, 0], [1, 0], [1, 1]]\n    hypothesis_values = [10, 10, 11]\n    hypothesis_shape = [2, 2]\n    truth_indices = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    truth_values = [1, 2, 1, -1]\n    truth_shape = [2, 3]\n    expected_output = [2.0, 2.0]\n\n    self._testEditDistance(\n        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),\n        truth=(truth_indices, truth_values, truth_shape),\n        normalize=False,\n        expected_output=expected_output)\n\n  def testEditDistanceProperDistance(self):\n    # In this case, the values are individual characters stored in the\n    # SparseTensor (type DT_STRING)\n    hypothesis_indices = ([[0, i] for i, _ in enumerate(\"algorithm\")] +\n                          [[1, i] for i, _ in enumerate(\"altruistic\")])\n    hypothesis_values = [x for x in \"algorithm\"] + [x for x in \"altruistic\"]\n    hypothesis_shape = [2, 11]\n    truth_indices = ([[0, i] for i, _ in enumerate(\"altruistic\")] +\n                     [[1, i] for i, _ in enumerate(\"algorithm\")])\n    truth_values = [x for x in \"altruistic\"] + [x for x in \"algorithm\"]\n    truth_shape = [2, 11]\n    expected_unnormalized = [6.0, 6.0]\n    expected_normalized = [6.0 / len(\"altruistic\"), 6.0 / len(\"algorithm\")]\n\n    self._testEditDistance(\n        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),\n        truth=(truth_indices, truth_values, truth_shape),\n        normalize=False,\n        expected_output=expected_unnormalized)\n\n    self._testEditDistance(\n        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),\n        truth=(truth_indices, truth_values, truth_shape),\n        normalize=True,\n        expected_output=expected_normalized)\n\n  def testEditDistance3D(self):\n    hypothesis_indices = [[0, 0, 0], [1, 0, 0]]\n    hypothesis_values = [0, 1]\n    hypothesis_shape = [2, 1, 1]\n    truth_indices = [[0, 1, 0], [1, 0, 0], [1, 1, 0]]\n    truth_values = [0, 1, 1]\n    truth_shape = [2, 2, 1]\n    expected_output = [\n        [np.inf, 1.0],  # (0,0): no truth, (0,1): no hypothesis\n        [0.0, 1.0]\n    ]  # (1,0): match,    (1,1): no hypothesis\n\n    self._testEditDistance(\n        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),\n        truth=(truth_indices, truth_values, truth_shape),\n        normalize=True,\n        expected_output=expected_output)\n\n  def testEditDistanceZeroLengthHypothesis(self):\n    hypothesis_indices = np.empty((0, 2), dtype=np.int64)\n    hypothesis_values = []\n    hypothesis_shape = [1, 0]\n    truth_indices = [[0, 0]]\n    truth_values = [0]\n    truth_shape = [1, 1]\n    expected_output = [1.0]\n\n    self._testEditDistance(\n        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),\n        truth=(truth_indices, truth_values, truth_shape),\n        normalize=True,\n        expected_output=expected_output)\n\n  def testEditDistanceZeroLengthTruth(self):\n    hypothesis_indices = [[0, 0]]\n    hypothesis_values = [0]\n    hypothesis_shape = [1, 1]\n    truth_indices = np.empty((0, 2), dtype=np.int64)\n    truth_values = []\n    truth_shape = [1, 0]\n    expected_output = [np.inf]  # Normalized, loss is 1/0 = inf\n\n    self._testEditDistance(\n        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),\n        truth=(truth_indices, truth_values, truth_shape),\n        normalize=True,\n        expected_output=expected_output)\n\n  def testEditDistanceZeroLengthHypothesisAndTruth(self):\n    hypothesis_indices = np.empty((0, 2), dtype=np.int64)\n    hypothesis_values = []\n    hypothesis_shape = [1, 0]\n    truth_indices = np.empty((0, 2), dtype=np.int64)\n    truth_values = []\n    truth_shape = [1, 0]\n    expected_output = [0]  # Normalized is 0 because of exact match\n\n    self._testEditDistance(\n        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),\n        truth=(truth_indices, truth_values, truth_shape),\n        normalize=True,\n        expected_output=expected_output)\n\n  def testEditDistanceBadIndices(self):\n    hypothesis_indices = np.full((3, 3), -1250999896764, dtype=np.int64)\n    hypothesis_values = np.zeros(3, dtype=np.int64)\n    hypothesis_shape = np.zeros(3, dtype=np.int64)\n    truth_indices = np.full((3, 3), -1250999896764, dtype=np.int64)\n    truth_values = np.full([3], 2, dtype=np.int64)\n    truth_shape = np.full([3], 2, dtype=np.int64)\n    expected_output = []  # dummy; ignored\n\n    self._testEditDistance(\n        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),\n        truth=(truth_indices, truth_values, truth_shape),\n        normalize=False,\n        expected_output=expected_output,\n        expected_err_re=(r\"inner product -\\d+ which would require writing \"\n                         \"to outside of the buffer for the output tensor|\"\n                         r\"Dimension -\\d+ must be >= 0\"))\n\n  def testEmptyShapeWithEditDistanceRaisesError(self):\n    para = {\n        \"hypothesis_indices\": [[]],\n        \"hypothesis_values\": [\"tmp/\"],\n        \"hypothesis_shape\": [],\n        \"truth_indices\": [[]],\n        \"truth_values\": [\"\"],\n        \"truth_shape\": [],\n        \"normalize\": False,\n    }\n\n    # Check edit distance raw op with empty shape in eager mode.\n    with self.assertRaisesRegex(\n        (errors.InvalidArgumentError, ValueError),\n        (\n            r\"Input Hypothesis SparseTensors must have rank at least 2, but\"\n            \" hypothesis_shape rank is: 0|Input SparseTensors must have rank \"\n            \"at least 2, but truth_shape rank is: 0\"\n        ),\n    ):\n      array_ops.gen_array_ops.EditDistance(**para)\n\n    # Check raw op with tf.function\n    @def_function.function\n    def TestFunction():\n      \"\"\"Wrapper function for edit distance call.\"\"\"\n      array_ops.gen_array_ops.EditDistance(**para)\n\n    with self.assertRaisesRegex(\n        ValueError,\n        (\n            \"Input Hypothesis SparseTensors must have rank at least 2, but\"\n            \" hypothesis_shape rank is: 0\"\n        ),\n    ):\n      TestFunction()\n\n    # Check with python wrapper API\n    hypothesis_indices = [[]]\n    hypothesis_values = [0]\n    hypothesis_shape = []\n    truth_indices = [[]]\n    truth_values = [1]\n    truth_shape = []\n    expected_output = []  # dummy ignored\n\n    with self.assertRaisesRegex(\n        ValueError,\n        (\n            \"Input Hypothesis SparseTensors must have rank at least 2, but\"\n            \" hypothesis_shape rank is: 0\"\n        ),\n    ):\n      self._testEditDistance(\n          hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),\n          truth=(truth_indices, truth_values, truth_shape),\n          normalize=False,\n          expected_output=expected_output,\n      )\n\n\nif __name__ == \"__main__\":\n  test.main()"