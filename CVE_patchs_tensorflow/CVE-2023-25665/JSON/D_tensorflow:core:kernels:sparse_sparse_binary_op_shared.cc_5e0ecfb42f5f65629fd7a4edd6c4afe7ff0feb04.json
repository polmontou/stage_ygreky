"diff --git a/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc b/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc\nindex 8d0642eb1d4..0863e5e3794 100644\n--- a/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc\n+++ b/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc\n@@ -41,6 +41,7 @@ limitations under the License.\n #include \"tensorflow/core/framework/types.h\"\n #include \"tensorflow/core/kernels/cwise_ops.h\"\n #include \"tensorflow/core/kernels/cwise_ops_common.h\"\n+#include \"tensorflow/core/kernels/sparse_utils.h\"\n #include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n \n namespace tensorflow {\n@@ -131,22 +132,12 @@ class SparseSparseBinaryOpShared : public OpKernel {\n     OP_REQUIRES_OK(ctx, ctx->input(\"b_shape\", &b_shape_t));\n \n     // Validations.\n-    OP_REQUIRES(\n-        ctx,\n-        TensorShapeUtils::IsMatrix(a_indices_t->shape()) &&\n-            TensorShapeUtils::IsMatrix(b_indices_t->shape()),\n-        errors::InvalidArgument(\"Inputs a_indices and b_indices should be \"\n-                                \"matrices but received shapes: \",\n-                                a_indices_t->shape().DebugString(), \", \",\n-                                b_indices_t->shape().DebugString()));\n-    OP_REQUIRES(ctx,\n-                TensorShapeUtils::IsVector(a_values_t->shape()) &&\n-                    TensorShapeUtils::IsVector(b_values_t->shape()),\n-                errors::InvalidArgument(\n-                    \"Inputs a_values and b_values should be vectors \"\n-                    \"but received shapes: \",\n-                    a_values_t->shape().DebugString(), \" and \",\n-                    b_values_t->shape().DebugString()));\n+    OP_REQUIRES_OK(ctx, sparse_utils::ValidateSparseTensor<int64_t>(\n+                            *a_indices_t, *a_values_t, *a_shape_t,\n+                            sparse_utils::IndexValidation::kUnordered));\n+    OP_REQUIRES_OK(ctx, sparse_utils::ValidateSparseTensor<int64_t>(\n+                            *b_indices_t, *b_values_t, *b_shape_t,\n+                            sparse_utils::IndexValidation::kUnordered));\n \n     const int64_t a_nnz = a_indices_t->dim_size(0);\n     const int64_t b_nnz = b_indices_t->dim_size(0);\n@@ -154,25 +145,7 @@ class SparseSparseBinaryOpShared : public OpKernel {\n     const auto a_values = a_values_t->vec<T>();\n     const auto b_values = b_values_t->vec<T>();\n \n-    OP_REQUIRES(\n-        ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,\n-        errors::InvalidArgument(\"Expected \", a_nnz, \" and \", b_nnz,\n-                                \" non-empty input values, got \",\n-                                a_values.size(), \" and \", b_values.size()));\n-\n-    OP_REQUIRES(ctx,\n-                TensorShapeUtils::IsVector(a_shape_t->shape()) &&\n-                    TensorShapeUtils::IsVector(b_shape_t->shape()),\n-                errors::InvalidArgument(\n-                    \"Input shapes should be a vector but received shapes \",\n-                    a_shape_t->shape().DebugString(), \" and \",\n-                    b_shape_t->shape().DebugString()));\n     const int num_dims = a_indices_t->dim_size(1);\n-    OP_REQUIRES(\n-        ctx, a_shape_t->NumElements() == num_dims,\n-        errors::InvalidArgument(\"Second dimension of a_indices and length of \"\n-                                \"a_shape must match, got \",\n-                                num_dims, \" and \", a_shape_t->NumElements()));\n     OP_REQUIRES(ctx, num_dims > 0,\n                 errors::InvalidArgument(\"Tensors must not be empty\"));\n     OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t),\n@@ -192,7 +165,7 @@ class SparseSparseBinaryOpShared : public OpKernel {\n     const auto a_indices_mat = a_indices_t->matrix<int64_t>();\n     const auto b_indices_mat = b_indices_t->matrix<int64_t>();\n     std::vector<T> a_augmented_values, b_augmented_values;\n-    std::vector<std::pair<bool, int64>> entries_to_copy;  // from_a?, idx\n+    std::vector<std::pair<bool, int64_t>> entries_to_copy;  // from_a?, idx\n     UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat,\n                                 b_values, b_nnz, num_dims, &a_augmented_values,\n                                 &b_augmented_values, &entries_to_copy);"