"# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Functional tests for pooling operations.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.compiler.tests import xla_test\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_nn_ops\nfrom tensorflow.python.ops import nn_ops\nfrom tensorflow.python.platform import googletest\n\n\ndef NHWCToNCHW(input_tensor):\n  \"\"\"Convert the input from NHWC format to NCHW.\n\n  Args:\n    input_tensor:  a 4-D tensor, or a 4-element array representing the same.\n\n  Returns:\n    the converted tensor or a shape array\n  \"\"\"\n  if isinstance(input_tensor, ops.Tensor):\n    return array_ops.transpose(input_tensor, [0, 3, 1, 2])\n  else:\n    return [input_tensor[0], input_tensor[3], input_tensor[1], input_tensor[2]]\n\n\ndef NCHWToNHWC(input_tensor):\n  \"\"\"Convert the input from NCHW format to NHWC.\n\n  Args:\n    input_tensor:  a 4-D tensor, or a 4-element array representing the same.\n\n  Returns:\n    the converted tensor or a shape array\n  \"\"\"\n  if isinstance(input_tensor, ops.Tensor):\n    return array_ops.transpose(input_tensor, [0, 2, 3, 1])\n  else:\n    return [input_tensor[0], input_tensor[2], input_tensor[3], input_tensor[1]]\n\n\ndef GetTestConfigs():\n  \"\"\"Get all the valid tests configs to run.\n\n  Returns:\n    all the valid test configs\n  \"\"\"\n  test_configs = [\"NHWC\", \"NCHW\"]\n  return test_configs\n\n\nclass PoolingTest(xla_test.XLATestCase):\n\n  def _VerifyOneTest(self, pool_func, input_sizes, ksize, strides, padding,\n                     data_format, expected):\n    \"\"\"Verifies the output values of the pooling function.\n\n    Args:\n      pool_func: Function to be called, currently only co.MaxPool.\n      input_sizes: Input tensor dimensions.\n      ksize: The kernel size dimensions\n      strides: The stride dimensions\n      padding: Padding type.\n      data_format: The data format we use to run the pooling operation.\n      expected: An array containing the expected operation outputs.\n    \"\"\"\n    total_size = np.prod(input_sizes)\n    # Initializes the input tensor with array containing incrementing\n    # numbers from 1.\n    x = np.array([f * 1.0 for f in range(1, total_size + 1)], dtype=np.float32)\n    x = x.reshape(input_sizes)\n    with self.session() as sess:\n      with self.test_scope():\n        inputs = array_ops.placeholder(dtypes.float32)\n        t = inputs\n        if data_format == \"NCHW\":\n          t = NHWCToNCHW(t)\n          ksize = NHWCToNCHW(ksize)\n          strides = NHWCToNCHW(strides)\n        t = pool_func(t,\n                      ksize=ksize,\n                      strides=strides,\n                      padding=padding,\n                      data_format=data_format)\n        if data_format == \"NCHW\":\n          t = NCHWToNHWC(t)\n      actual = sess.run(t, {inputs: x})\n      self.assertAllClose(expected, actual.flatten(), rtol=1e-5, atol=1e-6)\n\n  def _VerifyValues(self, pool_func, input_sizes, ksize, strides, padding,\n                    expected):\n    \"\"\"Verifies the output values of the pooling function.\n\n    Args:\n      pool_func: Function to be called, co.MaxPool, co.AvgPool,\n        or the Lua version.\n      input_sizes: Input tensor dimensions.\n      ksize: The kernel size dimensions\n      strides: The stride dimensions\n      padding: Padding type.\n      expected: An array containing the expected operation outputs.\n    \"\"\"\n    for data_format in GetTestConfigs():\n      self._VerifyOneTest(pool_func, input_sizes, ksize, strides, padding,\n                          data_format, expected)\n\n  def testMaxPoolValidPadding(self):\n    expected_output = [13.0, 14.0, 15.0]\n    self._VerifyValues(nn_ops.max_pool,\n                       input_sizes=[1, 3, 3, 3],\n                       ksize=[1, 2, 2, 1],\n                       strides=[1, 2, 2, 1],\n                       padding=\"VALID\",\n                       expected=expected_output)\n\n  def testMaxPoolSamePadding(self):\n    expected_output = [13.0, 14.0, 15.0, 16.0, 17.0, 18.0]\n    self._VerifyValues(nn_ops.max_pool,\n                       input_sizes=[1, 2, 3, 3],\n                       ksize=[1, 2, 2, 1],\n                       strides=[1, 2, 2, 1],\n                       padding=\"SAME\",\n                       expected=expected_output)\n\n  def testMaxPoolSamePaddingNonSquareWindow(self):\n    # input is:\n    # [1.0, 2.0\n    #  3.0  4.0]\n    #\n    # Window of [x, x] should do:\n    #\n    #  [max(1.0, 2.0), max(2.0, padded0),\n    #   max(3.0, 4.0), max(4.0, padded0)]\n    self._VerifyValues(\n        nn_ops.max_pool,\n        input_sizes=[1, 2, 2, 1],\n        ksize=[1, 1, 2, 1],\n        strides=[1, 1, 1, 1],\n        padding=\"SAME\",\n        expected=[2.0, 2.0, 4.0, 4.0])\n\n  def testMaxPoolValidPaddingUnevenStride(self):\n    self._VerifyValues(\n        nn_ops.max_pool,\n        input_sizes=[1, 4, 4, 1],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 1, 2, 1],\n        padding=\"VALID\",\n        expected=[6.0, 8.0, 10.0, 12.0, 14.0, 16.0])\n    self._VerifyValues(\n        nn_ops.max_pool,\n        input_sizes=[1, 4, 4, 1],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 2, 1, 1],\n        padding=\"VALID\",\n        expected=[6.0, 7.0, 8.0, 14.0, 15.0, 16.0])\n\n  def testMaxPoolSamePaddingFilter4(self):\n    expected_output = [\n        21.0, 22.0, 23.0, 24.0, 29.0, 30.0, 31.0, 32.0, 53.0, 54.0, 55.0, 56.0,\n        61.0, 62.0, 63.0, 64.0\n    ]\n    self._VerifyValues(\n        nn_ops.max_pool,\n        input_sizes=[1, 4, 4, 4],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"SAME\",\n        expected=expected_output)\n\n  def testMaxPoolSamePaddingFilter8(self):\n    expected_output = [\n        145.0, 146.0, 147.0, 148.0, 149.0, 150.0, 151.0, 152.0, 161.0, 162.0,\n        163.0, 164.0, 165.0, 166.0, 167.0, 168.0, 177.0, 178.0, 179.0, 180.0,\n        181.0, 182.0, 183.0, 184.0, 185.0, 186.0, 187.0, 188.0, 189.0, 190.0,\n        191.0, 192.0, 273.0, 274.0, 275.0, 276.0, 277.0, 278.0, 279.0, 280.0,\n        289.0, 290.0, 291.0, 292.0, 293.0, 294.0, 295.0, 296.0, 305.0, 306.0,\n        307.0, 308.0, 309.0, 310.0, 311.0, 312.0, 313.0, 314.0, 315.0, 316.0,\n        317.0, 318.0, 319.0, 320.0, 401.0, 402.0, 403.0, 404.0, 405.0, 406.0,\n        407.0, 408.0, 417.0, 418.0, 419.0, 420.0, 421.0, 422.0, 423.0, 424.0,\n        433.0, 434.0, 435.0, 436.0, 437.0, 438.0, 439.0, 440.0, 441.0, 442.0,\n        443.0, 444.0, 445.0, 446.0, 447.0, 448.0, 465.0, 466.0, 467.0, 468.0,\n        469.0, 470.0, 471.0, 472.0, 481.0, 482.0, 483.0, 484.0, 485.0, 486.0,\n        487.0, 488.0, 497.0, 498.0, 499.0, 500.0, 501.0, 502.0, 503.0, 504.0,\n        505.0, 506.0, 507.0, 508.0, 509.0, 510.0, 511.0, 512.0\n    ]\n    self._VerifyValues(\n        nn_ops.max_pool,\n        input_sizes=[1, 8, 8, 8],\n        ksize=[1, 3, 3, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"SAME\",\n        expected=expected_output)\n\n  # Tests for DepthwiseMaxPooling on CPU only.\n  def testDepthwiseMaxPool1x1DepthWindow1(self):\n    # input is:\n    # [1.0, ..., 10.0] along depth,\n    #\n    # We maxpool by depth in patches of 2.\n    self._VerifyValues(\n        nn_ops.max_pool,\n        input_sizes=[1, 1, 1, 10],\n        ksize=[1, 1, 1, 2],\n        strides=[1, 1, 1, 2],\n        padding=\"SAME\",\n        expected=[2.0, 4.0, 6.0, 8.0, 10.0])\n\n  def testDepthwiseMaxPool2x2DepthWindow3(self):\n    # input is:\n    #\n    # a 2x2x6 cube, and we depthwise max across 3 to produce a 2x2x2\n    # output.  Each node has contiguous values, so the depthwise max\n    # should be multiples of 3.0.\n    self._VerifyValues(\n        nn_ops.max_pool,\n        input_sizes=[1, 2, 2, 6],\n        ksize=[1, 1, 1, 3],\n        strides=[1, 1, 1, 3],\n        padding=\"SAME\",\n        expected=[3.0, 6.0, 9.0, 12.0, 15.0, 18.0, 21.0, 24.0])\n\n  def testKernelSmallerThanStrideValid(self):\n    self._VerifyValues(\n        nn_ops.max_pool,\n        input_sizes=[1, 7, 7, 1],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 3, 3, 1],\n        padding=\"VALID\",\n        expected=[9, 12, 30, 33])\n\n  def testKernelSmallerThanStrideSame(self):\n    self._VerifyValues(\n        nn_ops.max_pool,\n        input_sizes=[1, 3, 3, 1],\n        ksize=[1, 1, 1, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"SAME\",\n        expected=[1, 3, 7, 9])\n\n    self._VerifyValues(\n        nn_ops.max_pool,\n        input_sizes=[1, 4, 4, 1],\n        ksize=[1, 1, 1, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"SAME\",\n        expected=[1, 3, 9, 11])\n\n  # Average pooling\n  def testAvgPoolValidPadding(self):\n    expected_output = [7, 8, 9]\n    self._VerifyValues(\n        nn_ops.avg_pool,\n        input_sizes=[1, 3, 3, 3],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"VALID\",\n        expected=expected_output)\n\n  def testAvgPoolSamePadding(self):\n    expected_output = [7., 8., 9., 11.5, 12.5, 13.5]\n    self._VerifyValues(\n        nn_ops.avg_pool,\n        input_sizes=[1, 2, 3, 3],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"SAME\",\n        expected=expected_output)\n\n\nclass PoolGradTest(xla_test.XLATestCase):\n\n  CPU_DEVICE = \"/job:localhost/replica:0/task:0/cpu:0\"\n\n  def _VerifyOneTest(self,\n                     pool_func,\n                     pool_grad_func,\n                     input_sizes,\n                     ksize,\n                     strides,\n                     padding,\n                     data_format,\n                     pool_grad_grad_func=None):\n    \"\"\"Verifies the output values of the pooling gradient function.\n\n    Args:\n      pool_func: Forward pooling function\n      pool_grad_func: Pooling gradient function for pool_grad_func\n      input_sizes: Input tensor dimensions.\n      ksize: The kernel size dimensions\n      strides: The stride dimensions\n      padding: Padding type.\n      data_format: The data format we use to run the pooling operation.\n      pool_grad_grad_func: Second-order gradient function, if available.\n    \"\"\"\n    total_size = np.prod(input_sizes)\n    # TODO(b/73062247): MaxPoolGradGrad can confuse gradients when x is equally\n    # maximal at 16 bits. Switch to np.random.randn when resolved.\n    x = np.arange(1, total_size + 1, dtype=np.float32)\n    x *= (np.random.randint(2, size=total_size) * 2 - 1)  # Flip signs randomly\n    # Verify some specifically interesting values...\n    x[np.random.choice(total_size)] = np.inf\n    x[np.random.choice(total_size)] = -np.inf\n    # TODO(b/74222344): Fix nan handling for max pool grad.\n    # x[np.random.choice(total_size)] = np.nan\n    x = x.reshape(input_sizes)\n    with self.session() as sess:\n      # Use the forward pool function to compute some corresponding outputs\n      # (needed for the CPU device, and we need the shape in both cases).\n      with ops.device(self.CPU_DEVICE):\n        inputs = array_ops.placeholder(dtypes.float32, shape=input_sizes)\n        outputs = pool_func(\n            inputs,\n            ksize=ksize,\n            strides=strides,\n            padding=padding,\n            data_format=\"NHWC\")\n\n      output_vals = np.array(sess.run(outputs, {inputs: x}))\n      output_gradient_vals = np.arange(\n          1, output_vals.size + 1, dtype=np.float32)\n      output_gradient_vals = output_gradient_vals.reshape(output_vals.shape)\n      output_grad_grad_vals = np.arange(1, x.size + 1, dtype=np.float32)\n      output_grad_grad_vals = output_grad_grad_vals.reshape(x.shape)\n\n      # Use the Tensorflow CPU pooling gradient to compute the expected input\n      # gradients.\n      with ops.device(self.CPU_DEVICE):\n        output_gradients = array_ops.placeholder(\n            dtypes.float32, shape=output_vals.shape)\n        expected_input_gradients = pool_grad_func(\n            inputs,\n            outputs,\n            output_gradients,\n            ksize=ksize,\n            strides=strides,\n            padding=padding,\n            data_format=\"NHWC\")\n        expected_input_gradient_vals = sess.run(\n            expected_input_gradients,\n            {inputs: x,\n             output_gradients: output_gradient_vals})\n\n        output_grad_gradients = array_ops.placeholder(\n            dtypes.float32, shape=expected_input_gradient_vals.shape)\n        if pool_grad_grad_func is not None:\n          expected_grad_gradients = pool_grad_grad_func(\n              inputs,\n              outputs,\n              output_grad_gradients,\n              ksize=ksize,\n              strides=strides,\n              padding=padding,\n              data_format=\"NHWC\")\n          expected_grad_gradients_vals = sess.run(expected_grad_gradients, {\n              inputs: x,\n              output_grad_gradients: output_grad_grad_vals\n          })\n\n      # Run the gradient op on the XLA device\n      with self.test_scope():\n        outputs = array_ops.placeholder(dtypes.float32, shape=output_vals.shape)\n        xla_inputs = inputs\n        xla_outputs = outputs\n        xla_output_gradients = output_gradients\n        xla_output_grad_gradients = output_grad_gradients\n        xla_ksize = ksize\n        xla_strides = strides\n        if data_format == \"NCHW\":\n          xla_inputs = NHWCToNCHW(inputs)\n          xla_outputs = NHWCToNCHW(outputs)\n          xla_output_gradients = NHWCToNCHW(output_gradients)\n          xla_output_grad_gradients = NHWCToNCHW(output_grad_gradients)\n          xla_ksize = NHWCToNCHW(ksize)\n          xla_strides = NHWCToNCHW(strides)\n        actual_input_gradients = pool_grad_func(\n            xla_inputs,\n            xla_outputs,\n            xla_output_gradients,\n            ksize=xla_ksize,\n            strides=xla_strides,\n            padding=padding,\n            data_format=data_format)\n        if data_format == \"NCHW\":\n          actual_input_gradients = NCHWToNHWC(actual_input_gradients)\n        if pool_grad_grad_func is not None:\n          actual_grad_gradients = pool_grad_grad_func(\n              xla_inputs,\n              xla_outputs,\n              xla_output_grad_gradients,\n              ksize=xla_ksize,\n              strides=xla_strides,\n              padding=padding,\n              data_format=data_format)\n          if data_format == \"NCHW\":\n            actual_grad_gradients = NCHWToNHWC(actual_grad_gradients)\n      actual_input_gradients_vals = sess.run(actual_input_gradients, {\n          inputs: x,\n          outputs: output_vals,\n          output_gradients: output_gradient_vals\n      })\n      # Compare the Tensorflow and XLA results.\n      self.assertAllClose(\n          expected_input_gradient_vals,\n          actual_input_gradients_vals,\n          rtol=1e-4,\n          atol=1e-6)\n      self.assertShapeEqual(actual_input_gradients_vals, inputs)\n\n      if pool_grad_grad_func is not None:\n        actual_grad_gradients_vals = sess.run(\n            actual_grad_gradients, {\n                inputs: x,\n                outputs: output_vals,\n                output_grad_gradients: output_grad_grad_vals\n            })\n\n        # Compare the Tensorflow and XLA results.\n        self.assertAllClose(\n            expected_grad_gradients_vals,\n            actual_grad_gradients_vals,\n            rtol=1e-4,\n            atol=1e-6)\n        self.assertShapeEqual(actual_grad_gradients_vals, outputs)\n\n  def _VerifyValues(self,\n                    pool_func,\n                    pool_grad_func,\n                    input_sizes,\n                    ksize,\n                    strides,\n                    padding,\n                    pool_grad_grad_func=None):\n    \"\"\"Verifies the output values of the pooling function.\n\n    Args:\n      pool_func: Pooling function to be called, e.g., tf.nn.max_pool2d\n      pool_grad_func: Corresponding pooling gradient function.\n      input_sizes: Input tensor dimensions.\n      ksize: The kernel size dimensions\n      strides: The stride dimensions\n      padding: Padding type.\n      pool_grad_grad_func: Second-order gradient function, if available.\n    \"\"\"\n    for data_format in GetTestConfigs():\n      self._VerifyOneTest(\n          pool_func,\n          pool_grad_func,\n          input_sizes,\n          ksize,\n          strides,\n          padding,\n          data_format,\n          pool_grad_grad_func=pool_grad_grad_func)\n\n  def _TestPooling(self, forward_op, backward_op, pool_grad_grad_func=None):\n    # VALID padding\n    self._VerifyValues(\n        forward_op,\n        backward_op,\n        input_sizes=[1, 3, 3, 3],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"VALID\",\n        pool_grad_grad_func=pool_grad_grad_func)\n\n    # SAME padding\n    self._VerifyValues(\n        forward_op,\n        backward_op,\n        input_sizes=[1, 2, 3, 3],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"SAME\",\n        pool_grad_grad_func=pool_grad_grad_func)\n\n    # SAME padding, non square window\n    self._VerifyValues(\n        forward_op,\n        backward_op,\n        input_sizes=[1, 2, 2, 1],\n        ksize=[1, 1, 2, 1],\n        strides=[1, 1, 1, 1],\n        padding=\"SAME\",\n        pool_grad_grad_func=pool_grad_grad_func)\n\n    # VALID padding, uneven stride\n    self._VerifyValues(\n        forward_op,\n        backward_op,\n        input_sizes=[1, 4, 4, 1],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 1, 2, 1],\n        padding=\"VALID\",\n        pool_grad_grad_func=pool_grad_grad_func)\n    self._VerifyValues(\n        forward_op,\n        backward_op,\n        input_sizes=[1, 4, 4, 1],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 2, 1, 1],\n        padding=\"VALID\",\n        pool_grad_grad_func=pool_grad_grad_func)\n\n    # SAME padding, size 4 input\n    self._VerifyValues(\n        forward_op,\n        backward_op,\n        input_sizes=[1, 4, 4, 4],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"SAME\",\n        pool_grad_grad_func=pool_grad_grad_func)\n\n    # SAME padding, size 8 input\n    self._VerifyValues(\n        forward_op,\n        backward_op,\n        input_sizes=[1, 8, 8, 8],\n        ksize=[1, 3, 3, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"SAME\",\n        pool_grad_grad_func=pool_grad_grad_func)\n\n  def testMaxPool(self):\n    self._TestPooling(\n        nn_ops.max_pool,\n        gen_nn_ops.max_pool_grad,\n        pool_grad_grad_func=gen_nn_ops.max_pool_grad_grad)\n\n  def testAvgPool(self):\n    # Wrapper around AvgPoolGrad that ignores extra arguments needed by\n    # MaxPoolGrad.\n    def AvgPoolGrad(inputs, outputs, output_gradients, ksize, strides, padding,\n                    data_format):\n      del outputs  # Unused by average-pooling gradients.\n      return gen_nn_ops.avg_pool_grad(\n          inputs.get_shape().as_list(),\n          output_gradients,\n          ksize=ksize,\n          strides=strides,\n          padding=padding,\n          data_format=data_format)\n\n    self._TestPooling(nn_ops.avg_pool, AvgPoolGrad)\n\n  @test_util.disable_mlir_bridge(\n      \"TODO(b/266613412): investigate FPE in AvgPoolGrad for TPU\"\n  )\n  def testAvgPoolGradSamePaddingZeroStrideZeroSize(self):\n    output_gradient_vals = np.array([0.39117979], dtype=np.float32)\n    output_gradient_vals = output_gradient_vals.reshape([1, 1, 1, 1])\n    with self.session() as sess:\n      with self.test_scope():\n        output_gradients = array_ops.placeholder(\n            dtypes.float32, shape=output_gradient_vals.shape\n        )\n        t = gen_nn_ops.avg_pool_grad(\n            orig_input_shape=[1, 0, 0, 0],\n            grad=output_gradients,\n            ksize=[1, 0, 0, 0],\n            strides=[1, 0, 0, 0],\n            padding=\"SAME\",\n            data_format=\"NCHW\",\n        )\n      with self.assertRaisesRegex(\n          errors.InvalidArgumentError,\n          (\n              \"Sliding window ksize field for dimension 1 must be positive but\"\n              \" is 0\"\n          ),\n      ):\n        sess.run(t, {output_gradients: output_gradient_vals})\n\n  # The CPU implementation of AvgPoolGrad doesn't accept kernels smaller than\n  # the stride size, so we only run the following tests on MaxPoolGrad.\n\n  def testMaxPoolKernelSmallerThanStrideValid(self):\n    self._VerifyValues(\n        nn_ops.max_pool,\n        gen_nn_ops.max_pool_grad,\n        input_sizes=[1, 7, 7, 1],\n        ksize=[1, 2, 2, 1],\n        strides=[1, 3, 3, 1],\n        padding=\"VALID\")\n\n  def testMaxPoolKernelSmallerThanStrideSame(self):\n    self._VerifyValues(\n        nn_ops.max_pool,\n        gen_nn_ops.max_pool_grad,\n        input_sizes=[1, 3, 3, 1],\n        ksize=[1, 1, 1, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"SAME\")\n\n    self._VerifyValues(\n        nn_ops.max_pool,\n        gen_nn_ops.max_pool_grad,\n        input_sizes=[1, 4, 4, 1],\n        ksize=[1, 1, 1, 1],\n        strides=[1, 2, 2, 1],\n        padding=\"SAME\")\n\n\nif __name__ == \"__main__\":\n  googletest.main()"